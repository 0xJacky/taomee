
//这是一个专用于doxygen的文件

/**
 * @page doc_how_game_server_work 游戏服务器如何工作
 *
 * 游戏服务器是通过主程序加插件的形式来工作的，主程序提供了一个工作框架，
 * 并定义了一个插件接口，而插件实现了具体的接口。此外在这些内容之外，还
 * 存在一个基本的支持库，它提供了实现插件的常见功能。
 *
 * @section doc_how_game_server_work-main_program 主程序
 *
 * 主程序是已经存在于那里，作为一个游戏的作者而言，写一个新的游戏就是写一个新的主程序插件，
 * 所以对于主程序而言游戏作者不需要理解的太深入，他只需要知道主程序需要什么和主程序给了什么，
 * 当然个人爱好除外。
 *
 * 主程序为我们提供的框架中含有的基本概念：
 * <dl>
 * <dt>游戏组</dt>
 * 	<dd>每个游戏都在一个小组里进行的。比如有3个人进行滑雪比赛，那么他们3个人就会构成一个小组。
 * 	服务器对游戏是依组管理和维护的，就算只一个人参加的游戏也是如此，任务一个在游戏服务器中的人都属于一个游戏组。</dd>
 * 	<dd>	@see game_group_t
 * 		@see game_group
 * 	</dd>
 * <dt>游戏参与者</dt>
 * 	<dd>在一个游戏组里，其成员被分为两类，一类是玩游戏的，一类是看游戏的。其中玩游戏的就是游戏参与者。服务器需要接受并处理来游戏参与都的数据，同时也要发送数据给游戏参与者。</dd>
 * 	<dd>@see sprite_t</dd>
 * <dt>游戏观察者</dt>
 * 	<dd>在一个游戏组里，其成员被分为两类，一类是玩游戏的，一类是看游戏的。其中看游戏的就是游戏观察者。服务器需要发送数据给游戏观察者。</dd>
 * 	<dd>@see sprite_t</dd>
 * <dt>游戏服务对象</dt>
 * 	<dd>当一个参加一个游戏组的参与者都准备好之后，服务器会利用一个插件提供的@ref create_game函数创建一个对象，并把这个组传递给这个对象。主程序会记录一个组与哪个对象对应，当主程序收到来自用户的数据后，主程序依据这个对应关系把数据传递给相应的对象处理。</dd>
 * 	<dd>游戏服务对象由插件实现，但至少要提供主程序需要的接口。</dd>
 * 	<dd>	@see create_game()
 * 		@see mpog
 * 		@see on_game_begin
 * 		@see gamesession_t
 * 	</dd>
 * </dl>
 *
 * 主程序负责把一个用户加入一个组，或者把一个用户移除一个组；在游戏开始之前，用户之间需要互相等待以形成一个组，当一个组满足开始的条件时，主程序会调用插件提供的实现，生成相应的游戏对象来处理这一个组的交互。在游戏进行过程中，主程序还可能允许加入新的参赛者，而这些对于插件来说都透明，插件只需要处理组内参与者的之间游戏逻辑。
 *
 *
 * @section doc_how_game_server_work-surpose_library 支持库
 *
 * 支持库是本公司对现用的标准库或其它库的简单封装，使得它们在这个特殊的环境中更易于使用。这里的游戏插件的支持库有两个部分组成，一个位于名字空间ant下的C++库，一个是C语言实现的C库它们分别提供了定时器功能、数据库访问功能、时间处理功能和网络打包功能等等。
 * 对于这些库的具体功能可以观看相应的文档。
 * 	@see namespace ant
 * 	@see send_to_self
 * 	@see ADD_TIMER_EVENT 等等
 *
 * @section doc_how_game_server_work-plugin 游戏的逻辑处理——插件
 *
 * 服务器与支持库都框架的一部分，作为游戏作者来它们都是已经在那里了，一般是没有必要涉及的，但是对于插件来说，它是由游戏作者来完成的，当然对于不同的游戏完成的方法与复杂性都不相同，这里我们不可能涉及到如何去一个具体的游戏，这里我要说如何写一个插件，当我们说写一个游戏插件的时候，我们在说什么？
 *
 * 我们的游戏作为一个插件，它当然也必须提供主程序要求的接口，并完成主程序期待完成的事。插件必须提供的接口分为两类，一类是dlopen库需要的，一类是主程序自身逻辑需要的。
 *
 * @subsection doc_how_game_server_work-plugin-dlopen dlopen需要的接口
 *
 * dlopen是C语言API，也就是说它只能认识一个C链接的函数，然而我们整个插件是在C++架构下完成的。所以作为一个解决方案，我们必须提供至少一个C链接的函数作为一个中介，通过这个我们可以通过dlopen调用C++程序库。事实上，主程序会通过dlopen寻找C链接的函数有：
 *	@see register_plugin 
 *	@see game_t
 *	@see create_game
 * 	@see game_init
 * 	@see game_destroy
 *
 * 你应该相应地去看看这些函数的定义与使用，本文档已经相当完善了，同时也很易理解
 *
 *
 * @subsection doc_how_game_server_work-plugin-self 主程序自身逻辑需要的接口
 *
 * 主程序自身的逻辑要求插件提供三个接口，并且同时要求它们是一个类 @ref mpog 的派生类，并实现这个类。主程序只要求插件通过 @ref game::create_game 函数返回一个派生自 @ref mpog 的类，并把这个抽象类的接口作出适当的实现就可。你应该具体看看 @ref mpog 类的定义
 * 	@see mpog
 */


/* vim: set filetype=cpp:  */

