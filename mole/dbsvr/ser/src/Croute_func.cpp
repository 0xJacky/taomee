/*
 * =====================================================================================
 *
 *       Filename:  route_func.cpp
 *
 *    Description:  
 *
 *        Version:  1.0
 *        Created:  2007年11月02日 16时39分06秒 CST
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  xcwen (xcwen), xcwenn@gmail.com
 *        Company:  TAOMEE
 *
 * =====================================================================================
 */

#include <stdlib.h>
#include <string.h>
#include "Croute_func.h"
#include "common.h"
#include "benchapi.h"
#include "proto.h"
#include "logproto.h"
#include "msglog.h"
#include <algorithm>
#include <cmath>
#include <map>
#include <time.h>
extern  char * version_str;
#ifdef MAKE_SEND_EMAIL
CMD_MAP g_cmdmap[]={
	FILL_CMD_WITH_PRI_IN	(OTHER_SEND_EMAIL,other_send_email )
};
#else
CMD_MAP g_cmdmap[]={
	
	/// 客户端私有数据，获取
	FILL_CMD_WITH_PRI_IN(ROOMINFO_CLIENT_DATA_GET,  roominfo_client_data_get),

	/// 客户端私有数据，设置
	FILL_CMD_WITH_PRI_IN(ROOMINFO_CLIENT_DATA_SET,  roominfo_client_data_set),

	/// 用户宠物使用一次技能
	FILL_CMD_WITH_PRI_IN(USER_USE_SKILL_ONE, user_use_skill_one),

	/// 取得用户指定宠物的所有任务状态
	FILL_CMD_WITH_PRI_IN(USER_PET_TASK_GET_BY_USER, user_pet_task_get_by_user),

	FILL_CMD_WITH_PRI_IN(USER_PET_TASK_GET_CLIENT_BY_USER_TASK, user_pet_task_get_client_by_user_task),

	/// 取得神殿的高度
	FILL_CMD_WITHOUT_PRI_IN(USER_PET_HALT_GET, user_pet_halt_get),

	/// 设置神殿的高度
	FILL_CMD_WITH_PRI_IN(USER_PET_HALT_SET, user_pet_halt_set),

	/// 更新宠物技能点
	FILL_CMD_WITH_PRI_IN(USER_PET_SKILL_SET, user_pet_skill_set),

	///用户宠物泡温泉，可以加速宠物成长
	FILL_CMD_WITH_PRI_IN(USER_PET_HOT_SPRING, user_pet_hot_spring),

	FILL_CMD_WITH_PRI_IN_GE(USER_PET_GET_COUNT_WITH_ATTIREID, user_pet_get_count_with_attireid),
	
	FILL_CMD_WITH_PRI_IN	(USER_PET_SET_SKILL_FLAG,user_pet_set_skill_flag),

	FILL_CMD_WITHOUT_PRI_IN(ROOMINFO_WARRIOR_LUCKY_DRAW_GET, roominfo_warrior_lucky_draw_get),
	FILL_CMD_WITH_PRI_IN(ROOMINFO_WARRIOR_LUCKY_DRAW, roominfo_warrior_lucky_draw),

	FILL_CMD_WITHOUT_PRI_IN(ROOMINFO_STONE_MOVE_GET, roominfo_stone_move_get),
	FILL_CMD_WITHOUT_PRI_IN(ROOMINFO_STONE_MOVE_SET, roominfo_stone_move_set),

	FILL_CMD_WITHOUT_PRI_IN(ROOMINFO_PENGUIN_EGG_GET, roominfo_penguin_egg_get),
	FILL_CMD_WITH_PRI_IN(ROOMINFO_PENGUIN_EGG_SET, roominfo_penguin_egg_set),

	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_GET_MEE_FANS,userinfo_get_mee_fans),
	FILL_CMD_WITH_PRI_IN	(USERINFO_SET_MEE_FANS,userinfo_set_mee_fans),
	FILL_CMD_WITH_PRI_IN	(USERINFO_ADD_ACT_FLAG,userinfo_add_act_flag),
	FILL_CMD_WITH_PRI_IN	(USER_PET_TASK_ATTIRE_GIVE, user_pet_task_attire_give),
	FILL_CMD_WITH_PRI_IN_GE(USER_BUY_MANY_THING_IN_ONE_TIME,user_buy_many_thing_in_one_time),

	//----------------------------------------------------------------------------------------------------
	//新年拍照，设置拍照服装
	FILL_CMD_WITH_PRI_IN_GE(USER_DRESS_IN_PHOTO_SET, user_dress_in_photo_set),
	FILL_CMD_WITHOUT_PRI_IN(USER_DRESS_IN_PHOTO_GET, user_dress_in_photo_get),

	//----------------------------------------------------------------------------------------------------
	//钓鱼，可以换取物品
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_FISH_WEIGHT_GET, roominfo_fish_weight_get),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_FISH_WEIGHT_SET, roominfo_fish_weight_set),

	//----------------------------------------------------------------------------------------------------
	//蛋糕用于交换礼品
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_CAKE_GIFT_SWAP_GET_CAKE_NUM, roominfo_cake_gift_swap_get_cake_num),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_CAKE_GIFT_SWAP_DO_SWAP, roominfo_cake_gift_swap_do_swap),
	
	//---------------------------------------------------------------------------------
	//鸭子状态，鸭子可能被散架了，也可能是完好的
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_ROOMINFO_DUCK_STATU_GET, roominfo_roominfo_duck_statu_get),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_ROOMINFO_DUCK_STATU_SET, roominfo_roominfo_duck_statu_set),

	//---------------------------------------------------------------------------------
	//服装打分，查询某一服装组合的分数
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_ROOMINFO_DRESSING_MARK_GET, roominfo_roominfo_dressing_mark_get),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_ROOMINFO_DRESSING_MARK_SET, roominfo_roominfo_dressing_mark_set),

	//---------------------------------------------------------------------------------
	//暖房，兔子配对，插入一个配对的兔子
	FILL_CMD_WITH_PRI_IN	(USER_GREENHOUSE_INSERT, user_greenhouse_insert),
	//暖房，兔子配对，取得指定兔子的起始配对时间
	FILL_CMD_WITH_PRI_IN	(USER_GREENHOUSE_REMAIN_TIME, user_greenhouse_remain_time),
	//暖房，兔子配对，领取一个配对的兔子
	FILL_CMD_WITH_PRI_IN	(USER_GREENHOUSE_DROP, user_greenhouse_drop),
	//暖房，返回指定用户是否有用户正在配对
	FILL_CMD_WITHOUT_PRI_IN	(USER_GREENHOUSE_USER_EXIST, user_greenhouse_user_exist),
	//暖房，返回指定用户全部正在配对的动物
	FILL_CMD_WITHOUT_PRI_IN	(USER_GREENHOUSE_USER_ALL_ANIMAL, user_greenhouse_user_all_animal),

	//---------------------------------------------------------------------------------
	//FILL_CMD_WITH_PRI_IN    (USERINFO_LOG_WITH_STAT,userinfo_log_with_stat),
	FILL_CMD_WITH_PRI_IN	(USERINFO_LOGIN_EX,userinfo_login_ex),
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_GET_LOGIN_INFO,userinfo_get_login_info),
	FILL_CMD_WITH_PRI_IN	(USERINFO_REGISTER_EX,userinfo_register_ex),
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_GET_GAMEFLAG,userinfo_get_gameflag),
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_GET_GAME_ACT_FLAG,userinfo_get_game_act_flag),

	//客服，两个协议号同时绑定了一个函数，更改时注意
	FILL_CMD_WITHOUT_PRI_IN	(USER_GET_FRIEND_LIST,user_get_friend_list),
	FILL_CMD_WITHOUT_PRI_IN	(SU_USER_GET_FRIEND_LIST,user_get_friend_list),

	FILL_CMD_WITH_PRI_IN	(USERINFO_ADD_GAME,userinfo_add_game),
	FILL_CMD_WITH_PRI_IN	(USERINFO_DEL_GAME,userinfo_del_game),
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_GET_MEEFAN_GAMEFLAG,userinfo_get_meefan_gameflag),
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_DEL_USER,userinfo_del_user),
	FILL_CMD_WITH_PRI_IN	(USERINFO_CHANGE_PASSWD,userinfo_change_passwd),
	FILL_CMD_WITH_PRI_IN	(USERINFO_SET_PASSWD_EX,userinfo_set_passwd_ex),
	FILL_CMD_WITH_PRI_IN	(USERINFO_SET_CHANGE_PASSWD_FLAG_EX,userinfo_set_change_passwd_flag_ex),
	FILL_CMD_WITH_PRI_IN	(USERINFO_SET_PASSWD_ONLY_CHECK_CHANGE_FLAG,userinfo_set_passwd_only_check_change_flag),
	FILL_CMD_WITH_PRI_IN	(USERINFO_LOGIN_BY_MD5_TWO,userinfo_login_by_md5_two),
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_CHECK_EXISTED,userinfo_check_existed),
	FILL_CMD_WITH_PRI_IN	(USERINFO_CHANGE_PASSWD_NOCHECK,userinfo_change_passwd_nocheck),
	FILL_CMD_WITH_PRI_IN	(USERINFO_SET_USER_BIRTHDAY_SEX,userinfo_set_user_birthday_sex),
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_IS_SET_USER_BIRTHDAY,userinfo_is_set_user_birthday),
	
	FILL_CMD_WITH_PRI_IN	(USERINFO_SET_PASSWDEMAIL,userinfo_set_passwdemail),
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_ISSET_PASSWDEMAIL,userinfo_isset_passwdemail),
	FILL_CMD_WITH_PRI_IN	(USER_SET_PASSWDEMAIL_EX,user_set_passwdemail_ex),
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_ISCONFIRM_PASSWDEMAIL,userinfo_isconfirm_passwdemail),
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_CONFIRM_PASSWDEMAIL,userinfo_confirm_passwdemail),
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_GET_PASSWDEMAIL,userinfo_get_passwdemail),
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_GET_PASSWD_HISTORY,userinfo_get_passwd_history),
	FILL_CMD_WITH_PRI_IN	(USERINFO_SU_SET_PASSWD,userinfo_su_set_passwd),
	FILL_CMD_WITH_PRI_IN	(USERINFO_SU_SET_PAYPASSWD,userinfo_su_set_paypasswd),
	FILL_CMD_WITH_PRI_IN	(USERINFO_SET_PAYPASSWD_WITH_CHECK,userinfo_set_paypasswd_with_check),
	
	FILL_CMD_WITH_PRI_IN	(USERINFO_SET_USER_EMAIL,userinfo_set_user_email),
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_GET_USER_EMAIL,userinfo_get_user_email),
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_GET_INFO_EX,userinfo_get_info_ex),
	FILL_CMD_WITH_PRI_IN	(USERINFO_SET_INFO_EX,userinfo_set_info_ex),
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_GET_INFO_ALL,userinfo_get_info_all),
	FILL_CMD_WITH_PRI_IN	(USERINFO_SET_FLAG_CHANGE_PASSWD,userinfo_set_flag_change_passwd),
	FILL_CMD_WITHOUT_PRI_IN	(USERID_GET_USERID,userid_get_userid),
	FILL_CMD_WITHOUT_PRI_IN	(USERID_SET_NOUSED,userid_set_noused),
	FILL_CMD_WITH_PRI_IN	(USERINFO_SET_PAYINFO,userinfo_set_payinfo),
	FILL_CMD_WITH_PRI_IN	(USERINFO_CHECK_QUESTION,userinfo_check_question),
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_ISSET_QUESTION,userinfo_isset_question),
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_GET_SECURITY_FLAG,userinfo_get_security_flag),
	FILL_CMD_WITH_PRI_IN	(USERINFO_SET_PEMAIL_BY_QA,userinfo_set_pemail_by_qa),
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_SET_PEMAIL_ISOK,userinfo_set_pemail_isok),
	
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_SYNC_DV,userinfo_sync_dv),
	FILL_CMD_WITH_PRI_IN	(USERINFO_CHECK_PAYPASSWD,userinfo_check_paypasswd),
	FILL_CMD_WITH_PRI_IN	(USERINFO_SET_PAYPASSWD,userinfo_set_paypasswd),
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_ISSET_PAYPASSWD,userinfo_isset_paypasswd),
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_CLEAN_PAYPASSWD,userinfo_clean_paypasswd),
	FILL_CMD_WITH_PRI_IN	(USERINFO_SET_QA,userinfo_set_qa),
	
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_GET_QUESTION,userinfo_get_question),
	
	//客服，两个协议号同时绑定了一个函数，更改时注意	
	FILL_CMD_WITH_PRI_IN	(USER_DEL_BLACKUSER,user_del_blackuser),
	FILL_CMD_WITH_PRI_IN	(SU_USER_DEL_BLACKUSER,user_del_blackuser),
	FILL_CMD_WITHOUT_PRI_IN	(USER_GET_BLACKUSER_LIST,user_get_blackuser_list),
	FILL_CMD_WITHOUT_PRI_IN	(SU_USER_GET_BLACKUSER_LIST,user_get_blackuser_list),
	FILL_CMD_WITH_PRI_IN	(USER_SET_NICK,user_set_nick),
	FILL_CMD_WITH_PRI_IN	(SU_USER_SET_NICK,user_set_nick),

	FILL_CMD_WITHOUT_PRI_IN	(USER_GET_NICK,user_get_nick),
	FILL_CMD_WITH_PRI_IN	(USER_DEL_GROUP,user_del_group),
	
	FILL_CMD_WITH_PRI_IN	(USER_CHECK_FRIEND_EXISTED,user_check_friend_existed),
	FILL_CMD_WITH_PRI_IN	(USER_LEAVE_GROUP,user_leave_group),
	FILL_CMD_WITH_PRI_IN	(USER_JOIN_GROUP,user_join_group),
	FILL_CMD_WITH_PRI_IN	(USER_GET_USED_ATTIERLIST,user_get_used_attierlist),
	
	//客服，两个协议号同时绑定了一个函数，更改时注意	
	FILL_CMD_WITHOUT_PRI_IN	(USER_GET_GROUP,user_get_group),
	FILL_CMD_WITHOUT_PRI_IN	(SU_USER_GET_GROUP,user_get_group),

	FILL_CMD_WITHOUT_PRI_IN	(USER_GET_NICK_FLIST,user_get_nick_flist),
	FILL_CMD_WITH_PRI_IN	(USER_CLASSMSG_ADD,user_classmsg_add),
	FILL_CMD_WITH_PRI_IN	(USER_CLASS_SET_MEDAL_INFO,user_class_set_medal_info),
	
	////客服，两个协议号同时绑定了一个函数，更改时注意 
	FILL_CMD_WITH_PRI_IN	(USER_CLASSMSG_DEL,user_classmsg_del),
	FILL_CMD_WITH_PRI_IN	(SU_USER_CLASSMSG_DEL,user_classmsg_del),
	FILL_CMD_WITH_PRI_IN	(USER_CLASSMSG_REPORT,user_classmsg_report),
	FILL_CMD_WITH_PRI_IN	(SU_USER_CLASSMSG_REPORT,user_classmsg_report),
	FILL_CMD_WITH_PRI_IN	(USER_CLASSMSG_GET_LIST,user_classmsg_get_list),
	FILL_CMD_WITH_PRI_IN	(SU_USER_CLASSMSG_GET_LIST,user_classmsg_get_list),

	FILL_CMD_WITH_PRI_IN	(USER_CLASSMSG_SET_SHOW_FLAG,user_classmsg_set_show_flag),
	FILL_CMD_WITHOUT_PRI_IN	(USER_CLASS_GET_RANDOM_TOP,user_class_get_random_top),
	FILL_CMD_WITH_PRI_IN	(USER_CLASS_CREATE,user_class_create),

	////客服，两个协议号同时绑定了一个函数，更改时注意 
	FILL_CMD_WITHOUT_PRI_IN	(USER_CLASS_GET_ATTIRELIST,user_class_get_attirelist),
	FILL_CMD_WITHOUT_PRI_IN	(SU_USER_CLASS_GET_ATTIRELIST,user_class_get_attirelist),

	FILL_CMD_WITHOUT_PRI_IN	(USER_CLASS_DEL,user_class_del),

	//客服，两个协议号同时绑定了一个函数，更改时注意
	FILL_CMD_WITH_PRI_IN	(USER_CLASS_CHANGE_INFO,user_class_change_info),
	FILL_CMD_WITH_PRI_IN	(SU_USER_CLASS_CHANGE_INFO,user_class_change_info),
	FILL_CMD_WITHOUT_PRI_IN	(USER_CLASS_GET_INFO,user_class_get_info),
	FILL_CMD_WITHOUT_PRI_IN	(SU_USER_CLASS_GET_INFO,su_user_class_get_info),
	FILL_CMD_WITH_PRI_IN	(USER_CLASS_REDUCE_ATTIRE,user_class_reduce_attire),
	FILL_CMD_WITH_PRI_IN	(SU_USER_CLASS_REDUCE_ATTIRE,user_class_reduce_attire),

	FILL_CMD_WITHOUT_PRI_IN	(USER_CLASS_GET_SIMPLE_INFO,user_class_get_simple_info),
	FILL_CMD_WITH_PRI_IN	(USER_CLASS_ADD_MEMBER,user_class_add_member),
	FILL_CMD_WITH_PRI_IN	(USER_CLASS_DEL_MEMBER,user_class_del_member),
	//客服，两个协议号同时绑定了一个函数，更改时注意
	FILL_CMD_WITH_PRI_IN	(USER_CLASS_ADD_ATTIRE,user_class_add_attire),
	FILL_CMD_WITH_PRI_IN	(SU_USER_CLASS_ADD_ATTIRE,user_class_add_attire),

	FILL_CMD_WITHOUT_PRI_IN	(USER_GET_FIRST_CLASS,user_get_first_class),
	FILL_CMD_WITHOUT_PRI_IN	(USER_CLASS_GET_MEMBERLIST,user_class_get_memberlist),
	FILL_CMD_WITH_PRI_IN	(USER_ADD_CLASS,user_add_class),
	FILL_CMD_WITHOUT_PRI_IN	(USER_GET_CLASSLIST,user_get_classlist),
	FILL_CMD_WITH_PRI_IN	(USER_DEL_CLASS,user_del_class),
	FILL_CMD_WITHOUT_PRI_IN	(USER_CLASS_GET_FLAG_INFO,user_class_get_flag_info),
	FILL_CMD_WITH_PRI_IN	(USER_SET_FIRST_CLASS,user_set_first_class),
	FILL_CMD_WITH_PRI_IN	(USER_CLASS_SET_ACCESS_FLAG,user_class_set_access_flag),
	FILL_CMD_WITH_PRI_IN_GE	(USER_CLASS_EDIT_HOME,user_class_edit_home),

	FILL_CMD_WITHOUT_PRI_IN	(USER_DEL_USER ,user_del_user ),
	FILL_CMD_WITH_PRI_IN	(USER_SET_USER_ONLINE ,user_set_user_online ),
	FILL_CMD_WITH_PRI_IN 	(USER_BUY_ATTIRE_BY_XIAOMEE,user_buy_attire_by_xiaomee),
	//客服，两个协议号同时绑定了一个函数，更改时注意 
	FILL_CMD_WITH_PRI_IN 	(USER_SALE_ATTIRE,user_sale_attire),
	FILL_CMD_WITH_PRI_IN 	(SU_USER_SALE_ATTIRE,user_sale_attire),

	FILL_CMD_WITH_PRI_IN	(USER_CHANGE_XIAOMEE,user_change_xiaomee),
	FILL_CMD_WITHOUT_PRI_IN	(USER_GET_XIAOMEE,user_get_xiaomee),
	FILL_CMD_WITHOUT_PRI_IN	(USER_GET_VIP_NICK,user_get_vip_nick),

	////客服，两个协议号同时绑定了一个函数，更改时注意	
	FILL_CMD_WITH_PRI_IN	(USER_ADD_BLACKUSER,user_add_blackuser),
	FILL_CMD_WITH_PRI_IN	(SU_USER_ADD_BLACKUSER,user_add_blackuser),

	FILL_CMD_WITH_PRI_IN 	(USER_DEL_ATTIRE,user_del_attire),
	FILL_CMD_WITH_PRI_IN	(USERINFO_SET_QUESTION2,userinfo_set_question2),
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_GET_QUESTION2,userinfo_get_question2),
	FILL_CMD_WITH_PRI_IN	(USERINFO_VERIFY_QUESTION2,userinfo_verify_question2),
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_GET_QUESTION2_SET_FLAG,userinfo_get_question2_set_flag),

	//客服，两个协议号同时绑定了一个函数，更改时注意
	FILL_CMD_WITH_PRI_IN 	(USER_SET_ATTIRE_EX,user_set_attire_ex),
	FILL_CMD_WITH_PRI_IN 	(SU_USER_SET_ATTIRE_EX,user_set_attire_ex),
	
	////客服，两个协议号同时绑定了一个函数，更改时注意	
	FILL_CMD_WITH_PRI_IN 	(USER_GET_USER_PET,user_get_user_pet),
	FILL_CMD_WITH_PRI_IN 	(SU_USER_GET_USER_PET,user_get_user_pet),

	FILL_CMD_WITHOUT_PRI_IN	(USER_LOGIN_EX,user_login_ex),
	FILL_CMD_WITH_PRI_IN	(USER_REGISTER_EX2,user_register_ex2),
	FILL_CMD_WITH_PRI_IN	(USER_SET_XIAOMEE_MAX_INFO,user_set_xiaomee_max_info),
	FILL_CMD_WITH_PRI_IN	(USER_SET_VIP_FLAG,user_set_vip_flag),

	//设置一个VIP用户当前等级基值
	FILL_CMD_WITH_PRI_IN	(USER_VIP_MARK_LAST_SET,user_vip_mark_last_set),

	//设置VIP用户超拉等级
	FILL_CMD_WITH_PRI_IN	(USER_VIP_PET_LEVEL_SET,user_vip_pet_level_set),

	FILL_CMD_WITH_PRI_IN_GE	(USER_SWAP_HOMEATTIRE_LIST ,user_swap_homeattire_list ),
	FILL_CMD_WITH_PRI_IN_GE	(USER_SWAP_LIST,user_swap_list),
	FILL_CMD_WITH_PRI_IN_GE (SU_USER_SWAP_LIST, su_user_swap_list),
	FILL_CMD_WITH_PRI_IN_GE	(USER_SWAP_LIST_2,user_swap_list),
	FILL_CMD_WITHOUT_PRI_IN	(USER_HOME_NOUSED_ATTIRE_TYPE_COUNT,user_home_noused_attire_type_count),

	////客服，两个协议号同时绑定了一个函数，更改时注意
	FILL_CMD_WITH_PRI_IN	(USER_ADD_FRIEND,user_add_friend),
	FILL_CMD_WITH_PRI_IN	(SU_USER_ADD_FRIEND,user_add_friend),
	FILL_CMD_WITH_PRI_IN	(USER_DEL_FRIEND,user_del_friend),
	FILL_CMD_WITH_PRI_IN	(SU_USER_DEL_FRIEND,user_del_friend),
	
	FILL_CMD_WITH_PRI_IN_GE	(USER_SWAP_JYATTIRE_LIST ,user_swap_jyattire_list ),
	FILL_CMD_WITH_PRI_IN	(USER_ADD_SEED,user_add_seed),
	FILL_CMD_WITH_PRI_IN	(USER_SET_SEED_EX,user_set_seed_ex),
	FILL_CMD_WITH_PRI_IN	(USER_CATCH_FRUIT,user_catch_fruit),
	FILL_CMD_WITH_PRI_IN	(USER_GET_JY_NOUSED_LIST,user_get_jy_noused_list),
	//客服，两个协议号同时绑定了一个函数，更改时注意
	FILL_CMD_WITH_PRI_IN	(USER_DEL_SEED,user_del_seed),
	FILL_CMD_WITH_PRI_IN	(SU_USER_DEL_SEED,user_del_seed),

	FILL_CMD_WITH_PRI_IN	(USER_GET_SEED,user_get_seed),
	FILL_CMD_WITH_PRI_IN    (USER_KILL_BUG,user_kill_bug),
	FILL_CMD_WITH_PRI_IN    (USER_WATER_SEED,user_water_seed),
	FILL_CMD_WITH_PRI_IN    (USER_PLANT_GROWTH_ADD_BY_HOUR,user_plant_growth_add_by_hour),
	
	FILL_CMD_WITH_PRI_IN	(USER_SET_GROUP_FLAG,user_set_group_flag),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_FLAG,user_get_flag),
	FILL_CMD_WITH_PRI_IN 	(USER_SET_USER_PET_INFO,user_set_user_pet_info),
	FILL_CMD_WITH_PRI_IN 	(USER_SET_USER_PET_COMM,user_set_user_pet_comm),
	FILL_CMD_WITH_PRI_IN 	(USER_ADD_USER_PET,user_add_user_pet),
	FILL_CMD_WITH_PRI_IN_GE	(USER_SET_USER_PET_POSLIST,user_set_user_pet_poslist),
	FILL_CMD_WITH_PRI_IN	(USER_DEL_USER_PET,user_del_user_pet),
	FILL_CMD_WITH_PRI_IN 	(USER_SET_USER_PET_ALL,user_set_user_pet_all),
	FILL_CMD_WITH_PRI_IN 	(USER_SET_USER_PET_SKILL,user_set_user_pet_skill),
	FILL_CMD_WITH_PRI_IN 	(USER_SET_TASKLIST,user_set_tasklist),
	FILL_CMD_WITH_PRI_IN_GE	(USER_SWAP_ATTIRE_LIST ,user_swap_attire_list ),
	FILL_CMD_WITHOUT_PRI_IN (USER_CHECK_EXISTED,user_check_existed),
	FILL_CMD_WITHOUT_PRI_IN	(USER_CHECK_EXISTED_EX,user_check_existed_ex),
	FILL_CMD_WITH_PRI_IN	(USER_HOME_ATTIRE_CHANGE,user_home_attire_change),
	FILL_CMD_WITH_PRI_IN_GE	(USER_SET_USED_HOMEATTIRE,user_set_used_homeattire),
	FILL_CMD_WITH_PRI_IN_GE	(USER_SET_USED_JYATTIRE,user_set_used_jyattire),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_USER_ALL,user_get_user_all),
	FILL_CMD_WITHOUT_PRI_IN	(USER_GET_IP_HISTORY,user_get_ip_history),

	//----------------------------------------------------------------------------------------------------
	//用户宠物装扮
	FILL_CMD_WITH_PRI_IN_GE	(USER_PET_ATTIRE_SET_USED,user_pet_attire_set_used),
	FILL_CMD_WITH_PRI_IN	(USER_BUY_PET_ATTIRE_BY_XIAOMEE,user_buy_pet_attire_by_xiaomee),
	FILL_CMD_WITH_PRI_IN	(USER_GET_PET_ATTIRE_LIST,user_get_pet_attire_list),
	FILL_CMD_WITHOUT_PRI_IN	(USER_GET_PET_ATTIRE_ALL,user_get_pet_attire_all),
	FILL_CMD_WITH_PRI_IN	(USER_SET_PET_ATTIRE,user_set_pet_attire),
	FILL_CMD_WITHOUT_PRI_IN	(USER_GET_PET_ATTIRE_USED_ALL,user_get_pet_attire_used_all),
	FILL_CMD_WITH_PRI_IN	(USER_PET_ATTIRE_UPDATE_EX,user_pet_attire_update_ex),
	FILL_CMD_WITHOUT_PRI_IN	(USER_GET_INFO_EX,user_get_info_ex),
	//客服，两个协议号同时绑定了一个函数，更改时注意
	FILL_CMD_WITH_PRI_IN	(USER_SET_TASK,user_set_task),
	FILL_CMD_WITH_PRI_IN	(SU_USER_SET_TASK,user_set_task),

	FILL_CMD_WITH_PRI_IN_GE (USER_GET_TYPE_ITEM_LIST,user_get_type_item_list),	
	FILL_CMD_WITH_PRI_IN_GE	(USER_CHECK_ATTIRELIST,user_check_attirelist),

	//客服，两个协议号同时绑定了一个函数，更改时注意	
	FILL_CMD_WITH_PRI_IN_GE	(USER_ADD_OFFLINE_MSG ,user_add_offline_msg ),
	FILL_CMD_WITH_PRI_IN_GE	(SU_USER_ADD_OFFLINE_MSG ,user_add_offline_msg ),
	
	FILL_CMD_WITH_PRI_IN	(USER_CHANGE_USER_VALUE ,user_change_user_value ),
	FILL_CMD_WITH_PRI_IN_GE	(USER_SET_HOME_ATTIRELIST,user_set_home_attirelist),
	FILL_CMD_WITH_PRI_IN_GE	(USER_SET_JY_ATTIRELIST,user_set_jy_attirelist),

	//客服，两个协议号同时绑定了一个函数，更改时注意
	FILL_CMD_WITH_PRI_IN 	(USER_ADD_ATTIRE ,user_add_attire ),
	FILL_CMD_WITH_PRI_IN 	(SU_USER_ADD_ATTIRE ,user_add_attire ),
	FILL_CMD_WITH_PRI_IN	(USER_GET_HOME,user_get_home),
	FILL_CMD_WITH_PRI_IN	(SU_USER_GET_HOME,su_user_get_home),

	FILL_CMD_WITH_PRI_IN	(USER_SET_FLAG,user_set_flag),
	FILL_CMD_WITH_PRI_IN	(USER_SET_FLAG_UNUSED,user_set_flag_unused),
	FILL_CMD_WITH_PRI_IN	(USER_SET_FLAG_OFFLINE24,user_set_flag_offline24),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_JY ,user_get_jy ),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_JY_EX ,user_get_jy_ex ),
	FILL_CMD_WITHOUT_PRI_IN	(USER_GET_SEED_LIST,user_get_seed_list),
	FILL_CMD_WITH_PRI_IN	(USER_PET_GET_INFO,user_pet_get_info),
	//客服，两个协议号同时绑定了一个函数，更改时注意
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_USER,user_get_user),
	FILL_CMD_WITHOUT_PRI_IN (SU_USER_GET_USER,user_get_user),

	FILL_CMD_WITHOUT_PRI_IN (USER_GET_USER_WITH_MSGLIST,user_get_user_with_msglist),
	FILL_CMD_WITH_PRI_IN	(USER_SET_PETCOLOR,user_set_petcolor),

	//客服，两个协议号同时绑定了一个函数，更改时注意
	FILL_CMD_WITH_PRI_IN	(USER_GET_ATTIRE_LIST ,user_get_attire_list ),
	FILL_CMD_WITH_PRI_IN	(SU_USER_GET_ATTIRE_LIST ,user_get_attire_list ),

	FILL_CMD_WITH_PRI_IN	(USER_SET_ATTIRE ,user_set_attire ),
	FILL_CMD_WITH_PRI_IN	(USER_SET_HOME_ATTIRE_NOUSED,user_set_home_attire_noused),
	FILL_CMD_WITH_PRI_IN	(USER_SET_BIRTHDAY,user_set_birthday),
	FILL_CMD_WITHOUT_PRI_IN	(USER_ISSET_BIRTHDAY,user_isset_birthday),

	//客服，两个协议号同时绑定了一个函数，更改时注意
	FILL_CMD_WITHOUT_PRI_IN	(USER_PROFESSION_GET,user_profession_get),
	FILL_CMD_WITHOUT_PRI_IN	(SU_USER_PROFESSION_GET,user_profession_get),
	FILL_CMD_WITH_PRI_IN	(USER_PROFESSION_SET,user_profession_set),
	FILL_CMD_WITH_PRI_IN	(SU_USER_PROFESSION_SET,user_profession_set),

	FILL_CMD_WITH_PRI_IN    (USER_SET_ATTIRE_MAX_LIMIT,user_set_attire_max_limit),
	FILL_CMD_WITHOUT_PRI_IN	(USER_TEMP_ADD_VALUE,user_temp_add_value),
	FILL_CMD_WITHOUT_PRI_IN	(USER_TEMP_GET_VALUE,user_temp_get_value),
	FILL_CMD_WITHOUT_PRI_IN	(USER_GET_TEMPBUF,user_get_tempbuf),
	FILL_CMD_WITH_PRI_IN	(USER_SET_TEMPBUF,user_set_tempbuf),
	
	
	FILL_CMD_WITHOUT_PRI_IN	(USER_CARD_GETINFO,user_card_getinfo),
	FILL_CMD_WITH_PRI_IN	(USER_CARD_ADD_CARD,user_card_add_card),
	FILL_CMD_WITH_PRI_IN	(USER_CARD_ADD_WIN_LOSE,user_card_add_win_lose),
	FILL_CMD_WITHOUT_PRI_IN	(USER_CARD_ADD_LOWER_CARD,user_card_add_lower_card),
	FILL_CMD_WITH_PRI_IN	(USER_CARD_INIT,user_card_init),
	FILL_CMD_WITHOUT_PRI_IN	(USER_CARD_IS_INITED,user_card_is_inited),
	FILL_CMD_WITHOUT_PRI_IN	(USER_CARD_GET_ENABLE_COUNT,user_card_get_enable_count),
	FILL_CMD_WITH_PRI_IN	(USER_CARD_SET_WIN_LOSE,user_card_set_win_lose),
	FILL_CMD_WITHOUT_PRI_IN	(USER_CARD_GETINFO_EX,user_card_getinfo_ex),
	FILL_CMD_WITH_PRI_IN	(USER_CARD_SET_FLAG_BIT,user_card_set_flag_bit),
	FILL_CMD_WITH_PRI_IN	(USER_CONNECT_ADD_CHILD,user_connect_add_child),
	FILL_CMD_WITH_PRI_IN	(USER_CONNECT_SET_PARENT,user_connect_set_parent),
	//客服，两个协议号同时绑定了一个函数，更改时注意
	FILL_CMD_WITHOUT_PRI_IN	(USER_CONNECT_GET_INFO,user_connect_get_info),
	FILL_CMD_WITHOUT_PRI_IN	(SU_USER_CONNECT_GET_INFO,user_connect_get_info),

	FILL_CMD_WITH_PRI_IN	(USER_CONNECT_SET_CHILDCOUNT,user_connect_set_childcount),
	//user_task
	//客服，两个协议号同时绑定了一个函数，更改时注意
	FILL_CMD_WITH_PRI_IN	( USER_PET_TASK_SET ,user_pet_task_set ),
	FILL_CMD_WITH_PRI_IN	( SU_USER_PET_TASK_SET ,user_pet_task_set ),

	FILL_CMD_WITH_PRI_IN	(USER_PET_TASK_GET_LIST,user_pet_task_get_list),
	
	
	//user_task_ex 
	FILL_CMD_WITH_PRI_IN    (USER_TASK_SET, user_task_set),
	FILL_CMD_WITH_PRI_IN    (USER_TASK_DEL, user_task_del),
	FILL_CMD_WITH_PRI_IN    (USER_TASK_GET, user_task_get),
	FILL_CMD_WITHOUT_PRI_IN	(USER_TASK_GET_LIST,user_task_get_list),
	
	//bank
	FILL_CMD_WITH_PRI_IN    (USER_BANK_ADD,user_bank_add),
	//客服，两个协议号同时绑定了一个函数，更改时注意
	FILL_CMD_WITHOUT_PRI_IN (USER_BANK_GET_ACCOUNT,user_bank_get_account),
	FILL_CMD_WITHOUT_PRI_IN (SU_USER_BANK_GET_ACCOUNT,user_bank_get_account),

	FILL_CMD_WITH_PRI_IN    (USER_BANK_DELETE_ACCOUNT,user_bank_delete_account),
	FILL_CMD_WITH_PRI_IN	(USER_BANK_SET_ACCOUNT,user_bank_set_account),
	
	
	FILL_CMD_WITHOUT_PRI_IN	(USER_GET_ACCESS_JYLIST,user_get_access_jylist),
	FILL_CMD_WITH_PRI_IN	(USER_ACCESS_JY,user_access_jy),
	
	//pet
	FILL_CMD_WITH_PRI_IN    (USER_PET_SET_NICK,user_pet_set_nick),
	FILL_CMD_WITH_PRI_IN    (USER_PET_SET_FLAG,user_pet_set_flag),
	FILL_CMD_WITH_PRI_IN    (USER_PET_SET_BIRTHDAY,user_pet_set_birthday),
	FILL_CMD_WITH_PRI_IN    (USER_PET_SET_FLAG2,user_pet_set_flag2),
	FILL_CMD_WITH_PRI_IN    (USER_PET_SET_COLOR,user_pet_set_color),
	FILL_CMD_WITH_PRI_IN    (USER_PET_SET_SICKTIME,user_pet_set_sicktime),
	FILL_CMD_WITH_PRI_IN    (USER_PET_SET_ENDTIME,user_pet_set_endtime),
	FILL_CMD_WITH_PRI_IN    (USER_PET_SET_LIFE,user_pet_set_life),
	FILL_CMD_WITH_PRI_IN    (USER_PET_FEED_PET,user_pet_feed_pet),
	FILL_CMD_WITH_PRI_IN	(USER_JY_ACCESS_SET_OPT,user_jy_access_set_opt),
	FILL_CMD_WITH_PRI_IN    (USER_PET_RETRIEVE_PET,user_pet_retrieve_pet),
	FILL_CMD_WITH_PRI_IN    (USER_PET_GET_PET,user_pet_get_pet),
	FILL_CMD_WITH_PRI_IN    (USER_PET_TRAVEL_PET,user_pet_travel_pet),
	
	//email
	FILL_CMD_WITH_PRI_IN	(GET_USERID_BY_EMAIL,get_userid_by_email),
	FILL_CMD_WITH_PRI_IN	(EMAIL_CHECK_EMAIL_IS_EXISTED,email_check_email_is_existed),
	FILL_CMD_WITH_PRI_IN	(MAP_EMAIL_USERID ,map_email_userid ),
	FILL_CMD_WITH_PRI_IN	(DEL_MAP_EMAIL_USERID,del_map_email_userid),
	FILL_CMD_WITH_PRI_IN	(EMAIL_SET_EMAIL ,email_set_email ),
	
	//game score
	FILL_CMD_WITH_PRI_IN	(GET_GAME_SCORE_LIST,get_game_score_list),
	FILL_CMD_WITH_PRI_IN	(SET_GAME_SCORE,set_game_score),
	FILL_CMD_WITH_PRI_IN	(INIT_GAME_SCORE_LIST,init_game_score_list),
	FILL_CMD_WITH_PRI_IN	(GAME_SCORE_SET_SCORE,game_score_set_score),
	FILL_CMD_WITH_PRI_IN_GE	(GAME_USER_GET_LIST,game_user_get_list),
	FILL_CMD_WITH_PRI_IN	(GAME_GET_LIST,game_get_list),
	FILL_CMD_WITH_PRI_IN	(GAME_SET_PK_INFO,game_set_pk_info),
	FILL_CMD_WITH_PRI_IN	(GAME_GET_PK_INFO,game_get_pk_info),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_PK_GET_LIST,roominfo_pk_get_list),
	
	//serial SET_SERIAL_USED_CMD 
	FILL_CMD_WITH_PRI_IN	(SET_SERIAL_USED ,set_serial_used ),
	FILL_CMD_WITH_PRI_IN	(SET_SERIAL_UNUSED ,set_serial_unused ),
	FILL_CMD_WITH_PRI_IN	(SERIAL_GET_NOUSED_ID,serial_get_noused_id),
	FILL_CMD_WITH_PRI_IN	(SERIAL_SET_SERIAL_STR_USED ,serial_set_serial_str_used ),
	FILL_CMD_WITH_PRI_IN	(SERIAL_GET_INFO_SERIAL_STR ,serial_get_info_serial_str ),
	
	//MSG BOARD 
	FILL_CMD_WITH_PRI_IN_GE	(MSGBOARD_ADD_MSG ,msgboard_add_msg ),
	FILL_CMD_WITH_PRI_IN 	(MSGBOARD_GET_MSGLIST,msgboard_get_msglist),
	FILL_CMD_WITH_PRI_IN 	(MSGBOARD_GETMSG_BY_MSGID,msgboard_getmsg_by_msgid),
	FILL_CMD_WITH_PRI_IN 	(MSGBOARD_SET_MSG_FLAG ,msgboard_set_msg_flag ),
	FILL_CMD_WITH_PRI_IN 	(MSGBOARD_SET_MSG_FLAG_SU ,msgboard_set_msg_flag_su ),
	FILL_CMD_WITH_PRI_IN 	(MSGBOARD_ADD_HOT,msgboard_add_hot),
	FILL_CMD_WITH_PRI_IN 	(MSGBOARD_GET_LIST_WITH_FLAG,msgboard_get_list_with_flag),
	FILL_CMD_WITHOUT_PRI_IN (MSGBOARD_CLEAR_BY_DEL_FLAG,msgboard_clear_by_del_flag),
	FILL_CMD_WITH_PRI_IN	(MSGBOARD_GET_MSGLIST_USERID,msgboard_get_msglist_userid),
	FILL_CMD_WITH_PRI_IN	(MSGBOARD_GET_MSG_NOCHECK,msgboard_get_msg_nocheck),
	FILL_CMD_WITH_PRI_IN_GE	(MSGBOARD_RESET_MSG,msgboard_reset_msg),
	FILL_CMD_WITH_PRI_IN	(MSGBOARD_QA_ADD_MSG,msgboard_qa_add_msg),
	FILL_CMD_WITH_PRI_IN	(MSGBOARD_QA_GET_LIST,msgboard_qa_get_list),
	FILL_CMD_WITH_PRI_IN	(MSGBOARD_QA_DEL_MSG,msgboard_qa_del_msg),
	FILL_CMD_WITH_PRI_IN	(MSGBOARD_QA_GET_LIST_EX,msgboard_qa_get_list_ex),

	//客服两个协议号，同时绑定了一个函数
	FILL_CMD_WITHOUT_PRI_IN	(MSGBOARD_QA_GET_COUNT,msgboard_qa_get_count),
	FILL_CMD_WITHOUT_PRI_IN	(SU_MSGBOARD_QA_GET_COUNT,msgboard_qa_get_count),
	
	//FILL_CMD_WITH_PRI_IN 	(GET_REGISTER_SERIAL,GET_REGISTER_SERIAL),
	
	FILL_CMD_WITH_PRI_IN	(USERMSG_SET_REPORT_MSG ,usermsg_set_report_msg ),
	FILL_CMD_WITH_PRI_IN	(USERMSG_GET_REPORT_BY_DATE,usermsg_get_report_by_date),
	FILL_CMD_WITH_PRI_IN	(USERMSG_GET_REPORT_BY_DATE_USERID,usermsg_get_report_by_date_userid),
	FILL_CMD_WITH_PRI_IN_GE	(USERMSG_ADD_WRITING,usermsg_add_writing),
	FILL_CMD_WITH_PRI_IN	(USERMSG_GET_WRITING,usermsg_get_writing),
	FILL_CMD_WITH_PRI_IN	(USERMSG_GET_WRITING_LIST,usermsg_get_writing_list),
	FILL_CMD_WITH_PRI_IN	(USERMSG_CLEAR_WRITING,usermsg_clear_writing),
	FILL_CMD_WITH_PRI_IN_GE	(USERMSG_SET_DEL_WRITING,usermsg_set_del_writing),
	FILL_CMD_WITH_PRI_IN_GE	(USERMSG_SET_WRITING_REPORT,usermsg_set_writing_report),
	FILL_CMD_WITH_PRI_IN	(USERMSG_GET_WRITING_COUNT,usermsg_get_writing_count),
	FILL_CMD_WITH_PRI_IN	(USERMSG_CLEAR_BY_DATE_USERID ,usermsg_clear_by_date_userid ),
	FILL_CMD_WITH_PRI_IN	(USERMSG_ADD_REPORT_DEAL ,usermsg_add_report_deal ),
	FILL_CMD_WITH_PRI_IN	(USERMSG_GET_DEAL_REPORT_LIST,usermsg_get_deal_report_list),
	
	FILL_CMD_WITH_PRI_IN 	(SU_LOGIN,su_login),
	FILL_CMD_WITH_PRI_IN 	(SU_CHANGE,su_change),
	FILL_CMD_WITH_PRI_IN 	(SU_CHANGE_PASSWD,su_change_passwd),
	FILL_CMD_WITH_PRI_IN 	(SU_GET_ADMIN_LIST,su_get_admin_list),
	FILL_CMD_WITH_PRI_IN 	(SU_ADD_ADMIN,su_add_admin),
	FILL_CMD_WITHOUT_PRI_IN 	(SU_DEL_ADMIN,su_del_admin),
	FILL_CMD_WITH_PRI_IN 	(SU_GET_ADMINID_BY_NICK,su_get_adminid_by_nick),
	FILL_CMD_WITH_PRI_IN_GE	(SU_ADD_MSG_ATTIME,su_add_msg_attime),
	FILL_CMD_WITH_PRI_IN	(SU_GET_MSG_ATTIME_ALL,su_get_msg_attime_all),
	FILL_CMD_WITH_PRI_IN	(SU_DEL_MSG_ATTIME,su_del_msg_attime),
	FILL_CMD_WITH_PRI_IN	(SU_GET_MSG_ATTIME_BY_DATE,su_get_msg_attime_by_date),
	FILL_CMD_WITH_PRI_IN	(SU_CHANGELIST_ADD,su_changelist_add),
	
	FILL_CMD_WITH_PRI_IN 	(DV_CHANGE_PASSWD,dv_change_passwd),
	FILL_CMD_WITH_PRI_IN 	(DV_CHANGE_NICK,dv_change_nick),
	FILL_CMD_WITH_PRI_IN 	(DV_REGISTER,dv_register),
	
	FILL_CMD_WITH_PRI_IN 	(SYSARG_DAY_ADD,sysarg_day_add),
	FILL_CMD_WITHOUT_PRI_IN	(SYSARG_MONTH_TASK_GET_LIST,sysarg_month_task_get_list),
	FILL_CMD_WITH_PRI_IN	(SYSARG_MONTH_TASK_ADD,sysarg_month_task_add),
	FILL_CMD_WITH_PRI_IN 	(SYSARG_DAY_QUERY,sysarg_day_query),
	FILL_CMD_WITHOUT_PRI_IN	(SYSARG_DAY_GET_LIST_BY_USERID,sysarg_day_get_list_by_userid),
	FILL_CMD_WITH_PRI_IN	(SYSARG_DAY_SET,sysarg_day_set),
	FILL_CMD_WITHOUT_PRI_IN	(SYSARG_DAY_CLEAR,sysarg_day_clear),
	FILL_CMD_WITH_PRI_IN 	(SYSARG_GET_COUNT ,sysarg_get_count ),
	FILL_CMD_WITH_PRI_IN 	(SYSARG_SET_COUNT ,sysarg_set_count ),
	FILL_CMD_WITH_PRI_IN 	(SYSARG_GET_COUNT_LIST,sysarg_get_count_list),
	FILL_CMD_WITH_PRI_IN	(SYSARG_GET_QUESTIONNAIRE_LIST,sysarg_get_questionnaire_list),
	FILL_CMD_WITH_PRI_IN	(SYSARG_DAY_CLEAN_BY_TYPE,sysarg_day_clean_by_type),
	FILL_CMD_WITH_PRI_IN	(SYSARG_GET_QUESTIONNAIRE_SUBTYPE, sysarg_get_questionnaire_subtype),

	FILL_CMD_WITH_PRI_IN_GE	(SYSARG_ADD_QUESTIONNAIRE,sysarg_add_questionnaire),
	//TEMP 活动
	//FILL_CMD_WITHOUT_PRI_IN (CUP_GET_GROUP_HISTORY,cup_get_group_history),
	FILL_CMD_WITH_PRI_IN	(CONFECT_CHANGE_VALUE,confect_change_value),
	FILL_CMD_WITHOUT_PRI_IN	(CONFECT_GET_VALUE,confect_get_value),
	FILL_CMD_WITH_PRI_IN	(CONFECT_SET_TASK,confect_set_task),
	FILL_CMD_WITH_PRI_IN	(CONFECT_SET_VALUE,confect_set_value),
	
	FILL_CMD_WITHOUT_PRI_IN	(TEMPGS_GET_VALUE,tempgs_get_value),
	FILL_CMD_WITHOUT_PRI_IN	(TEMPGS_SET_COUNT,tempgs_set_count),
	FILL_CMD_WITH_PRI_IN	(TEMPGS_SET_TASK,tempgs_set_task),
	
	FILL_CMD_WITH_PRI_IN	(CHRISTMAS_ADD_MSG,christmas_add_msg),
	FILL_CMD_WITHOUT_PRI_IN	(CHRISTMAS_GET_MSG,christmas_get_msg),
	FILL_CMD_WITHOUT_PRI_IN	(CHRISTMAS_IS_GET_MSG,christmas_is_get_msg),
	FILL_CMD_WITHOUT_PRI_IN	(CHRISTMAS_IS_ADD_MSG,christmas_is_add_msg),
	
	FILL_CMD_WITH_PRI_IN	(USERSERIAL_GEN_SERIAL,userserial_gen_serial),
	FILL_CMD_WITH_PRI_IN	(USERSERIAL_DEL_SERIAL,userserial_del_serial),
	FILL_CMD_WITH_PRI_IN	(USERSERIAL_GET_SERIAL,userserial_get_serial),
	
	FILL_CMD_WITHOUT_PRI_IN	(SPRING_GET_VALUE,spring_get_value),
	FILL_CMD_WITH_PRI_IN	(SPRING_CHANGE_VALUE,spring_change_value),
	FILL_CMD_WITH_PRI_IN	(SPRING_SET_MSG,spring_set_msg),
	FILL_CMD_WITHOUT_PRI_IN	(SPRING_GET_MSG,spring_get_msg),
	FILL_CMD_WITHOUT_PRI_IN	(SPRING_INIT_GOLD_SILVER,spring_init_gold_silver),
	FILL_CMD_WITHOUT_PRI_IN	(SPRING_GET_FLAG,spring_get_flag),
	FILL_CMD_WITHOUT_PRI_IN	(SPRING_GET_SPRING,spring_get_spring),
	FILL_CMD_WITH_PRI_IN	(SPRING_SET_SPRING,spring_set_spring),
	
	//拉姆运动会
	FILL_CMD_WITHOUT_PRI_IN	(TEMP_PET_SPORTS_GET_LIST,temp_pet_sports_get_list),
	FILL_CMD_WITHOUT_PRI_IN	(TEMP_PET_USER_REPORTED,temp_pet_user_reported),
	FILL_CMD_WITHOUT_PRI_IN	(TEMP_PET_GET_PET_LIST,temp_pet_get_pet_list),
	FILL_CMD_WITH_PRI_IN	(TEMP_PET_REPORT,temp_pet_report),
	FILL_CMD_WITHOUT_PRI_IN	(TEMP_PET_GET_SCORE_LIST,temp_pet_get_score_list),
	FILL_CMD_WITH_PRI_IN	(TEMP_PET_SPORTS_SET_SCORE,temp_pet_sports_set_score),
	FILL_CMD_WITH_PRI_IN	(TEMP_PET_SPORTS_GET_MAX_SCORE,temp_pet_sports_get_max_score),
	FILL_CMD_WITH_PRI_IN	(TEMP_PET_GET_GROUP_ALLCOUNT,temp_pet_get_group_allcount),
	//客服，两个协议号同时绑定了一个函数，更改时注意	
	FILL_CMD_WITH_PRI_IN_GE (EMAILSYS_ADD_EMAIL,emailsys_add_email),
	FILL_CMD_WITH_PRI_IN_GE (SU_EMAILSYS_ADD_EMAIL,emailsys_add_email),

	FILL_CMD_WITH_PRI_IN 	(EMAILSYS_GET_EMAIL,emailsys_get_email),
	FILL_CMD_WITHOUT_PRI_IN (EMAILSYS_GET_EMAILID_LIST,emailsys_get_emailid_list),
	FILL_CMD_WITH_PRI_IN 	(EMAILSYS_DEL_EMAIL ,emailsys_del_email ),
	FILL_CMD_WITHOUT_PRI_IN	(EMAILSYS_GET_EMAIL_MSG,emailsys_get_email_msg),
	//客服，两个协议号同时绑定了一个函数，更改时注意   
	FILL_CMD_WITHOUT_PRI_IN	(EMAILSYS_CLEAN_EMAIL,emailsys_clean_email),
	FILL_CMD_WITHOUT_PRI_IN	(SU_EMAILSYS_CLEAN_EMAIL,emailsys_clean_email),
	//HOPE
	FILL_CMD_WITH_PRI_IN 	(HOPE_ADD_HOPE ,hope_add_hope ),
	FILL_CMD_WITH_PRI_IN 	(HOPE_SET_HOPE_USED,hope_set_hope_used),
	FILL_CMD_WITH_PRI_IN 	(HOPE_CHECK_HOPE,hope_check_hope),
	FILL_CMD_WITH_PRI_IN 	(HOPE_GET_HOPE_LIST,hope_get_hope_list),
	FILL_CMD_WITH_PRI_IN 	(HOPE_GET_HOPE_LIST_BY_DATE,hope_get_hope_list_by_date),
	FILL_CMD_WITHOUT_PRI_IN	(HOPE_GET_HOPE_ALL,hope_get_hope_all),
	FILL_CMD_WITH_PRI_IN	(HOPE_SET_HOPE_EX,hope_set_hope_ex),
	
	//HOME
	//客服，两个协议号同时绑定了一个函数，更改时注意  
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_GET_HOT,roominfo_get_hot),
	FILL_CMD_WITHOUT_PRI_IN	(SU_ROOMINFO_GET_HOT,roominfo_get_hot),

	FILL_CMD_WITH_PRI_IN	(ROOMINFO_PK_ADD,roominfo_pk_add),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_VOTE_ROOM,roominfo_vote_room),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_CLASS_QA_ADD_SCORE,roominfo_class_qa_add_score),
	FILL_CMD_WITH_PRI_IN	(GAME_SET_SCORE,game_set_score),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_CLASS_QA_CHECK_ADD,roominfo_class_qa_check_add),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_BOX_GET_LIST,roominfo_box_get_list),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_BOX_ADD,roominfo_box_add),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_PUG_LIST,roominfo_pug_list),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_INIT_USER,roominfo_init_user),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_INIT_MUD,roominfo_init_mud),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_DEL_MUD,roominfo_del_mud),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_SET_INFO,roominfo_set_info),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_PRESENTLIST_GET,roominfo_presentlist_get),
	
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_ADD_HOT,roominfo_add_hot),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_PRESENTLIST_ADD,roominfo_presentlist_add),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_CLASS_QA_GET_INFO,roominfo_class_qa_get_info),
	
	
	// room_msg
	FILL_CMD_WITH_PRI_IN (ROOMMSG_ADD_MSG,roommsg_add_msg), 
	
	//客服，两个协议号同时绑定了一个函数，更改时注意
	FILL_CMD_WITH_PRI_IN (ROOMMSG_SHOW_MSG,roommsg_show_msg), 
	FILL_CMD_WITH_PRI_IN (SU_ROOMMSG_SHOW_MSG,roommsg_show_msg), 
	FILL_CMD_WITH_PRI_IN (ROOMMSG_LIST_MSG,roommsg_list_msg), 
	FILL_CMD_WITH_PRI_IN (SU_ROOMMSG_LIST_MSG,roommsg_list_msg), 

	//客服，两个协议号同时绑定了一个函数，更改时注意	
	FILL_CMD_WITH_PRI_IN (ROOMMSG_DEL_MSG,roommsg_del_msg),
	FILL_CMD_WITH_PRI_IN (SU_ROOMMSG_DEL_MSG,roommsg_del_msg),
	FILL_CMD_WITH_PRI_IN (ROOMMSG_RES_MSG,roommsg_res_msg), 
	FILL_CMD_WITH_PRI_IN (SU_ROOMMSG_RES_MSG,roommsg_res_msg), 

	FILL_CMD_WITH_PRI_IN_GE	(ROOMMSG_ADD_DIARY,roommsg_add_diary),
	FILL_CMD_WITH_PRI_IN_GE	(ROOMMSG_SET_DIARY,roommsg_set_diary),
	FILL_CMD_WITH_PRI_IN	(ROOMMSG_SET_DIARY_PUB_FLAG,roommsg_set_diary_pub_flag),
	FILL_CMD_WITH_PRI_IN	(ROOMMSG_GET_DIARY_LIST,roommsg_get_diary_list),
	FILL_CMD_WITH_PRI_IN	(ROOMMSG_GET_DIARY,roommsg_get_diary),
	
	
	
	FILL_CMD_WITHOUT_PRI_IN	(GROUPMAIN_GEN_GROUPID,groupmain_gen_groupid),
	
	FILL_CMD_WITH_PRI_IN	(GROUP_ADD_GROUP,group_add_group),
	FILL_CMD_WITH_PRI_IN	(GROUP_ADD_MEMBER,group_add_member),
	FILL_CMD_WITH_PRI_IN	(GROUP_DEL_MEMBER,group_del_member),
	FILL_CMD_WITH_PRI_IN	(GROUP_SET_MSG,group_set_msg),
	FILL_CMD_WITHOUT_PRI_IN	(GROUP_GET_INFO,group_get_info),
	FILL_CMD_WITH_PRI_IN	(GROUP_DEL_GROUP,group_del_group),
	FILL_CMD_WITHOUT_PRI_IN	(GROUP_CHECK_GROUP,group_check_group),
	FILL_CMD_WITHOUT_PRI_IN	(GROUP_GET_OWNERID,group_get_ownerid),
	FILL_CMD_WITHOUT_PRI_IN	(GROUP_GET_MEMBERLIST,group_get_memberlist),
	
	
	
	FILL_CMD_WITHOUT_PRI_IN	(MMS_GET_INFO,mms_get_info),
	FILL_CMD_WITH_PRI_IN	(MMS_OPT,mms_opt),
	FILL_CMD_WITH_PRI_IN	(MMS_GET_OPTLIST,mms_get_optlist),
	FILL_CMD_WITHOUT_PRI_IN	(MMS_PICK_ONE_FRUIT,mms_pick_one_fruit),
	FILL_CMD_WITHOUT_PRI_IN	(MMS_GET_TYPE_LIST,mms_get_type_list),
	FILL_CMD_WITHOUT_PRI_IN	(MMS_GET_TYPE_LIST_EX,mms_get_type_list_ex),
	FILL_CMD_WITH_PRI_IN	(MMS_SET_VALUE,mms_set_value),
	FILL_CMD_WITH_PRI_IN	(MMS_GET_INFO_BY_TYPE,mms_get_info_by_type),
	FILL_CMD_WITH_PRI_IN    (MMS_SET_WATER_LIST,mms_set_water_list),
	FILL_CMD_WITHOUT_PRI_IN (MMS_GET_WATER_LIST,mms_get_water_list),

	FILL_CMD_WITH_PRI_IN    (PASSWD_ADD_CHANGE,passwd_add_change),
	FILL_CMD_WITH_PRI_IN_GE	(LOG_ADD_CHAT,log_add_chat),
	FILL_CMD_WITH_PRI_IN	(LOG_ADD_CHANGE,log_add_change),
	
	//ADMIN
	FILL_CMD_WITH_PRI_IN	(ADMIN_ADD_ADMIN,admin_add_admin),
	FILL_CMD_WITH_PRI_IN	(ADMIN_GET_ADMINLIST,admin_get_adminlist),
	FILL_CMD_WITH_PRI_IN	(ADMIN_CHANGE_PASSWD,admin_change_passwd),
	FILL_CMD_WITH_PRI_IN	(ADMIN_DEL_ADMIN,admin_del_admin),
	FILL_CMD_WITH_PRI_IN	(ADMIN_LOGIN,admin_login),
	FILL_CMD_WITH_PRI_IN	(ADMIN_ADD_POWER,admin_add_power),
	FILL_CMD_WITH_PRI_IN	(ADMIN_DEL_POWER,admin_del_power),
	FILL_CMD_WITHOUT_PRI_IN	(ADMIN_GET_POWERLIST,admin_get_powerlist),
	FILL_CMD_WITH_PRI_IN	(ADMIN_ROOT_CHANGE_PASSWD,admin_root_change_passwd),
	FILL_CMD_WITH_PRI_IN	(ADMIN_SET_USE_FLAG,admin_set_use_flag),
	FILL_CMD_WITH_PRI_IN	(ADMIN_GET_ADMINID_BY_NICK,admin_get_adminid_by_nick),
	FILL_CMD_WITH_PRI_IN	(ADMIN_GET_ADMINLIST_BY_POWERID,admin_get_adminlist_by_powerid),
	
	FILL_CMD_WITH_PRI_IN	(PARTY_ADD_PARTY,party_add_party),
	FILL_CMD_WITH_PRI_IN	(PARTY_GET_PARTYLIST,party_get_partylist),
	FILL_CMD_WITH_PRI_IN	(PARTY_GET_COUNT_BY_SERVER,party_get_count_by_server),
	FILL_CMD_WITH_PRI_IN	(PARTY_GETLIST_BY_OWNERID,party_getlist_by_ownerid),
	//PIC
	FILL_CMD_WITH_PRI_IN	(PIC_ADD_PIC,pic_add_pic),
	FILL_CMD_WITH_PRI_IN	(PIC_GET_USER_ABLUM_PICLIST,pic_get_user_ablum_piclist),
	FILL_CMD_WITH_PRI_IN	(PIC_GET_PIC_BY_PHOTOID_USERID,pic_get_pic_by_photoid_userid),
	FILL_CMD_WITH_PRI_IN	(PIC_DEL_PIC_BY_PHOTOID_USERID,pic_del_pic_by_photoid_userid),
	
	//APPEAL
	FILL_CMD_WITH_PRI_IN	(APPEAL_ADD_APPEAL,appeal_add_appeal),
	FILL_CMD_WITH_PRI_IN	(APPEAL_EX_GET_USER_LAST_STATE,appeal_ex_get_user_last_state),
	FILL_CMD_WITH_PRI_IN	(APPEAL_EX_GET_STATE,appeal_ex_get_state),
	FILL_CMD_WITH_PRI_IN	(APPEAL_GET_LIST,appeal_get_list),
	FILL_CMD_WITH_PRI_IN	(APPEAL_GET_APPEAL,appeal_get_appeal),
	FILL_CMD_WITH_PRI_IN	(APPEAL_DEAL,appeal_deal),
	FILL_CMD_WITH_PRI_IN	(APPEAL_EX_DEAL,appeal_ex_deal),
	FILL_CMD_WITH_PRI_IN	(APPEAL_EX_ADD_APPEAL,appeal_ex_add_appeal),
	FILL_CMD_WITH_PRI_IN	(APPEAL_EX_GET_LIST,appeal_ex_get_list),
	
	//question
	FILL_CMD_WITH_PRI_IN    (ROOMINFO_QUESTION_SET,roominfo_question_set),
	FILL_CMD_WITHOUT_PRI_IN (ROOMINFO_QUESTION_GET,roominfo_question_get),

	////farm
	FILL_CMD_WITH_PRI_IN_GE	(USER_FARM_EDIT,user_farm_edit),
	FILL_CMD_WITH_PRI_IN	(USER_FARM_GET_NOUSEDLIST,user_farm_get_nousedlist),
	FILL_CMD_WITHOUT_PRI_IN	(USER_GET_FARM,user_get_farm),

    FILL_CMD_WITH_PRI_IN    (USER_DEL_ANIMAL,user_del_animal),
	FILL_CMD_WITHOUT_PRI_IN	(USER_FARM_ANIMAL_ADD,user_farm_animal_add),
	FILL_CMD_WITH_PRI_IN	(USER_FARM_ANIMAIL_DEL_EX,user_farm_animail_del_ex),
    FILL_CMD_WITH_PRI_IN    (USER_FARM_FEEDSTUFF_ADD,user_farm_feedstuff_add),
    FILL_CMD_WITH_PRI_IN    (USER_FARM_PUT_ANIMAL,user_farm_put_animal),
    FILL_CMD_WITHOUT_PRI_IN (USER_FARM_WATER,user_farm_water),
	FILL_CMD_WITH_PRI_IN    (USER_FARM_SET_ACCESTLIST,user_farm_set_accestlist),
	FILL_CMD_WITH_PRI_IN    (USER_FARM_GET_FISH, user_farm_get_fish),
	FILL_CMD_WITHOUT_PRI_IN (USER_FARM_GET_ACCESTLIST,user_farm_get_accestlist),
	FILL_CMD_WITHOUT_PRI_IN (USER_FARM_GET_ALL_ANIMAL_INFO,user_farm_get_all_animal_info),
	FILL_CMD_WITH_PRI_IN    (USER_FARM_UPDATE_ANIMAL_INFO,user_farm_update_animal_info),
	FILL_CMD_WITH_PRI_IN    (USER_FARM_SET_STATE,user_farm_set_state),

	//calss
	FILL_CMD_WITH_PRI_IN	(FF_LOGIN_ADD,ff_login_add),
	FILL_CMD_WITH_PRI_IN    (FF_LOGIN_GET_LIST,ff_login_get_list),
	FILL_CMD_WITHOUT_PRI_IN	(IP_HISTORY_GET_LASTIP,ip_history_get_lastip),
	FILL_CMD_WITH_PRI_IN_GE	(DWG_SENDMSG_TO_FRIENDS,dwg_sendmsg_to_friends),
	FILL_CMD_WITH_PRI_IN    (USER_THIEVE_FRUIT,user_thieve_fruit),

	//FILL_CMD_WITHOUT_PRI_IN  (CROOMINFO_GEN_VIP,croominfo_gen_vip),
	//FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_GEN_VIP_DEL,roominfo_gen_vip_del),
	//FILL_CMD_WITHOUT_PRI_IN (ROOMINFO_CHECK_IF_GEN_VIP,roominfo_check_if_gen_vip),
	//card
	FILL_CMD_WITH_PRI_IN    (USER_SWAP_CARD_SEARCH,user_swap_card_search),
	FILL_CMD_WITH_PRI_IN    (USER_SWAP_CARD_SET_SWAP,user_swap_card_set_swap),
	FILL_CMD_WITH_PRI_IN    (USER_SWAP_CARD_SWAP,user_swap_card_swap),
	FILL_CMD_WITHOUT_PRI_IN    (USER_SWAP_CARD_GET_SUPER,user_swap_card_get_super),
	
	//客服，两个协议号同时绑定了一个函数，更改时注意
	FILL_CMD_WITHOUT_PRI_IN (USER_SWAP_CARD_GET_CARD,user_swap_card_get_card),
	FILL_CMD_WITHOUT_PRI_IN (SU_USER_SWAP_CARD_GET_CARD,user_swap_card_get_card),

	FILL_CMD_WITH_PRI_IN    (USER_SWAP_CARD_SET_CARD,user_swap_card_set_card),
	//clothe
	//FILL_CMD_WITHOUT_PRI_IN    (ROOMINFO_GET_CLOTHE_WASTE,roominfo_get_clothe_waste),
	//FILL_CMD_WITH_PRI_IN    (ROOMINFO_SET_CLOTHE_WASTE,roominfo_set_clothe_waste),
	//point
	//FILL_CMD_WITHOUT_PRI_IN    (ROOMINFO_GET_POINT,roominfo_get_point),
	//FILL_CMD_WITH_PRI_IN    (ROOMINFO_SET_POINT,roominfo_set_point),
	FILL_CMD_WITHOUT_PRI_IN (ROOMINFO_GET_POS,roominfo_get_pos),
	FILL_CMD_WITH_PRI_IN    (ROOMINFO_SET_POS,roominfo_set_pos),
	FILL_CMD_WITH_PRI_IN (ROOMINFO_CLEAR_POS,roominfo_clear_pos),
	FILL_CMD_WITH_PRI_IN    (ROOMINFO_SET_CLASS_MEDAL_FLAG,roominfo_set_class_medal_flag),
	FILL_CMD_WITHOUT_PRI_IN (USER_CLASS_GET_MEDAL_LIST,user_class_get_medal_list),
	FILL_CMD_WITH_PRI_IN    (USER_CLASS_SET_MEDAL_LIST,user_class_set_medal_list),
	FILL_CMD_WITH_PRI_IN    (USER_SET_PUNISH_FLAG,user_set_punish_flag),
	FILL_CMD_WITH_PRI_IN    (USER_SET_PET_SICK_TYPE,user_set_pet_sick_type),
	//fire cup
	FILL_CMD_WITH_PRI_IN    (ROOMINFO_SIG_FIRE_CUP,roominfo_sig_fire_cup),
	FILL_CMD_WITHOUT_PRI_IN (ROOMINFO_GET_FIRE_CUP_TEAM,roominfo_get_fire_cup_team),
	FILL_CMD_WITHOUT_PRI_IN (ROOMINFO_FIRE_CUP_GET,roominfo_fire_cup_get),
	FILL_CMD_WITH_PRI_IN    (ROOMINFO_FIRE_CUP_UPDATE,roominfo_fire_cup_update),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_GET_FIRE_CUP_PRIZE, roominfo_get_fire_cup_prize),
	//FILL_CMD_WITHOUT_PRI_IN (SYSARG_GET_TEAM,sysarg_get_team),
	//FILL_CMD_WITH_PRI_IN 	(SYSARG_GET_FIRE_CUP,sysarg_get_fire_cup),
	FILL_CMD_WITH_PRI_IN    (SYS_ADD_TEAM_MEDAL,sys_add_team_medal),
	FILL_CMD_WITHOUT_PRI_IN (SYS_GET_ALL_MEDAL_LIST,sys_get_all_medal_list),

	FILL_CMD_WITH_PRI_IN    (ROOMINFO_SET_TASK,roominfo_set_task),
	FILL_CMD_WITHOUT_PRI_IN (ROOMINFO_GET_TASK,roominfo_get_task),
	FILL_CMD_WITH_PRI_IN    (HISTORY_IP_RECORD, history_ip_record),
	FILL_CMD_WITH_PRI_IN    (USER_UPDATE_GAME_SCORE, user_update_game_score),
	FILL_CMD_WITH_PRI_IN    (USER_LAMU_DIARY_EDIT,user_lamu_diary_edit),
	FILL_CMD_WITH_PRI_IN    (USER_LAMU_CATALOG_GET,user_lamu_catalog_get),
	FILL_CMD_WITH_PRI_IN    (USER_LAMU_DIARY_DELETE,user_lamu_diary_delete),
	FILL_CMD_WITH_PRI_IN    (USER_LAMU_DIARY_STATE_UPDATE,user_lamu_diary_state_update),
	FILL_CMD_WITH_PRI_IN (USER_LAMU_DIARY_FLOWER_UPDATE,user_lamu_diary_flower_update),
	FILL_CMD_WITH_PRI_IN    (USER_LAMU_DIARY_CONTENT_GET,user_lamu_diary_content_get),
	FILL_CMD_WITH_PRI_IN    (ROOMINFO_WORK_SET,roominfo_work_set),
	FILL_CMD_WITHOUT_PRI_IN    (ROOMINFO_WORK_GET,roominfo_work_get),
	FILL_CMD_WITH_PRI_IN    (USER_EX_SET_DIARY_LOCK,user_ex_set_diary_lock),
	FILL_CMD_WITHOUT_PRI_IN (USER_EX_DIARY_LOCK_GET,user_ex_diary_lock_get),
	FILL_CMD_WITHOUT_PRI_IN (USER_LAMU_DIARY_COUNT,user_lamu_diary_count),
	FILL_CMD_WITH_PRI_IN    (USER_SET_WORK_LEVEL,user_set_work_level),
	FILL_CMD_WITH_PRI_IN    (USER_PET_TASK_SET_EX, user_pet_task_set_ex),
	FILL_CMD_WITH_PRI_IN (USER_TASK_PET_FIRST_STAGE_SET,user_task_pet_first_stage_set),
	//客服，两个协议号同时绑定了一个函数，更改时注意
	FILL_CMD_WITH_PRI_IN	(USER_RESET_HOME,user_reset_home),
	FILL_CMD_WITH_PRI_IN	(SU_USER_RESET_HOME,user_reset_home),

	FILL_CMD_WITH_PRI_IN    (USER_TASK_TASKID_DEL,user_task_taskid_del),
	FILL_CMD_WITH_PRI_IN    (USER_TASK_SET_CLIENT_DATA,user_task_set_client_data),
	FILL_CMD_WITH_PRI_IN    (USER_TASK_GET_CLIENT_DATA,user_task_get_client_data),
	FILL_CMD_WITH_PRI_IN    (USER_TASK_GET_PET_TASK,user_task_get_pet_task),
	FILL_CMD_WITH_PRI_IN    (USER_ATTIRE_PUT_CHEST,user_attire_put_chest),
	FILL_CMD_WITH_PRI_IN	(USER_ATTIRE_GET_LIST_EX,user_attire_get_list_ex),
	FILL_CMD_WITH_PRI_IN    (USER_ATTIRE_DEL_CHEST,user_attire_del_chest),
	FILL_CMD_WITHOUT_PRI_IN    (USER_ATTIRE_GET_CHEST_LIST,user_attire_get_chest_list),
	FILL_CMD_WITH_PRI_IN    (ROOMINFO_CHANGE_PRESENT,roominfo_change_present),
	FILL_CMD_WITHOUT_PRI_IN (ROOMINFO_GET_PRESENT_NUM,roominfo_get_present_num),
	FILL_CMD_WITHOUT_PRI_IN (USER_MAGIC_TASK_PET_GET_ALL,user_magic_task_pet_get_all),
	FILL_CMD_WITH_PRI_IN    (USER_MAGIC_TASK_PET_UPDATE,user_magic_task_pet_update),
	FILL_CMD_WITH_PRI_IN    (USER_GET_ATTIRE_LIST_ALL,user_get_attire_list_all),
	FILL_CMD_WITHOUT_PRI_IN	(USER_FARM_GET_SHEEP_NUM,user_farm_get_sheep_num),
	FILL_CMD_WITH_PRI_IN	(USER_AUTO_INSERT,user_auto_insert),
	FILL_CMD_WITH_PRI_IN	(USER_AUTO_CHANGE_ATTIRE,user_auto_change_attire),
	FILL_CMD_WITH_PRI_IN	(USER_AUTO_CHANGE_PROPERY,user_auto_change_propery),
	FILL_CMD_WITHOUT_PRI_IN	(USER_AUTO_GET_ALL,user_auto_get_all),
	FILL_CMD_WITH_PRI_IN	(USER_AUTO_ADD_OIL,user_auto_add_oil),
	FILL_CMD_WITH_PRI_IN	(USER_AUTO_GET_ONE_INFO,user_auto_get_one_info),
	FILL_CMD_WITHOUT_PRI_IN	(USER_EX_SET_DRIVER_TIME,user_ex_set_driver_time),
	FILL_CMD_WITH_PRI_IN	(USER_EX_SET_SHOW_AUTO,user_ex_set_show_auto),
	FILL_CMD_WITHOUT_PRI_IN	(USER_EX_GET_SHOW_AUTO,user_ex_get_show_auto),
	FILL_CMD_WITH_PRI_IN	(USER_SET_INT_VALUE,user_set_int_value),
	FILL_CMD_WITH_PRI_IN	(USER_EX_SET_INT_VALUE,user_ex_set_int_value),
	FILL_CMD_WITH_PRI_IN	(USER_EX_SET_AUTO_SKILL,user_ex_set_auto_skill),
	FILL_CMD_WITH_PRI_IN	(USER_AUTO_CHANGE_ADRON,user_auto_change_adron),
	FILL_CMD_WITH_PRI_IN	(USER_CLASS_ADD_SCORE,user_class_add_score),
	FILL_CMD_WITHOUT_PRI_IN	(USER_CLASS_GET_SCORE,user_class_get_score),
	//FILL_CMD_WITH_PRI_IN	(ROOMINFO_ADD_CANDY,roominfo_add_candy),
	//FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_GET_CANDY,roominfo_get_candy),
	FILL_CMD_WITHOUT_PRI_IN	(USER_INFO_GET_SET_PASSWD_FLAG,user_info_get_set_passwd_flag),
	//FILL_CMD_WITH_PRI_IN	(ROOMINFO_ADD_CLASS_SCORE,roominfo_add_class_score),
	//FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_GET_CLASS_SCORE,roominfo_get_class_score),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_GET_SCORE_CANDY,roominfo_get_score_candy),
	FILL_CMD_WITH_PRI_IN_GE	(USER_FARM_SET_ATTIRELIST,user_farm_set_attirelist),
	//FILL_CMD_WITH_PRI_IN	(ROOMINFO_ADD_CATCH_CANDY,roominfo_add_catch_candy),
	//FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_RALLY_SIGN,roominfo_rally_sign),
	//FILL_CMD_WITH_PRI_IN	(ROOMINFO_RALLY_ADD_SCORE,roominfo_rally_add_score),
	//FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_RALLY_GET_SCORE,roominfo_rally_get_score),
	//FILL_CMD_WITH_PRI_IN	(SYS_RALLY_UPDATE_SCORE,sys_rally_update_score),
	//FILL_CMD_WITH_PRI_IN	(SYS_RALLY_UPDATE_RACE,sys_rally_update_race),
	//FILL_CMD_WITHOUT_PRI_IN	(SYS_GET_TEAM_RACE_LIST,sys_get_team_race_list),
	//FILL_CMD_WITHOUT_PRI_IN	(SYS_GET_TEAM_SCORE_LIST,sys_get_team_score_list),
	//FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_RALLY_GET_RACE_INFO,roominfo_rally_get_race_info),
	//FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_RALLY_GET_TODAY_SCORE,roominfo_rally_get_today_score),
	//FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_RALLY_DESC_RACE,roominfo_rally_desc_race),
	//FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_RALLY_GET_TEAM,roominfo_rally_get_team),
	FILL_CMD_WITH_PRI_IN	(USER_AUTO_GET_ONE_KIND_NUM,user_auto_get_one_kind_num),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_RALLY_ADD_MEDAL,roominfo_rally_add_medal),
	FILL_CMD_WITH_PRI_IN	(USER_FARM_SET_OUTGO,user_farm_set_outgo),
	FILL_CMD_WITH_PRI_IN	(USER_FARM_SET_EATTIME,user_farm_set_eattime),
	FILL_CMD_WITH_PRI_IN	(USER_AUTO_DEL,user_auto_del),
	FILL_CMD_WITH_PRI_IN_GE	(USER_ATTIRE_GET_SOME_ATTIRE_COUNT,user_attire_get_some_attire_count),
	FILL_CMD_WITHOUT_PRI_IN	(USER_AUTO_GET_ALL_WEB,user_auto_get_all_web),
	FILL_CMD_WITH_PRI_IN	(USER_AUTO_SET_AUTO_WEB,user_auto_set_auto_web),
	//FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_GET_MERGE,roominfo_get_merge),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_MERGE_UPDATE,roominfo_merge_update),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_MERGE_SET_GET,roominfo_merge_set_get),
	FILL_CMD_WITH_PRI_IN	(USERINFO_LOG_FOR_BLW,userinfo_log_for_blw),
	FILL_CMD_WITH_PRI_IN_GE	(USER_ATTIRE_SET_USED,user_attire_set_used),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_CHECK_CANDY,roominfo_check_candy),
	//FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_RALLY_GET_USER_ALL_INFO_WEB,roominfo_rally_get_user_all_info_web),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_GET_USER_ALL_INFO_WEB,roominfo_get_user_all_info_web),
	FILL_CMD_WITHOUT_PRI_IN	(USER_FARM_NET_CATCH_FISH,user_farm_net_catch_fish),
	FILL_CMD_WITHOUT_PRI_IN	(USER_FARM_SET_NET,user_farm_set_net),
	FILL_CMD_WITHOUT_PRI_IN	(USER_FARM_GET_NET,user_farm_get_net),
	//FILL_CMD_WITH_PRI_IN	(ROOMINFO_CHANGE_CANDY_EX,roominfo_change_candy_ex),
	//FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_CHANGE_CANDY,roominfo_change_candy),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_SET_USER_ALL_INFO_WEB,roominfo_set_user_all_info_web),
	//FILL_CMD_WITH_PRI_IN	(ROOMINFO_CHECK_CANDY_LIST,roominfo_check_candy_list),
	FILL_CMD_WITH_PRI_IN	(ROOMMSG_INSERT_BIBO,roommsg_insert_bibo),
	FILL_CMD_WITH_PRI_IN	(ROOMMSG_DEL_BIBO,roommsg_del_bibo),
	FILL_CMD_WITH_PRI_IN	(ROOMMSG_GET_BIBO_LIST,roommsg_get_bibo_list),
	FILL_CMD_WITH_PRI_IN	(SYSARG_DB_MSG_EDIT,sysarg_db_msg_edit),
	FILL_CMD_WITH_PRI_IN	(SYSARG_DB_MSG_DEL,sysarg_db_msg_del),
	FILL_CMD_WITH_PRI_IN	(SYSARG_DB_MSG_GET,sysarg_db_msg_get),
	FILL_CMD_WITHOUT_PRI_IN	(SYSARG_DB_MSG_GET_ALL_WEB,sysarg_db_msg_get_all_web),
	FILL_CMD_WITH_PRI_IN	(USER_JY_ADD_EXP,user_jy_add_exp),
	FILL_CMD_WITH_PRI_IN	(USER_NPC_CHANGE,user_npc_change),
	FILL_CMD_WITHOUT_PRI_IN	(USER_FARM_GET_WEB,user_farm_get_web),
	FILL_CMD_WITH_PRI_IN	(USER_FARM_SET_WEB,user_farm_set_web),
	FILL_CMD_WITHOUT_PRI_IN	(USER_NPC_GET_WEB,user_npc_get_web),
	FILL_CMD_WITH_PRI_IN	(USER_NPC_UPDATE_WEB,user_npc_update_web),
	FILL_CMD_WITH_PRI_IN	(USER_FARM_RABBIT_FOSTER,user_farm_rabbit_foster),
	FILL_CMD_WITHOUT_PRI_IN	(USER_FARM_RABBIT_DEL,user_farm_rabbit_del),
	FILL_CMD_WITH_PRI_IN	(SYSARG_DAY_GET_LIST,sysarg_day_get_list),
	FILL_CMD_WITHOUT_PRI_IN	(USER_FARM_GET_PLANT_BREED,user_farm_get_plant_breed),
	FILL_CMD_WITH_PRI_IN	(USER_EGG_INSERT,user_egg_insert),
	FILL_CMD_WITH_PRI_IN	(USER_EGG_FUDAN,user_egg_fudan),
	FILL_CMD_WITH_PRI_IN	(USER_EGG_GET_INFO,user_egg_get_info),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_PIC_INSERT,roominfo_pic_insert),
	FILL_CMD_WITH_PRI_IN	(USER_FARM_ANIMAL_GET_WOOL,user_farm_animal_get_wool),
	FILL_CMD_WITH_PRI_IN	(SYSARG_DB_UPDATE_ANIMAL_LIMIT,sysarg_db_update_animal_limit),
	FILL_CMD_WITH_PRI_IN	(SYSARG_GET_ANIMAL_LIMIT,sysarg_get_animal_limit),
	FILL_CMD_WITH_PRI_IN	(USER_NPC_TASK_RECV,user_npc_task_recv),
	FILL_CMD_WITH_PRI_IN	(USER_NPC_TASK_FINISH,user_npc_task_finish),
	FILL_CMD_WITH_PRI_IN	(USER_NPC_TASK_GET_BUF,user_npc_task_get_buf),
	FILL_CMD_WITH_PRI_IN	(USER_NPC_TASK_SET_BUF,user_npc_task_set_buf),
	FILL_CMD_WITH_PRI_IN	(USER_NPC_ONE_TASK_GET_INFO,user_npc_one_task_get_info),
	FILL_CMD_WITH_PRI_IN	(USER_NPC_TASK_GET_NPC_TASK,user_npc_task_get_npc_task),
	FILL_CMD_WITH_PRI_IN	(USER_NPC_TASK_DELETE_NPC_TASK,user_npc_task_delete_npc_task),
	FILL_CMD_WITH_PRI_IN	(USER_EGG_BROOD_EGG,user_egg_brood_egg),
	FILL_CMD_WITHOUT_PRI_IN	(USER_EGG_GET_ALL_WEB,user_egg_get_all_web),
	FILL_CMD_WITH_PRI_IN	(USER_EGG_UPDATE_WEB,user_egg_update_web),
	FILL_CMD_WITH_PRI_IN	(USER_EX_UPDATE_PIC_CLOTHE,user_ex_update_pic_clothe),
	FILL_CMD_WITHOUT_PRI_IN	(USER_EX_GET_PIC_CLOTHE,user_ex_get_pic_clothe),
	FILL_CMD_WITH_PRI_IN	(USER_MODE_LEVEL_SET,user_mode_level_set),
	FILL_CMD_WITH_PRI_IN_GE	(USER_ATTIRE_SET_MODE_ATTIRE,user_attire_set_mode_attire),
	FILL_CMD_WITHOUT_PRI_IN	(USER_ATTIRE_GET_MODE_ATTIRE,user_attire_get_mode_attire),
	FILL_CMD_WITH_PRI_IN	(USER_ATTIRE_SET_MODE_TO_MOLE,user_attire_set_mode_to_mole),
	FILL_CMD_WITH_PRI_IN	(USER_ATTIRE_SET_CLOTHE_MOLE_TO_MODE,user_attire_set_clothe_mole_to_mode),
	FILL_CMD_WITHOUT_PRI_IN	(USER_HOME_ADD_MODE,user_home_add_mode),
	//FILL_CMD_WITHOUT_PRI_IN	(USER_PIC_BOOK_UPDATE,user_pic_book_update),
	FILL_CMD_WITHOUT_PRI_IN	(USER_PIC_BOOK_GET,user_pic_book_get),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_FLOWER_UPDATE,roominfo_flower_update),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_FLOWER_GET,roominfo_flower_get),
	FILL_CMD_WITH_PRI_IN	(SYSARG_ANIMAL_GET_MAX_WEIGHT_FISH,sysarg_animal_get_max_weight_fish),
	FILL_CMD_WITH_PRI_IN	(USER_FARM_SET_COL,user_farm_set_col),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_GET_SOCKES,roominfo_get_sockes),
	FILL_CMD_WITH_PRI_IN	(USER_ANIMAL_RELEASE_INSECT,user_animal_release_insect),
	FILL_CMD_WITH_PRI_IN	(USER_ANIMAL_SET_ANIMAL_FLAG,user_animal_set_animal_flag),
	FILL_CMD_WITH_PRI_IN	(USER_JY_BUTTERFLY_POLLINATE_FLOWER,user_jy_butterfly_pollinate_flower),
	FILL_CMD_WITH_PRI_IN	(USER_ANIMAL_POLLINATE,user_animal_pollinate),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_UPDATE_WISH,roominfo_update_wish),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_GET_WISH,roominfo_get_wish),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_CHANGE_GIFT_NUM,roominfo_change_gift_num),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_GET_GIFT_NUM,roominfo_get_gift_num),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_RECORD_GIVE_GIFT_USERID,roominfo_record_give_gift_userid),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_GET_GIVE_GIFT_USERID,roominfo_get_give_gift_userid),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_ADD_ENERGY_STAR,roominfo_add_energy_star),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_GET_ENERGY_STAR,roominfo_get_energy_star),
	FILL_CMD_WITH_PRI_IN	(USER_ATTIRE_DELETE_ATTIRE_LIST,user_attire_delete_attire_list),
	FILL_CMD_WITHOUT_PRI_IN	(USER_GET_VIP_MONTH,user_get_vip_month),
	FILL_CMD_WITH_PRI_IN	(USER_INFO_SET_FALG_CHANGE_PAYPASSWD,user_info_set_falg_change_paypasswd),
	FILL_CMD_WITH_PRI_IN	(USER_INFO_CHANGE_PAYPASSWD_NOCHECK,user_info_change_paypasswd_nocheck),
	FILL_CMD_WITH_PRI_IN	(USER_JY_GET_MATURE_FRUIT_ID,user_jy_get_mature_fruit_id),
	FILL_CMD_WITH_PRI_IN_GE	(USER_ATTIRE_GET_ATTIRE_EXCEPT_CHEST,user_attire_get_attire_except_chest),
	FILL_CMD_WITH_PRI_IN	(USER_PET_TASK_SET_TASK,user_pet_task_set_task),
	FILL_CMD_WITH_PRI_IN	(USER_PET_TASK_GET_TASKLIST,user_pet_task_get_tasklist),
	FILL_CMD_WITH_PRI_IN	(USER_PET_TASK_SET_TEMP_DATA,user_pet_task_set_temp_data),
	FILL_CMD_WITH_PRI_IN	(USER_PET_TASK_GET_TEMP_DATA,user_pet_task_get_temp_data),
	FILL_CMD_WITH_PRI_IN	(USER_ANIMAL_SET_FLAG,user_animal_set_flag),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_LIST_SET_WISH,roominfo_list_set_wish),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_LIST_GET_WISH,roominfo_list_get_wish),
	FILL_CMD_WITH_PRI_IN	(USER_PET_SET_CHANGE_VALUE,user_pet_set_change_value),
	FILL_CMD_WITH_PRI_IN_GE	(USER_CHANGE_OBJECT_ID,user_change_object_id),
	FILL_CMD_WITH_PRI_IN	(USER_NOAH_SN_BIND_USERID,user_noah_sn_bind_userid),
	FILL_CMD_WITH_PRI_IN	(USER_NOAH_SN_UNBIND_USERID,user_noah_sn_unbind_userid),
	FILL_CMD_WITH_PRI_IN	(USER_NOAH_ADD_USER_INFO,user_noah_add_user_info),
	FILL_CMD_WITHOUT_PRI_IN	(USER_NOAH_GET_USER_BIND_INFO,user_noah_get_user_bind_info),
	FILL_CMD_WITH_PRI_IN	(USER_NOAH_GET_USERID_BY_SN,user_noah_get_userid_by_sn),
	FILL_CMD_WITHOUT_PRI_IN	(USER_GET_NOAH_INFO,user_get_noah_info),
	FILL_CMD_WITH_PRI_IN	(USER_MDOG_GET_MDOG,user_mdog_get_mdog),
	FILL_CMD_WITH_PRI_IN	(USER_MDOG_DEL_MDOG,user_mdog_del_mdog),
	////客服，两个协议号同时绑定了一个函数，更改时注意
	FILL_CMD_WITH_PRI_IN	(USER_MDOG_QUERY_MDOG_INFO,user_mdog_query_mdog_info),
	FILL_CMD_WITH_PRI_IN	(SU_USER_MDOG_QUERY_MDOG_INFO,user_mdog_query_mdog_info),

	FILL_CMD_WITH_PRI_IN	(USER_MDOG_SUPPLY_ENERGE,user_mdog_supply_energe),
	FILL_CMD_WITH_PRI_IN	(USER_PET_SET_HOT_SKILL,user_pet_set_hot_skill),
	FILL_CMD_WITH_PRI_IN	(USER_MDOG_QUERY_USER_MDOG,user_mdog_query_user_mdog),
	FILL_CMD_WITHOUT_PRI_IN	(USER_SU_GET_CHANGE_VALUE,user_su_get_change_value),
	FILL_CMD_WITH_PRI_IN	(USER_ANIMAL_MILK_COW,user_animal_milk_cow),
	FILL_CMD_WITH_PRI_IN	(USER_EX_SET_EVENT_FLAG,user_ex_set_event_flag),
	FILL_CMD_WITH_PRI_IN    (USER_EX_SET_SENDMAIL_FLAG,user_ex_set_sendmail_flag),
	FILL_CMD_WITH_PRI_IN    (USER_EX_ADD_MONTH,user_ex_add_month),
	FILL_CMD_WITHOUT_PRI_IN (USER_EX_GET_MONTH,user_ex_get_month),

	FILL_CMD_WITH_PRI_IN	(DININGROOM_USER_CREATE_DININGROOM,diningroom_user_create_diningroom),
	FILL_CMD_WITH_PRI_IN	(DININGROOM_USER_GET_FRAME_DININGROOM,diningroom_user_get_frame_diningroom),
	FILL_CMD_WITH_PRI_IN	(DININGROOM_USER_SET_ROOM_NAME,diningroom_user_set_room_name),
	FILL_CMD_WITH_PRI_IN	(DININGROOM_USER_SET_ROOM_STYLE,diningroom_user_set_room_style),
	FILL_CMD_WITH_PRI_IN	(USER_DININGROOM_CREATE_ROOM,user_diningroom_create_room),
	FILL_CMD_WITHOUT_PRI_IN	(DININGROOM_USER_GET_LAST_FRAMEID,diningroom_user_get_last_frameid),
	FILL_CMD_WITH_PRI_IN	(USER_DININGROOM_SET_ROOM_NAME,user_diningroom_set_room_name),
	FILL_CMD_WITH_PRI_IN	(USER_DININGROOM_SET_ROOM_STYLE,user_diningroom_set_room_style),
	FILL_CMD_WITH_PRI_IN	(USER_DININGROOM_SET_ROOM_INNER_STYLE,user_diningroom_set_room_inner_style),
	//客服，两个协议号同时绑定了一个函数，更改时注意
	FILL_CMD_WITH_PRI_IN	(USER_GET_DININGROOM,user_get_diningroom),
	FILL_CMD_WITH_PRI_IN	(SU_USER_GET_DININGROOM,su_user_get_diningroom),

	FILL_CMD_WITH_PRI_IN	(USER_DINING_ADD_EMPLOYER,user_dining_add_employer),
	FILL_CMD_WITH_PRI_IN	(USER_DINING_DEL_EMPLOYER,user_dining_del_employer),
	FILL_CMD_WITH_PRI_IN	(USER_DINING_COOK_DISH,user_dining_cook_dish),
	FILL_CMD_WITH_PRI_IN	(USER_DINING_DISH_IN_CHEST,user_dining_dish_in_chest),
	FILL_CMD_WITH_PRI_IN	(USER_DINING_EAT_DISH,user_dining_eat_dish),
	FILL_CMD_WITH_PRI_IN	(USER_DINING_FALL_DISH,user_dining_fall_dish),
	FILL_CMD_WITH_PRI_IN	(USER_DINING_COOK_CHANGE_STATE,user_dining_cook_change_state),
	FILL_CMD_WITH_PRI_IN	(USER_DINING_USER_WORK_FOR_OTHER,user_dining_user_work_for_other),
	FILL_CMD_WITHOUT_PRI_IN	(USER_DINING_GET_SYS_EMPLOYER_LIST,user_dining_get_sys_employer_list),
	FILL_CMD_WITH_PRI_IN	(USER_DINING_GET_USER_BOARD_INFO,user_dining_get_user_board_info),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_USER_SET_NPC_SCORE,roominfo_user_set_npc_score),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_USER_GET_NPC_SCORE,roominfo_user_get_npc_score),
	FILL_CMD_WITHOUT_PRI_IN	(USER_CATCH_FRUIT_ALL,user_catch_fruit_all),	
	FILL_CMD_WITH_PRI_IN	(USER_DINING_DEC_EVALUATE,user_dining_dec_evaluate),
	FILL_CMD_WITH_PRI_IN	(USER_DINING_SET_LEVEL,user_dining_set_level),
	FILL_CMD_WITH_PRI_IN	(USER_DINING_USER_ROOM_COUNT,user_dining_user_room_count),
	FILL_CMD_WITH_PRI_IN	(USER_PET_SET_EMPLOY_USER,user_pet_set_employ_user),
	FILL_CMD_WITHOUT_PRI_IN	(USER_PET_EMPLOY_INFO_LIST,user_pet_employ_info_list),
	FILL_CMD_WITH_PRI_IN	(USER_DINING_SET_HONOR_FLAG,user_dining_set_honor_flag),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_USER_SET_PROVE,roominfo_user_set_prove),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_USER_SET_ITEM,roominfo_user_set_item),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_USER_GET_PROVE,roominfo_user_get_prove),
	FILL_CMD_WITH_PRI_IN	(USER_FARM_ANIMAL_GET_TYPE_MATURE,user_farm_animal_get_type_mature),
	//FILL_CMD_WITHOUT_PRI_IN (USER_BATTLE_RESPECT_MASTER,user_battle_respect_master),
	
	
	//test
	FILL_CMD_WITHOUT_PRI_IN	(USER_TEST_PROTO,user_test_proto),
	FILL_CMD_WITH_PRI_IN    (PP_SET_VIP,pp_set_vip),

		
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_SPORTS_MEET_TEAMID_GET,roominfo_sports_meet_teamid_get),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_SPORTS_MEET_SET,roominfo_sports_meet_set),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_SET_CLIENT_BUF,roominfo_set_client_buf),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_GET_CLIENT_BUF,roominfo_get_client_buf),
	FILL_CMD_WITH_PRI_IN	(USER_DINING_INC_EXP,user_dining_inc_exp),
	FILL_CMD_WITH_PRI_IN	(USER_DINING_INC_XIAOMEE,user_dining_inc_xiaomee),
	FILL_CMD_WITH_PRI_IN	(SYSARG_DB_SPORTS_TEAMINFO_SET,sysarg_db_sports_teaminfo_set),
	FILL_CMD_WITHOUT_PRI_IN	(SYSARG_DB_SPORTS_TEAMINFO_SCORE_GET,sysarg_db_sports_teaminfo_score_get),
	FILL_CMD_WITHOUT_PRI_IN	(SYSARG_DB_SPORTS_TEAMINFO_MEDAL_GET,sysarg_db_sports_teaminfo_medal_get),
	FILL_CMD_WITH_PRI_IN	(SYSARG_DB_SPORTS_TMPUSER_USER_SET,sysarg_db_sports_tmpuser_user_set),
	
	
	FILL_CMD_WITH_PRI_IN	(USER_DINING_DEC_DISH,user_dining_dec_dish),
	FILL_CMD_WITHOUT_PRI_IN	(USER_DINING_COOK_DISH_LIST,user_dining_cook_dish_list),
	
	FILL_CMD_WITH_PRI_IN	(SYSARG_DB_SPORTS_GAMESCORE_SET,sysarg_db_sports_gamescore_set),
	FILL_CMD_WITH_PRI_IN	(SYSARG_DB_SPORTS_GAMESCORE_GET,sysarg_db_sports_gamescore_get),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_SPORTS_MEET_MEDAL_SET,roominfo_sports_meet_medal_set),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_SPORTS_PET_REWARD_SET,roominfo_sports_pet_reward_set),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_SPORTS_USER_REWARD_SET,roominfo_sports_user_reward_set),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_SPORTS_REWARD_GET,roominfo_sports_reward_get),
	FILL_CMD_WITH_PRI_IN	(SYSARG_DB_SPORTS_TEAM_REWARD_GET,sysarg_db_sports_team_reward_get),
	
	FILL_CMD_WITH_PRI_IN	(USER_PET_PET_FLAG_SET,user_pet_pet_flag_set),
	FILL_CMD_WITHOUT_PRI_IN	(USER_DININGROOM_EVENT_NUM_SET,user_diningroom_event_num_set),
	FILL_CMD_WITH_PRI_IN	(USER_SPORTS_INC_XIAOMEE,user_sports_inc_xiaomee),
	FILL_CMD_WITH_PRI_IN    (USER_DINING_GET_DISH_COUNT,user_dining_get_dish_count),
	FILL_CMD_WITH_PRI_IN	(USER_DINING_STARS_GET,user_dining_stars_get),
	FILL_CMD_WITHOUT_PRI_IN (SELECT_DISH_STARS,select_dish_stars),
	FILL_CMD_WITH_PRI_IN	(USERINFO_SET_USER_ENABLE_FLAG,userinfo_set_user_enable_flag),
	FILL_CMD_WITHOUT_PRI_IN	(USERINFO_GET_USER_ENABLE_FLAG,userinfo_get_user_enable_flag),
	FILL_CMD_WITH_PRI_IN	(USER_DINING_DISH_HISTORY_STARS_SET,user_dining_dish_history_stars_set),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_REWARD_NUM_SET,roominfo_reward_num_set),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_REWARD_NUM_GET,roominfo_reward_num_get),
	FILL_CMD_WITH_PRI_IN	(SYSARG_SET_TYPE_BUF,sysarg_set_type_buf),
	FILL_CMD_WITH_PRI_IN	(SYSARG_GET_TYPE_BUF,sysarg_get_type_buf),
	FILL_CMD_WITH_PRI_IN	(USER_DINING_DEC_EXP,user_dining_dec_exp),
	FILL_CMD_WITH_PRI_IN	(USER_NOAH_INC_USER_INFO,user_noah_inc_user_info),

	//客服，两个协议号同时绑定了一个函数，更改时注意
	FILL_CMD_WITHOUT_PRI_IN	(USER_NEW_CARD_GET_CARD_INFO,user_new_card_get_card_info),
	FILL_CMD_WITHOUT_PRI_IN	(SU_USER_NEW_CARD_GET_CARD_INFO,user_new_card_get_card_info),

	FILL_CMD_WITH_PRI_IN	(USER_NEW_CARD_INIT_CARD,user_new_card_init_card),
	FILL_CMD_WITH_PRI_IN	(USER_NEW_CARD_ADD_CARD,user_new_card_add_card),
	FILL_CMD_WITH_PRI_IN	(USER_NEW_CARD_ADD_EXP,user_new_card_add_exp),
	FILL_CMD_WITHOUT_PRI_IN (USER_NEW_CARD_GET_EXP,user_new_card_get_exp),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_NICK_COLOR,user_get_nick_color),
	FILL_CMD_WITH_PRI_IN    (HATCH_DRAGON_EGG,hatch_dragon_egg),
	FILL_CMD_WITHOUT_PRI_IN (GET_EGG_HATCH_TIME,get_egg_hatch_time),
	FILL_CMD_WITH_PRI_IN    (ADD_DRAGON_EGG_HATCH_TIME,add_dragon_egg_hatch_time),
	FILL_CMD_WITHOUT_PRI_IN (GET_DRAGON_HATCHED,get_dragon_hatched),
	//客服，两个协议号同时绑定了一个函数，更改时注意
	FILL_CMD_WITHOUT_PRI_IN (GET_DRAGON_LIST,get_dragon_list),
	FILL_CMD_WITHOUT_PRI_IN (SU_GET_DRAGON_LIST,get_dragon_list),

	FILL_CMD_WITH_PRI_IN    (ADD_DRAGON_GROWTH,add_dragon_growth),
	FILL_CMD_WITH_PRI_IN    (SET_DRAGON_STATE,set_dragon_state),
	FILL_CMD_WITH_PRI_IN    (RELEASE_DRAGON,release_dragon),
	FILL_CMD_WITH_PRI_IN_GE	(USER_NEW_CARD_ADD_CARDS,user_new_card_add_cards),
	FILL_CMD_WITH_PRI_IN    (USER_SET_DRAGON_NAME,user_set_dragon_name),
    FILL_CMD_WITH_PRI_IN    (ROOMINFO_GET_ITEM_SELL,roominfo_get_item_sell),
    FILL_CMD_WITH_PRI_IN    (ROOMINFO_ADD_ITEM_SELL,roominfo_add_item_sell),
	FILL_CMD_WITHOUT_PRI_IN	(USER_GET_USER_BOARD_INFO,user_get_user_board_info),

	FILL_CMD_WITH_PRI_IN	(USER_SET_FIGHT_MONSTER,user_set_fight_monster),
	FILL_CMD_WITHOUT_PRI_IN (GET_CURRENT_DRAGON,get_current_dragon),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_LAMU_DIARY_LIST,user_get_lamu_diary_list),
	FILL_CMD_WITHOUT_PRI_IN (GET_FRIEND_BOX_ITEMS,get_friend_box_items),
	FILL_CMD_WITHOUT_PRI_IN (GET_FRIEND_BOX_HISTORY,get_friend_box_history),
	FILL_CMD_WITH_PRI_IN    (PUT_ITEM_TO_FRIEND_BOX,put_item_to_friend_box),
	FILL_CMD_WITH_PRI_IN    (GET_ITEM_FROM_FRIEND_BOX,get_item_from_friend_box),
	FILL_CMD_WITH_PRI_IN    (CHECK_ITEM_FROM_FRIEND,check_item_from_friend),
	FILL_CMD_WITH_PRI_IN    (SET_TAG_ITEM_FROM_FRIEND,set_tag_item_from_friend),
	FILL_CMD_WITH_PRI_IN    (USER_CHECKIN_BLACK,user_checkin_black),
	FILL_CMD_WITH_PRI_IN    (USER_PET_IS_SUPER_LAMU,user_pet_is_super_lamu),
	FILL_CMD_WITH_PRI_IN	(LAMU_CLASSROOM_USER_CREATE_CLASSROOM,lamu_classroom_user_create_classroom),
	FILL_CMD_WITH_PRI_IN	(LAMU_CLASSROOM_USER_SET_CLASSROOM_NAME,lamu_classroom_user_set_classroom_name),
	FILL_CMD_WITHOUT_PRI_IN	(LAMU_CLASSROOM_TW_GET_EXP_AND_NAME,lamu_classroom_tw_get_exp_and_name),
	FILL_CMD_WITH_PRI_IN    (LAMU_CLASSROOM_USER_GET_FRAME_CLASSROOM,lamu_classroom_user_get_frame_classroom),
	FILL_CMD_WITHOUT_PRI_IN (LAMU_CLASSROOM_USER_GET_LAST_FRAMEID,lamu_classroom_user_get_last_frameid),
	FILL_CMD_WITHOUT_PRI_IN (LAMU_CLASSROOM_GET_RAND_USER,lamu_classroom_get_rand_user),
	FILL_CMD_WITH_PRI_IN    (LAMU_CLASSROOM_SET_TEACHER_EXP,lamu_classroom_set_teacher_exp),
	FILL_CMD_WITH_PRI_IN	(LAMU_CLASSROOM_SET_OUTSTAND_SUM,lamu_classroom_set_outstand_sum),
	FILL_CMD_WITH_PRI_IN_GE (LAMU_CLASSROOM_GET_FRIEND_RANK,lamu_classroom_get_friend_rank),
	FILL_CMD_WITH_PRI_IN    (LAMU_CLASSROOM_SET_EXP_AND_OUTSTAND_SUM,lamu_classroom_set_exp_and_outstand_sum),	
	FILL_CMD_WITH_PRI_IN    (USER_LAMU_CLASSROOM_CREATE_CLASSROOM,user_lamu_classroom_create_classroom),
	FILL_CMD_WITH_PRI_IN    (USER_LAMU_CLASSROOM_SET_NAME,user_lamu_classroom_set_name),
	FILL_CMD_WITH_PRI_IN    (USER_LAMU_CLASSROOM_SET_INNER_STYLE,user_lamu_classroom_set_inner_style),
	FILL_CMD_WITH_PRI_IN_GE (USER_LAMU_CLASSROOM_ADD_LAMUS,user_lamu_classroom_add_lamus),
	FILL_CMD_WITHOUT_PRI_IN (USER_LAMU_CLASSROOM_ABANDON_LAMUS,user_lamu_classroom_abandon_lamus),
	FILL_CMD_WITH_PRI_IN 	(USER_LAMU_CLASSROOM_GET_CLASS_INFO,user_lamu_classroom_get_class_info),
	//客服，两个协议号同时绑定了一个函数，更改时注意	
	FILL_CMD_WITHOUT_PRI_IN (USER_LAMU_CLASSROOM_GET_LAMUS_INFO,user_lamu_classroom_get_lamus_info),
	FILL_CMD_WITHOUT_PRI_IN (SU_USER_LAMU_CLASSROOM_GET_LAMUS_INFO,user_lamu_classroom_get_lamus_info),
	FILL_CMD_WITHOUT_PRI_IN (USER_LAMU_CLASSROOM_GET_RECORD,user_lamu_classroom_get_record),
	FILL_CMD_WITHOUT_PRI_IN (SU_USER_LAMU_CLASSROOM_GET_RECORD,user_lamu_classroom_get_record),

	FILL_CMD_WITHOUT_PRI_IN (USER_LAMU_CLASSROOM_GET_REMEMBRANCE,user_lamu_classroom_get_remembrance),
	FILL_CMD_WITHOUT_PRI_IN (USER_LAMU_CLASSROOM_GET_TEACH_PLAN,user_lamu_classroom_get_teach_plan),
	FILL_CMD_WITHOUT_PRI_IN (USER_LAMU_CLASSROOM_GET_COURSE_LIST,user_lamu_classroom_get_course_list),
	FILL_CMD_WITH_PRI_IN    (USER_LAMU_CLASSROOM_CLASS_BEGIN,user_lamu_classroom_class_begin),
	FILL_CMD_WITH_PRI_IN    (USER_LAMU_CLASSROOM_SET_TEACH_MODE,user_lamu_classroom_set_teach_mode),
	FILL_CMD_WITH_PRI_IN 	(USER_LAMU_CLASSROOM_CLASS_END,user_lamu_classroom_class_end),
	FILL_CMD_WITHOUT_PRI_IN (USER_LAMU_CLASSROOM_GET_EXP_COURSE,user_lamu_classroom_get_exp_course),
	FILL_CMD_WITHOUT_PRI_IN (USER_LAMU_CLASSROOM_IS_CLASS_TIME,user_lamu_classroom_is_class_time),
	FILL_CMD_WITH_PRI_IN_GE (USER_LAMU_CLASSROOM_BEGIN_EXAM,user_lamu_classroom_begin_exam),
	FILL_CMD_WITH_PRI_IN    (USER_LAMU_CLASSROOM_GET_EXAM_INFO,user_lamu_classroom_get_exam_info),
	FILL_CMD_WITH_PRI_IN	(USER_LAMU_CLASSROOM_TW_GET_EXAM_RESULT,user_lamu_classroom_tw_get_exam_result),
	FILL_CMD_WITHOUT_PRI_IN (USER_LAMU_CLASSROOM_HAVE_CLASS,user_lamu_classroom_have_class),
	FILL_CMD_WITH_PRI_IN_GE (USER_LAMU_CLASSROOM_GET_PRIZE,user_lamu_classroom_get_prize),
	FILL_CMD_WITHOUT_PRI_IN (USER_LAMU_CLASSROOM_GET_CLASS_FLAG,user_lamu_classroom_get_class_flag),
	FILL_CMD_WITHOUT_PRI_IN (USER_LAMU_CLASSROOM_CLASS_GRADUATE,user_lamu_classroom_class_graduate),
	FILL_CMD_WITH_PRI_IN    (USER_LAMU_CLASSROOM_ADD_COURSE_CNT,user_lamu_classroom_add_course_cnt),
	FILL_CMD_WITH_PRI_IN    (USER_LAMU_CLASSROOM_CHECK_ADD_COURSE,user_lamu_classroom_check_add_course),
	FILL_CMD_WITH_PRI_IN    (USER_LAMU_CLASSROOM_RECOVER_TEACHER_ATTR,user_lamu_classroom_recover_teacher_attr),
	FILL_CMD_WITH_PRI_IN    (USER_LAMU_CLASSROOM_SET_LAMU_MOOD,user_lamu_classroom_set_lamu_mood),
	FILL_CMD_WITH_PRI_IN	(USER_LAMU_CLASSROOM_UPDATE_LAMU_ATTR,user_lamu_classroom_update_lamu_attr),
	FILL_CMD_WITH_PRI_IN	(USER_LAMU_CLASSROOM_ADD_COURSE_SCORE,user_lamu_classroom_add_course_score),
	FILL_CMD_WITH_PRI_IN    (USER_LAMU_CLASSROOM_SET_EVENT_CNT,user_lamu_classroom_set_event_cnt),
	FILL_CMD_WITH_PRI_IN    (USER_LAMU_CLASSROOM_SET_HONOR_FLAG,user_lamu_classroom_set_honor_flag),
	FILL_CMD_WITH_PRI_IN    (USER_LAMU_CLASSROOM_ADD_LAMU_ATTRS,user_lamu_classroom_add_lamu_attrs),
	FILL_CMD_WITHOUT_PRI_IN (SYSARG_AUCTION_BEGIN_AUCTION,sysarg_auction_begin_auction),
	FILL_CMD_WITH_PRI_IN    (SYSARG_AUCTION_ADD_ONE_RECORD,sysarg_auction_add_one_record),
	FILL_CMD_WITHOUT_PRI_IN (SYSARG_AUCTION_GET_ATTIREID_AND_TIME,sysarg_auction_get_attireid_and_time),
	FILL_CMD_WITHOUT_PRI_IN (SYSARG_AUCTION_END_AUCTION,sysarg_auction_end_auction),
	FILL_CMD_WITH_PRI_IN    (SYSARG_CONTRIBUTE_XIAMEE_INSERT,sysarg_contribute_xiamee_insert),
	FILL_CMD_WITH_PRI_IN    (SYSARG_CONTRIBUTE_GET_RANK,sysarg_contribute_get_rank),
	FILL_CMD_WITHOUT_PRI_IN (SYSARG_CONTRIBUTE_GET_USER_COUNT,sysarg_contribute_get_user_count),
	FILL_CMD_WITH_PRI_IN    (USER_GET_ATTIREID_AND_CNT,user_get_attireid_and_cnt),
	FILL_CMD_WITH_PRI_IN    (SET_CLASS_NETWORK,set_class_network),
	FILL_CMD_WITH_PRI_IN	(SYSARG_GET_RANKLIST,sysarg_get_ranklist),
	FILL_CMD_WITH_PRI_IN	(SYSARG_SET_RANKLIST,sysarg_set_ranklist),
	FILL_CMD_WITH_PRI_IN	(USER_SET_USER_RANK_BUF,user_set_user_rank_buf),
	FILL_CMD_WITH_PRI_IN	(USER_GET_RECV_RECORD,user_get_recv_record),
	FILL_CMD_WITH_PRI_IN	(EXCHANGE_FLOWER_TO_PRESENT,exchange_flower_to_present),
	FILL_CMD_WITH_PRI_IN    (USER_CHECK_OUT_BUF,user_check_out_buf),
	FILL_CMD_WITH_PRI_IN	(SYSARG_GET_DOUBLE_COUNT,sysarg_get_double_count),
	//点点豆摇奖机
	FILL_CMD_WITHOUT_PRI_IN (ROOMINFO_GET_SHAKE_REWARDS_TIMES,roominfo_get_shake_rewards_times),
	FILL_CMD_WITHOUT_PRI_IN    (ROOMINFO_CHANGE_SHAKE_REWARDS_TIMES,roominfo_change_shake_rewards_times),
	//米币消耗
	FILL_CMD_WITHOUT_PRI_IN (ROOMINFO_GET_CONSUME_MONEY,roominfo_get_consume_money),
	FILL_CMD_WITH_PRI_IN    (ROOMINFO_INC_CONSUME_MONEY,roominfo_inc_consume_money),
	FILL_CMD_WITH_PRI_IN    (ROOMINFO_DEC_CONSUME_MONEY,roominfo_dec_consume_money),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_ADD_CHRISTMAS_SOCK,roominfo_add_christmas_sock),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_GET_CHRISTMAS_SOCK_INFO,roominfo_get_christmas_sock_info),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_DEL_CHRISTMAS_SOCK_INFO,roominfo_del_christmas_sock_info),

	//清空包月信息
	FILL_CMD_WITHOUT_PRI_IN (USER_EX_CLEAR_BONUS_USED,user_ex_clear_bonus_used),
	//蛋糕积分
	FILL_CMD_WITH_PRI_IN    (ROOMINFO_INC_CAKE_SCORE,roominfo_inc_cake_score),
	FILL_CMD_WITH_PRI_IN    (ROOMINFO_DEC_CAKE_SCORE,roominfo_dec_cake_score),
	FILL_CMD_WITHOUT_PRI_IN (ROOMINFO_GET_CAKE_SCORE,roominfo_get_cake_score),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_QUERY_USER_CAKE_INFO,roominfo_query_user_cake_info),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_USER_DO_CAKE_FIN,roominfo_user_do_cake_fin),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_USER_SEND_CAKE,roominfo_user_send_cake),
	
	//小脚印
	FILL_CMD_WITH_PRI_IN    (ROOMINFO_FOOTPRINT_ADD,roominfo_footprint_add),
	FILL_CMD_WITH_PRI_IN    (ROOMINFO_EXCHANGE_FOOTPRINT,roominfo_exchange_footprint),
	FILL_CMD_WITHOUT_PRI_IN (ROOMINFO_GET_FOOTPRINT_COUNT,roominfo_get_footprint_count),

	//连续登陆礼包
	FILL_CMD_WITHOUT_PRI_IN (ROOMINFO_QUERY_LOGIN_GIFTS,roominfo_query_login_gifts),

	FILL_CMD_WITHOUT_PRI_IN (USER_FARM_GET_FAIRY,user_farm_get_fairy),
	FILL_CMD_WITH_PRI_IN    (USER_FARM_SPEED_ANIMAL_GROWTH,user_farm_speed_animal_growth),
	FILL_CMD_WITH_PRI_IN    (USER_FAIRY_SKILL_GET_INFO,user_fairy_skill_get_info),
	FILL_CMD_WITH_PRI_IN    (USER_FAIRY_SKILL_UPDATE_INFO,user_fairy_skill_update_info),	
	FILL_CMD_WITH_PRI_IN    (USER_FAIRY_GET_GROWTH,user_fairy_get_growth),
	FILL_CMD_WITHOUT_PRI_IN	(ROOMINFO_GET_TRAIN_KAKUNIAN_INFO,roominfo_get_train_kakunian_info),
	FILL_CMD_WITH_PRI_IN	(ROOMINFO_SET_TRAIN_KAKUNIAN_COUNT,roominfo_set_train_kakunian_count),
	FILL_CMD_WITH_PRI_IN    (SYSARG_ADD_SKILL_COUNT,sysarg_add_skill_count),
	FILL_CMD_WITHOUT_PRI_IN (SYSARG_UPDATE_SKILL_COUNT,sysarg_update_skill_count),
	FILL_CMD_WITHOUT_PRI_IN (USER_FARM_GET_SUPER_ANIMAL_COUNT,user_farm_get_super_animal_count),
	FILL_CMD_WITHOUT_PRI_IN (SYSARG_GET_SKILL_USE_INFO,sysarg_get_skill_use_info),
   //天使乐园
	FILL_CMD_WITH_PRI_IN (USER_GET_PARADISE,user_get_paradise),
	FILL_CMD_WITH_PRI_IN    (USER_CHANGE_PARADISE_BACKGOUND,user_change_paradise_backgound),
	FILL_CMD_WITH_PRI_IN    (USER_CHANGE_ANGEL_POS,user_change_angel_pos),
	FILL_CMD_WITH_PRI_IN    (USER_PARADISE_SET_NIMBUS,user_paradise_set_nimbus),
	FILL_CMD_WITH_PRI_IN    (USER_ANGEL_SIGN_CONTRACT,user_angel_sign_contract),
	FILL_CMD_WITH_PRI_IN    (USER_ANGEL_FREE,user_angel_free),
	FILL_CMD_WITH_PRI_IN (USER_PARADISE_GET_VISITLIST,user_paradise_get_visitlist),
	    //客服，两个协议号同时绑定了一个函数，更改时注意
    FILL_CMD_WITHOUT_PRI_IN    (USER_GET_PARADISE_ATTIRELIST,user_get_paradise_attirelist),
    FILL_CMD_WITHOUT_PRI_IN    (SU_USER_GET_PARADISE_ATTIRELIST,user_get_paradise_attirelist),

    FILL_CMD_WITH_PRI_IN    (USER_DEL_ATTIRE_ANGEL_TOOL,user_del_attire_angel_tool),
    FILL_CMD_WITHOUT_PRI_IN (USER_GET_ANGEL_CONTRACT_ALL,user_get_angel_contract_all),
    FILL_CMD_WITH_PRI_IN    (USER_TERMINATE_CONTRACT,user_terminate_contract),
    FILL_CMD_WITH_PRI_IN    (USER_GET_CONTRACT_ANGEL_FOLLOW,user_get_contract_angel_follow),
    FILL_CMD_WITH_PRI_IN    (USER_FAIRY_CONVERT_ANGEL,user_fairy_convert_angel),
    FILL_CMD_WITHOUT_PRI_IN (ROOMINFO_GET_WEEK_COUNT,roominfo_get_week_count),
    FILL_CMD_WITHOUT_PRI_IN (ROOMINFO_UPDATE_WEEK_COUNT,roominfo_update_week_count),
    FILL_CMD_WITH_PRI_IN_GE (SYSARG_GET_PARADISE_FRIEND_RANK,sysarg_get_paradise_friend_rank),
    FILL_CMD_WITH_PRI_IN    (SYSARG_UPDATE_HOT_PLAY,sysarg_update_hot_play),
    FILL_CMD_WITH_PRI_IN_GE (SYSARG_GET_PARADISE_ACCESS_RANK,sysarg_get_paradise_access_rank),
    FILL_CMD_WITH_PRI_IN    (USER_PARADISE_UPDATE_VISITLIST,user_paradise_update_visitlist),
    FILL_CMD_WITHOUT_PRI_IN (SYSARG_GET_HOT_PLAY,sysarg_get_hot_play),
    FILL_CMD_WITH_PRI_IN    (SYSARG_UPDATE_PARADISE_RANK,sysarg_update_paradise_rank),
    FILL_CMD_WITHOUT_PRI_IN (USER_GET_MOLE_LEV_ATT_NICK,user_get_mole_lev_att_nick),
    FILL_CMD_WITH_PRI_IN    (USER_ANGEL_SPEED_UP,user_angel_speed_up),
    FILL_CMD_WITHOUT_PRI_IN (USER_GET_BATTLE_ANGEL_INFO,user_get_battle_angel_info),
    FILL_CMD_WITHOUT_PRI_IN (USER_ANGEL_GET_BATTLE_LEVEL,user_angel_get_battle_level),
    FILL_CMD_WITH_PRI_IN    (USER_ANGEL_BARRIER_GET_SCORE,user_angel_barrier_get_score),
    FILL_CMD_WITH_PRI_IN_GE    (USER_ANGEL_BATTLE_OVER,user_angel_battle_over),
    FILL_CMD_WITH_PRI_IN    (USER_CAPTURE_ANGEL,user_capture_angel),
    FILL_CMD_WITHOUT_PRI_IN (USER_GET_ANGEL_IN_HOSPITAL,user_get_angel_in_hospital),
    FILL_CMD_WITH_PRI_IN    (USER_ANGEL_TOOL_RECOVER,user_angel_tool_recover),
    FILL_CMD_WITH_PRI_IN_GE    (USER_ANGEL_GO_OUT_HOSPITAL,user_angel_go_out_hospital),
    FILL_CMD_WITH_PRI_IN_GE (USER_ADD_ANGEL_CONTRACT,user_add_angel_contract),
    FILL_CMD_WITHOUT_PRI_IN (USER_GET_ANGEL_FAVORITE,user_get_angel_favorite),
    FILL_CMD_WITH_PRI_IN    (USER_EXHIBIT_FAVORITE_ANGEL,user_exhibit_favorite_angel),
    FILL_CMD_WITHOUT_PRI_IN (USER_GET_USED_BACKGROUND,user_get_used_background),
    FILL_CMD_WITHOUT_PRI_IN (USER_EXCHANGE_DAVIS_BEAN,user_exchange_davis_bean),
    FILL_CMD_WITHOUT_PRI_IN (USER_GET_ANGEL_HONORS,user_get_angel_honors),
    FILL_CMD_WITH_PRI_IN    (USER_GET_GIFT_AFTER_UNLOCK,user_get_gift_after_unlock),
    FILL_CMD_WITH_PRI_IN    (USER_GET_DIG_TREASURE_BEGIN,user_get_dig_treasure_begin),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_ANGEL_CONTRACT_ALL_EX,user_get_angel_contract_all_ex),
    FILL_CMD_WITH_PRI_IN    (USER_DIG_TREASURE_UPDATE_PLAYER,user_dig_treasure_update_player),
    FILL_CMD_WITH_PRI_IN    (USER_DIG_TREASURE_USED_TOOL,user_dig_treasure_used_tool),
	FILL_CMD_WITH_PRI_IN_GE    (USER_DIG_TREASURE_UPDATE_RANDOM_COUNT,user_dig_treasure_update_random_count),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_EXPEDITION_BAG,user_get_expedition_bag),
	FILL_CMD_WITHOUT_PRI_IN (USER_SYNTHESIS_ANGEL_GET_MATERIAL,user_synthesis_angel_get_material),
	FILL_CMD_WITH_PRI_IN_GE (USER_SYNTHESIS_ANGEL_WITH_MATERIAL,user_synthesis_angel_with_material),
	FILL_CMD_WITH_PRI_IN    (USER_SET_ATTIRE_COUNT,user_set_attire_count),
	FILL_CMD_WITH_PRI_IN    (USER_SET_ANGEL_TYPE_EX,user_set_angel_type_ex),
	FILL_CMD_WITH_PRI_IN    (USER_SYNTHESIS_HISTORY,user_synthesis_history),
	FILL_CMD_WITH_PRI_IN (USER_GET_TREASURE_WAREHOUSE,user_get_treasure_warehouse),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_TREASURE_COLLECTION,user_get_treasure_collection),
	FILL_CMD_WITH_PRI_IN    (USER_SHOW_TREASURE,user_show_treasure),
	FILL_CMD_WITH_PRI_IN    (USER_EXCHANGE_TREASURE_SHOW_POS,user_exchange_treasure_show_pos),
	FILL_CMD_WITHOUT_PRI_IN (USER_TREASURE_COLLECTION_GET_VISITLIST,user_treasure_collection_get_visitlist),
	FILL_CMD_WITH_PRI_IN    (USER_TREASURE_COLLECTION_UPDATE_VISITLIST,user_treasure_collection_update_visitlist),
	FILL_CMD_WITH_PRI_IN    (USER_CHANGE_SHOW_TREASURE_STATUS,user_change_show_treasure_status),
	FILL_CMD_WITH_PRI_IN    (SYSARG_UPDATE_TREASURE_COLLECTION,sysarg_update_treasure_collection),
	FILL_CMD_WITH_PRI_IN_GE (SYSARG_GET_TREASURE_FRIEND,sysarg_get_treasure_friend),
	FILL_CMD_WITH_PRI_IN_GE (SYSARG_GET_TREASURE_VISIT,sysarg_get_treasure_visit),
	FILL_CMD_WITH_PRI_IN    (ROOMINFO_STRIKE_PENGIN_GAME,roominfo_strike_pengin_game),
	FILL_CMD_WITHOUT_PRI_IN (ROOMINFO_STRIKE_PENGUIN_GET_INFO,roominfo_strike_penguin_get_info),
	FILL_CMD_WITHOUT_PRI_IN (USER_CONTINUE_LOGIN_SHOP,user_continue_login_shop),
	FILL_CMD_WITH_PRI_IN    (USER_HIDE_AND_SEEK_GET_AWARD,user_hide_and_seek_get_award),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_MONGOLIAN_COW_PASTURE,user_get_mongolian_cow_pasture),
	FILL_CMD_WITH_PRI_IN    (USER_PLAY_WITH_MILK_COW,user_play_with_milk_cow),
	FILL_CMD_WITH_PRI_IN    (USER_MILK_COW_PASTURE_PLANT,user_milk_cow_pasture_plant),
	FILL_CMD_WITHOUT_PRI_IN (USER_SET_PASTURE_MILK_STORAGE,user_set_pasture_milk_storage),
	FILL_CMD_WITH_PRI_IN    (EMAILSYS_SET_IS_WARD,emailsys_set_is_ward),
	FILL_CMD_WITHOUT_PRI_IN (EMAILSYS_GET_EMAIL_INFO_LIST, emailsys_get_email_info_list),
	FILL_CMD_WITH_PRI_IN_GE (EMAILSYS_DEL_LIST,emailsys_del_list),
	FILL_CMD_WITH_PRI_IN    (ROOMINFO_GET_RANDOM_GAIN_TIMES,roominfo_get_random_gain_times),
	FILL_CMD_WITH_PRI_IN    (ROOMINFO_CHANGE_RANDOM_GAIN_TIMES,roominfo_change_random_gain_times),

	//2011暑期版本战斗部分
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_BATTLE_CHARACTER_BAG,user_get_battle_character_bag),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_BATTLE_SKILL,user_get_battle_skill),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_BATTLE_BAG,user_get_battle_bag),
	FILL_CMD_WITH_PRI_IN    (USER_BATTLE_USE_PROPS,user_battle_use_props),
	FILL_CMD_WITHOUT_PRI_IN (USER_BATTLE_GET_CARD_BOOKLET,user_battle_get_card_booklet),
	FILL_CMD_WITHOUT_PRI_IN (USER_GAMESERV_BATTLE_GET_INFO,user_gameserv_battle_get_info),
	FILL_CMD_WITH_PRI_IN    (USER_BATTLE_USE_CARD,user_battle_use_card),
	FILL_CMD_WITH_PRI_IN    (USER_BATTLE_UPGRADE_SKILL,user_battle_upgrade_skill),
	FILL_CMD_WITH_PRI_IN    (USER_EQUIP_SKILL_ATTIRE,user_equip_skill_attire),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_BATTLE_COLLETION,user_get_battle_colletion),
	FILL_CMD_WITH_PRI_IN    (USER_BATTLE_GAME_OVER_CACULATE,user_battle_game_over_caculate),
	FILL_CMD_WITH_PRI_IN_GE (ANGEL_BATTLE_GET_FRIENDS_EXP,angel_battle_get_friends_exp),
	FILL_CMD_WITH_PRI_IN    (ANGEL_BATTLE_UPDATE_EXP,angel_battle_update_exp),
	FILL_CMD_WITHOUT_PRI_IN (USER_BATTLE_GET_FRIEND_FIGHT_LIST,user_battle_get_friend_fight_list),
	FILL_CMD_WITH_PRI_IN_GE (USER_BATTLE_MAP_INFO,user_battle_map_info),
	FILL_CMD_WITH_PRI_IN    (USER_BATTLE_GET_ONE_SKILL,user_battle_get_one_skill),
	FILL_CMD_WITH_PRI_IN    (USER_BATTLE_GAMESERV_CONSUME,user_battle_gameserv_consume),
	FILL_CMD_WITHOUT_PRI_IN (USER_BATTLE_GET_FLIP_INFO,user_battle_get_flip_info),
	FILL_CMD_WITH_PRI_IN    (USER_BATTLE_OVER_INFO,user_battle_over_info), 
	FILL_CMD_WITHOUT_PRI_IN (USER_DININGROOM_GET_WISH,user_diningroom_get_wish),
	FILL_CMD_WITH_PRI_IN	(USER_BATTLE_ABLE_TO_WISH,user_battle_able_to_wish),
	FILL_CMD_WITH_PRI_IN	(USER_BATTLE_WISH_SUCC,user_battle_wish_succ),
	FILL_CMD_WITH_PRI_IN_GE (USER_BATTLE_GET_FRIEND_EVENT_INFO,user_battle_get_friend_event_info),
	FILL_CMD_WITH_PRI_IN_GE (USER_GET_SELF_EVENTS_INFO,user_get_self_events_info),
	FILL_CMD_WITH_PRI_IN	(USER_BATTLE_BLESS_FRIEND_INFO,user_battle_bless_friend_info),
	FILL_CMD_WITHOUT_PRI_IN	(USER_DININGROOM_SET_WISH_CNT,user_diningroom_set_wish_cnt),
	FILL_CMD_WITH_PRI_IN    (USER_DININGROOM_BLESS_GET_WISH_INFO,user_diningroom_bless_get_wish_info),
	FILL_CMD_WITH_PRI_IN    (USER_DINING_ROOM_GET_C_EVENT_INFO,user_dining_room_get_c_event_info),
	FILL_CMD_WITH_PRI_IN    (USER_DININGROOM_SET_COM_EVENT,user_diningroom_set_com_event),
	FILL_CMD_WITH_PRI_IN    (USER_BATTLE_HANDLE_COMMON_EVENT,user_battle_handle_common_event),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_WISH_ITEM_ID,user_get_wish_item_id),
	FILL_CMD_WITHOUT_PRI_IN (USER_BATTLE_GEFIGHT_OVER_INFO,user_battle_gefight_over_info),
	FILL_CMD_WITHOUT_PRI_IN (USER_BATTLE_GIVE_WISH_ARTICLE,user_battle_give_wish_article),
  	FILL_CMD_WITHOUT_PRI_IN (USER_BATTLE_GET_DAY_TASKLIST,user_battle_get_day_tasklist),
	FILL_CMD_WITH_PRI_IN    (USER_BATTLE_REFRESH_DAY_TASK,user_battle_refresh_day_task),
	FILL_CMD_WITH_PRI_IN_GE (USER_BATTLE_NEW_DAY_TASK,user_battle_new_day_task),
	FILL_CMD_WITH_PRI_IN    (USER_BATTLE_TERMINATE_DAY_TASK,user_battle_terminate_day_task),
	FILL_CMD_WITH_PRI_IN    (USER_BATTLE_ADD_EXP,user_battle_add_exp),
	FILL_CMD_WITH_PRI_IN    (USER_BATTLE_NEW_A_TASK,user_battle_new_a_task),
	FILL_CMD_WITHOUT_PRI_IN (USER_BATTLE_GET_CHALLENGE_TIMES,user_battle_get_challenge_times),
	FILL_CMD_WITHOUT_PRI_IN (USER_BATTLE_GET_PRENTICE_MARKET_FILTER,user_battle_get_prentice_market_filter),
	FILL_CMD_WITH_PRI_IN_GE (USER_BATTLE_GET_PRENTICE_MARKET,user_battle_get_prentice_market),
	FILL_CMD_WITHOUT_PRI_IN (USER_BATTLE_GET_SELF_MP_RELATRION,user_battle_get_self_mp_relatrion),
    FILL_CMD_WITHOUT_PRI_IN (USER_BATTLE_GET_MASTER_INFO,user_battle_get_master_info),
	FILL_CMD_WITHOUT_PRI_IN (USER_BATTLE_CHECK_TEACH_PRENTICE,user_battle_check_teach_prentice),
	FILL_CMD_WITH_PRI_IN    (USER_BATTLE_GET_TRAIN_INFO,user_battle_get_train_info),
	FILL_CMD_WITH_PRI_IN    (USER_BATTLE_TRAIN_PRENTICE,user_battle_train_prentice),
	FILL_CMD_WITH_PRI_IN    (USER_BATTLE_EVICT_PRENTICE,user_battle_evict_prentice),
	FILL_CMD_WITH_PRI_IN 	(USER_DINININGROOM_EVICT_PRENTICE_ANOTHER,user_dininingroom_evict_prentice_another),
	FILL_CMD_WITHOUT_PRI_IN (USER_BATTLE_RESPECT_MASTER,user_battle_respect_master),
	FILL_CMD_WITH_PRI_IN (USER_BATTLE_RESPECT_SET_IN_MASTER,user_battle_respect_set_in_master),
	FILL_CMD_WITH_PRI_IN    (USER_BATTLE_MASTER_RECEIVE_RESPECT,user_battle_master_receive_respect),
	FILL_CMD_WITH_PRI_IN (USER_CHECK_FINISH_APPRENTICE,user_check_finish_apprentice),
	FILL_CMD_WITH_PRI_IN    (USER_MASTER_FINISH_APPRENTICE,user_master_finish_apprentice),
	FILL_CMD_WITHOUT_PRI_IN    (USER_BATTLE_PRENTICE_FINISH_MASTER,user_battle_prentice_finish_master),
	FILL_CMD_WITHOUT_PRI_IN (USER_BATTLE_GET_MASTER_PRENTICE_INFO,user_battle_get_master_prentice_info),
	FILL_CMD_WITHOUT_PRI_IN (USER_BATTLE_CHECK_PRENTICE,user_battle_check_prentice),
	//客服，两个协议号同时绑定了一个函数，更改时注意
	FILL_CMD_WITHOUT_PRI_IN (USER_BATTLE_GET_LEVEL,user_battle_get_level),
	FILL_CMD_WITHOUT_PRI_IN (SU_USER_BATTLE_GET_LEVEL,user_battle_get_level),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_EXP_AND_VIP_LEVEL,user_get_exp_and_vip_level),

	FILL_CMD_WITH_PRI_IN (USER_BATTLE_ADD_PRENTICE,user_battle_add_prentice),
	FILL_CMD_WITH_PRI_IN    (USER_BATTLE_ADD_MP_MSG,user_battle_add_mp_msg),
	FILL_CMD_WITH_PRI_IN    (USER_BATTLE_SET_NEW_MASTER,user_battle_set_new_master),
	FILL_CMD_WITH_PRI_IN    (USER_BATTLE_EVICT_PRENTICE_ANOTHER,user_battle_evict_prentice_another),
	FILL_CMD_WITHOUT_PRI_IN (USER_BATTLE_GET_INI_SKILL_LEVEL_EX,user_battle_get_ini_skill_level_ex),
	FILL_CMD_WITHOUT_PRI_IN (USER_BATTLE_GET_PVP_INFO,user_battle_get_pvp_info),
	FILL_CMD_WITH_PRI_IN    (USER_BATTLE_RECVEIVE_PVP_CARD,user_battle_recveive_pvp_card),
	FILL_CMD_WITH_PRI_IN    (USER_EAT_MOON_CAKE,user_eat_moon_cake),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_MOON_CAKE,user_get_moon_cake),

	
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_TIME_MAIL,user_get_time_mail),
	FILL_CMD_WITH_PRI_IN    (USER_SEND_TIME_ITEM,user_send_time_item),
	FILL_CMD_WITH_PRI_IN_GE (USER_SEND_TIME_MAIL,user_send_time_mail),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_TIME_ITEM,user_get_time_item),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_NON_DIG_TIME_ARTICLE,user_get_non_dig_time_article),
    FILL_CMD_WITHOUT_PRI_IN (USER_GET_ANGEL_BATTLE_LEVEL_EX,user_get_angel_battle_level_ex),
	FILL_CMD_WITH_PRI_IN_GE (USER_BATCH_DEL_FRIENDS,user_batch_del_friends),
	FILL_CMD_WITHOUT_PRI_IN (GET_USER_TASK_EX_IDLIST,get_user_task_ex_idlist),
	
	FILL_CMD_WITH_PRI_IN (USER_GET_PIGLET_HOUSE,user_get_piglet_house),
	FILL_CMD_WITH_PRI_IN (USER_GET_SINGLE_PIGLET_INFO,user_get_single_piglet_info),
	FILL_CMD_WITH_PRI_IN (USER_GET_PIGLET_HUNGRY,user_get_piglet_hungry),
	FILL_CMD_WITH_PRI_IN    (USER_FEED_FANCY_PIGLET,user_feed_fancy_piglet),
	FILL_CMD_WITH_PRI_IN    (USER_TRAIN_PIGLET,user_train_piglet),
	FILL_CMD_WITH_PRI_IN    (USER_AMUSE_PIGLET,user_amuse_piglet),
	FILL_CMD_WITH_PRI_IN (USER_BATH_PIGLET,user_bath_piglet),
	FILL_CMD_WITH_PRI_IN    (USER_CHANGE_PIGLET_NICK,user_change_piglet_nick),
	FILL_CMD_WITH_PRI_IN    (USER_CHANGE_PIGLET_FORMATION,user_change_piglet_formation),
	FILL_CMD_WITH_PRI_IN    (USER_CHECK_MAIL_PIGLET,user_check_mail_piglet),
	FILL_CMD_WITH_PRI_IN_GE (USER_FEMAIL_PIGLET_PREGNANT,user_femail_piglet_pregnant),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_PIGLET_ARTICLES,user_get_piglet_articles),
	FILL_CMD_WITH_PRI_IN_GE    (USER_SALE_PIGLET,user_sale_piglet),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_ABLE_MAKE_PAIR_MAIL_PIGLET,user_get_able_make_pair_mail_piglet),
	FILL_CMD_WITH_PRI_IN    (SYSARG_ALTER_PIGLET_HOUSE_LEVEL,sysarg_alter_piglet_house_level),
	FILL_CMD_WITH_PRI_IN    (USER_UPGRADE_PIGLET_HOUSE,user_upgrade_piglet_house),
	FILL_CMD_WITH_PRI_IN_GE (USER_GET_FRIEND_PIGLET_HOUSE,user_get_friend_piglet_house),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_PIGLET_DAY_TASK,user_get_piglet_day_task),
	FILL_CMD_WITH_PRI_IN    (USER_NEW_PIGLET_TASK,user_new_piglet_task),
	FILL_CMD_WITH_PRI_IN    (USER_FINISH_PIGLET_TASK,user_finish_piglet_task),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_ALL_MSG,user_get_all_msg),
	FILL_CMD_WITH_PRI_IN_GE (USER_PIGLET_FACTORY_PROCESS,user_piglet_factory_process),
	FILL_CMD_WITHOUT_PRI_IN    (USER_PIGLET_RAND_FORTUNE,user_piglet_rand_fortune),
	FILL_CMD_WITHOUT_PRI_IN (USER_PIGLET_GET_HANDBOOK,user_piglet_get_handbook),
	FILL_CMD_WITH_PRI_IN    (USER_PIGLET_UPGRADE_BUILDING,user_piglet_upgrade_building),
	FILL_CMD_WITH_PRI_IN    (USER_PIGLET_USE_TOOL,user_piglet_use_tool),
	FILL_CMD_WITH_PRI_IN    (USER_GET_LUCKY_TICKET,user_get_lucky_ticket),
	FILL_CMD_WITH_PRI_IN    (USER_CHECK_GET_TICKET,user_check_get_ticket),
	FILL_CMD_WITH_PRI_IN    (USER_SWAP_TICKET_PRIZE,user_swap_ticket_prize),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_HISTORY_TICKET_INFO,user_get_history_ticket_info),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_NATIONAL_DAY_LOGIN,user_get_national_day_login),
	FILL_CMD_WITH_PRI_IN    (USER_SET_NATIONAL_DAY_GIFT,user_set_national_day_gift),
	FILL_CMD_WITH_PRI_IN    (USER_PIGLET_TASK_CHANGE,user_piglet_task_change),
	FILL_CMD_WITH_PRI_IN    (USER_PIGLET_RECEIVE_TICKET,user_piglet_receive_ticket),
	FILL_CMD_WITHOUT_PRI_IN (USER_PIGLET_GET_EFFECT_TOOLS,user_piglet_get_effect_tools),
	FILL_CMD_WITH_PRI_IN    (USER_PIGLET_POLL,user_piglet_poll),
	FILL_CMD_WITH_PRI_IN    (USER_PIGLET_USE_EFFECT_TOOL,user_piglet_use_effect_tool),
	FILL_CMD_WITH_PRI_IN    (USER_CHECK_RESPONSE_FRIEND,user_check_response_friend),
	FILL_CMD_WITH_PRI_IN    (USER_CHECK_EXIST_FRIEND,user_check_exist_friend),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_PIGLET_POLL,user_get_piglet_poll),
	FILL_CMD_WITH_PRI_IN    (USER_DELETE_BANK_MONEY,user_delete_bank_money),
	FILL_CMD_WITH_PRI_IN    (USER_SWAP_HALLOWEEN_CANDY,user_swap_halloween_candy),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_SWAP_HALLOWEEN_HISTORY,user_get_swap_halloween_history),
	FILL_CMD_WITHOUT_PRI_IN (USER_SWAP_HALLOWEEN_ITEM,user_swap_halloween_item),
	FILL_CMD_WITHOUT_PRI_IN (SU_USER_GET_ALL_PIGLETS,su_user_get_all_piglets),
	FILL_CMD_WITHOUT_PRI_IN (SU_USER_GET_PILGET_ATTIRE,su_user_get_pilget_attire),
	FILL_CMD_WITH_PRI_IN (USER_GET_XHX_TASK_STATE, user_get_xhx_task_state),
	FILL_CMD_WITH_PRI_IN (USER_SET_CONTINUE_LOGIN_VALUE, user_set_continue_login_value),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_PROFILES,user_get_profiles),
	FILL_CMD_WITH_PRI_IN_GE (USER_ADD_PROFILE_DRESS,user_add_profile_dress),
	FILL_CMD_WITH_PRI_IN    (USER_REMOVE_PROFILE_DRESS,user_remove_profile_dress),
	FILL_CMD_WITH_PRI_IN    (USER_SWAP_PIGLET_HOUSE_BACK,user_swap_piglet_house_back),
	FILL_CMD_WITH_PRI_IN_GE (USER_GET_TASK_LIST,user_get_task_list),
	FILL_CMD_WITH_PRI_IN    (SU_GET_USERMSG_MUSHROOM_GUIDE,su_get_usermsg_mushroom_guide),
	FILL_CMD_WITH_PRI_IN    (USER_MUSHROOM_GUIDER_RECEIVE_AWARD,user_mushroom_guider_receive_award),
	FILL_CMD_WITHOUT_PRI_IN (USER_GUID_MUSHROOM_GET_AWARDS,user_guid_mushroom_get_awards),
	FILL_CMD_WITH_PRI_IN    (USERMSG_MUSHROOM_GUIDE_DEL, usermsg_mushroom_guide_del),
	FILL_CMD_WITH_PRI_IN    (USER_PIGLET_CARRY_PIGLET,user_piglet_carry_piglet),
	FILL_CMD_WITH_PRI_IN    (USER_CHECK_PIGLET_PERFORMANCE,user_check_piglet_performance),
	FILL_CMD_WITH_PRI_IN_GE (USER_TRANSFER_PIGLET,user_transfer_piglet),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_ANOTHER_PIGHOUSE, user_get_another_pighouse),
	FILL_CMD_WITH_PRI_IN    (USER_PIGLET_ADD_BEATY_TOOL,user_piglet_add_beaty_tool),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_BEAUTY_PIGLET_TOOL,user_get_beauty_piglet_tool),
	FILL_CMD_WITH_PRI_IN    (SU_USER_DROP_SUPER_MUSHROOM_RECORD,su_user_drop_super_mushroom_record),
	FILL_CMD_WITH_PRI_IN    (USER_PUT_ON_PIGLET_CLOTHES,user_put_on_piglet_clothes),
	FILL_CMD_WITH_PRI_IN_GE (USER_CHANGE_BEAUTY_PIGLET,user_change_beauty_piglet),
	FILL_CMD_WITH_PRI_IN    (SYSARG_JOIN_BEAUTY_CONTEND,sysarg_join_beauty_contend),
	FILL_CMD_WITHOUT_PRI_IN (SYSARG_GET_BEAUTY_CONTEND,sysarg_get_beauty_contend),
	FILL_CMD_WITH_PRI_IN    (USER_CHECK_FEED_PIGLET,user_check_feed_piglet),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_BEAUTY_CONTEND_CNT,user_get_beauty_contend_cnt),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_HOME_ATTIRE_COUNT,user_get_home_attire_count),
	FILL_CMD_WITH_PRI_IN    (USER_AS_COMMON_ADD,user_as_common_add),
	FILL_CMD_WITH_PRI_IN    (USER_AS_COMMON_QUERY,user_as_common_query),
	FILL_CMD_WITH_PRI_IN    (ROOMINFO_SET_BEAUTY_CONTINUATION,roominfo_set_beauty_continuation),
	FILL_CMD_WITH_PRI_IN    (ROOMINFO_GET_AWARD_BEAUTY,roominfo_get_award_beauty),
	FILL_CMD_WITHOUT_PRI_IN (ROOMINFO_GET_AWARD_HISTORY,roominfo_get_award_history),
	FILL_CMD_WITH_PRI_IN    (USER_PUT_ON_CHRISTMAS_SOCKS,user_put_on_christmas_socks),
	FILL_CMD_WITH_PRI_IN    (USER_QUERY_CHRISTMAS_SOCKS,user_query_christmas_socks),
	FILL_CMD_WITH_PRI_IN    (USER_CHECK_CHRISTMAS_SOCKS,user_check_christmas_socks),
	FILL_CMD_WITH_PRI_IN	(USER_SYSARG_GET_CHRISTMAS_TOP10,user_sysarg_get_christmas_top10),
	FILL_CMD_WITH_PRI_IN    (USER_SYSARG_SET_CHRISTMAS_TOP10,user_sysarg_set_christmas_top10),
	FILL_CMD_WITH_PRI_IN_GE (USER_CHECK_PIGLET_HANDBOOK,user_check_piglet_handbook),
	FILL_CMD_WITH_PRI_IN    (USER_CHECK_CHRISTMAS_SOCK_GIFT,user_check_christmas_sock_gift),
	FILL_CMD_WITH_PRI_IN    (USER_SET_CHRISTMAS_SOCK_GIFT,user_set_christmas_sock_gift),
	FILL_CMD_WITH_PRI_IN (USER_GET_VIP_ANGEL_INFO,user_get_vip_angel_info),
	FILL_CMD_WITH_PRI_IN (USER_EXCHANGE_VIP_ANGEL_INFO,user_exchange_vip_angel_info),
	FILL_CMD_WITHOUT_PRI_IN (USER_SYSARG_CHECK_PLAYER_NUM,user_sysarg_check_player_num),
	FILL_CMD_WITH_PRI_IN    (USER_SYSARG_MATCHING_MAP,user_sysarg_matching_map),
	FILL_CMD_WITHOUT_PRI_IN (USER_SYSARG_DROP_MAP,user_sysarg_drop_map),
	FILL_CMD_WITHOUT_PRI_IN (USER_SYSARG_GET_MAP,user_sysarg_get_map),
	FILL_CMD_WITHOUT_PRI_IN    (USER_EXPLORE_GET_KEY,user_explore_get_key),
	FILL_CMD_WITHOUT_PRI_IN (USER_EXPLORE_CLEAR_STATE,user_explore_clear_state),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_EXPLORE_STATE,user_get_explore_state),
	FILL_CMD_WITH_PRI_IN    (SYSARG_ADD_CONTRIBUTE_ITEM,sysarg_add_contribute_item),
	FILL_CMD_WITHOUT_PRI_IN (SYSARG_BEGIN_LOVE_AUCTION,sysarg_begin_love_auction),
	FILL_CMD_WITH_PRI_IN (SYSARG_GET_AUCTION_LIST,sysarg_get_auction_list),
	FILL_CMD_WITH_PRI_IN    (SYSARG_AUCTION_ITEM,sysarg_auction_item),
	FILL_CMD_WITHOUT_PRI_IN (USER_SYSARG_CLEAR_EXPLORE_NUM,user_sysarg_clear_explore_num),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_PIGLET_HONOR,user_get_piglet_honor),
	FILL_CMD_WITH_PRI_IN    (USER_SET_PIGLET_HONOR,user_set_piglet_honor),
	FILL_CMD_WITH_PRI_IN (USER_SYSARG_SET_WISH_WALL,user_sysarg_set_wish_wall),
	FILL_CMD_WITH_PRI_IN    (USER_SYSARG_GET_WISH_WALL,user_sysarg_get_wish_wall),
	FILL_CMD_WITH_PRI_IN    (USER_WRITE_SPRING_COUPLET,user_write_spring_couplet),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_WISH_WALL,user_get_wish_wall),
	FILL_CMD_WITH_PRI_IN_GE (SYSARG_DAY_GET_VALUE,sysarg_day_get_value),
	FILL_CMD_WITH_PRI_IN    (USER_SET_WISH,user_set_wish),
	FILL_CMD_WITHOUT_PRI_IN    (SYSARG_CHECK_PROB_LAHM,sysarg_check_prob_lahm),
	FILL_CMD_WITH_PRI_IN    (SYSARG_ADD_PROB_LAHM,sysarg_add_prob_lahm),
	FILL_CMD_WITHOUT_PRI_IN (SYSARG_GET_PROB_LAHM,sysarg_get_prob_lahm),
	FILL_CMD_WITH_PRI_IN    (SYSARG_SET_TWO_TEAM_ENERGY,sysarg_set_two_team_energy),
	FILL_CMD_WITHOUT_PRI_IN (SYSARG_GET_TWO_TEAM_ENERGY,sysarg_get_two_team_energy),
	FILL_CMD_WITH_PRI_IN    (SYSARG_ADD_GUESS_PRICE,sysarg_add_guess_price),
	FILL_CMD_WITH_PRI_IN    (SYSARG_GET_GUESS_PRICE,sysarg_get_guess_price),
	FILL_CMD_WITHOUT_PRI_IN (USER_SPRING_FESTIVAL_LOGIN,user_spring_festival_login),
	FILL_CMD_WITH_PRI_IN    (USER_SPRING_FESTIVAL_RECIVE_AWARD,user_spring_festival_recive_award),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_SPRING_FESTIVAL_LOGIN_INFO,user_get_spring_festival_login_info),
	FILL_CMD_WITH_PRI_IN    (USER_SET_SPRING_FEAST,user_set_spring_feast),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_WISH_AWARD,user_get_wish_award),
	FILL_CMD_WITHOUT_PRI_IN (USER_VIP_CONTINUE_WEEK_LOGIN,user_vip_continue_week_login),
	FILL_CMD_WITH_PRI_IN (USER_VIP_GET_CONTINUE_WEEK,user_vip_get_continue_week),
	FILL_CMD_WITHOUT_PRI_IN (USER_VIP_GET_WEEK_WARD,user_vip_get_week_ward),
	FILL_CMD_WITHOUT_PRI_IN (USER_SET_WEEKEND_LOGIN,user_set_weekend_login),
	FILL_CMD_WITH_PRI_IN (USER_GET_WEEKEND_LOGIN_AWARD,user_get_weekend_login_award),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_LOGIN_WEEKEND,user_get_login_weekend),
	
	FILL_CMD_WITH_PRI_IN_GE (SYSARG_ADD_MARK_ATTIRE,sysarg_add_mark_attire),
	FILL_CMD_WITHOUT_PRI_IN (SYSARG_GET_MARK_ATTIRE,sysarg_get_mark_attire),
	FILL_CMD_WITH_PRI_IN_GE (USER_SET_MARK_ATTIRE,user_set_mark_attire),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_MARK_ATTIRE,user_get_mark_attire),
	FILL_CMD_WITHOUT_PRI_IN (USER_STRENGTH_ICE_DRAGON,user_strength_ice_dragon),
	FILL_CMD_WITH_PRI_IN    (USER_EXCHANGE_PIGLET_HOUSE,user_exchange_piglet_house),
	FILL_CMD_WITH_PRI_IN    (USER_GET_GOLDEN_KEY,user_get_golden_key),
	FILL_CMD_WITH_PRI_IN (USER_GET_PIGLET_MACHINE_WORK,user_get_piglet_machine_work),
    FILL_CMD_WITH_PRI_IN    (USER_SEND_PIGLET_MINING,user_send_piglet_mining),
    FILL_CMD_WITH_PRI_IN_GE (USER_PIGLET_MELT_ORE,user_piglet_melt_ore),
    FILL_CMD_WITHOUT_PRI_IN (USER_GET_PIGLET_MINING_INFO,user_get_piglet_mining_info),
    FILL_CMD_WITH_PRI_IN_GE (USER_FINISH_SOME_MAP_MINING,user_finish_some_map_mining),
    FILL_CMD_WITH_PRI_IN_GE (USER_PRODUCE_MACHINE_PART,user_produce_machine_part),
    FILL_CMD_WITH_PRI_IN    (USER_PIGLET_FINISH_WORK,user_piglet_finish_work),
    FILL_CMD_WITH_PRI_IN    (USER_GET_PIGLET_WORK_MACHINE,user_get_piglet_work_machine),
    FILL_CMD_WITH_PRI_IN    (USER_USE_MACHINE_TOOLS,user_use_machine_tools),
	FILL_CMD_WITHOUT_PRI_IN    (USER_GET_PROCESS,user_get_process),
    FILL_CMD_WITH_PRI_IN    (USER_SET_PROCESS,user_set_process),
	FILL_CMD_WITH_PRI_IN    (USER_GET_MENUE,user_get_menue),
    FILL_CMD_WITH_PRI_IN    (USER_FINISH_MENUE,user_finish_menue),
	FILL_CMD_WITH_PRI_IN    (USER_SUBMIT_MENUE,user_submit_menue),
	FILL_CMD_WITHOUT_PRI_IN (USER_PRODUCE_PRODUCT,user_produce_product),
	FILL_CMD_WITHOUT_PRI_IN (GET_PARTYMENUE_SETTING,get_partymenue_setting),
	FILL_CMD_WITH_PRI_IN    (SET_PARTYMENUE_SETTING,set_partymenue_setting),
	FILL_CMD_WITH_PRI_IN    (USER_PRODUCE_SPECIAL_MACHINE,user_produce_special_machine),
	FILL_CMD_WITHOUT_PRI_IN (SYSARG_SET_GREATE_PRODUCE,sysarg_set_greate_produce),
	FILL_CMD_WITHOUT_PRI_IN (SYSARG_GET_GREATE_PRODUCE,sysarg_get_greate_produce),
	FILL_CMD_WITHOUT_PRI_IN (GET_NEW_FRIENDSHIP_BOX_ITEMS,get_new_friendship_box_items),
	FILL_CMD_WITHOUT_PRI_IN (GET_NEW_FRIENDSHIP_BOX_HISTORY,get_new_friendship_box_history),
	FILL_CMD_WITH_PRI_IN    (PUT_ITEM_TO_NEW_FRIENDSHIP_BOX,put_item_to_new_friendship_box),
	FILL_CMD_WITH_PRI_IN    (GET_ITEM_FROM_NEW_FRIENDSHIP_BOX,get_item_from_new_friendship_box),
	FILL_CMD_WITH_PRI_IN    (CHECK_ITEM_FROM_NEW_FRIENDSHIP_BOX,check_item_from_new_friendship_box),
	FILL_CMD_WITH_PRI_IN    (SET_TAG_ITEM_FROM_NEW_FRIENDSHIP_BOX,set_tag_item_from_new_friendship_box),
	FILL_CMD_WITH_PRI_IN 	(SYSARG_VOTE_BIRTHDAY_DECORATE,sysarg_vote_birthday_decorate),
	FILL_CMD_WITH_PRI_IN    (SYSARG_GET_BIRTHDAY_DECORATE,sysarg_get_birthday_decorate),
    FILL_CMD_WITHOUT_PRI_IN (USER_GET_BUTTERFLY,user_get_butterfly),
	FILL_CMD_WITH_PRI_IN    (USER_RESET_PIGMAP,user_reset_pigmap),
	FILL_CMD_WITH_PRI_IN    (USER_CREATE_TEAM,user_create_team),
	FILL_CMD_WITHOUT_PRI_IN (USER_MVP_GET_TEAMID,user_mvp_get_teamid),
	FILL_CMD_WITH_PRI_IN    (USER_MVP_SET_TEAMID,user_mvp_set_teamid),
    FILL_CMD_WITH_PRI_IN    (USER_MVP_REMOVEONE,user_mvp_removeone),
	FILL_CMD_WITH_PRI_IN    (USER_MVP_ADDONE,user_mvp_addone),
	FILL_CMD_WITHOUT_PRI_IN    (USER_MVP_DELETEALL,user_mvp_deleteall),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_TEAMINFO,user_get_teaminfo),
	FILL_CMD_WITH_PRI_IN    (SYSARG_CREATE_MVP_TEAM,sysarg_create_mvp_team),
	FILL_CMD_WITH_PRI_IN    (SYSARG_DROP_MVP_TEAM,sysarg_drop_mvp_team),
	FILL_CMD_WITH_PRI_IN    (SYSARG_GET_MVP_TEAM,sysarg_get_mvp_team),
	FILL_CMD_WITH_PRI_IN	(SYSARG_SET_MVP_BADGE,sysarg_set_mvp_badge),
	FILL_CMD_WITH_PRI_IN	(USER_SET_MVP_BADGE,user_set_mvp_badge),
	FILL_CMD_WITH_PRI_IN    (SYSARG_CHANGE_MVP_TEAM_MEMBER_COUNT,sysarg_change_mvp_team_member_count),
	FILL_CMD_WITH_PRI_IN (SYSARG_GET_RANDOM_MVP_TEAM,sysarg_get_random_mvp_team),
	FILL_CMD_WITHOUT_PRI_IN	(USER_GET_MVP_BADGE,user_get_mvp_badge),
	FILL_CMD_WITHOUT_PRI_IN	(USER_GET_TEAMID,user_get_teamid),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_SYSARG_MVP_TEAMINFO,user_get_sysarg_mvp_teaminfo),
	FILL_CMD_WITH_PRI_IN	(USER_SET_PIG_GUESS,user_set_pig_guess),
	FILL_CMD_WITHOUT_PRI_IN	(USER_GET_PIG_GUESS,user_get_pig_guess),
	FILL_CMD_WITH_PRI_IN	(USER_GET_PIG_PRIZE,user_get_pig_prize),
	FILL_CMD_WITHOUT_PRI_IN (SU_USER_GET_PIGLET_MACHINE_INFO,su_user_get_piglet_machine_info),
	FILL_CMD_WITHOUT_PRI_IN (SU_USER_GET_WORK_PIGLET_INFO,su_user_get_work_piglet_info),
	FILL_CMD_WITHOUT_PRI_IN (SU_USER_GET_PIGLET_MACHINE_WAREHOUSE,su_user_get_piglet_machine_warehouse),
	FILL_CMD_WITHOUT_PRI_IN    (SYSARG_TW_DAY_AWARD_GET,sysarg_tw_day_award_get),
	FILL_CMD_WITH_PRI_IN (USER_GET_TOGETHER_PHOTO_INFO,user_get_together_photo_info),
	FILL_CMD_WITH_PRI_IN_GE (USER_SET_TOGETHER_PHOTO,user_set_together_photo),
	FILL_CMD_WITHOUT_PRI_IN (SYSARG_MAGIC_BEAN_WATERING,sysarg_magic_bean_watering),
	FILL_CMD_WITHOUT_PRI_IN (SYSARG_MAGIC_BEAN_QUERYING,sysarg_magic_bean_querying),
	FILL_CMD_WITH_PRI_IN    (USER_MISS_NOTE_STONE,user_miss_note_stone),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_MISS_NOT_STONE,user_get_miss_not_stone),
	FILL_CMD_WITHOUT_PRI_IN	(USER_SHAKE_DICE_ACT,user_shake_dice_act),
	FILL_CMD_WITHOUT_PRI_IN	(USER_GET_SHAKE_DICE_LEFT_TIME,user_get_shake_dice_left_time),
	FILL_CMD_WITH_PRI_IN (USER_CHECK_EXPEDITION_LOCK,user_check_expedition_lock),
	FILL_CMD_WITH_PRI_IN    (USER_SET_STORY_CHAPTER_STATE,user_set_story_chapter_state),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_STORY_CHAPTER_STATE,user_get_story_chapter_state),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_MAKE_SUBMARINE,user_get_make_submarine),
	FILL_CMD_WITH_PRI_IN    (USER_STONE_SCISSORS_CLOTH,user_stone_scissors_cloth),
	FILL_CMD_WITHOUT_PRI_IN (USER_CHECK_ROLL_DICE,user_check_roll_dice),
	FILL_CMD_WITHOUT_PRI_IN (SYSARG_GET_FREE_VIP_PLAYER,sysarg_get_free_vip_player),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_MERMAN_KINGDOM,user_get_merman_kingdom),
	FILL_CMD_WITHOUT_PRI_IN (USER_MIDDLE_YEAR_CHEAP_SEAL,user_middle_year_cheap_seal),
	FILL_CMD_WITH_PRI_IN	(USER_JOIN_COSPLAY_RACE,user_join_cosplay_race),
	FILL_CMD_WITH_PRI_IN	(SYSARG_SET_COS_USER_INFO,sysarg_set_cos_user_info),
	FILL_CMD_WITH_PRI_IN	(SYSARG_GET_COS_RANK,sysarg_get_cos_rank),
	FILL_CMD_WITHOUT_PRI_IN	(SYSARG_GET_USER_RANK_FLAG,sysarg_get_user_rank_flag),
	
	//ocean	
	FILL_CMD_WITH_PRI_IN    (USER_ENTER_OCEAN,user_enter_ocean),
	FILL_CMD_WITH_PRI_IN    (USER_FEED_FISH,user_feed_fish),
	FILL_CMD_WITH_PRI_IN    (USER_PUT_IN_OCEAN,user_put_in_ocean),
	FILL_CMD_WITH_PRI_IN_GE    (USER_DIY_OCEAN,user_diy_ocean),
	FILL_CMD_WITH_PRI_IN    (USER_APPLY_FISH_TOOL,user_apply_fish_tool),
	FILL_CMD_WITH_PRI_IN    (USER_EXPAND_OCEAN_CAPACITY,user_expand_ocean_capacity),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_OCEAN_ITEMS,user_get_ocean_items),
	FILL_CMD_WITH_PRI_IN    (USER_GET_OCEAN_OFFLINE_SHELLS,user_get_ocean_offline_shells),
	FILL_CMD_WITH_PRI_IN    (USER_GET_OCEAN_ONLINE_SHELLS,user_get_ocean_online_shells),
	FILL_CMD_WITHOUT_PRI_IN (USER_CLEAR_ONLINE_OCEAN_DROP,user_clear_online_ocean_drop),
	FILL_CMD_WITH_PRI_IN (USER_SET_EXPEDITION_PRAY,user_set_expedition_pray),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_EXPEDITION_PRAY,user_get_expedition_pray),
	FILL_CMD_WITH_PRI_IN_GE (USER_SALE_OCEAN_FISH,user_sale_ocean_fish),
	FILL_CMD_WITH_PRI_IN    (USER_SET_OCEAN_SHELL,user_set_ocean_shell),
	FILL_CMD_WITH_PRI_IN    (USER_BUY_OCEAN_THINGS,user_buy_ocean_things),
	FILL_CMD_WITH_PRI_IN    (USER_ADD_MOLE_ADVENTURE_PASS,user_add_mole_adventure_pass),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_MOLE_ADVENTURE_PASS,user_get_mole_adventure_pass),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_GAMES_INFO,user_get_games_info),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_OCEAN_HANDBOOK,user_get_ocean_handbook),
	FILL_CMD_WITH_PRI_IN_GE (SYSARG_GET_OCEAN_FRIEND,sysarg_get_ocean_friend),
	FILL_CMD_WITHOUT_PRI_IN (SYSARG_GET_GAME_TOP_TEN,sysarg_get_game_top_ten),
	FILL_CMD_WITH_PRI_IN    (USER_ADD_GAME_SOCRE,user_add_game_socre),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_SOCRE_BY_GAMEID,user_get_socre_by_gameid),
	FILL_CMD_WITH_PRI_IN    (SYSARG_GAME_HALL_CHANGE,sysarg_game_hall_change),
	FILL_CMD_WITHOUT_PRI_IN (USER_GET_SCROLL_MAP_STATE,user_get_scroll_map_state),
	FILL_CMD_WITH_PRI_IN    (USER_GET_SCROLL_DRAGMENT,user_get_scroll_dragment),
	FILL_CMD_WITH_PRI_IN    (SYSARG_OCEAN_SYNCHRO_EXP,sysarg_ocean_synchro_exp),
	FILL_CMD_WITHOUT_PRI_IN (SYSARG_SELF_GAME_RANK,sysarg_self_game_rank),
	FILL_CMD_WITHOUT_PRI_IN (USER_FINISH_MERMAN_KINDOM,user_finish_merman_kindom),
};


#endif

#define DEALFUN_COUNT  (int(sizeof(g_cmdmap )/sizeof(g_cmdmap[0])))

/*
 *--------------------------------------------------------------------------------------
 *       Class:  Croute_func
 *      Method:  Croute_func
 * Description:  constructor
 *--------------------------------------------------------------------------------------
 */
Croute_func::Croute_func (mysql_interface * db,Cclientproto * cp ): 
	item_change_log(db, "USER"), user(db,&(this->send_log), &item_change_log), user_ex(db),
	sync_user(config_get_intval("SYNC_DV_MSGLIST_KEY",0)),
	user_attire(db, &item_change_log) ,serial(db)  ,email(db) ,game_score(db) ,
	msgboard(db), register_serial(db), user_pet(db),usermsg(db),user_writing(db),admin(db),
	changelist(db,cp), dvuser(db) ,usermap_day(db) ,msg_attime(db),user_connect(db),
   	user_email(db), sys_arg(db),
	hope_history(db),report_deal_history(db),user_task(db),user_info(db),user_info_ex(db),
	send_email(cp),confect(db),roominfo(db),tempgs(db) ,questionnaire(db),group_main(db),
	group(db),user_group(db),mms(db), roommsg(db),christmas(db),
	chat(db),change_log(db),user_card(db),admin_all(db),party(db),user_serial(db),admin_power(db),
	user_picture(db),spring(db),user_diary(db),qa(db),user_pet_attire(db, &item_change_log),sports_count(db),
	pet_sports(db),pet_max_score(db),user_bank(db) ,user_jy(db), user_task_ex(db),
	appeal(db),appeal_ex(db),change_passwd(db),roominfo_question(db),
	dwg_user_friend(db),dwg_user_msg(db),user_class(db, &item_change_log),month_task(db),login_log(db),
	user_classmsg(db),roominfo_gen_vip(db),class_qa(db),user_farm(db, &item_change_log),user_farm_animal(db),
	user_swap_card(db, &item_change_log),
	roominfo_clothe_waste(db),roominfo_point(db),roominfo_fire_cup(db),sys_fire_cup(db), 
	ip_history(db),game(db),user_game(db),user_game_pk(db), user_lamu_diary(db), roominfo_work(db), user_auto(db, &item_change_log),
	roominfo_rally(db),sys_rally(db),roommsg_bibo(db), sys_msg(db), user_npc(db), user_greenhouse(db), user_egg(db),
	sys_animal(db), user_npc_task(db), roominfo_cake_gift_swap(db), user_pic_book(db),roominfo_animal_weight(db),
	roominfo_flower(db),login_info(),user_ip_map(),roominfo_list(db),writing_day_count(db), roominfo_stone_move(db),
	user_pet_task(db), roominfo_client_data(db), roominfo_skill_limit(db),roominfo_day_limit(db),user_noah(db),user_noah_info(db),
	user_sn(db),user_mdog(db, &item_change_log),diningroom(db),user_diningroom(db),user_dining_dish(db),user_dining_employer(db),
	user_dining_dish_history(db),roominfo_sbh(db),roominfo_sports_meet(db),roominfo_client_buf(db),reg_userid(db),
	sysarg_db_sports_teaminfo(db),sysarg_db_sports_tmpuser(db),sysarg_db_sports_petscore(db),
	sysarg_db_sports_gamescore(db),roominfo_sports_pet_info(db),sysarg_type_buf(db),user_new_card(db, &item_change_log),
	user_dragon(db),user_dragon_egg(db),roominfo_item_sell(db),user_friend_box(db),lamu_classroom(db),
	user_lamu_classroom(db),user_lamu_classroom_lamu(db),user_lamu_classroom_course(db),user_lamu_classroom_remembrance(db),
	user_lamu_classroom_exam(db), user_lamu_classroom_score(db),user_temp_item(db, &item_change_log),sysarg_auction(db),
	sysarg_contribute_rank(db),sysarg_contribute_total(db),sysarg_ranklist(db),user_rank_buf(db),sysarg_top_rank(db),
	roominfo_consume_money(db),roominfo_shake_rewards_times(db),roominfo_sock(db),roominfo_cake(db),roominfo_user_cake(db),
	roominfo_footprint(db),roominfo_login_gifts(db),roominfo_kakunian(db),user_farm_fairy(db),user_farm_speed_tool(db),
	user_farm_fairy_skill(db),user_paradise(db),user_paradise_angel(db),user_paradise_contract(db),roominfo_login_weekend(db),
	user_angel_statistics(db),sysarg_paradise_rank(db),sysarg_hot_play(db),user_angel_battle(db),user_angel_barrier(db),
	user_angel_capture(db),user_angel_hospital(db),user_exchange_bean(db),user_angel_honor(db),user_dig_treasure(db),
   	user_dig_treasure_info(db), user_synth_history(db),user_treasure_show(db),user_treasure_collection(db),
	sysarg_treasure_collection(db), roominfo_strike_penguin(db), user_continue_login(db), user_hide_and_seek(db),
	user_milk_cow(db), user_cow_pasture(db),roominfo_random_gain_gift(db),user_battle_character_attribute(db),
   	user_battle_skill_equip(db),user_battle_props_info(db),user_battle_articles(db, &item_change_log),user_battle_card_booklet(db),
	user_battle_friend_event(db),user_battle_challenge_note(db),user_battle_pass_barrier(db),angel_battle(db),
	user_battle_flip_card_info(db),user_battle_accident(db),user_battle_fight_record(db),user_battle_day_task(db),
	user_battle_master(db),user_battle_prentice(db),user_battle_master_prentice_msg(db),user_through_time_mail(db),
	user_through_time_item(db), user_piglet(db),user_piglet_house(db), user_piglet_attire(db, &item_change_log),
	user_piglet_task(db), user_piglet_msg(db), user_piglet_handbook(db), user_lucky_ticket(db),user_piglet_effect_tool(db),
	user_response_friend(db), user_halloween_candy(db), user_profile_dress(db), sysarg_beauty_contend(db),user_as_common(db),
	roominfo_beauty_piglet(db), user_christmas_socks(db), sysarg_christmas_socks(db), user_vip_months(db),user_dragon_explore(db),
	sysarg_dragon_explore(db),sysarg_love_contribute(db),sysarg_love_auction(db), user_piglet_honor(db),sysarg_wish_wall(db),
	user_wish_wall(db),sysarg_prob_lahm(db),sysarg_prob_month_lahm(db),sysarg_guess_price(db),sysarg_mark_attire(db),
	user_mark_attire(db),user_temp_active(db), user_piglet_mining(db), user_piglet_work(db),user_temp_decorate(db),
	user_new_friendship_box(db), sysarg_vote_decorate(db),user_temp_team(db) , user_mvp_team(db), sysarg_mvp_team(db),
	sysarg_mvp_day(db),sysarg_tw_day_award(db), user_together_photo(db),user_shake_dice(db), sysarg_cos_rank(db),
	user_ocean(db),user_fish(db), user_ocean_info(db), user_ocean_adventure(db),user_self_games(db),sysarg_game_hall(db),
	user_ocean_handbook(db),sysarg_ocean_info(db)
{
	this->db=db;
	this->cp=cp;
	this->cfg.xiaomee= 20000;//config_get_intval("INIT_XIAOMEE",0);	
	this->cfg.userflag=config_get_intval("INIT_USERFLAG",0);	
	DEBUG_LOG("DEALFUN_COUNT: %u ==============",DEALFUN_COUNT);
	this->initlist(g_cmdmap,DEALFUN_COUNT );

	this->sem.init(65299);
	/*const char * udp_ip=NULL ;
	short  udp_port;
	udp_ip=config_get_strval("CHANGE_LOG_IP");
	if( !udp_ip )
		udp_ip="10.1.1.89";
	udp_port=config_get_intval("CHANGE_LOG_PORT",11001);
	this->change_log_fd=open_socket_udp(udp_ip,udp_port,&(this->change_log_addr));*/
	
	this->msglog_file = config_get_strval("MSG_LOG_FILE");
#ifdef MAKE_SEND_EMAIL
	DEBUG_LOG("mk from MAKE_SEND_EMAIL");
#endif


	//this->cmdmaplist.show_item();

	//
	//
}  /* -----  end of method Croute_func::Croute_func  (constructor)  ----- */

int Croute_func::deal(char *recvbuf, int rcvlen, char **sendbuf, int *sndlen )
{
	PRI_STRU * p_pri_stru;
	uint16_t cmdid=((PROTO_HEADER*)recvbuf)->cmd_id;
	if((p_pri_stru =this->cmdmaplist.getitem(cmdid))!=NULL){
		DEBUG_LOG("I:%04X:%d", cmdid, ((PROTO_HEADER*)recvbuf)->id);
		//检查报文长度
		if (! p_pri_stru->check_proto_size(rcvlen - PROTO_HEADER_SIZE) ){
			DEBUG_LOG("len err pre [%ld] send [%d]",p_pri_stru->predefine_len+PROTO_HEADER_SIZE ,rcvlen );
			return PROTO_LEN_ERR;
		}

		//调用相关DB处理函数
		//this->ret=9999;
		//return (this->*(p_pri_stru->p_deal_fun))(recvbuf, sendbuf, sndlen );
	   this->ret=9999;
        this->ret=(this->*(p_pri_stru->p_deal_fun))(recvbuf, sendbuf, sndlen );
        STD_OPEN_AUTOCOMMIT() ; 
		return this->ret;
	}else{
		DEBUG_LOG("cmd no define  comid[%04X]",cmdid );
		return  CMDID_NODEFINE_ERR;
	}
}

//-------------------------------------------------------------------------------------------------
int Croute_func::userinfo_set_user_email(DEAL_FUN_ARG)
{
	userinfo_set_user_email_in * p_in = PRI_IN_POS; 
	ret=this->user_info.update_email(RECVBUF_USERID,p_in->email );
	STD_RETURN(ret );
}

int Croute_func::su_change(DEAL_FUN_ARG)
{
	su_change_in * p_in = PRI_IN_POS; 
	ret=this->changelist.changevalue(RECVBUF_USERID,p_in );
	STD_RETURN(ret );
}

int Croute_func::msgboard_clear_by_del_flag(DEAL_FUN_ARG)
{
	ret=this-> msgboard.clear_by_delete_flag( );
	STD_RETURN(ret );
}

int Croute_func::usermsg_clear_writing(DEAL_FUN_ARG)
{
	usermsg_clear_writing_in * p_in = PRI_IN_POS; 
	ret=this-> user_writing.clear_by_delete_flag( p_in );
	STD_RETURN(ret );
}

int Croute_func::su_login(DEAL_FUN_ARG)
{	
	su_login_in * p_in = PRI_IN_POS; 
	su_login_out out={}; 
	memset(&out,0,sizeof(out));
	ret=this->admin .user_check(RECVBUF_USERID ,p_in->passwd, out.nick , &(out.flag));
	STD_RETURN_WITH_STRUCT(ret,out );
}

int Croute_func::userinfo_register_ex(DEAL_FUN_ARG)
{
	userinfo_register_ex_in *p_in=PRI_IN_POS;
	user_info_item user_info={ }; 
	user_info_ex_item user_info_ex={ };
	memset(&user_info,0,sizeof(user_info) );
	memset(&user_info_ex,0,sizeof(user_info_ex) );

	strcpy (user_info_ex.mobile,"0" );
	//init value
	user_info_ex.birthday=0;
	user_info_ex.addr_province=p_in-> addr_province;
	user_info_ex.addr_city=p_in-> addr_city;


	user_info.regflag=p_in->reg_addr_type;
	memcpy_with_dstsize(user_info.passwd,p_in->passwd);	
	memcpy_with_dstsize(user_info.signature,p_in-> signature );	

	memcpy_with_dstsize(user_info.email,p_in->email);	
	memcpy_with_dstsize(user_info_ex.mobile,p_in-> mobile);	
	memcpy_with_dstsize(user_info_ex.addr,p_in-> addr);	

	if ( p_in->sex==1)
		user_info_ex.flag |= USEREX_FLAG_SEX;

	ret=this->user_info.insert( RECVBUF_USERID ,&user_info);
	if (ret!=SUCC) return ret;
	ret=this->user_info_ex.insert( RECVBUF_USERID ,&user_info_ex);
	if (ret!=SUCC){
		int tmpret=this->user_info.del(RECVBUF_USERID);
		if (tmpret!=SUCC){
			ERROR_LOG ("__ERROR__ DEL userid[%u]ret[%u]",RECVBUF_USERID,tmpret);
		}
	}

	if (ret==SUCC)
	{
		{
			//同步论坛注册数据
			dv_register_in t;
			t.sex=p_in->sex;
			memcpy(t.passwd,p_in->passwd,PASSWD_LEN);
			memcpy(t.email,p_in-> email,EMAIL_LEN);
			this->send_log.dv_register(RECVBUF_USERID,&t);
		}

		{
			//同步论坛注册数据，台湾版本需要
			//不考虑失败的情况
			TDV_REGISTER t={ };	
			t.msg_flag=DV_REGISTER_CMD;
			t.sendcount=0;	
			t.userid=RECVBUF_USERID;
			t.sex=p_in->sex;
			memcpy(t.passwd,p_in->passwd,PASSWD_LEN);
		//	memcpy(t.nick,p_in-> nick,NICK_LEN);
			memcpy(t.email,p_in-> email,EMAIL_LEN);
			this->sync_user.send((char*) &t, sizeof(t) );
		}

		//统计信息处理：
		TUSER_REG tp;		
		tp.logtime=time(NULL);
		tp.userid=RECVBUF_USERID;
		tp.reg_addr_type=p_in->reg_addr_type;
		tp.ip=p_in->ip;
		SAVE_PROTOLOG_USER_REG(tp);
	}

	STD_RETURN(ret);
}

int Croute_func::user_register(DEAL_FUN_ARG)
{
	user_register_in *p_in=PRI_IN_POS;
	user_without_id user_msg; 
	memset(&user_msg,0,sizeof(user_msg) );
	user_msg.flag=this->cfg.userflag;
	user_msg.petcolor=p_in->petcolor;
	//init value
	user_msg.xiaomee=this->cfg.xiaomee;
	user_msg.petbirthday=time(NULL);

	ret=this->user.insert( RECVBUF_USERID ,&user_msg );
	STD_RETURN(ret);
}

int Croute_func::user_register_ex(DEAL_FUN_ARG)
{
	user_register_ex_in *p_in=PRI_IN_POS; 
	user_without_id user_msg; 
	memset(&user_msg,0,sizeof(user_msg) );
	user_msg.flag=this->cfg.userflag;
	user_msg.petcolor=p_in->petcolor;
	//init value
	user_msg.xiaomee=this->cfg.xiaomee;
	user_msg.petbirthday=time(NULL);

	ret=this->user.insert( RECVBUF_USERID ,&user_msg );
	STD_RETURN(ret);


}

int Croute_func::user_get_user_with_msglist(DEAL_FUN_ARG)
{
	user_get_user_with_msglist_out out={};
	
	//每月一次清除邮件标记
	uint32_t last_clear_month = 0;
	this->user_temp_active.get_one(RECVBUF_USERID, 300, "value_1", &last_clear_month);	
	uint32_t datetime = time(0); 
	if(get_month(last_clear_month) != get_month(datetime)){
		this->user_temp_active.add(RECVBUF_USERID, 300, datetime, 0);
		this->user_ex.update_one_col(RECVBUF_USERID, "sendmail_flag", 0);
	}	
	

	ret=this->user.user_check(RECVBUF_USERID );
	if(ret!=SUCC) {
		return ret;
	}
	ret=this->user.get_user_ex(RECVBUF_USERID ,&out);
	if (ret!=SUCC){ return ret; } 

	if (ret==SUCC&& out.msglist.len>2008){
		ERROR_LOG("__ERROR_ DB_DATA_ERR len %u ", out.msglist.len);
		return DB_DATA_ERR;	
	}
	out.user_other.ol_last_time = out.Ol_last;
	uint32_t now = get_date(time(NULL));
	uint32_t od_date = get_date(out.Ol_last);
	if (now != od_date) {
		ret = this->user.update_last_onlinetime(RECVBUF_USERID, 0, time(NULL));
		if (ret != SUCC) {
			return ret;
		}
		out.Ol_today = 0;
		out.Ol_last = now;
	}
	user_connect_get_info_out connect_out={};

	ret=this->user_connect.get_info(RECVBUF_USERID,&connect_out );
	if (ret!=SUCC){
		return ret;
	}
	//登入ONLINE ,标志: 该函数一次登入中只会调用一次
	{
		//进入统计数据
		TUSER_ON_OFF_LINE t;
		t.flag=3;
		t.logtime=time(NULL);
		t.userid=RECVBUF_USERID;
		SAVE_PROTOLOG_USER_ON_OFF_LINE(t);
	}

	out.parentid=connect_out.parentid;
	out.childcount=connect_out.childcount;
	out.old_childcount=connect_out.old_childcount;



	ret=this->user_bank.record_out_of_day(RECVBUF_USERID, &out.is_bank_daoqi);
	if (ret!=SUCC){ return ret; }
		

	uint32_t flag = 0;
	this->user_ex.get_int_value(RECVBUF_USERID, "flag", &flag);
	if (flag == 2) {//如果曾经是VIP用户
		uint32_t add_viplamu_val = 0;
		this->user_continue_login.cal_superlamu_value_continue(RECVBUF_USERID, 1, &add_viplamu_val);
		if (add_viplamu_val != 0) {
			this->user_ex.inc_login_vip_mark(RECVBUF_USERID, add_viplamu_val);
		}
	}
	this->user_continue_login.cal_national_day_continue(RECVBUF_USERID, 2);

	creategroupid_list clist={ };
	ret=this->user_ex.get_info(RECVBUF_USERID ,&(out.user_other));

	if (ret!=SUCC)  return ret;
	this->user_group.get_creategroup_list(RECVBUF_USERID,&(clist));

	out.user_other.creategroup_count=clist.count;	
	out.user_other.creategroup_id1=clist.creategroupid[0].groupid;	
	out.user_other.creategroup_id2=clist.creategroupid[1].groupid;	
	out.user_other.creategroup_id3=clist.creategroupid[2].groupid;	
	
	ret = this->user_task.get_all_count(RECVBUF_USERID, 101, 104, &out.lamu_task);	
	if (ret != SUCC) {
		return ret;
	}
	uint32_t temp_time = 0;
	ret = this->user_farm.time_limit(RECVBUF_USERID, &temp_time, &out.plant_limit, &out.breed_limit, &out.plant, &out.breed);
	if (ret != SUCC && ret != 1105) {
		return ret;
	}

	uint32_t today_date = get_date(time(NULL));
	if (today_date != temp_time)
	{
		out.plant_limit = 0;
		out.breed_limit = 0;
	}

	user_npc_out temp = {};
	ret = this->user_npc.get_npc(RECVBUF_USERID, &temp);
	if (ret == USER_ID_NOFIND_ERR) {
		ret = SUCC;
	}
	memcpy(out.npc, &temp, sizeof(user_npc_out));

	uint32_t dining_level = 0;
	uint32_t dining_eva = 0;
	ret = this->user_diningroom.get_level_evaluate(RECVBUF_USERID, dining_level, dining_eva);
	if (ret != SUCC && ret != USER_ID_NOFIND_ERR)
	{
		return  ret;
	}
	else
	{
		if (ret == USER_ID_NOFIND_ERR) 
		{
			out.dining_flag = 0;
			ret = SUCC;
		}
		else
		{
			out.dining_flag = 1;
			out.dining_level = dining_level;
		}
	}

	get_current_dragon_out dragon_out;
	ret = this->user_dragon.get_current_dragon(RECVBUF_USERID,&dragon_out);
	if(ret == SUCC) {
		out.dragon_id = dragon_out.dragon_id;
		memcpy(out.dragon_name,dragon_out.name,16);
		out.dragon_growth = dragon_out.growth;
	} else {
		out.dragon_id = 0;
		out.dragon_growth = 0;
		memset(out.dragon_name,0,16);
		ret = SUCC;
	}

    user_lamu_classroom_get_exp_course_out lamu_class ={};
	ret = this->user_lamu_classroom.get_exp_course_cnt(RECVBUF_USERID, &lamu_class);
	if (ret == SUCC) {
		ret = this->user_lamu_classroom_lamu.get_lamus_count(RECVBUF_USERID, &(lamu_class.lamu_cnt));
	}
	out.teach_exp = lamu_class.exp;
	out.exam_num = lamu_class.exam_times;
	out.student_num = lamu_class.lamu_cnt;
	uint32_t super_animal_count = 0;
	ret = this->user_farm.get_count(RECVBUF_USERID, super_animal_count);
	out.super_animal_count = super_animal_count;
	uint32_t dig_treasure_exp = 0;
	ret = this->user_dig_treasure_info.get_exp(RECVBUF_USERID, dig_treasure_exp);
	out.dig_treasure_exp = dig_treasure_exp;
	//拉取猪倌等级,经验，猪币
	ret = this->user_piglet_house.get_login_game(RECVBUF_USERID, &out.piglet_exp, &out.piglet_level);
	uint32_t level = 0;
	ret = this->user_paradise.get_level(RECVBUF_USERID, level);
	out.level = level;
	DEBUG_LOG("out.animal_super_count:%u",out.super_animal_count);
	ret = SUCC;
	//确定返回长度
	uint32_t  private_size;
	private_size=sizeof (out)-(sizeof (stru_msg_list) - out.msglist.len);

	{ // 添加用户宠物是否有已经接任务
		bool have_doing_task_for_pet=0;
		this->user_pet_task.userid(RECVBUF_USERID);
		this->user_pet_task.get_task_stat_by_user(have_doing_task_for_pet);
		out.have_doing_task=have_doing_task_for_pet;

	}
	DEBUG_LOG("len: %u", private_size);
	STD_RETURN_WITH_BUF(ret, &out, private_size);
}

int Croute_func::user_get_user(DEAL_FUN_ARG)
{	
	user_get_user_out out={};

	//每月一次清除邮件标记
	uint32_t last_clear_month = 0;
	this->user_temp_active.get_one(RECVBUF_USERID, 300, "value_1", &last_clear_month);	
	uint32_t datetime = time(0); 
	if(get_month(last_clear_month) != get_month(datetime)){
		this->user_temp_active.add(RECVBUF_USERID, 300, datetime, 0);
		this->user_ex.update_one_col(RECVBUF_USERID, "sendmail_flag", 0);
	}	

	
	ret=this->user.get_user(RECVBUF_USERID ,&out);
	if (ret!=SUCC){ return ret; }

	out.user_other.ol_last_time = out.Ol_last;

	//uint32_t now = get_date(time(NULL));
	//uint32_t od_date = get_date(out.Ol_last);
	//if (now != od_date) {
		//ret = this->user.update_last_onlinetime(RECVBUF_USERID, 0, time(NULL));
		//if (ret != SUCC) {
			//return ret;
		//}
		//out.Ol_today = 0;
		//out.Ol_last = now;
	//}
	user_connect_get_info_out connect_out={};
	ret=this->user_connect.get_info(RECVBUF_USERID,&connect_out );
	if (ret!=SUCC){ return ret; }

	out.parentid=connect_out.parentid;
	out.childcount=connect_out.childcount;
	out.old_childcount=connect_out.old_childcount;
	ret=this->user_bank.record_out_of_day(RECVBUF_USERID, &(out.is_bank_daoqi));
	if (ret!=SUCC){ return ret; }

	/*
	uint32_t flag = 0;
	this->user_ex.get_int_value(RECVBUF_USERID, "flag", &flag);
	if (flag == 2) {//曾经是VIP用户
		uint32_t add_viplamu_val = 0;
		this->user_continue_login.cal_superlamu_value_continue(RECVBUF_USERID, 1, &add_viplamu_val);
		if (add_viplamu_val != 0) {
			this->user_ex.inc_login_vip_mark(RECVBUF_USERID, add_viplamu_val);
		}
	}
	this->user_continue_login.cal_national_day_continue(RECVBUF_USERID, 2);
	*/

	creategroupid_list clist={ };
	ret=this->user_ex.get_info(RECVBUF_USERID ,&(out.user_other));

	if (ret!=SUCC)  return ret;
	this->user_group.get_creategroup_list(RECVBUF_USERID,&(clist));

	out.user_other.creategroup_count=clist.count;	
	out.user_other.creategroup_id1=clist.creategroupid[0].groupid;	
	out.user_other.creategroup_id2=clist.creategroupid[1].groupid;	
	out.user_other.creategroup_id3=clist.creategroupid[2].groupid;	
	
	ret = this->user_task.get_all_count(RECVBUF_USERID, 101, 104, &out.lamu_task);
	if (ret != SUCC)
	{
		return ret;
	}
	uint32_t temp_time = 0;
	ret = this->user_farm.time_limit(RECVBUF_USERID, &temp_time, &out.plant_limit, &out.breed_limit, &out.plant, &out.breed);
	if (ret != SUCC && ret != USER_ID_NOFIND_ERR)
	{
		return ret;
	}
	
	uint32_t today_date = get_date(time(NULL));
	if (today_date != temp_time)
	{
		out.plant_limit = 0;
		out.breed_limit = 0;
	}

	user_npc_out temp = {};
	ret = this->user_npc.get_npc(RECVBUF_USERID, &temp);
	if (ret == USER_ID_NOFIND_ERR)
	{
		ret = SUCC;
	}

	uint32_t dining_level = 0;
	uint32_t dining_eva = 0;
	ret = this->user_diningroom.get_level_evaluate(RECVBUF_USERID, dining_level, dining_eva);
	if (ret != SUCC && ret != USER_ID_NOFIND_ERR)
	{
		return  ret;
	}
	else
	{
		if (ret == USER_ID_NOFIND_ERR) 
		{
			out.dining_flag = 0;
			ret = SUCC;
		}
		else
		{
			out.dining_flag = 1;
			out.dining_level = dining_level;
		}
	}

    get_current_dragon_out dragon_out;
    ret = this->user_dragon.get_current_dragon(RECVBUF_USERID,&dragon_out);
    if(ret == SUCC) {
    	out.dragon_id = dragon_out.dragon_id;
		memcpy(out.dragon_name,dragon_out.name,16);
    	out.dragon_growth = dragon_out.growth;						   
	} else {
		out.dragon_id = 0;
		out.dragon_growth = 0;
		memset(out.dragon_name,0,16);
		ret = SUCC;								   
	}

    user_lamu_classroom_get_exp_course_out lamu_class ={0};
	ret = this->user_lamu_classroom.get_exp_course_cnt(RECVBUF_USERID, &lamu_class);
	if (ret == SUCC) {
		ret = this->user_lamu_classroom_lamu.get_lamus_count(RECVBUF_USERID, &(lamu_class.lamu_cnt));
	}
	out.teach_exp = lamu_class.exp;
	out.exam_num = lamu_class.exam_times;
	out.student_num = lamu_class.lamu_cnt;
	uint32_t super_animal_count = 0;
	ret = this->user_farm.get_count(RECVBUF_USERID, super_animal_count);
	out.super_animal_count = super_animal_count;
	uint32_t dig_treasure_exp = 0;
    ret = this->user_dig_treasure_info.get_exp(RECVBUF_USERID, dig_treasure_exp);
    out.dig_treasure_exp = dig_treasure_exp;
	//拉取猪倌等级,经验，猪币
	ret = this->user_piglet_house.get_login_game(RECVBUF_USERID, &out.piglet_exp, &out.piglet_level);
	uint32_t level = 0;
	ret= this->user_paradise.get_level(RECVBUF_USERID, level);
	out.level = level ;
	ret = SUCC;
	memcpy(out.npc, &temp, sizeof(user_npc_out));
	{ // 添加用户宠物是否有已经接任务
		bool have_doing_task_for_pet=0;
		this->user_pet_task.userid(RECVBUF_USERID);
		this->user_pet_task.get_task_stat_by_user(have_doing_task_for_pet);
		out.have_doing_task=have_doing_task_for_pet;

	}

	STD_RETURN_WITH_BUF(ret, &out, 
			sizeof (out)-(sizeof(stru_msg_list) )); /*MSG_LIST,不返回*/
}

int Croute_func::user_get_user_all(DEAL_FUN_ARG)
{	
	user_get_user_all_out out={};
	ret=this->user.get_user_all(RECVBUF_USERID ,&out);
	if(ret!=SUCC) return ret;
	ret=this->user_ex.get_info(RECVBUF_USERID ,&out);
	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::userinfo_get_info_ex(DEAL_FUN_ARG)
{	
	userinfo_get_info_ex_out out={};
	ret=this->user_info_ex.get(RECVBUF_USERID ,&out);
	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::userinfo_set_info_ex(DEAL_FUN_ARG)
{	
	userinfo_set_info_ex_in * p_in=PRI_IN_POS;
	ret=this->user_info_ex.update(RECVBUF_USERID ,p_in );
	STD_RETURN(ret);
}

int Croute_func::userinfo_get_user_email(DEAL_FUN_ARG)
{	
	userinfo_get_user_email_out out={};
	ret=this->user_info.get_email(RECVBUF_USERID ,out.email);
	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::userinfo_get_nick(DEAL_FUN_ARG)
{	
	userinfo_get_nick_out out={};
//	ret=this->user_info.get_nick(RECVBUF_USERID ,out.nick);
	STD_RETURN_WITH_STRUCT(ret, out);
}
int Croute_func::user_get_nick(DEAL_FUN_ARG)
{	
	user_get_nick_out out={};
	ret=this->user_ex.get_nick(RECVBUF_USERID ,out.nick);
	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::user_set_petcolor(DEAL_FUN_ARG)
{	
	user_set_petcolor_in * p_in=PRI_IN_POS;
	ret=this->user.update_petcolor(RECVBUF_USERID ,p_in );
	STD_RETURN(ret );
}

int Croute_func::user_del_attire(DEAL_FUN_ARG)
{	
	user_del_attire_in * p_in=PRI_IN_POS;
	ret=this->user_del_attire(RECVBUF_USERID ,p_in);
	STD_RETURN(ret );
}

int Croute_func::hope_add_hope(DEAL_FUN_ARG)
{	
	hope_add_hope_in * p_in=PRI_IN_POS;
	hope_add_hope_out out={};
	out.recv_id=p_in->recv_id;
	memcpy(out.recv_type_name,p_in->recv_type_name,
			sizeof(out.recv_type_name) );
	uint32_t randid=random()%100;

		
	if (randid<6){//实现了愿望
		//原有愿望
	}else if(randid<14){
		//宠物三明治
		p_in->recv_type=180020;	
	}else if(randid<22){
		//西瓜果实
		p_in->recv_type=17006;	
	}else if(randid<30){
		//石像果实
		p_in->recv_type=17007;	
	}else if(randid<36){
		//青苹果洗面奶
		p_in->recv_type=180009;	
	}else if(randid<40){
		//中秋月饼
		p_in->recv_type=180016;	
	}else{
		//没有实现
		p_in->recv_type=0;	
	}
	ret=this->hope_history.insert(p_in);
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::hope_set_hope_used(DEAL_FUN_ARG)
{	
	hope_set_hope_used_in * p_in=PRI_IN_POS;
	hope_set_hope_used_out out={};	

	ret=this->hope_history.get_hope(p_in->send_id ,p_in->recv_id,p_in->hopedate ,&out );
	if (ret!=SUCC){ return ret; }

	ret=this->hope_history.set_useflag(p_in->send_id,p_in->recv_id ,p_in->hopedate);
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_set_attire_ex(DEAL_FUN_ARG)
{	
	user_set_attire_ex_in * p_in=PRI_IN_POS;
	ret = SUCC;
    STD_CLOSE_AUTOCOMMIT(ret);
	if(ret != SUCC) return ret;
	ret = this->user_attire.update_ex(RECVBUF_USERID ,
			p_in->attireid,p_in->usedcount,p_in->chestcount,p_in->count);

	if(ret==SUCC){
        //提交
        STD_COMMIT(ret);
    }else{
        //回滚
        STD_ROLLBACK();
    }
    //关闭事务
    STD_OPEN_AUTOCOMMIT() ;

	STD_RETURN(ret);
}

int Croute_func::user_add_attire (DEAL_FUN_ARG)
{
	user_add_attire_in	*p_in =PRI_IN_POS;
	ret=this->user_add_attire(RECVBUF_USERID,p_in);
	if(ret == SUCC) {
		change_log_item c_item;
		c_item.userid=RECVBUF_USERID;
		c_item.change_type=10004;
		c_item.logtime=time(NULL);
		c_item.change_value=p_in->count;
		c_item.change_v1=p_in->attireid;
		c_item.change_v2=0;
		this->send_log.send(&c_item );																		   
	}
	STD_RETURN(ret );
}

int Croute_func::hope_check_hope(DEAL_FUN_ARG)
{
	hope_check_hope_in * p_in=PRI_IN_POS;
    ret=this->hope_history.check_today_hope(p_in->send_id);
    if (ret==SUCC){
        ret=HOPE_IS_EXISTED_ERR;
    }else if(ret==USER_ID_NOFIND_ERR){
        ret=SUCC;
    }
    STD_RETURN(ret );
}

int Croute_func::usermsg_add_report_deal(DEAL_FUN_ARG)
{
	usermsg_add_report_deal_in *p_in =PRI_IN_POS;
	ret=this->report_deal_history.insert(RECVBUF_USERID,
			p_in->amdinid,p_in->deal_type,p_in->reason,p_in->nick);
	STD_RETURN(ret );
}

int Croute_func::user_add_attire( userid_t userid, user_add_attire_in * p_in, uint32_t is_vip_opt_type )
{
	DEBUG_LOG("type: %u, attireid: %u",p_in->attiretype, p_in->attireid);
	if (p_in ->attireid == 1351056) {//因为配表错误，临时物品商城积分放到了装扮表中
		p_in->attiretype = 0;
		DEBUG_LOG("user add attire 1351056");
	}
	if(is_vip_opt_type == USER_SWAP_IS_VIP_OPT){//USER_SWAP_IS_VIP_OPT, 摩尔商城，使用金豆时reason_ex 专用值 
		is_vip_opt_type = 1;//表示通过米币购买得到的
	}
	else{
		is_vip_opt_type = 0;//普通通添加
	}
	if ( p_in->attiretype==0)
	{//是装扮

		user_set_attire_in 	stru_add_attire_in;
		user_set_attire_out  	stru_add_attire_out={};

		stru_add_attire_in.attireid=p_in->attireid;
		stru_add_attire_in.operatetype = 0x01; //add + no used
		stru_add_attire_in.value=p_in->count;
		stru_add_attire_in.maxvalue=p_in->maxcount;

		ret=this->user_attire.update_common(userid ,
				&stru_add_attire_in ,
				&stru_add_attire_out, is_vip_opt_type);

		//修正数据问题。当其物品中已经有了:12365,仍然认为加成功
		if (p_in->attireid==12365 && ret==VALUE_OUT_OF_RANGE_ERR)
		{
			return SUCC;
		}
		DEBUG_LOG("stru_add_attire_in.attireid: %u", stru_add_attire_in.attireid);
		if (attire_id_in_pic_list(stru_add_attire_in.attireid)
			|| attire_id_is_mature_id_in_pic_list(stru_add_attire_in.attireid)
			|| attire_id_is_fruitid_in_pic_list(stru_add_attire_in.attireid))
		{
			//把装扮加入图鉴列表中，为每一个用户
			this->user_pic_book.insert(userid, stru_add_attire_in.attireid);
		}
	}
	else if(p_in->attiretype==1)
	{//小屋

		attire_count_with_max item;
		item.attireid=p_in->attireid;
		item. count=p_in->count;
		item.maxcount=p_in->maxcount;
		//得到vip flag
		bool is_vip;	
		ret=this->user_ex.get_vip(userid,&is_vip );
		if(ret==SUCC){
			ret=this->user.home_add_attire(userid,&item,is_vip, is_vip_opt_type);
		}
	}else if(p_in->attiretype==2) {//庄园
		attire_count_with_max item;
		item.attireid=p_in->attireid;
		item. count=p_in->count;
		item.maxcount=p_in->maxcount;
		ret=this->user.add_home_attire(JY_STR,userid,&item, is_vip_opt_type);
	} else if(p_in->attiretype==4) {//牧场
		attire_count_with_max item;
		item.attireid=p_in->attireid;
		item. count=p_in->count;
		item.maxcount=p_in->maxcount;
		ret=this->user_farm.add_home_attire(FARM_STR,userid,&item, is_vip_opt_type);
	} else if (p_in->attiretype == 6) { //增加卡牌
		ret = this->user_swap_card.add(userid, p_in->attireid, is_vip_opt_type);
		if (ret != SUCC) {
			return ret;
		}
	} else if(p_in->attiretype== 7) {
		attire_count_with_max item;
		item.attireid = p_in->attireid;
		item.count = 1;
		item.maxcount = p_in->maxcount;
		ret = this->user_class.add_home_attire(CLASS_HOME_STR, userid, &item, is_vip_opt_type);
		if (ret != SUCC) {
			return ret;
		}
	} else if(p_in->attiretype == 8) {
		user_auto_insert_in item;
		item.auto_id = p_in->attireid;
		uint32_t id = 0;
		ret = this->user_auto.add(userid, &item, &id, is_vip_opt_type);
		if (ret != SUCC) {
			return ret;
		}
	} else if (p_in->attiretype == 10) { //增加新版卡牌id
		ret = this->user_new_card.add_new_card(userid, p_in->attireid, is_vip_opt_type);
		if (ret != SUCC) {
			return ret;
		}
	} else if (p_in->attiretype == 11) { //增加机器狗
		//ret = this->user_mdog.insert(userid, p_in->attireid, is_vip_opt_type);
		ret = this->user_mdog.add(userid, p_in->attireid, is_vip_opt_type);
		if (ret != SUCC) {
			return ret;
		}
	} else if (p_in->attiretype > 100) { //增加拉姆物品
		user_set_attire_in set_info = {};
		user_set_attire_out set_out = {};
		set_info.attireid=p_in->attireid;
		set_info.maxvalue=p_in->maxcount;
		set_info.value=p_in->count;
		set_info.operatetype=0x01; //add + no used
		uint32_t petid = p_in->attiretype - 100;
		ret=this->user_pet_attire.update_common(userid,petid,&set_info, &set_out, is_vip_opt_type);
		if (ret != SUCC) {
			return ret;
		}
	} else if(p_in->attiretype == 99) {
		ret = this->user_temp_item.add_count(userid,p_in->attireid,p_in->count,p_in->maxcount, is_vip_opt_type);
		if (p_in->attireid == 1351126) {//花宝猪,表示任务完成
			this->user_continue_login.update_count(userid, 10000, 3);
		}
	} else if(p_in->attiretype == 32){
		ret = this->user_battle_articles.add_count(userid,p_in->attireid,p_in->count,p_in->maxcount, is_vip_opt_type);
	}
	else if(p_in->attiretype == 36){
		ret = this->user_piglet_attire.add_count(userid,p_in->attireid,p_in->count,p_in->maxcount, is_vip_opt_type);
	}
   	else if(p_in->attiretype == 27) {
		ret = this->user_dragon.add(userid, p_in->attireid);
	} else {
		return ENUM_OUT_OF_RANGE_ERR;
	}
	if (ret==SUCC){
		//log_change
		DEBUG_LOG("ACTION REWARD [uid: %u; itemid: %u; count: %u]",userid, p_in->attireid, p_in->count);
		change_log_item c_item;
		c_item.userid=userid;
		c_item.change_type=5;
		c_item.logtime=time(NULL);
		c_item.change_value=-p_in->count;
		c_item.change_v1=p_in->attireid;
		c_item.change_v2=0;
		this->send_log.send(&c_item );
	}

	return ret;
}

int Croute_func::user_del_attire( userid_t userid, user_del_attire_in * p_in, uint32_t is_vip_opt_type)
{
	DEBUG_LOG("===begin del %u", p_in->attiretype);
	if ( p_in->attiretype==0){//是装扮
		user_set_attire_in 	stru_add_attire_in;
		user_set_attire_out  	stru_add_attire_out={};

		stru_add_attire_in.attireid=p_in->attireid;
		stru_add_attire_in.operatetype=0x04; //del + all
		stru_add_attire_in.value=p_in->count;
		stru_add_attire_in.maxvalue=p_in->maxcount;

		ret=this->user_attire.update_common(userid ,
				&stru_add_attire_in ,
				&stru_add_attire_out, is_vip_opt_type);
	}else if(p_in->attiretype==1) {//小屋
		attire_count_with_max item;
		item.attireid=p_in->attireid;
		item. count=p_in->count;
		item.maxcount=p_in->maxcount;
		ret=this->user.home_reduce_attire(userid,&item, is_vip_opt_type);
	}else if(p_in->attiretype==2) {//家园
		attire_count_with_max item;
		item.attireid=p_in->attireid;
		item. count=p_in->count;
		item.maxcount=p_in->maxcount;
		ret=this->user.del_home_attire_noused(JY_STR,userid,&item, is_vip_opt_type);
	}else if(p_in->attiretype==4) {//牧场
		attire_count_with_max item;
		item.attireid=p_in->attireid;
		item. count=p_in->count;
		item.maxcount=p_in->maxcount;
		ret=this->user_farm.del_home_attire_noused(FARM_STR,userid,&item, is_vip_opt_type);
	} else if (p_in->attiretype == 6) {
		DEBUG_LOG("===del type %u", p_in->attireid);
		ret = this->user_swap_card.del_card(userid, p_in->attireid, is_vip_opt_type);
	} else if(p_in->attiretype == 26){
		user_dining_dec_dish_in req;
		req.dish_id = p_in->attireid;
		req.num = p_in->count;
		ret = this->user_dec_dish(userid,&req);
	} else if(p_in->attiretype == 99) {
		ret = this->user_temp_item.sub_count(userid,p_in->attireid,p_in->count, is_vip_opt_type);
	} else if(p_in->attiretype == 32){
		ret = this->user_battle_articles.sub_count(userid,p_in->attireid,p_in->count, is_vip_opt_type);
	}
	else if(p_in->attiretype == 36){
		ret = this->user_piglet_attire.sub_count(userid,p_in->attireid,p_in->count, is_vip_opt_type);
	}
	else {
		return  ENUM_OUT_OF_RANGE_ERR ;
	}

	if (ret==SUCC){
		//log_change
		change_log_item c_item;
		c_item.userid=userid;
		c_item.change_type=5;
		c_item.logtime=time(NULL);
		c_item.change_value=p_in->count;
		c_item.change_v1=p_in->attireid;
		c_item.change_v2=0;
		this->send_log.send(&c_item );
	}


	return ret;
}

int Croute_func::user_buy_attire_by_xiaomee(DEAL_FUN_ARG)
{
	user_buy_attire_by_xiaomee_in* p_in= PRI_IN_POS;   
	user_buy_attire_by_xiaomee_out out={};
	int xiaomee;	

	ret=this->user.change_xiaomee(
			RECVBUF_USERID, -p_in->usexiaomee,
			XIAOMEE_USE_DEL_BUY_ATTIRE ,p_in->attire_item.attireid,
		  	&xiaomee);

	if (ret!=SUCC) return ret;
	ret=this->user_add_attire(RECVBUF_USERID,&(p_in->attire_item ) );
	if (ret!=SUCC){ //没有增加成功 ,设置xiaomee为原值 
			int tmp_ret=this->user.change_xiaomee(
				RECVBUF_USERID ,p_in->usexiaomee,
				XIAOMEE_USE_ADD_BACK,p_in-> attire_item.attireid,&xiaomee);
			if (tmp_ret!=SUCC){
				//回滚出现严重 ,需要手工处理
				ERROR_LOG("ERROR:xiaomee route back error ret[%d],userid[%u],xiaomee[%d]",
					 tmp_ret ,RECVBUF_USERID,p_in->usexiaomee);
			}
	}
	out.leave_xiaomee=xiaomee;
	out.buy_attireid=p_in->attire_item.attireid;
	out.buy_count=p_in->attire_item.count;
	if (ret==SUCC){
		//log_change
		change_log_item c_item;
		c_item.userid=RECVBUF_USERID;
		c_item.change_type=1;
		c_item.logtime=time(NULL);
		c_item.change_value=-p_in->usexiaomee;
		c_item.change_v1=p_in->attire_item.attireid;
		c_item.change_v2=out.leave_xiaomee;
		this->send_log.send(&c_item );
	}
	msglog(this->msglog_file, 0x04040105,time(NULL), &(RECVBUF_USERID), 4);

	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_sale_attire(DEAL_FUN_ARG)
{
	user_sale_attire_in* p_in= PRI_IN_POS;   
	user_sale_attire_out out={};
	int xiaomee;	
	ret=this->user.change_xiaomee(
			RECVBUF_USERID, p_in->usexiaomee,
			XIAOMEE_USE_ADD_SALE, p_in-> attire_item.attireid,
		  	&xiaomee);

	if (ret!=SUCC) return ret;
	ret=this->user_del_attire(RECVBUF_USERID,&(p_in-> attire_item) );
	if (ret!=SUCC){ //没有增加成功 ,设置xiaomee为原值 
			int tmp_ret=this->user.change_xiaomee(
				RECVBUF_USERID ,-p_in->usexiaomee,
				XIAOMEE_USE_ADD_BACK,p_in-> attire_item.attireid,&xiaomee);
			if (tmp_ret!=SUCC){
				//回滚出现严重 ,需要手工处理
				ERROR_LOG("ERROR:xiaomee route back error ret[%d],userid[%u],xiaomee[%d]",
					 tmp_ret ,RECVBUF_USERID,p_in->usexiaomee);
			}
	}

	out.xiaomee=xiaomee;
	if (ret==SUCC){
		//log_change
		change_log_item c_item;
		c_item.userid=RECVBUF_USERID;
		c_item.change_type=1;
		c_item.logtime=time(NULL);
		c_item.change_value=p_in->usexiaomee;
		c_item.change_v1=p_in->attire_item.attireid;
		c_item.change_v2=out.xiaomee;
		this->send_log.send(&c_item );
	}

	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_set_attire(DEAL_FUN_ARG)
{
	user_set_attire_in * p_in=PRI_IN_POS;
	user_set_attire_out out={};	
	ret=this->user_attire.update_common(RECVBUF_USERID ,
			p_in, &out );
	if (ret==SUCC)
	{
		//log_change
		bool isused= p_in->operatetype &0x02;
		if (!isused){
			change_log_item c_item;
			c_item.userid=RECVBUF_USERID;
			c_item.change_type=5;
			c_item.logtime=time(NULL);
			if ((p_in->operatetype &0x01)==0x01){//add
				c_item.change_value=-p_in->value;
			}else{
				c_item.change_value=p_in->value;
			}

			c_item.change_v1=p_in->attireid;
			c_item.change_v2=out.count;
			this->send_log.send(&c_item );
		}
	}

	if(attire_id_in_pic_list(p_in->attireid)
		|| attire_id_is_mature_id_in_pic_list(p_in->attireid)
		|| attire_id_is_fruitid_in_pic_list(p_in->attireid))
	{
		//把装扮加入图鉴列表中，为每一个用户
		this->user_pic_book.insert(RECVBUF_USERID, p_in->attireid);
	}

	STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * @brief 增加attireid的数量，如果数量大于最大值，设置为最大值，
 */
int Croute_func::user_set_attire_max_limit(DEAL_FUN_ARG)
{
	user_set_attire_max_limit_in *p_in = PRI_IN_POS;
	user_set_attire_max_limit_out out = {};
	ret = this->user_attire.update_max_limit(RECVBUF_USERID, p_in, &out);
	if (ret == SUCC)
	{
		change_log_item c_item;
		c_item.userid = RECVBUF_USERID;
		c_item.change_type = 5;
		c_item.logtime = time(NULL);
		c_item.change_value = -p_in->value;
		c_item.change_v1 = p_in->attireid;
		c_item.change_v2 = out.count;
		this->send_log.send(&c_item);
	}

	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::user_get_attire_list(DEAL_FUN_ARG)
{
	stru_count out_header; 	
	user_get_attire_list_out_item * list; 	
	user_get_attire_list_in *p_in=PRI_IN_POS;
	const char * type_str;
	DEBUG_LOG("===p_in->attireid : %u==============p_in->attiretype: %u",p_in->startattireid, p_in->attiretype);
	switch ( p_in->attiretype ){
		case 0 ://装扮
			ret=this->user_attire.get_list_by_attireid_interval(
				RECVBUF_USERID , p_in->startattireid,p_in->endattireid,
				p_in->attire_usedflag, &(out_header.count),&list );
 				STD_RETURN_WITH_STRUCT_LIST(ret, out_header ,list,out_header.count );
		case 1://小屋
			stru_noused_attirelist home_noused_attirelist;
			if (p_in->attire_usedflag==0 && p_in->startattireid+1 != p_in->endattireid ){ //未使用
				ret =this->user.home_get_noused_attirelist(RECVBUF_USERID,
						&home_noused_attirelist);
				if (ret!=SUCC) return ret;

				if (ret==SUCC&& home_noused_attirelist.count>HOME_NOUSE_ATTIRE_ITEM_MAX_EX ){
					ERROR_LOG(" __ERROR__  DB_DATA_ERR %u ",home_noused_attirelist .count);
					return USER_ATTIRE_MAX_ERR;		
				}
				uint32_t  private_size;
				private_size= sizeof(home_noused_attirelist )-
					(HOME_NOUSE_ATTIRE_ITEM_MAX_EX -home_noused_attirelist .count)*
					sizeof(home_noused_attirelist .item[0]);
				STD_RETURN_WITH_BUF(ret,&home_noused_attirelist ,private_size);

			} else if (p_in->attire_usedflag == 2 && p_in->startattireid + 1 != p_in->endattireid) {//所有
				stru_home_used_attirelist usedlist_1;
		   	stru_home_used_attirelist usedlist_2;
		   	stru_home_used_attirelist usedlist_3;	
				ret = this->user.home_get_all(RECVBUF_USERID, &home_noused_attirelist, &usedlist_1, &usedlist_2,&usedlist_3);
				if (ret != SUCC) return ret;

				for (uint32_t i = 0; i < usedlist_1.count; i++) {
					uint32_t j;
					for (j = 0; j < home_noused_attirelist.count; j++) {
						if (usedlist_1.item[i].attireid == home_noused_attirelist.item[j].attireid) {
							home_noused_attirelist.item[j].count += usedlist_1.get_attire_count(usedlist_1.item[i].attireid);
							break;
						}
					}
					if (j == home_noused_attirelist.count) {
						home_noused_attirelist.count += 1;
						if (home_noused_attirelist.count>HOME_NOUSE_ATTIRE_ITEM_MAX_EX ) {
							ERROR_LOG(" __ERROR__  DB_DATA_ERR %u ",home_noused_attirelist .count);
							return USER_ATTIRE_MAX_ERR;		
						}

						home_noused_attirelist.item[j].attireid = usedlist_1.item[i].attireid;
						home_noused_attirelist.item[j].count = usedlist_1.get_attire_count(usedlist_1.item[i].attireid);
					}
				}
				for (uint32_t i = 0; i < usedlist_2.count; i++) {
					uint32_t j;
					for (j = 0; j < home_noused_attirelist.count; j++) {
						if (usedlist_2.item[i].attireid == home_noused_attirelist.item[j].attireid) {
							home_noused_attirelist.item[j].count += usedlist_2.get_attire_count(usedlist_2.item[i].attireid);
							break;
						}
					}
					if (j == home_noused_attirelist.count) {
						home_noused_attirelist.count += 1;
						if (home_noused_attirelist.count>HOME_NOUSE_ATTIRE_ITEM_MAX_EX ) {
							ERROR_LOG(" __ERROR__  DB_DATA_ERR %u ",home_noused_attirelist .count);
							return USER_ATTIRE_MAX_ERR;		
						}

						home_noused_attirelist.item[j].attireid = usedlist_2.item[i].attireid;
						home_noused_attirelist.item[j].count = usedlist_2.get_attire_count(usedlist_2.item[i].attireid);
					}
				}
				for (uint32_t i = 0; i < usedlist_3.count; i++) {
					uint32_t j;
					for (j = 0; j < home_noused_attirelist.count; j++) {
						if (usedlist_3.item[i].attireid == home_noused_attirelist.item[j].attireid) {
							home_noused_attirelist.item[j].count += usedlist_3.get_attire_count(usedlist_3.item[i].attireid);
							break;
						}
					}
					if (j == home_noused_attirelist.count) {
						home_noused_attirelist.count += 1;
						if (home_noused_attirelist.count>HOME_NOUSE_ATTIRE_ITEM_MAX_EX ) {
							ERROR_LOG(" __ERROR__  DB_DATA_ERR %u ",home_noused_attirelist .count);
							return USER_ATTIRE_MAX_ERR;		
						}

						home_noused_attirelist.item[j].attireid = usedlist_3.item[i].attireid;
						home_noused_attirelist.item[j].count = usedlist_3.get_attire_count(usedlist_3.item[i].attireid);
					}
				}
				uint32_t  private_size;
				private_size = sizeof(home_noused_attirelist )-
								(HOME_NOUSE_ATTIRE_ITEM_MAX_EX - home_noused_attirelist.count)*
								sizeof(home_noused_attirelist .item[0]);
				STD_RETURN_WITH_BUF(ret,&home_noused_attirelist ,private_size);
			} else if ( p_in->startattireid+1 == p_in->endattireid){//只取一个
				uint32_t count;  
				uint32_t buf[3];
				ret=this->user.home_get_attire_count(RECVBUF_USERID,
						p_in->startattireid,p_in->attire_usedflag, &count  );
				if (count==0){
					buf[0]=0;
					STD_RETURN_WITH_BUF(ret,buf,4);
				}else{
					buf[0]=1;
					buf[1]=p_in->startattireid;
					buf[2]=count;
					STD_RETURN_WITH_BUF(ret,buf,12);
				}
			}else{
				return ENUM_OUT_OF_RANGE_ERR;
			}

		case 2://庄园
			type_str=JY_STR;		

			noused_homeattirelist noused_homeattirelist ; 	
			if (p_in->attire_usedflag==0 && p_in->startattireid+1 != p_in->endattireid ){ //未使用
				ret =this->user.get_noused_home_attirelist(type_str ,RECVBUF_USERID,
						&noused_homeattirelist);
				if (ret!=SUCC) return ret;

				uint32_t  private_size;
				if (ret==SUCC&& noused_homeattirelist.count>HOME_NOUSE_ATTIRE_ITEM_MAX ){
					ERROR_LOG(" __ERROR__  DB_DATA_ERR %u ",noused_homeattirelist.count);
					return USER_ATTIRE_MAX_ERR;		
				}
				private_size= sizeof(noused_homeattirelist )-
					(HOME_NOUSE_ATTIRE_ITEM_MAX -noused_homeattirelist.count)*
					sizeof(noused_homeattirelist .item[0]);

				STD_RETURN_WITH_BUF(ret,&noused_homeattirelist,private_size);

			}else if ( p_in->startattireid+1 == p_in->endattireid){//只取一个
				uint32_t count;  
				uint32_t buf[3];
				ret=this->user.get_attire_count(type_str ,RECVBUF_USERID,
						p_in->startattireid,p_in->attire_usedflag, &count  );
				if (count==0){
					//DEBUG_LOG("attireid %u null",p_in->startattireid );
					buf[0]=0;
					STD_RETURN_WITH_BUF(ret,buf,4);
				}else{
					//DEBUG_LOG("attireid %u count %u ",p_in->startattireid,count );
					buf[0]=1;
					buf[1]=p_in->startattireid;
					buf[2]=count;
					STD_RETURN_WITH_BUF(ret,buf,12);
				}
			}else{
				return ENUM_OUT_OF_RANGE_ERR;
			}
		case 3://卡片
			if ( p_in->startattireid+1 == p_in->endattireid){//只取一个
				uint32_t is_existed;  
				uint32_t buf[3];
				ret=this->user_card.check_id(RECVBUF_USERID,p_in->startattireid,&is_existed);
				if (is_existed==0){
					buf[0]=0;
					STD_RETURN_WITH_BUF(ret,buf,4);
				}else{
					buf[0]=1;
					buf[1]=p_in->startattireid;
					buf[2]=1;
					STD_RETURN_WITH_BUF(ret,buf,12);
				}
			}else{
				return ENUM_OUT_OF_RANGE_ERR;
			}
		case 4://牧场
		case 5://牧场
			if (p_in->attiretype==4){
				type_str=FARM_STR;		
			}else{
				type_str=FEEDSTUFF_STR;		
			}


			if (p_in->attire_usedflag==0 && p_in->startattireid+1 != p_in->endattireid ){ //未使用
				ret =this->user_farm.get_noused_home_attirelist(type_str ,RECVBUF_USERID,
						&noused_homeattirelist);
				if (ret!=SUCC) return ret;

				uint32_t  private_size;
				if (ret==SUCC&& noused_homeattirelist.count>HOME_NOUSE_ATTIRE_ITEM_MAX ){
					ERROR_LOG(" __ERROR__  DB_DATA_ERR %u ",noused_homeattirelist.count);
					return USER_ATTIRE_MAX_ERR;		
				}
				private_size= sizeof(noused_homeattirelist )-
					(HOME_NOUSE_ATTIRE_ITEM_MAX -noused_homeattirelist.count)*
					sizeof(noused_homeattirelist .item[0]);

				STD_RETURN_WITH_BUF(ret,&noused_homeattirelist,private_size);

			}else if ( p_in->startattireid+1 == p_in->endattireid){//只取一个
				uint32_t count;  
				uint32_t buf[3];
				ret=this->user_farm.get_attire_count(type_str ,RECVBUF_USERID,
						p_in->startattireid,p_in->attire_usedflag, &count  );
				if (count==0){
					//DEBUG_LOG("attireid %u null",p_in->startattireid );
					buf[0]=0;
					STD_RETURN_WITH_BUF(ret,buf,4);
				}else{
					//DEBUG_LOG("attireid %u count %u ",p_in->startattireid,count );
					buf[0]=1;
					buf[1]=p_in->startattireid;
					buf[2]=count;
					STD_RETURN_WITH_BUF(ret,buf,12);
				}
			}else{
				return ENUM_OUT_OF_RANGE_ERR;
			}

		case 6://吉吉乐
			ret  = this->user_swap_card.get_card_interval(RECVBUF_USERID, p_in->startattireid,
					p_in->endattireid, &list, &out_header.count);
			STD_RETURN_WITH_STRUCT_LIST(ret, out_header ,list,out_header.count);
		case 7://得到班级物品
		{
			char out[PROTO_MAX_LEN] = {	};
			uint32_t *p_count = (uint32_t *)out;
			user_get_attire_list_all_out_item *p_attire = (user_get_attire_list_all_out_item *)(out + 4);
			if (p_in->startattireid >= p_in->endattireid) {
				return VALUE_OUT_OF_RANGE_ERR;
			}
			for(uint32_t i = p_in->startattireid; i < p_in->endattireid; i++) {
				uint32_t count = 0;
				ret = this->user_class.get_attire_list_count(RECVBUF_USERID, i, p_in->attire_usedflag, &count);
				if (ret != SUCC) {
					return ret;
				}
				if (count != 0) {
					(p_attire + *p_count)->attireid = i;
					(p_attire + *p_count)->count = count;
					(*p_count)++;
				}
			}
			STD_RETURN_WITH_BUF(ret, out , 4 + (*p_count) * sizeof(user_get_attire_list_all_out_item));
		}
		case 8://得到每个汽车种类的数目 
		{
			ret = this->user_auto.get_auto_num_by_class(RECVBUF_USERID, &list, &(out_header.count),
						p_in->startattireid, p_in->endattireid);
			STD_RETURN_WITH_STRUCT_LIST(ret, out_header, list, out_header.count);
		}
		case 11:
		{
			if (p_in->startattireid + 1 != p_in->endattireid) {
				return ENUM_OUT_OF_RANGE_ERR;
			}
			uint32_t count = 0;
			ret = this->user_mdog.get_mdog(RECVBUF_USERID, p_in->startattireid, count);
			if (count > 0) {
				out_header.count = 1;
				if ((list = (user_get_attire_list_out_item*)malloc(sizeof(user_get_attire_list_out_item)))) {
					list->attireid = p_in->startattireid;
					list->count = out_header.count;
				} else {
					return SYS_ERR;
				}
				STD_RETURN_WITH_STRUCT_LIST(ret, out_header ,list,out_header.count);
			} else {
				if (ret != SUCC) {
					return ret;
				} else {
					uint32_t buff[1] = {0};
					STD_RETURN_WITH_BUF(ret, buff, 4);
				}
			}
		}
		case 99:
			{
				if(p_in->startattireid == 1351056){//商城积分特殊处理
					ret=this->user_attire.get_list_by_attireid_interval(
						RECVBUF_USERID , p_in->startattireid,p_in->endattireid,
						p_in->attire_usedflag, &(out_header.count),&list );
					STD_RETURN_WITH_STRUCT_LIST(ret, out_header ,list,out_header.count );
				}
				else{
					ret = this->user_temp_item.get_items_count(RECVBUF_USERID, p_in->startattireid,
							p_in->endattireid, &out_header.count,&list);
					STD_RETURN_WITH_STRUCT_LIST(ret, out_header ,list,out_header.count);
				}
			}
		case 32:
			ret = this->user_battle_articles.get_items_range(RECVBUF_USERID, p_in->startattireid, p_in->endattireid, 
					   p_in->attire_usedflag, &out_header.count, &list);
			STD_RETURN_WITH_STRUCT_LIST(ret, out_header ,list,out_header.count);
		case 36:
			ret = this->user_piglet_attire.get_items_range(RECVBUF_USERID, p_in->startattireid, p_in->endattireid,
                       p_in->attire_usedflag, &out_header.count, &list);
            STD_RETURN_WITH_STRUCT_LIST(ret, out_header ,list,out_header.count);

		default :
			return  ENUM_OUT_OF_RANGE_ERR;
	}
}

int Croute_func::userinfo_set_user_birthday_sex(DEAL_FUN_ARG)
{	
	userinfo_set_user_birthday_sex_in *p_in=PRI_IN_POS; 	
	ret=this->user_info_ex.update_birthday_sex(RECVBUF_USERID,p_in->birthday,p_in->sex);
	STD_RETURN(ret );
}

int Croute_func::user_set_user_online(DEAL_FUN_ARG)
{
	user_set_user_online_in *p_in=PRI_IN_POS;
	ret=this->user.update_onlinetime(RECVBUF_USERID ,p_in->onlinetime,p_in->ip );
	if (ret != SUCC) {
		return ret;
	}
	ret = this->user_ex.update_driver(RECVBUF_USERID, p_in->onlinetime);
	//进入统计日志
    {
        TUSER_ON_OFF_LINE t;
        t.flag=4;/*离开*/
        t.logtime=time(NULL);
        t.userid=RECVBUF_USERID;
        SAVE_PROTOLOG_USER_ON_OFF_LINE(t);
    }
	STD_RETURN( ret );
}

int Croute_func::userinfo_add_friend(DEAL_FUN_ARG)
{
	userinfo_add_friend_in *p_in=PRI_IN_POS;
	//ret =this->user_info.add_friend(RECVBUF_USERID, p_in->id);
	STD_RETURN(ret );
}

int Croute_func::user_add_friend(DEAL_FUN_ARG)
{
	user_add_friend_in *p_in=PRI_IN_POS;
	if (RECVBUF_USERID==p_in->id ){
		return 	ADD_FRIEND_IS_SELF_ERR;
	}
	ret =this->user_ex.add_friend(RECVBUF_USERID, p_in->id);
	STD_RETURN(ret );
}

int Croute_func::userinfo_del_friend(DEAL_FUN_ARG)
{
	userinfo_del_friend_in *p_in=PRI_IN_POS;
//	ret=this->user_info.del_id(RECVBUF_USERID , FRIEND_LIST_STR,p_in->id);
	STD_RETURN(ret);
}

int Croute_func::user_batch_del_friends(DEAL_FUN_ARG)
{

	user_batch_del_friends_in_header *p_in= PRI_IN_POS;
	user_batch_del_friends_out out = { 0 };
	CHECK_PRI_IN_LEN_WITHOUT_HEADER(
			sizeof (user_batch_del_friends_in_item) * p_in->count );
	user_batch_del_friends_in_item * p_in_item = (user_batch_del_friends_in_item*)(RCVBUF_PRIVATE_POS + sizeof(*p_in));
	uint32_t del_date = 0, del_cnt = 0;
	ret = this->user_ex.get_two_cols(RECVBUF_USERID, "del_frd_date", "del_frd_cnt", del_date, del_cnt);
	out.remainder_cnt = 20 - del_cnt;
	if(p_in->count <= 20){
		uint32_t today = get_date(time(0));
		uint32_t real_del_count = 0;
		if(del_date == today){
			if(del_cnt + p_in->count <=  20){
				DEBUG_LOG("this branche reached: %u !!!!!!!!!!!!!", p_in->count);
				ret = this->user_ex.batch_del_friends(RECVBUF_USERID, FRIEND_LIST_STR, p_in->count, p_in_item, &real_del_count);
				if(ret == SUCC){
					ret = this->user_ex.set_int_value(RECVBUF_USERID, "del_frd_cnt", del_cnt+real_del_count);
					out.state = 1;
					out.remainder_cnt = 20 - (del_cnt+real_del_count);
				}
			}//if(del_date==today)
		}
		else{
			ret = this->user_ex.batch_del_friends(RECVBUF_USERID, FRIEND_LIST_STR, p_in->count, p_in_item, &real_del_count);
			if(ret == SUCC){
				ret = this->user_ex.update_two_cols(RECVBUF_USERID,"del_frd_date", "del_frd_cnt", today, real_del_count);
				out.state = 1;
				out.remainder_cnt = 20 - real_del_count;
			}//if
		}
	}//if(p_in->count <= 20)

	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::user_del_friend(DEAL_FUN_ARG)
{
	user_del_friend_in *p_in=PRI_IN_POS;
	ret=this->user_ex.del_id(RECVBUF_USERID , FRIEND_LIST_STR,p_in->id);

	STD_RETURN(ret);
}

int Croute_func::sysarg_day_add(DEAL_FUN_ARG)
{
	sysarg_day_add_in*p_in=PRI_IN_POS;
	sysarg_day_add_out out = {0}; 
	DEBUG_LOG("maxvalue: %u, add_value: %u , type: %u", p_in->maxvalue, p_in->add_value, p_in->type);
	if (p_in->maxvalue==1) {
		//最大值是为1,只要进行插入测试
		out.count = 1;
		ret=this->usermap_day.insert(p_in->type, RECVBUF_USERID,1);
	}else{
		ret=this->usermap_day.add_cnt(p_in->type, RECVBUF_USERID, p_in->maxvalue, p_in->add_value, &out.count);
	}
	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::su_add_admin(DEAL_FUN_ARG)
{
	su_add_admin_in*p_in=PRI_IN_POS;
	ret=this-> admin.insert(p_in-> adminid,p_in->nick);
	STD_RETURN(ret);
}

int Croute_func::su_del_admin(DEAL_FUN_ARG)
{
	ret=this-> admin.del(RECVBUF_USERID);
	STD_RETURN(ret);
}

int Croute_func::userinfo_is_set_user_birthday(DEAL_FUN_ARG)
{
	ret=this-> user_info_ex.isset_birthday(RECVBUF_USERID);
	userinfo_is_set_user_birthday_out out={};

	if (ret==USER_ID_NOFIND_ERR){
		out.is_existed=0;
		ret=SUCC;
	}else if (ret==SUCC){
		out.is_existed=1;
	}
	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::sysarg_day_query(DEAL_FUN_ARG)
{
	sysarg_day_query_in*p_in=PRI_IN_POS;
	sysarg_day_query_out out={};
	ret=this->usermap_day.get_ex(p_in->type,RECVBUF_USERID,&(out.count));

	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::user_get_blackuser_list(DEAL_FUN_ARG)
{
	id_list idlist={ };
	ret=this->user_ex.get_idlist(
			RECVBUF_USERID,BLACKUSER_LIST_STR ,&idlist );
	if (ret!=SUCC) return ret;

	if (ret==SUCC&& idlist.count>ID_LIST_MAX) {
		DEBUG_LOG("ERR:DB_DATA_ERR black count %u ", idlist.count );
		return DB_DATA_ERR;
	}
	STD_RETURN_WITH_BUF(ret,(char*) &idlist,
			sizeof(idlist)-(ID_LIST_MAX-idlist.count)*sizeof(idlist.item[0]));
}

int Croute_func::userinfo_add_blackuser(DEAL_FUN_ARG)
{
	userinfo_add_blackuser_in *p_in=PRI_IN_POS;
	//ret =this->user_info.add_id( RECVBUF_USERID,
	//		BLACKUSER_LIST_STR, p_in->id);
	STD_RETURN(ret);
}

int Croute_func::user_add_blackuser(DEAL_FUN_ARG)
{
	userinfo_add_blackuser_in *p_in=PRI_IN_POS;
	if (RECVBUF_USERID==p_in->id ){
		return 	ADD_BLACKUSER_IS_SELF_ERR;
	}
	ret =this->user_ex.add_id( RECVBUF_USERID,
			BLACKUSER_LIST_STR, p_in->id,100 );
	STD_RETURN(ret);
}

int Croute_func::userinfo_del_blackuser(DEAL_FUN_ARG)
{
	userinfo_del_blackuser_in *p_in=PRI_IN_POS;
//	ret=this->user_info.del_id(RECVBUF_USERID ,
//		  	BLACKUSER_LIST_STR,p_in->id);
	STD_RETURN(ret);
}

int Croute_func::user_del_blackuser(DEAL_FUN_ARG)
{
	user_del_blackuser_in *p_in=PRI_IN_POS;
	ret=this->user_ex.del_id(RECVBUF_USERID ,
		  	BLACKUSER_LIST_STR,p_in->id);
	STD_RETURN(ret);
}

int Croute_func::user_change_user_value (DEAL_FUN_ARG)
{
	user_change_user_value_in *p_in=PRI_IN_POS;
	user_change_user_value_out out={};
	ret=this->user.change_user_value (
			RECVBUF_USERID ,p_in,&out);
	if (ret==SUCC){
		//log_change
		change_log_item c_item;
		c_item.userid=RECVBUF_USERID;
		c_item.change_type=1;
		c_item.logtime=time(NULL);
		c_item.change_value=p_in->addxiaomee;
		c_item.change_v2=p_in->reason_ex;
		c_item.change_v1=out.xiaomee;
		this->send_log.send(&c_item );
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::get_userid_by_email(DEAL_FUN_ARG)
{
	get_userid_by_email_in *p_in=PRI_IN_POS;
	get_userid_by_email_out out;
	ret=this->email.getuserid (p_in->email,&(out.map_userid));

	STD_RETURN_WITH_STRUCT(ret,out  );
}

int Croute_func::email_check_email_is_existed(DEAL_FUN_ARG)
{
	email_check_email_is_existed_in *p_in=PRI_IN_POS; 
	email_check_email_is_existed_out out={};
	userid_t db_userid;
	ret=this->email.getuserid (p_in->email,&(db_userid));
	if (ret==USER_ID_NOFIND_ERR) {
		out.is_existed=0;	
		ret=SUCC;
	}else{
		out.is_existed=1;	
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}



int Croute_func::su_get_adminid_by_nick(DEAL_FUN_ARG)
{
	su_get_adminid_by_nick_in *p_in=PRI_IN_POS;
	su_get_adminid_by_nick_out out={};
	ret=this->admin.get_adminid_by_nick(p_in->nick, &(out.id) );
	STD_RETURN_WITH_STRUCT(ret,out  );
}

int Croute_func::map_email_userid (DEAL_FUN_ARG)
{
	map_email_userid_in *p_in=PRI_IN_POS;
	map_email_userid_out out;
	out.is_succ=1;
	ret=this->email.map_email_userid(p_in->email,RECVBUF_USERID,&(out.old_map_userid));
	if (ret==EMAIL_EXISTED_ERR){
		out.is_succ=0;
		ret=SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret,out  );
}

int Croute_func::del_map_email_userid (DEAL_FUN_ARG)
{
	del_map_email_userid_in *p_in=PRI_IN_POS;
	ret=this->email.remove(p_in->email,RECVBUF_USERID );
	STD_RETURN(ret);
}

int Croute_func::email_set_email(DEAL_FUN_ARG)
{
	email_set_email_in *p_in=PRI_IN_POS;
	ret=this->email.update_email(RECVBUF_USERID,
			p_in->old_email,p_in->new_email );
	STD_RETURN(ret);
}

int Croute_func::userinfo_change_passwd(DEAL_FUN_ARG)
{
	userinfo_change_passwd_in *p_in= PRI_IN_POS;
	ret=this->user_info.change_passwd(
			RECVBUF_USERID,p_in->oldpasswd,p_in->newpasswd );

	if (ret==SUCC)
	{
		{
			//同步论坛数据
			dv_change_passwd_in t; 		
			memcpy(t.newpasswd,	p_in->newpasswd,PASSWD_LEN);
			this->send_log.dv_change_passwd(RECVBUF_USERID, &t);
		}

		{
			//同步论坛数据
			TDV_CHANGE_PASSWD t;	
			t.msg_flag=DV_CHANGE_PASSWD_CMD;
			t.sendcount=0;	
			t.userid=RECVBUF_USERID;
			memcpy(t.newpasswd,	p_in->newpasswd,PASSWD_LEN);
			this->sync_user.send((char*) &t, sizeof(t) );
		}
	}

	if (ret == SUCC) {
		passwd_change_item item;
		item.userid = RECVBUF_USERID;
		item.time = time(NULL);
		item.opt_type=1001;
		memcpy(&item.passwd, &p_in->newpasswd, PASSWD_LEN);
		this->send_log.send_passwd(&item);
	}

	STD_RETURN(ret);
}

int Croute_func::su_change_passwd(DEAL_FUN_ARG)
{
	su_change_passwd_in *p_in= PRI_IN_POS;
	ret=this->admin.change_passwd(
			RECVBUF_USERID,p_in->oldpasswd,p_in->newpasswd );
	STD_RETURN(ret);
}

int Croute_func::dv_change_passwd(DEAL_FUN_ARG)
{
	dv_change_passwd_in *p_in= PRI_IN_POS;
	char hex_passwd[33]	;
	ASC2HEX_2_lower(hex_passwd,p_in->newpasswd,PASSWD_LEN );
	ret=this-> dvuser.change_passwd(
			RECVBUF_USERID, hex_passwd);
	STD_RETURN(ret);
}
int Croute_func::dv_change_nick(DEAL_FUN_ARG)
{
	dv_change_nick_in *p_in= PRI_IN_POS;
	dv_register_in reg_item={ };

	ret=this-> dvuser.change_nick( RECVBUF_USERID, p_in->newnick);
	if(ret!=SUCC){
		char hex_passwd[33];
		ASC2HEX_2_lower(hex_passwd,reg_item.passwd,PASSWD_LEN );
		ret=this-> dvuser.insert(
				RECVBUF_USERID,hex_passwd,reg_item.sex ,p_in->newnick, reg_item.email	);
	}
	STD_RETURN(ret);
}

int Croute_func::user_set_nick(DEAL_FUN_ARG)
{
	user_set_nick_in *p_in= PRI_IN_POS;
	ret=this->user_ex.update_nick(RECVBUF_USERID, p_in->nick );
    if (ret==SUCC )
	{
		{
			//更新昵称
			//同步论坛数据
			dv_change_nick_in t;  
			memcpy(t.newnick,   p_in->nick ,NICK_LEN);
			this->send_log.dv_change_nick(RECVBUF_USERID,&t );	
		}

		{
			//同步论坛数据,更新昵称,台湾版本
			TDV_CHANGE_NICK t;  
			t.msg_flag=DV_CHANGE_NICK_CMD;
			t.sendcount=0;  
			t.userid=RECVBUF_USERID;
			memcpy(t.newnick,   p_in->nick ,NICK_LEN);
			this->sync_user.send((char*) &t, sizeof(t) );
		}
    }

	STD_RETURN(ret);
}





int Croute_func::dv_register(DEAL_FUN_ARG)
{
	dv_register_in *p_in= PRI_IN_POS;
	char hex_passwd[33]	;
	ASC2HEX_2_lower(hex_passwd,p_in-> passwd,PASSWD_LEN );
	ret=this-> dvuser.insert(
			RECVBUF_USERID,hex_passwd,p_in->sex ,p_in->nick, p_in->email   );
	//已经存在了
	if (ret!=SUCC){
		char hex_passwd[33]	;
		ASC2HEX_2_lower(hex_passwd,p_in->passwd,PASSWD_LEN );
		ret=this->dvuser.change_passwd(RECVBUF_USERID, hex_passwd );
	}
	STD_RETURN(ret);
}


int Croute_func::userinfo_change_passwd_nocheck(DEAL_FUN_ARG)
{
	stru_new_passwd *p_in= PRI_IN_POS;
	ret=this->user_info.set_flag(RECVBUF_USERID,
			FLAG1_STR ,USER_FLAG1_CHANGE_PASSWD,false);
	if (ret!=SUCC) return ret;
	ret=this->user_info.update_passwd(RECVBUF_USERID , p_in->newpasswd );
	if (ret==SUCC)
	{
		{
			//同步论坛数据
			dv_change_passwd_in t; 		
			memcpy(t.newpasswd,	p_in->newpasswd,PASSWD_LEN);
			this->send_log.dv_change_passwd(RECVBUF_USERID, &t);
		}
		{
			//同步论坛数据,台湾版本需要
			TDV_CHANGE_PASSWD t;	
			t.msg_flag=DV_CHANGE_PASSWD_CMD;
			t.sendcount=0;	
			t.userid=RECVBUF_USERID;
			memcpy(t.newpasswd,	p_in->newpasswd,PASSWD_LEN);
			this->sync_user.send((char*) &t, sizeof(t));
		}
	}
	if (ret == SUCC)
	{
		passwd_change_item item;
		item.userid = RECVBUF_USERID;
		item.opt_type=1002;
		item.time = time(NULL);
		memcpy(&item.passwd, &p_in->newpasswd, PASSWD_LEN);
		this->send_log.send_passwd(&item);
	}

	STD_RETURN(ret);
}

int Croute_func::user_set_jy_attirelist(DEAL_FUN_ARG)
{
	user_set_jy_attirelist_in_header *p_in= PRI_IN_POS;
	home_attirelist  usedlist;
	noused_homeattirelist nousedlist; 


	CHECK_PRI_IN_LEN_WITHOUT_HEADER(
		sizeof (home_attire_item)* p_in->usedcount+
		sizeof (attire_noused_item )* p_in->nousedcount);

	if (p_in->nousedcount>HOME_NOUSE_ATTIRE_ITEM_MAX){
		return USER_ATTIRE_MAX_ERR; 
	}	

	if (p_in->usedcount>HOME_ATTIRE_ITEM_MAX){
		return VALUE_OUT_OF_RANGE_ERR; 
	}

	//构造结构
	nousedlist.count=p_in->nousedcount;
	memcpy(nousedlist.item, ((char*)p_in)+sizeof(*p_in),
		sizeof(attire_noused_item)*nousedlist.count);

	usedlist.count=p_in->usedcount;
	memcpy(usedlist.item,
		(((char*)p_in)+sizeof(*p_in)+sizeof(attire_noused_item)*nousedlist.count),
		sizeof(home_attire_item)*usedlist.count);

	ret=this->user.update_homeattire_all(JY_STR,RECVBUF_USERID,
		&usedlist,&nousedlist);
	STD_RETURN (ret );
}


int Croute_func::user_set_home_attirelist(DEAL_FUN_ARG)
{
	user_set_home_attirelist_in_header *p_in= PRI_IN_POS;
	home_attirelist  usedlist;

	CHECK_PRI_IN_LEN_WITHOUT_HEADER(
		sizeof (home_attire_item)* p_in->usedcount );

	if (p_in->usedcount>=HOME_ATTIRE_ITEM_MAX){ //最多99999个
		return VALUE_OUT_OF_RANGE_ERR; 
	}

	//构造结构
	usedlist.count=p_in->usedcount;
	memcpy(usedlist.item,
		(((char*)p_in)+sizeof(*p_in)),
		sizeof(usedlist.item[0])*usedlist.count);

	ret=this->user.home_edit(RECVBUF_USERID, p_in->homeid, 
		&usedlist);
	STD_RETURN (ret );
}


int Croute_func::su_user_get_home( DEAL_FUN_ARG)
{
	su_user_get_home_in *p_in=PRI_IN_POS; 
	stru_user_get_home_out out={};
	memset( &out,0,sizeof(out));
	if (p_in->homeid==1) {//房型就在第一个小屋
		ret=this->user.home_get_used_attirelist( RECVBUF_USERID,
				p_in->homeid,&(out.attirelist) );
		if (ret!=SUCC) return ret;
		memcpy(&(out.home_type_item),&(out.attirelist.item[0]),sizeof(out.home_type_item));
	}else{
		stru_home_used_attirelist home_usedlist_1;
		ret=this->user.home_get(RECVBUF_USERID,p_in->homeid,
				&home_usedlist_1,&(out.attirelist)  );
		if (ret!=SUCC) return ret;
		memcpy(&(out.home_type_item),&(home_usedlist_1.item[0]),sizeof(out.home_type_item));
	}



	if (ret==SUCC&& out.attirelist.count >HOME_ATTIRE_ITEM_MAX){
		DEBUG_LOG("ERR:DB_DATA_ERR black count %u ", out.attirelist.count );
		return DB_DATA_ERR;
	}
	//STD_RETURN_WITH_BUF( ret, (char*) &out, 
	//sizeof(out)- sizeof(home_attire_item)*
	//(HOME_ATTIRE_ITEM_MAX-out.attirelist.count));
	STD_RETURN_WITH_BUF( ret, (char*)(&out.attirelist),4+sizeof(home_attire_item)* (out.attirelist.count));
}

int Croute_func::user_get_home( DEAL_FUN_ARG)
{
	user_get_home_in *p_in=PRI_IN_POS; 
	stru_user_get_home_out out={};
	memset( &out,0,sizeof(out));
	if (p_in->homeid==1) {//房型就在第一个小屋
		ret=this->user.home_get_used_attirelist( RECVBUF_USERID,
				p_in->homeid,&(out.attirelist) );
		if (ret!=SUCC) return ret;
		memcpy(&(out.home_type_item),&(out.attirelist.item[0]),sizeof(out.home_type_item));
		/*
		 * 万圣节小屋翻转
		 */
		{
			//uint32_t candy_count = 0; 
			//const uint32_t candy = 1351123;
			//this->user_temp_item.get_count(RECVBUF_USERID, candy, candy_count);
			//if(candy_count == 0){
				//for(uint32_t k = 0; k < out.attirelist.count; ++k){
					//out.attirelist.item[k].value[8] = rand()%359 + 1;	
				//}//for
			//}//if
		}

	}else{
		stru_home_used_attirelist home_usedlist_1;
		ret=this->user.home_get(RECVBUF_USERID,p_in->homeid,
				&home_usedlist_1,&(out.attirelist)  );
		if (ret!=SUCC) return ret;
		memcpy(&(out.home_type_item),&(home_usedlist_1.item[0]),sizeof(out.home_type_item));
	}

	if (ret==SUCC&& out.attirelist.count >HOME_ATTIRE_ITEM_MAX){
		DEBUG_LOG("ERR:DB_DATA_ERR black count %u ", out.attirelist.count );
		return DB_DATA_ERR;
	}
	STD_RETURN_WITH_BUF( ret, (char*) &out, 
			sizeof(out)- sizeof(home_attire_item)*
				(HOME_ATTIRE_ITEM_MAX-out.attirelist.count));
}


int Croute_func::user_get_jy_ex( DEAL_FUN_ARG)
{
	user_get_jy_ex_out out={};
	memset( &out,0,sizeof(out));
	ret=this->user.get_attirelist( JY_STR, RECVBUF_USERID ,&(out.attirelist) );
	if (ret!=SUCC) return ret;

	if (ret==SUCC&& out.attirelist.count >HOME_ATTIRE_ITEM_MAX) {
		DEBUG_LOG("ERR:DB_DATA_ERR black count %u ", out.attirelist.count );
		return DB_DATA_ERR;
	}
	STD_RETURN_WITH_BUF( ret, (char*) &out, 
			sizeof(out)- sizeof(home_attire_item)*
				(HOME_ATTIRE_ITEM_MAX-out.attirelist.count));
}



int Croute_func::user_get_jy( DEAL_FUN_ARG)
{
	char out[PROTO_MAX_LEN]={ };
	user_get_jy_out_header  * p_out_header=(user_get_jy_out_header*)out ;
	user_get_jy_out_item_2  * p_out_item_2;

	//得到房型 
	ret=this->user.get_hometypeid( RECVBUF_USERID, &(p_out_header->hometype_id) );
	if (ret!=SUCC){ return ret; }

 	char * p_offset=&(out[0])+sizeof(* p_out_header);
	uint32_t cpy_len;
	
	//得到家园
	home_attirelist used_jy={};
	memset( &used_jy ,0,sizeof(used_jy));
	ret=this->user.get_attirelist( JY_STR, RECVBUF_USERID ,&(used_jy));
	if (ret!=SUCC) return ret;
	p_out_header->item1_count=used_jy.count;
	cpy_len=(sizeof(used_jy.item[0])* p_out_header->item1_count) ;
	memcpy(p_offset,&(used_jy.item[0]) ,cpy_len);
	p_offset+=cpy_len ;

    uint32_t mdog = 1320001;
	uint32_t imi_mdog = 1320002;
    uint32_t end_time = 0;
	uint32_t end_imi_time =0;
    this->user_mdog.get_mdog_end_time(RECVBUF_USERID, mdog, end_time);
    this->user_mdog.get_mdog_end_time(RECVBUF_USERID, imi_mdog, end_imi_time);
	if(end_time < end_imi_time){
		mdog = imi_mdog;
		end_time = end_imi_time;
	}
    uint32_t insent_kill = 0;
    uint32_t plant_water = 0;

	//得到种子列表
	ret=this->user_jy.get_list(RECVBUF_USERID,&(p_out_header->item2_count), &p_out_item_2, 
			end_time, insent_kill, plant_water);
	if (ret!=SUCC) {
		return ret;
	}

	this->user_mdog.update_kill_water(RECVBUF_USERID, mdog, insent_kill, plant_water);

	cpy_len=(sizeof(*p_out_item_2)* p_out_header->item2_count) ;
	memcpy(p_offset,p_out_item_2,cpy_len);
	free(p_out_item_2);
	p_offset+=cpy_len;

	//返回
	STD_RETURN_WITH_BUF(ret, out , p_offset -&(out[0]));
}

int Croute_func::user_water_seed(DEAL_FUN_ARG)
{

	user_water_seed_in *p_in=PRI_IN_POS; 
	user_water_seed_out out={};
	ret=this->user_jy.get(RECVBUF_USERID, p_in->id, &out.item);
	if (ret != SUCC) { return ret; }
	if (out.item.mature_time != 0) {
		return FRUIT_IS_BAD_ERR;
	}
	ret=this->user_jy.water_seed(&out.item);
	if (ret != SUCC) { return ret; }
	ret=this->user_jy.update_seed_info(RECVBUF_USERID, &out.item);
	if (ret != SUCC) { return ret; }

	if (p_in->opt_userid!= RECVBUF_USERID ){
		//不是本人操作
		ret=this->user_ex.jy_accesslist_set_opt(RECVBUF_USERID,
				p_in->opt_userid,WATER_OPT_FLAG );
	}
	//ret = this->user_farm.add_other(RECVBUF_USERID, 2, 1, &out.exp);
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_kill_bug(DEAL_FUN_ARG)
{
	user_kill_bug_in *p_in=PRI_IN_POS; 
	user_kill_bug_out out={};
    ret=this->user_jy.get(RECVBUF_USERID, p_in->id, &out.item);
	if (ret != SUCC) { return ret; }
	ret=this->user_jy.kill_bug(&out.item);
	if (ret != SUCC) { return ret; }
	ret=this->user_jy.update_seed_info(RECVBUF_USERID, &out.item);
	if (ret != SUCC) { return ret; }
	if (p_in->opt_userid!= RECVBUF_USERID ){
		//不是本人操作
		ret=this->user_ex.jy_accesslist_set_opt(RECVBUF_USERID,
				p_in->opt_userid,KILL_BUG_OPT_FLAG );
	}
    STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_vip_mark_last_set( DEAL_FUN_ARG )
{
	user_vip_mark_last_set_in* p_in=PRI_IN_POS;
	this->user_ex.userid(RECVBUF_USERID);
	ret=this->user_ex.vip_mark_last_set(p_in->vip_mark_last);
	STD_RETURN(ret);
}

int Croute_func::user_vip_pet_level_set( DEAL_FUN_ARG )
{
	user_vip_pet_level_set_in* p_in=PRI_IN_POS;
	ret=this->user_ex.set_int_value(RECVBUF_USERID, "vip_pet_level", p_in->vip_pet_level);
	STD_RETURN(ret);
}

/*
int Croute_func::user_set_vip_flag( DEAL_FUN_ARG )
{
	this->user_ex.userid(RECVBUF_USERID);

	user_set_vip_flag_in *p_in=PRI_IN_POS;
	ret=this->user_ex.set_flag(RECVBUF_USERID, FLAG_STR,USER_VIPFLAG_VIP,bool(p_in->flag));
	ret=this->user_ex.user_vip_set_flag_no_check(*p_in);
	STD_RETURN(ret);
}
*/

/*
 * @brief 充值VIP礼包、邮件
 * @param vip_level: VIP用户本次包月次数
 */
int Croute_func::user_vip_send_gift(userid_t userid, uint32_t vip_level)
{

	{
		char buf[4096] = {0};
		char msg[1024] = {0};
		emailsys_add_email_in_header *e_in;
		e_in = (emailsys_add_email_in_header *) buf ;
		e_in->sendtime = time(NULL);
		e_in->senderid = 0;
		e_in->type = 1000439;

		user_add_attire_in st_attire_add_array[] = {
			//{0, 14179, 1, 1},//战斗力扫描仪
			{0, 1351056, 100, 999999999}, //商城积分
			{99, 1351365, 1, 999999999}, //黄金罗盘机会
			{0, 1353323, 1, 999999999}, //蟹宝宝
		};

		uint32_t vip_pet_level = 0;
		ret = this->user_ex.get_int_value(userid, "vip_pet_level", &vip_pet_level);

		if(vip_pet_level == 0 || vip_pet_level == 1){
			st_attire_add_array[1].count = 3;
		}
		else if(vip_pet_level >= 2 && vip_pet_level <= 4){
			st_attire_add_array[1].count= 4;
		}
		else if(vip_pet_level >= 5){
			st_attire_add_array[1].count= 6;
		}
		for (uint32_t i = 0; i < sizeof(st_attire_add_array) / sizeof(st_attire_add_array[0]); i++) {
			if(st_attire_add_array[i].attireid == 1351056 || st_attire_add_array[i].attireid == 1351365
					|| st_attire_add_array[i].attireid == 1353323){
				st_attire_add_array[i].count *= vip_level;
			}
			this->user_add_attire(userid, st_attire_add_array + i);
		}
/*	
		uint32_t months = 0, receive = 0;
		ret = this->user_vip_months.select(userid, 2, &months, &receive);
		if(receive == 0 && months >= 2){
			user_add_attire_in st_attire_add_arr_year[] = {
				{0, 14178, 1, 1},//天线双螺旋发型
				{0, 14180, 1, 1},//加农炮战斗服
				{0, 14181, 1, 1},//咩咩战靴
			};
			for (uint32_t i = 0; i < sizeof(st_attire_add_arr_year) / sizeof(st_attire_add_arr_year[0]); i++) {
				ret = this->user_add_attire(userid, st_attire_add_arr_year + i);
			}
			this->user_vip_months.update(userid, 0, "receive", 1);	
#ifndef TW_VER
		strcpy(e_in->sendernick, "克劳神父");
		sprintf(msg, "你获得了%u摩尔商城积分,%u次黄金罗盘机会, 一个战斗扫描仪, 一个天线双螺旋发型，一件加农炮战斗服， 一双咩咩战靴!",
				st_attire_add_array[1].count, st_attire_add_array[2].count);
#else
		strcpy(e_in->sendernick, "克勞神父");
		sprintf(msg, "你獲得了%u摩爾商城積分,%u次黃金羅盤機會, 一個戰鬥掃描儀, 一個天線雙螺旋髮型，一件加農炮戰鬥服， 一雙咩咩戰鬥靴！", 
				st_attire_add_array[1].count, st_attire_add_array[2].count);
#endif

		}
*/		
//		else{
#ifndef TW_VER
		strcpy(e_in->sendernick, "克劳神父");
		sprintf(msg, "你获得了%u摩尔商城积分,%u次黄金罗盘机会, %u个巨蟹天使种子!",
				st_attire_add_array[0].count, st_attire_add_array[1].count, st_attire_add_array[2].count);
#else
		strcpy(e_in->sendernick, "克勞神父");
		sprintf(msg, "你獲得了%u摩爾商城積分,%u次黃金羅盤機會, %u個巨蟹天使種子！", 
				st_attire_add_array[0].count, st_attire_add_array[1].count, st_attire_add_array[2].count);
#endif
//		}

		e_in->mapid = 0;
		e_in->msglen = strlen(msg);
		memcpy(buf + sizeof(*e_in), msg, e_in->msglen);
		this->cp->f_emailsys_add_email(userid, e_in);
	}//

	//从非超拉变为超拉的额外奖励,,邮件从2月10日持续到2月15日
	/*  
	uint32_t flag = 0;
	this->user_ex.get_int_value(userid, "flag", &flag);
	if((flag & 0x01) == 0){
		char buf[4096] = {0};
		char msg[1024] = {0};
		emailsys_add_email_in_header * e_in;
		e_in = (emailsys_add_email_in_header *) buf ;
		e_in->sendtime = time(NULL);
		e_in->senderid = 0;
		e_in->type = 1000331;

		user_add_attire_in st_attire_add_arr[] = {
			//{0, 14118, 1, 1},//龙宝头冠
			//{0, 14119, 1, 1},//吉祥绣袄
			//{0, 14120, 1, 1},//龙宝鞋
			{0, 1353322, 1, 99999999},//双子天使
		};
		DEBUG_LOG("=====vip_level: %u", vip_level);
		for (uint32_t i = 0; i < sizeof(st_attire_add_arr) / sizeof(st_attire_add_arr[0]); i++) {
			if(st_attire_add_arr[i].attireid == 1353322){
				st_attire_add_arr[i].count *= vip_level;
			}
			this->user_add_attire(userid, st_attire_add_arr + i);
		}
			
		//点点豆摇奖机会
		//this->user_ex.inc_months(userid, vip_level);

		#ifndef TW_VER
		strcpy(e_in->sendernick, "克劳神父");
		sprintf(msg, "你获得了一个双子天使!");
#else
		strcpy(e_in->sendernick, "克勞神父");
		sprintf(msg, "你獲得了1個雙子天使！");
#endif

		e_in->mapid = 0;
		e_in->msglen = strlen(msg);
		memcpy(buf + sizeof(*e_in), msg, e_in->msglen);
		this->cp->f_emailsys_add_email(userid, e_in);
	}
	*/
	///////////////////////////
	// 01月13日 ~ 02月08日累计包月次数达到12个月时，送奖励和发邮件
	/*  	
	{
		uint32_t months = 0, receive = 0;
		ret = this->user_vip_months.select(userid, 1, &months, &receive);
		if(receive == 0 && months >= 2){
			char buf[4096] = {0};
			char msg[1024] = {0};
			emailsys_add_email_in_header * e_in;
			e_in = (emailsys_add_email_in_header *) buf ;
			e_in->sendtime = time(NULL);
			e_in->senderid = 0;
			e_in->type = 1000296;

			user_add_attire_in st_attire_add_arr[] = {
				{0, 14178, 1, 1},//天线双螺旋发型
				{0, 14180, 1, 1},//加农炮战斗服
				{0, 14181, 1, 1},//咩咩战靴
			};
			for (uint32_t i = 0; i < sizeof(st_attire_add_arr) / sizeof(st_attire_add_arr[0]); i++) {
				ret = this->user_add_attire(userid, st_attire_add_arr + i);
			}
			this->user_vip_months.update(userid, 0, "receive", 1);	
			if(ret == SUCC){
				#ifndef TW_VER
				strcpy(e_in->sendernick, "克劳神父");
				sprintf(msg, "你获得了一个天线双螺旋发型，一件加农炮战斗服， 一双咩咩战靴， 快去看看吧!");
#else
				strcpy(e_in->sendernick, "克勞神父");
				sprintf(msg, "你獲得了一個天線雙螺旋髮型，一件加農炮戰鬥服， 一雙咩咩戰鬥靴， 快去看看吧!");
#endif

				e_in->mapid = 0;
				e_in->msglen = strlen(msg);
				memcpy(buf + sizeof(*e_in), msg, e_in->msglen);
				this->cp->f_emailsys_add_email(userid, e_in);

			}
		
		}
	}*/
	return 0;
}

/*
 * @brief 同步VIP信息
 */
int Croute_func::user_set_vip_flag( DEAL_FUN_ARG )
{
	user_set_vip_flag_in *p_in=PRI_IN_POS;
	//把userid传递到对象内部
	this->user_ex.userid(RECVBUF_USERID);
	/*if (p_in->flag)
	{
		ret = this->user_ex.set_int_value(RECVBUF_USERID, "level", p_in->level);
		if (ret != SUCC)
		{
			return ret;
		}
	}*/

	if(p_in->vip_charge_changel_last == 90){
		char buf[4096] = {0};
		char msg[1024] = {0};
		emailsys_add_email_in_header * e_in;
		e_in = (emailsys_add_email_in_header *) buf ;
		e_in->sendtime = time(NULL);
		e_in->senderid = 0;
		e_in->type = 1000433;
#ifndef TW_VER
		strcpy(e_in->sendernick, "克劳神父");
		sprintf(msg, "恭喜你在库拉生日派对活动中抽中超级拉姆特权，快带自己的拉姆去爱心教堂内找克劳神父升级为超级拉姆吧!");
#else
		strcpy(e_in->sendernick, "克勞神父");
		sprintf(msg, "恭喜你在庫拉生日派對活動中抽中超級拉姆特權，快帶自己的拉姆去愛心教堂內找克拉神父升級為超級拉姆吧！");
#endif

		e_in->mapid = 0;
		e_in->msglen = strlen(msg);
		memcpy(buf + sizeof(*e_in), msg, e_in->msglen);
		this->cp->f_emailsys_add_email(RECVBUF_USERID, e_in);
	}
	uint32_t old_level = 0;//之前包月的次数
	ret = this->user_ex.get_int_value(RECVBUF_USERID, "level", &old_level);
	DEBUG_LOG("------------user vip level: %u old level %u", p_in->level, old_level);
	//vip_charge_changel_last 18为手机VIP充值
	if (p_in->level > old_level && p_in->vip_charge_changel_last != 18) {

		//活动，01月13日 - 02月09日累计包月12个月，送奖励	
		uint32_t now = time(0);
		if( now >=  1331827201 && now <= 1334246399){
			this->user_vip_months.add(RECVBUF_USERID, 2,(p_in->level-old_level));
		}

		ret = this->user_vip_send_gift(RECVBUF_USERID, p_in->level - old_level);
	}

	ret=this->user_ex.user_vip_set_flag_no_check(*p_in);
	
	ret=this->user_ex.set_flag(RECVBUF_USERID, FLAG_STR,USER_VIPFLAG_VIP,bool(p_in->flag));
	if (ret!=SUCC) {
		return ret;
	}

	if (p_in->flag)
	{ //设置VIP 设置其曾经是VIP
		this->user_ex.set_flag(RECVBUF_USERID, FLAG_STR,USER_VIPFLAG_IS_VIP_OLD,true);
		this->user_dragon.clear_state_2(RECVBUF_USERID);
	}else{//取消VIP
		int tmpret;
		tmpret=this->user_attire.set_no_vip(RECVBUF_USERID );
		if (tmpret!=SUCC)
			ERROR_LOG(" SET_NO_VIP ATTIRE:userid:%u,ret:%d ",RECVBUF_USERID,ret );
		//tmpret=this->user_pet.set_no_vip(RECVBUF_USERID );
	//	if (tmpret!=SUCC)
	//		ERROR_LOG(" SET_NO_VIP PET:userid:%u,ret:%d ",RECVBUF_USERID,ret );
		tmpret=this->user_pet_attire.set_no_vip(RECVBUF_USERID);
		if (tmpret!=SUCC)
			ERROR_LOG(" SET_NO_VIP PET_ATTIRE:userid:%u,ret:%d ",RECVBUF_USERID,ret );
	
		uint32_t count = 0;
		uint32_t mole_exp = 0;
		uint32_t perm_count = 0;

		tmpret=this->user_dragon.get_dragon_count(RECVBUF_USERID,count);
		if(tmpret == SUCC) {
			uint32_t upgrade = 0;
			this->user_ex.get_flag(RECVBUF_USERID,"event_flag",&upgrade);
        		upgrade &= (1 << 14);
			this->user.get_field_uint32(RECVBUF_USERID,"exp",mole_exp);
			perm_count = this->user_dragon.get_perm_count(mole_exp,upgrade,0);
		
			if(perm_count < count) {
				this->user_dragon.lock_all_dragons(RECVBUF_USERID);
			}
		}
		
	}

	ret=this->user_ex.user_vip_set_flag_no_check(*p_in);

	//ret=this->user_ex.vip_start_end_time_set(*p_in);

	STD_RETURN (ret);
}

int Croute_func::user_set_flag_unused( DEAL_FUN_ARG )
{
	user_set_flag_unused_in *p_in=PRI_IN_POS;
	ret=this->user.set_flag(RECVBUF_USERID,
			VIP_FLAG_STR ,USER_FLAG_UNUSED,bool(p_in->flag));
	STD_RETURN (ret );
}

int Croute_func::user_set_flag_offline24( DEAL_FUN_ARG )
{
	user_set_flag_offline24_in *p_in=PRI_IN_POS;
	ret=this->user.set_flag(RECVBUF_USERID,
			VIP_FLAG_STR, USER_FLAG_OFFLINE24,bool(p_in->flag));
	if (bool(p_in->flag) )
		ret=this->user.update_onlinetime(RECVBUF_USERID,0,0);	
	STD_RETURN (ret );
}

int Croute_func::userinfo_set_pemail_isok(DEAL_FUN_ARG)
{
	ret=this->user_info.set_flag(RECVBUF_USERID,FLAG1_STR, USER_FLAG1_ISSET_PEMAIL,true  );
	STD_RETURN(ret);
}

int Croute_func::userinfo_set_flag_change_passwd( DEAL_FUN_ARG )
{
	userinfo_set_flag_change_passwd_in *p_in=PRI_IN_POS;
	ret=this->user_info.set_flag(RECVBUF_USERID,
			FLAG1_STR ,USER_FLAG1_CHANGE_PASSWD,bool(p_in->flag));

	STD_RETURN (ret );
}

int Croute_func::get_game_score_list(DEAL_FUN_ARG)
{
	stru_count	out_header;
	score_list_item * list; 	
	get_game_score_list_in *p_in= PRI_IN_POS;
	ret=this->game_score.get_score_list(
			p_in->gameid,&(out_header.count) ,&list );
 	STD_RETURN_WITH_STRUCT_LIST(ret, out_header ,list,out_header.count);
}

int Croute_func::user_pet_task_get_list(DEAL_FUN_ARG)
{
	stru_count	out_header;
	user_task_item * p_list; 	
	user_pet_task_get_list_in *p_in= PRI_IN_POS;
	ret=this->user_task.get(RECVBUF_USERID, p_in,
			&(out_header.count) ,&p_list  );
 	STD_RETURN_WITH_STRUCT_LIST(ret, out_header ,p_list,out_header.count);
}

int Croute_func::usermsg_get_deal_report_list(DEAL_FUN_ARG)
{
	stru_count	out_header;
	usermsg_get_deal_report_list_item * p_list; 	
	usermsg_get_deal_report_list_in *p_in= PRI_IN_POS;
	ret=this->report_deal_history.get_list(RECVBUF_USERID , p_in,
		  	&(out_header.count) ,&p_list );
 	STD_RETURN_WITH_STRUCT_LIST(ret, out_header ,p_list,out_header.count);
}


int Croute_func::su_get_admin_list(DEAL_FUN_ARG)
{
	stru_count	out_header;
	admin_item * list; 	
	su_get_admin_list_in *p_in= PRI_IN_POS;
	ret=this->admin.get_adminlist( p_in->index,&(out_header.count) ,&list );
 	STD_RETURN_WITH_STRUCT_LIST(ret, out_header ,list,out_header.count);
}

int Croute_func::set_game_score(DEAL_FUN_ARG)
{
	set_game_score_in *p_in= PRI_IN_POS;
	ret=this->game_score.update_score(
			p_in->gameid,p_in->userid,p_in->score,p_in->nick);
	STD_RETURN (ret);
}

int Croute_func::init_game_score_list(DEAL_FUN_ARG )
{
	init_game_score_list_in *p_in= PRI_IN_POS;
	ret=this->game_score.init_score_list(p_in->gameid,p_in->count);
	STD_RETURN (ret);
}

int Croute_func::game_score_set_score(DEAL_FUN_ARG )
{
	game_score_set_score_in *p_in= PRI_IN_POS;
	ret=this->game_score.change_score(p_in->gameid,
			p_in->userid,p_in->score);
	STD_RETURN (ret);
}

int Croute_func::set_serial_used (DEAL_FUN_ARG )
{
	set_serial_used_out out={};
	set_serial_used_in *p_in=PRI_IN_POS;
	ret= this->serial.set_used(p_in->serialid,
			p_in->useflag,&(out.price));
	if (ret==DB_ERR ){//table no find  
		ret=SERIAL_ID_NOFIND_ERR;			
	}
	STD_RETURN_WITH_STRUCT (ret,out);
}

int Croute_func::serial_get_info_serial_str (DEAL_FUN_ARG )
{
	serial_get_info_serial_str_out out={};
	serial_get_info_serial_str_in  *p_in=PRI_IN_POS;
	uint32_t t_useflag;
	ret= this->serial. get_info_by_serialid_str(
			p_in->serial_str,&t_useflag ,&(out.type));
	if (ret==DB_ERR ){//table no find  
		ret=SERIAL_ID_NOFIND_ERR;			
	}else if (ret==SUCC ){
		if (t_useflag!=0){//已使用过了.
			ret=SERIAL_ID_IS_USED_ERR;
		}
	}
	//进入统计...
	this->questionnaire.add_value(0, 99,get_date(time(NULL)) ,1 );
		
	STD_RETURN_WITH_STRUCT (ret,out);
}

int Croute_func::serial_set_serial_str_used (DEAL_FUN_ARG )
{
	serial_set_serial_str_used_out out={};
	serial_set_serial_str_used_in  *p_in=PRI_IN_POS;
	ret= this->serial. set_used_by_serialid_str(
			p_in->serial_str ,&(out.type));
	if (ret==DB_ERR ){//table no find  
		ret=SERIAL_ID_NOFIND_ERR;			
	}
	STD_RETURN_WITH_STRUCT (ret,out);
}

int Croute_func::set_serial_unused (DEAL_FUN_ARG )
{
	set_serial_unused_in *p_in=PRI_IN_POS;
	ret= this->serial.set_unused(p_in->serialid);
	STD_RETURN(ret);
}

int Croute_func::serial_get_noused_id(DEAL_FUN_ARG )
{
	serial_get_noused_id_in *p_in=PRI_IN_POS;
	serial_get_noused_id_out out={};
	uint64_t serialid ;
	ret= this->serial.get_noused_id( p_in->type, &serialid);
	sprintf(out.serialid ,"%"PRIu64, serialid );
	STD_RETURN_WITH_STRUCT (ret,out);
}

int Croute_func::msgboard_get_msglist(DEAL_FUN_ARG)
{
	msgboard_get_msglist_in *p_in= PRI_IN_POS;
	msgboard_get_msglist_out out={};

	ret= this->msgboard.getmsglist_lock(
			p_in->boardid ,p_in->pageid , &out);
	STD_RETURN_WITH_BUF(ret,&out,
			8 + sizeof(out.item_msgboard[0])*out.count);
}

int Croute_func::msgboard_get_list_with_flag(DEAL_FUN_ARG)
{
	msgboard_get_list_with_flag_in *p_in= PRI_IN_POS;
	stru_msgboard_item *p_item;
	stru_count out_header;

	ret= this->msgboard.getmsglist_from_db(p_in->boardid,p_in->flag,
			p_in->pageid*10, 10, &(out_header.count), &p_item  );
 	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_item,out_header.count);
}

int Croute_func::msgboard_add_msg(DEAL_FUN_ARG)
{
	msgboard_add_msg_in_header *p_in= PRI_IN_POS;
	msgboard_add_msg_out out={};

	CHECK_PRI_IN_LEN_WITHOUT_HEADER_EX(p_in->msglen,1023 );

	msg_item *p_msg_item=(msg_item *)(&p_in->msglen);
	msgboard_item_max item;
	memset(&item ,0,sizeof(item));

	item.userid=RECVBUF_USERID;

	//保证msg有'\0'结尾
	memcpy(item.msg,p_msg_item->msg, p_msg_item->itemlen);
	item.msg[p_msg_item->itemlen]='\0';

	memcpy(item.nick, p_in->nick  ,NICK_LEN );
	item.color=p_in->color;
	item.logdate=time(NULL);

	ret= this->msgboard.addmsg_lock(p_in->boardid, &item,p_msg_item->itemlen, &(out.msgid));
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_add_offline_msg(DEAL_FUN_ARG)
{
	user_add_offline_msg_in_header *p_in= PRI_IN_POS;

	//-4： /*大小包括自身4个字节*/
	CHECK_PRI_IN_LEN_WITHOUT_HEADER(p_in->msglen-4);

	ret= this->user.add_offline_msg(RECVBUF_USERID , 
			(msg_item*) p_in);
	STD_RETURN(ret);
}

int Croute_func::su_user_add_offline_msg(DEAL_FUN_ARG)
{
	su_user_add_offline_msg_in_header *p_in= PRI_IN_POS;

	CHECK_PRI_IN_LEN_WITHOUT_HEADER(p_in->msglen);
	p_in->msglen += 4;
	ret= this->user.add_offline_msg(RECVBUF_USERID , 
			(msg_item*) p_in);
	STD_RETURN(ret);
}


int Croute_func::get_register_serial(DEAL_FUN_ARG)
{
	get_register_serial_in*p_in= PRI_IN_POS;
	get_register_serial_out out={};
	ret=this->register_serial.get_userid(p_in->register_serial_id, 
			&(out.userid));
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_del_user(DEAL_FUN_ARG)
{
	ret=this->user.del(RECVBUF_USERID );
	STD_RETURN(ret);
}

int Croute_func::userinfo_del_user(DEAL_FUN_ARG)
{
	ret=this->user_info.del(RECVBUF_USERID );
	if(ret!=SUCC) return ret;
	ret=this->user_info_ex.del(RECVBUF_USERID );
	STD_RETURN(ret);
}

int Croute_func::user_get_user_pet(DEAL_FUN_ARG)
{
	user_get_user_pet_in*p_in= PRI_IN_POS;
	stru_count out_header;
	user_get_user_pet_out_item  *p_item;
	ret=this->user_pet.get( RECVBUF_USERID, 
			p_in->petid, &(out_header.count), &p_item);	
 	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_item,out_header.count);
}

int Croute_func::sysarg_get_count_list(DEAL_FUN_ARG)
{
	sysarg_get_count_list_in *p_in= PRI_IN_POS;
	stru_count out_header;
	sysarg_get_count_list_out_item *p_item;
	ret=this->sys_arg.get_value_list(p_in->start_type,p_in->end_type, 
		 	&(out_header.count), &p_item);	

 	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_item,out_header.count);
}


int Croute_func::user_del_user_pet(DEAL_FUN_ARG)
{
	user_del_user_pet_in*p_in= PRI_IN_POS;
	ret=this->user_pet.remove( RECVBUF_USERID, 
			p_in->petid);	
	if(ret!=SUCC) return ret;
	ret=this->user_task.remove_pet_task(RECVBUF_USERID, 
			p_in->petid);

	ret = this->user_pet_task.del(RECVBUF_USERID, p_in->petid);

	ret=this->user_pet_attire.remove_pet_attire(RECVBUF_USERID, 
			p_in->petid);	
	if(ret!=SUCC) return ret;
 	STD_RETURN(ret);
}

int Croute_func::user_add_user_pet(DEAL_FUN_ARG)
{
	user_add_user_pet_in*p_in= PRI_IN_POS;
	user_add_user_pet_out out={};
	ret=this->user_pet.add( RECVBUF_USERID, p_in,& (out.petid) );	
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_set_user_pet_info(DEAL_FUN_ARG)
{
	user_set_user_pet_info_in*p_in= PRI_IN_POS;
	ret=this->user_pet.set_info( RECVBUF_USERID, p_in);	
	STD_RETURN(ret);
}

int Croute_func::user_set_user_pet_all(DEAL_FUN_ARG)
{
	user_set_user_pet_all_in*p_in= PRI_IN_POS;
	ret=this->user_pet.set_all( RECVBUF_USERID, p_in);	
	STD_RETURN(ret);
}

int Croute_func::user_set_user_pet_comm(DEAL_FUN_ARG)
{
	user_set_user_pet_comm_in*p_in= PRI_IN_POS;
	ret=this->user_pet.set_comm( RECVBUF_USERID, p_in );	
	STD_RETURN(ret);
}

int Croute_func::user_set_user_pet_skill(DEAL_FUN_ARG)
{
	user_set_user_pet_skill_in *p_in= PRI_IN_POS;
	user_set_user_pet_skill_out out={};
	out.skill=p_in->skill;
	ret=this->user_pet.set_skill( RECVBUF_USERID, p_in );	
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_pet_set_skill_flag(DEAL_FUN_ARG)
{
	user_pet_set_skill_flag_in *p_in=PRI_IN_POS; 
	ret=this->user_pet.set_skill_flag( RECVBUF_USERID, p_in );
	if (ret != SUCC)
	{
		return ret;
	}
	ret = this->user_attire.reset_usedcount(RECVBUF_USERID, 1200001, 1209999);	
	ret = this->user_pet_attire.set_pet_used_attire(RECVBUF_USERID,p_in->petid,0,NULL,true);	
	STD_RETURN(ret);
}


int Croute_func::user_set_tasklist(DEAL_FUN_ARG)
{
	user_set_tasklist_in*p_in= PRI_IN_POS;
	ret=this->user.set_tasklist( RECVBUF_USERID, p_in);	
	STD_RETURN(ret );
}

int Croute_func::user_set_flag(DEAL_FUN_ARG)
{
	user_set_flag_in *p_in= PRI_IN_POS;
	ret=this->user.update_flag( RECVBUF_USERID,COMM_FLAG_STR , p_in->flag);	
	STD_RETURN(ret );
}

int Croute_func::usermsg_set_report_msg(DEAL_FUN_ARG)
{
	usermsg_set_report_msg_in*p_in= PRI_IN_POS;
	DEBUG_LOG("---------medal: %u, objuserid: %u, reason: %u --------", p_in->medal, p_in->objuserid, p_in->reason);
	ret=this->usermsg.insert(RECVBUF_USERID, 
			p_in->objuserid,p_in->reason, p_in->medal);
	STD_RETURN(ret );
}

int Croute_func::usermsg_set_del_writing(DEAL_FUN_ARG)
{
	usermsg_set_del_writing_in_header*p_in= PRI_IN_POS;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER_EX(p_in->msglen,1000 );
	msg_item * p_msg_item=(msg_item*)&(p_in->msglen);
	ret=this-> user_writing.set_del_flag(p_in->srcuserid, 
			p_in-> date, p_msg_item );
	STD_RETURN(ret );
}

int Croute_func::msgboard_set_msg_flag(DEAL_FUN_ARG)
{
	msgboard_set_msg_flag_in*p_in= PRI_IN_POS;
	ret=this->msgboard.update_flag( RECVBUF_USERID, 
			p_in->flag );
	if (ret==SUCC){
		this->msgboard.set_cache_is_inited(p_in->boardid, false);
	}	
	STD_RETURN(ret );
}

int Croute_func::msgboard_set_msg_flag_su(DEAL_FUN_ARG)
{
	msgboard_set_msg_flag_su_in*p_in= PRI_IN_POS;
	DEBUG_LOG("msgid: %u, boardid: %u, flag: %u", p_in->msgid, p_in->boardid, p_in->flag);
	ret=this->msgboard.update_flag( p_in->msgid, p_in->flag );
	if (ret==SUCC){
		this->msgboard.set_cache_is_inited(p_in->boardid, false);
	}	
	STD_RETURN(ret );
}

int Croute_func::user_set_user_pet_poslist(DEAL_FUN_ARG)
{
	user_set_user_pet_poslist_in_header *p_in= PRI_IN_POS;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(pet_pos_item));

	pet_pos_item *p_item=
		(pet_pos_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in));

	for (uint32_t i=0;i<p_in->count; i++){
		this->user_pet.set_pos(RECVBUF_USERID, p_item+i);
	}
	STD_RETURN(SUCC);
}
int Croute_func::userinfo_check_existed(DEAL_FUN_ARG)
{
	ret=this->user_info.check_existed(RECVBUF_USERID);
	STD_RETURN(ret);
}

int Croute_func::user_swap_homeattire_list(DEAL_FUN_ARG)
{
	user_swap_homeattire_list_in_header *p_in= PRI_IN_POS;
	attire_count *oldlist;  	
	attire_count_with_max *newlist;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER( 
			p_in->oldcount* sizeof (attire_count) +
			p_in->newcount*sizeof (attire_count_with_max));

	oldlist=(attire_count*)(RCVBUF_PRIVATE_POS+sizeof(*p_in) );
	newlist=( attire_count_with_max* ) (oldlist +p_in->oldcount);
	ret=this->user.home_swap_attirelist( RECVBUF_USERID, 
			p_in->oldcount,oldlist, p_in->newcount,newlist );
	STD_RETURN(ret);
}

int Croute_func::user_swap_jyattire_list(DEAL_FUN_ARG)
{
	user_swap_homeattire_list_in_header *p_in= PRI_IN_POS;
	attire_count *oldlist;  	
	attire_count_with_max *newlist;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER( 
			p_in->oldcount* sizeof (attire_count) +
			p_in->newcount*sizeof (attire_count_with_max));

	oldlist=(attire_count*)(RCVBUF_PRIVATE_POS+sizeof(*p_in) );
	newlist=( attire_count_with_max* ) (oldlist +p_in->oldcount);
	ret=this->user.swap_homeattire(JY_STR, RECVBUF_USERID, 
			p_in->oldcount,oldlist, p_in->newcount,newlist );
	STD_RETURN(ret);
}

int Croute_func::user_swap_attire_list(DEAL_FUN_ARG)
{
	user_swap_attire_list_in_header *p_in= PRI_IN_POS;
	attire_count *oldlist;  	
	attire_count_with_max *newlist;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER( 
			p_in->oldcount* sizeof (attire_count) +
			p_in->newcount*sizeof (attire_count_with_max));

	oldlist=(attire_count*)(RCVBUF_PRIVATE_POS+sizeof(*p_in) );
	newlist=( attire_count_with_max* ) (oldlist +p_in->oldcount);
	user_change_user_value_in uci; 	
	user_change_user_value_out uco; 	
	memset(&uci, 0,sizeof(uci)  );
	ret=this->user_attire.check_list( RECVBUF_USERID, 
		p_in->oldcount,oldlist, p_in->newcount,newlist ,&uci);

	if (ret==SUCC){
		uci.reason=p_in->reason;
		uci.reason_ex=p_in->reason_ex;
		ret=this->user.change_user_value( RECVBUF_USERID, &uci,  &uco );
	}
	if (ret==SUCC){

		ret=this->user_attire.swaplist( RECVBUF_USERID, 
			p_in->oldcount,oldlist, p_in->newcount,newlist );
		for (uint32_t i = 0; i < p_in->newcount; i++) {
			if(attire_id_in_pic_list(newlist[i].attireid)
				|| attire_id_is_mature_id_in_pic_list(newlist[i].attireid)
				|| attire_id_is_fruitid_in_pic_list(newlist[i].attireid))
			{
				//把装扮加入图鉴列表中，为每一个用户
				this->user_pic_book.insert(RECVBUF_USERID, newlist[i].attireid);
			}
		}
	}
	if (ret==SUCC){
		//log_change
		change_log_item c_item;
		c_item.userid=RECVBUF_USERID;
		c_item.change_type=1;
		c_item.logtime=time(NULL);
		c_item.change_value=uci.addxiaomee;
		c_item.change_v1=uco.xiaomee;
		c_item.change_v2=uci.reason_ex;
		this->send_log.send(&c_item );
	}

	STD_RETURN(ret);
}

int Croute_func::usermsg_add_writing (DEAL_FUN_ARG)
{
	usermsg_add_writing_in_header *p_in= PRI_IN_POS;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER_EX(p_in->msglen,4000);

	msg_item * p_msg_item=(msg_item*)&(p_in->msglen);
    ret=this->writing_day_count.add_count(1,RECVBUF_USERID);//1:摩尔
    if (ret==VALUE_OUT_OF_RANGE_ERR){
        return ret;
    }
		
	
	ret= this-> user_writing.insert (p_in->type, RECVBUF_USERID , p_msg_item );
	STD_RETURN(ret);
}

int Croute_func::su_add_msg_attime(DEAL_FUN_ARG)
{
	su_add_msg_attime_in_header *p_in= PRI_IN_POS;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER(p_in->msglen);

	msg_item * p_msg_item=(msg_item*)(&(p_in->msglen));
	ret= this-> msg_attime .insert ( p_in->deal_date, 
			p_in->deal_hour,p_in->deal_minute,p_in->flag,p_in->pic_id, p_msg_item );
	STD_RETURN(ret);
}

int Croute_func::su_del_msg_attime(DEAL_FUN_ARG)
{
	su_del_msg_attime_in *p_in= PRI_IN_POS;
	ret= this-> msg_attime.remove( 
		p_in->deal_date, p_in->deal_hour,p_in->deal_minute);
	STD_RETURN(ret);
}

int Croute_func::user_connect_add_child(DEAL_FUN_ARG)
{
	user_connect_add_child_in *p_in= PRI_IN_POS;
	user_connect_add_child_out out={};
	ret= this-> user_connect.add_childid(RECVBUF_USERID,p_in->childid,
		&(out.childcount));

	if (ret==USER_ID_NOFIND_ERR){
		ret=this->user_connect.init(RECVBUF_USERID,0,p_in->childid);
		out.childcount=1;
	}
	uint32_t seven7_count = 0;	
	this->user_temp_active.get_one(RECVBUF_USERID, 50, "value_1", &seven7_count);
	this->user_temp_active.add(RECVBUF_USERID, 50, seven7_count+1, 0);
	uint32_t msg_buff[2]={ RECVBUF_USERID, 1 };
	msglog(this->msglog_file, 0x0409C3DB, time(NULL), msg_buff, 8);

	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_connect_set_parent(DEAL_FUN_ARG)
{
	user_connect_set_parent_in *p_in= PRI_IN_POS;
	ret=this->user_connect.set_parentid(RECVBUF_USERID,p_in->parentid);
	if (ret==USER_ID_NOFIND_ERR){
		ret=this->user_connect.init(RECVBUF_USERID,p_in->parentid,0);
	}
	STD_RETURN(ret);
}

int Croute_func::user_pet_task_set(DEAL_FUN_ARG)
{
	user_pet_task_set_in *p_in= PRI_IN_POS;

	user_pet_task_set_out out={};
	ret=this->user_task.set_info(RECVBUF_USERID,p_in );
	if (ret==SUCC)
	{
		out.petid=p_in->petid;
		out.taskid=p_in->taskid;
	}

	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_connect_get_info(DEAL_FUN_ARG)
{
	user_connect_get_info_out out={};
	ret=this->user_connect.get_info(RECVBUF_USERID,&out);

	user_connect_get_info_other_out out_final = { 0 };
	out_final.childcount = out.childcount;
	out_final.old_childcount = out.old_childcount;
	out_final.parentid = out.parentid;

	this->user_temp_active.get_one(RECVBUF_USERID, 50, "value_1", &out_final.seven7_count);
	STD_RETURN_WITH_STRUCT(ret, out_final );
}

int Croute_func::usermsg_set_writing_report (DEAL_FUN_ARG)
{
	usermsg_set_writing_report_in_header *p_in= PRI_IN_POS;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER(p_in->msglen);
	msg_item * p_msg_item=(msg_item*)&(p_in->msglen);

	if (p_msg_item->itemlen >4) {
		ret= this->user_writing.set_report(RECVBUF_USERID,p_in->date, 
			p_in->type,p_in->flag,  p_msg_item );
	}else{
		ret= this->user_writing.set_type(RECVBUF_USERID,p_in->date, 
			p_in->type);
	}	
	STD_RETURN(ret);
}

int Croute_func::usermsg_get_report_by_date(DEAL_FUN_ARG)
{	
	usermsg_get_report_by_date_in *p_in= PRI_IN_POS;
	usermsg_get_report_by_date_out_item *p_item;
	stru_count out_header; 	
	ret=this->usermsg.get_by_date(RECVBUF_USERID, p_in , &(out_header.count) ,&p_item);
 	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_item,out_header.count);
}

int Croute_func::msgboard_getmsg_by_msgid(DEAL_FUN_ARG)
{	
	msgboard_getmsg_by_msgid_in *p_in= PRI_IN_POS;
	msgboard_getmsg_by_msgid_out out={};	
	uint32_t boardid;
	ret=this->msgboard.getmsg_by_msgid(p_in->msgid,
		&boardid,&(out));
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::sysarg_get_count(DEAL_FUN_ARG)
{	
	sysarg_get_count_in *p_in= PRI_IN_POS;
	sysarg_get_count_out out={};	
	ret=this->sys_arg.get_value(p_in->type,&(out.value));
	if (ret==KEY_NOFIND_ERR){
		out.value=0;
		ret=SUCC;
	}
	out.type=p_in->type;
	STD_RETURN_WITH_STRUCT(ret,out);
}
int Croute_func::sysarg_set_count(DEAL_FUN_ARG)
{	
	sysarg_set_count_in *p_in= PRI_IN_POS;
	ret=this->sys_arg.add_value(p_in->type,p_in->add_value);
	STD_RETURN(ret);
}

int Croute_func::usermsg_get_report_by_date_userid(DEAL_FUN_ARG)
{	
	usermsg_get_report_by_date_userid_in *p_in= PRI_IN_POS;
	usermsg_get_report_by_date_userid_out_item *p_item;
	stru_count out_header; 	
	ret=this->usermsg.get_by_date_userid(RECVBUF_USERID ,
		  	p_in ,&(out_header.count) ,&p_item);
 	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_item,out_header.count);
}

int Croute_func::usermsg_clear_by_date_userid(DEAL_FUN_ARG)
{	
	usermsg_clear_by_date_userid_in *p_in= PRI_IN_POS;
	stru_id *p_item;
	stru_count out_header; 	
	ret=this->usermsg.get_reportid_by_date_userid(RECVBUF_USERID ,
		  	p_in ,&(out_header.count) ,&p_item);
	if (ret==SUCC){
		this->usermsg.clear_by_date_userid(RECVBUF_USERID ,p_in);	
	}
 	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_item,out_header.count);
}

int Croute_func::usermsg_get_writing (DEAL_FUN_ARG)
{	
	usermsg_get_writing_in *p_in= PRI_IN_POS;
	usermsg_get_writing_out out={};
	memset(&out,0,sizeof(out));
	ret=this->user_writing.get(p_in ,&out);
	STD_RETURN_WITH_BUF(ret, &out, 
		(sizeof(out)-sizeof(out.msg) +out.msglen+out.reportlen) ); 
}

int Croute_func::usermsg_get_writing_list (DEAL_FUN_ARG)
{	
	usermsg_get_writing_list_in *p_in= PRI_IN_POS;
	stru_count	out_header;
	usermsg_get_writing_list_out_item * p_list; 	
	ret=this->user_writing.get_list(p_in, &(out_header.count),&p_list );
 	STD_RETURN_WITH_STRUCT_LIST(ret, out_header ,p_list,out_header.count);
}

int Croute_func::usermsg_get_writing_count (DEAL_FUN_ARG)
{	
	usermsg_get_writing_count_in *p_in= PRI_IN_POS;
	usermsg_get_writing_count_out out={};
	memset(&out,0,sizeof(out));
	ret=this->user_writing.get_count(p_in ,&(out.count));
	STD_RETURN_WITH_STRUCT(ret, out ); 
}

int Croute_func::su_get_msg_attime_all(DEAL_FUN_ARG)
{	
	su_get_msg_attime_all_in *p_in= PRI_IN_POS;
	su_get_msg_attime_all_out  out={};
	memset(&out,0,sizeof(out));
	ret=this->msg_attime.get(p_in ,&out);
	STD_RETURN_WITH_BUF(ret, &out,sizeof(out)-sizeof(out.msg)+out.msglen);
}

int Croute_func::su_get_msg_attime_by_date(DEAL_FUN_ARG)
{	
	su_get_msg_attime_by_date_in *p_in= PRI_IN_POS;
	su_get_msg_attime_all_out  out={};
	memset(&out,0,sizeof(out));
	ret=this->msg_attime.get_by_date(p_in,&out);
	STD_RETURN_WITH_BUF(ret, &out,sizeof(out)-sizeof(out.msg) +out.msglen); 
}

int Croute_func::msgboard_add_hot(DEAL_FUN_ARG)
{
	msgboard_add_hot_in*p_in= PRI_IN_POS;
	ret=this->msgboard.addhot( p_in->boardid, p_in-> msgid);
	STD_RETURN(ret );
}

int Croute_func::user_set_home_attire_noused(DEAL_FUN_ARG)
{
 	user_set_home_attire_noused_in *p_in= PRI_IN_POS;
	if (p_in->type==1 ) 	{
		ret=this->user.home_reduce_used_attire( RECVBUF_USERID,p_in->attireid );
	}else if(p_in->type==2) {
		ret=this->user.home_set_attire_noused(JY_STR, RECVBUF_USERID,p_in->attireid );
	}
	STD_RETURN(ret );
}

int  Croute_func::user_check_existed(DEAL_FUN_ARG)
{
	ret=this->user.check_existed(RECVBUF_USERID);
	STD_RETURN(ret );
}

int Croute_func::user_test_proto(DEAL_FUN_ARG)
{
	user_test_proto_out  out={};
	snprintf ( out.msg,sizeof(out.msg), "%s-%s", get_ip(1),version_str ) ;
	STD_RETURN_WITH_STRUCT(SUCC, out); 
}

int Croute_func::userinfo_get_info_all(DEAL_FUN_ARG)
{
	userinfo_get_info_all_out out={};
	ret=this->user_info.get_info_all(RECVBUF_USERID, &(out.info));
	ret=this->user_info_ex.get(RECVBUF_USERID, &(out.info_ex));
	STD_RETURN_WITH_STRUCT(ret, out); 
}

int Croute_func::userinfo_set_payinfo(DEAL_FUN_ARG)
{
	userinfo_set_payinfo_in *p_in=PRI_IN_POS; 
	ret=1000;
	
	if ( p_in->question[0]!='\0'){
	//	ret=this->user_info.isset_question(RECVBUF_USERID);	
	//	if (ret!=USER_QUESTION_NOSET_ERR ) return USER_QUESTION_SETED_ERR;
		ret=this->user_info.update_for_pay(RECVBUF_USERID, p_in);
	}

	if (p_in->birthday>0){
		ret=this->user_info_ex.update_for_pay(RECVBUF_USERID,p_in);
	}
	STD_RETURN(ret);
}

int Croute_func::hope_get_hope_list(DEAL_FUN_ARG)
{
	hope_get_hope_list_in *p_in= PRI_IN_POS;
	hope_get_hope_list_out_header out_header;
	hope_get_hope_list_out_item * p_list; 	
	ret=this->hope_history.get_hope_list(p_in->recv_id, &(out_header.count),&p_list );
 	STD_RETURN_WITH_STRUCT_LIST(ret, out_header ,p_list,out_header.count);
}

int Croute_func::hope_get_hope_list_by_date(DEAL_FUN_ARG)
{
	hope_get_hope_list_by_date_in *p_in= PRI_IN_POS;
	stru_count	out_header;
	hope_get_hope_by_date_out_item * p_list; 	
	ret=this->hope_history.get_hope_list_by_date(p_in->logdate, p_in->index,
			&(out_header.count), &p_list );
 	STD_RETURN_WITH_STRUCT_LIST(ret, out_header ,p_list,out_header.count);
}

int Croute_func::emailsys_add_email(DEAL_FUN_ARG)
{
	emailsys_add_email_in_header *p_in= PRI_IN_POS;
	emailsys_add_email_out out={};
	out.flag=1;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER_EX(p_in->msglen,USER_EMAIL_LEN);
	ret = this->user_ex.check_black(RECVBUF_USERID, p_in->senderid, &(out.flag));
	if (out.flag == 0 || ret != SUCC) {
		ret=this->user_email.insert(RECVBUF_USERID,
			(user_email_item_without_id*)p_in  );
	}
	out.flag=1;
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::emailsys_get_email(DEAL_FUN_ARG)
{
	emailsys_get_email_in *p_in= PRI_IN_POS;
	emailsys_get_email_out out={}; 
	uint32_t read_flag;
	ret=this-> user_email.get_email(RECVBUF_USERID,p_in->emailid,&read_flag,&out );
	if (ret==SUCC && read_flag==0 ){//成功，并且未读过
		this->user_email.set_read(RECVBUF_USERID,p_in->emailid );
	}
	STD_RETURN_WITH_BUF(ret,(char*)&out, sizeof(out)-sizeof(out.msg)+out.msglen);
}

int Croute_func::emailsys_get_emailid_list(DEAL_FUN_ARG)
{
	emailsys_get_emailid_list_out_header out_header; 
	uint32_t count;
	uint32_t *p_emailid;
	ret=this->user_email.get_emailid_list(RECVBUF_USERID,
		  	&(out_header.noread_count), &count, &p_emailid);
	if(ret==SUCC){
		out_header.read_count=count-out_header.noread_count;
	}
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_emailid, count);
}

int Croute_func::emailsys_del_email(DEAL_FUN_ARG)
{
	emailsys_del_email_in *p_in= PRI_IN_POS;
	ret=this->user_email.remove(RECVBUF_USERID,p_in->emailid);
	STD_RETURN(ret);
}
/*
 * 置邮件表中是否已经领奖标志
 */
int Croute_func::emailsys_set_is_ward(DEAL_FUN_ARG)
{
    emailsys_set_is_ward_in *p_in=PRI_IN_POS;
    ret=this->user_email.set_is_award(RECVBUF_USERID, p_in->id);
	ret = SUCC;

    STD_RETURN(ret);
}

int Croute_func::emailsys_get_email_info_list(DEAL_FUN_ARG)
{
    emailsys_get_email_info_list_out_header  out_header ={0};
    emailsys_get_email_info_list_out_item *p_out_item = 0;
    ret=this->user_email.get_email_info_list(RECVBUF_USERID, &out_header.non_read_count, &out_header.read_count,
			   &p_out_item);

	uint32_t count = out_header.non_read_count + out_header.read_count;
	ret = SUCC;

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item, count);
}

int Croute_func::user_get_flag(DEAL_FUN_ARG)
{
	user_get_flag_out out={};
	ret=this->user.get_flags(RECVBUF_USERID, &out );
	STD_RETURN_WITH_STRUCT(SUCC, out); 
}
int Croute_func::userinfo_check_question(DEAL_FUN_ARG)
{
	userinfo_check_question_in *p_in=PRI_IN_POS; 
	ret=this->user_info.check_question(RECVBUF_USERID, p_in->question, p_in->answer);
	STD_RETURN(ret);
	//log_change
	change_log_item c_item;
	c_item.userid=RECVBUF_USERID;
	c_item.change_type=2;
	c_item.logtime=time(NULL);
	c_item.change_value=3;
	c_item.change_v1=ret;
	c_item.change_v2=0;
	this->send_log.send(&c_item );
}

int Croute_func::userinfo_isset_question(DEAL_FUN_ARG)
{
	ret=this->user_info.isset_question(RECVBUF_USERID);
	STD_RETURN(ret);
}
int Croute_func::userinfo_get_security_flag(DEAL_FUN_ARG)
{
	userinfo_get_security_flag_out  out={}; 
	ret=this->user_info.get_security_flag(RECVBUF_USERID,&(out.flag) );
	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::userinfo_set_pemail_by_qa(DEAL_FUN_ARG)
{
	userinfo_set_pemail_by_qa_in *p_in=PRI_IN_POS; 
	ret=this->user_info.check_question(RECVBUF_USERID, p_in->question,p_in->answer );
	if (ret==SUCC){
		ret=this->user_info.update_pemail(RECVBUF_USERID , p_in->parent_email);
	}
	STD_RETURN(ret);
}

int Croute_func::user_get_nick_flist(DEAL_FUN_ARG)
{
	user_get_nick_flist_out out={};
	ret=this->user_ex.get_nick_fiendlist(RECVBUF_USERID ,out.nick, &(out.fiend_list));
	uint32_t  private_size;
	private_size= sizeof(out)- 
		(ID_LIST_MAX-  out.fiend_list.count) *sizeof(out.fiend_list.item[0]);
	STD_RETURN_WITH_BUF(ret,(char*)  &out , private_size );
}



int Croute_func::other_send_email(DEAL_FUN_ARG)
{
	other_send_email_in *p_in=PRI_IN_POS; 
	ret=this->send_email.send_email(RECVBUF_USERID,p_in->flag, p_in->add_level);
	STD_RETURN(ret);
}

int Croute_func::sysarg_day_clear(DEAL_FUN_ARG)
{
	ret=this->usermap_day.remove(RECVBUF_USERID);
	ret=this->month_task.remove(RECVBUF_USERID);
	STD_RETURN(ret);
}

int Croute_func::confect_change_value(DEAL_FUN_ARG)
{
	confect_change_value_in *p_in=PRI_IN_POS; 
	confect_change_value_out out={}; 
	ret=this->confect.add_count(RECVBUF_USERID,p_in, &out);
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::confect_get_value(DEAL_FUN_ARG)
{
	confect_get_value_out  out={}; 
	ret=this->confect.get_value_ex(RECVBUF_USERID , &out );
	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::confect_set_task(DEAL_FUN_ARG)
{
	confect_set_task_in *p_in=PRI_IN_POS; 
	ret=this->confect.update_task(RECVBUF_USERID,p_in->task );
	STD_RETURN(ret);
}
int Croute_func::user_home_attire_change(DEAL_FUN_ARG)
{
	user_home_attire_change_in *p_in=PRI_IN_POS; 
	//ret=this->user.home_attire_change(HOME_STR, RECVBUF_USERID,p_in );
	STD_RETURN(ret);
}

int Croute_func::msgboard_get_msglist_userid(DEAL_FUN_ARG)
{
	msgboard_get_msglist_userid_in *p_in=PRI_IN_POS; 
	msgboard_get_msglist_userid_out_header out_header;
	msgboard_get_msglist_userid_out_item  * p_list;
	ret=this->msgboard.getmsglist_by_userid(p_in->userid,p_in->boardid,p_in->pageid*6, 6,
		 &(out_header.count), &p_list );
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_list,out_header.count);
}

int Croute_func::user_set_used_homeattire(DEAL_FUN_ARG)
{
	user_set_used_homeattire_in_header *p_in=PRI_IN_POS; 
	CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_set_used_homeattire_in_item)); 

	ret=this->user.home_update_used_attirelist_with_check(RECVBUF_USERID, p_in->homeid,
		 (home_attirelist*) (&(p_in->count )) );
	STD_RETURN(ret);
}
int Croute_func::user_set_used_jyattire(DEAL_FUN_ARG)
{
	user_set_used_jyattire_in_header *p_in=PRI_IN_POS; 
	CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_set_used_jyattire_in_item)); 

	ret=this->user.update_used_homeattirelist_with_check(JY_STR, RECVBUF_USERID, 
		 (home_attirelist*) p_in );
	STD_RETURN(ret);
}

int Croute_func::msgboard_get_msg_nocheck(DEAL_FUN_ARG)
{
	msgboard_get_msg_nocheck_in *p_in=PRI_IN_POS; 
	msgboard_get_msg_nocheck_out  out={}; 
	ret=this->msgboard.getmsg_by_msgid_nocheckflag(p_in->msgid, &out);
	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::emailsys_get_email_msg(DEAL_FUN_ARG)
{
	emailsys_get_email_msg_out out={}; 
	ret=this->user_email.get_unread_count(RECVBUF_USERID, &(out.email_unread) );
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::userinfo_sync_dv(DEAL_FUN_ARG)
{
	user_info_item info;	
	ret=this->user_info.get_info_all(RECVBUF_USERID,&info);
	if (ret==SUCC)
	{
		{
			//同步论坛注册数据
			dv_register_in t={};
			memcpy(t.passwd,info.passwd,PASSWD_LEN);
			this->send_log.dv_register(RECVBUF_USERID,&t);
		}

		{
			//同步论坛注册数据，台湾版本需要
			TDV_REGISTER t={};	
			t.msg_flag=DV_REGISTER_CMD;
			t.sendcount=0;	
			t.userid=RECVBUF_USERID;
			t.sex=0;
			memcpy(t.passwd,info.passwd,PASSWD_LEN);
			//memcpy(t.nick,info. nick,NICK_LEN);
			this->sync_user.send((char*) &t, sizeof(t));
		}

	}
	
	STD_RETURN(ret);
}

int Croute_func::roominfo_get_hot(DEAL_FUN_ARG)
{
	roominfo_get_hot_out out={}; 
	ret=this->roominfo.get_hot(RECVBUF_USERID,&out);
	if (ret==USER_ID_NOFIND_ERR)  {

		this->roominfo.insert(RECVBUF_USERID);
		ret=this->roominfo.get_hot(RECVBUF_USERID,&out);
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::roominfo_vote_room(DEAL_FUN_ARG)
{
	roominfo_vote_room_in *p_in=PRI_IN_POS; 
	ret=this->roominfo.vote_room(RECVBUF_USERID,p_in);
	STD_RETURN(ret);
}

int Croute_func::roominfo_pug_add(DEAL_FUN_ARG)
{
	roominfo_pug_add_in *p_in=PRI_IN_POS; 
	ret=this->roominfo.add_vote( RECVBUF_USERID, STR_ROOM_PUGLIST, p_in );
	STD_RETURN(ret);
}

int Croute_func::roominfo_box_add(DEAL_FUN_ARG)
{
	roominfo_box_add_in *p_in=PRI_IN_POS; 
	ret=this->roominfo.add_vote( RECVBUF_USERID,STR_ROOM_PUGLIST , p_in );
	STD_RETURN(ret);
}



int Croute_func::roominfo_pug_list(DEAL_FUN_ARG)
{
	roominfo_pug_list_out out={};
	ret=this->roominfo.get_vote_list(RECVBUF_USERID , STR_ROOM_PUGLIST,&out  );
	STD_RETURN_WITH_BUF(ret,(char*) &out,
			sizeof(out)-(50-out.count)*sizeof(out.item[0]));
}

int Croute_func::roominfo_init_user(DEAL_FUN_ARG)
{
	ret=this->roominfo.insert(RECVBUF_USERID );
	STD_RETURN(ret);
}

int Croute_func::confect_set_value(DEAL_FUN_ARG)
{
	confect_set_value_in *p_in=PRI_IN_POS; 
	ret=this->confect.update_count_all(RECVBUF_USERID,p_in);
	STD_RETURN(ret);
}
int Croute_func::roominfo_init_mud(DEAL_FUN_ARG)
{
	ret=this->roominfo.init_mud(RECVBUF_USERID );
	STD_RETURN(ret);
}
int Croute_func::emailsys_clean_email(DEAL_FUN_ARG)
{
	ret=this->user_email.remove_by_userid(RECVBUF_USERID);
	STD_RETURN(ret);
}

int Croute_func::tempgs_get_value(DEAL_FUN_ARG)
{
	tempgs_get_value_out out={};
	ret=this->tempgs.get_value_ex(RECVBUF_USERID,&out );
	STD_RETURN_WITH_STRUCT(ret,out);
}
int Croute_func::tempgs_set_count(DEAL_FUN_ARG)
{
	ret=this->tempgs.add_count(RECVBUF_USERID);
	STD_RETURN(ret);
}
int Croute_func::tempgs_set_task(DEAL_FUN_ARG)
{
	tempgs_set_task_in *p_in=PRI_IN_POS; 
	ret=this->tempgs.update_task(RECVBUF_USERID , p_in->task);
	STD_RETURN(ret);
}
int Croute_func::sysarg_add_questionnaire(DEAL_FUN_ARG)
{
	sysarg_add_questionnaire_in_header *p_in=PRI_IN_POS;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER(
			(p_in->count)*sizeof(sysarg_add_questionnaire_in_item));
	sysarg_add_questionnaire_in_item * p_in_item= 
		(sysarg_add_questionnaire_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in));
	uint32_t i;
	uint32_t qid;
	uint32_t value;
	for (i=0;i<p_in->count;i++ ){
		qid=(p_in_item+i )->questionnaireid;
		value=(p_in_item+i )->value;
		
		for (uint32_t j = 0; j < sizeof(uint32_t) * 8; ++j) {
			if ((value & (1<<j)) > 0) {
				this->questionnaire.add_value(p_in->type,qid, j+1, 1);
			}
		}
		/* 
		if ((value &0x01)>0) this->questionnaire.add_value(qid,1,1 );
		if ((value &0x02)>0) this->questionnaire.add_value(qid,2,1 );				
		if ((value &0x04)>0) this->questionnaire.add_value(qid,3,1 );				
		if ((value &0x08)>0) this->questionnaire.add_value(qid,4,1 );		
		*/
	}
	STD_RETURN(SUCC);
}
int Croute_func::groupmain_gen_groupid(DEAL_FUN_ARG)
{
	groupmain_gen_groupid_out out={};
	ret=this->group_main.insert(&(out.groupid));
	STD_RETURN_WITH_STRUCT(ret,out);
}
int Croute_func::group_add_group(DEAL_FUN_ARG)
{
	group_add_group_in *p_in=PRI_IN_POS; 
	group_item_without_id item={ }; 
	memcpy(&item,p_in,sizeof(*p_in) );
	item.membercount=1;
	item.memberlist[0]=item.groupownerid;
	ret=this->group.insert(RECVBUF_GROUPID,&item);
	STD_RETURN(ret);
}
int Croute_func::group_add_member(DEAL_FUN_ARG)
{
	group_add_member_in *p_in=PRI_IN_POS; 
	group_add_member_out out={};

	ret=this->group.add_member(RECVBUF_GROUPID,p_in->groupownerid,
			p_in->memberid,&out );
	uint32_t  private_size;
	private_size=sizeof(out)-sizeof(out.memberlist)
		+sizeof(out.memberlist[0])*out.membercount ;
	STD_RETURN_WITH_BUF(ret,(char*)&out , private_size );
}
int Croute_func::group_del_member(DEAL_FUN_ARG)
{
	group_del_member_in *p_in=PRI_IN_POS; 
	group_del_member_out out={};
	ret=this->group.del_member(RECVBUF_GROUPID,p_in->groupownerid,
			p_in->memberid,&out );
	uint32_t  private_size;
	private_size=sizeof(out)-sizeof(out.memberlist)
		+sizeof(out.memberlist[0])*out.membercount ;
	STD_RETURN_WITH_BUF(ret,(char*)&out , private_size );
}
int Croute_func::group_set_msg(DEAL_FUN_ARG)
{
	group_set_msg_in *p_in=PRI_IN_POS; 
	ret=this->group.set_msg(RECVBUF_GROUPID, p_in );
	STD_RETURN(ret);
}
int Croute_func::group_get_info(DEAL_FUN_ARG)
{
	group_get_info_out out={};
	ret=this->group.get(RECVBUF_GROUPID,&out );

	uint32_t  private_size;
	private_size=sizeof(out)-sizeof(out.memberlist)
		+sizeof(out.memberlist[0])*out.membercount ;
	STD_RETURN_WITH_BUF(ret,(char*)&out , private_size );
}

int Croute_func::user_get_group(DEAL_FUN_ARG)
{
	user_get_group_out out={};
	creategroupid_list createlist={}; 	
	group_list  list={ };
	out.count=0;

	ret=this->user_group.get_grouplist(RECVBUF_USERID,&createlist, &list);
	if (ret!=SUCC) return ret;

	out.count=createlist.count+list.count;

	if(out.count > (sizeof(out.groupidlist)/sizeof(out.groupidlist[0]) )){
		DEBUG_LOG("ERR===max count:%u",out.count );
		//数据有误
		return  DB_ERR;  
	}
		
	//复制创建列表
	if (createlist.count>0 && createlist.count<=CREATE_GROUP_MAX ){
		memcpy( &(out.groupidlist[0]),&(createlist.creategroupid[0])  ,
					sizeof(out.groupidlist[0])*createlist.count );
	}else{
		//DEBUG_LOG("ERR===count:%u",createlist.count);
	}
	//复制加入列表
	if (list.count>0 && list.count<=GROUP_LIST_LEN){
		memcpy( &(out.groupidlist[0+createlist.count]),&(list.groupidlist[0])  ,
					sizeof(out.groupidlist[0])*list.count);
	}


	uint32_t  private_size;
	private_size=sizeof(out)-sizeof(out.groupidlist)
		+sizeof(out.groupidlist[0])*out.count;

	STD_RETURN_WITH_BUF(ret,(char*)&out , private_size );
}


int Croute_func::userinfo_get_group(DEAL_FUN_ARG)
{
	userinfo_get_group_out out={};
	creategroupid_list createlist={}; 	
	group_list  list={ };
	out.count=0;

	ret=this->user_group.get_grouplist(RECVBUF_USERID,&createlist, &list);
	if (ret!=SUCC) return ret;

	out.count=createlist.count+list.count;

	if(out.count > (sizeof(out.groupidlist)/sizeof(out.groupidlist[0]) )){
		DEBUG_LOG("ERR===max count:%u",out.count );
		//数据有误
		return  DB_ERR;  
	}
		
	//复制创建列表
	if (createlist.count>0 && createlist.count<=CREATE_GROUP_MAX ){
		memcpy( &(out.groupidlist[0]),&(createlist.creategroupid[0])  ,
					sizeof(out.groupidlist[0])*createlist.count );
	}else{
		//DEBUG_LOG("ERR===count:%u",createlist.count);
	}
	//复制加入列表
	if (list.count>0 && list.count<=GROUP_LIST_LEN){
		memcpy( &(out.groupidlist[0+createlist.count]),&(list.groupidlist[0])  ,
					sizeof(out.groupidlist[0])*list.count);
	}


	uint32_t  private_size;
	private_size=sizeof(out)-sizeof(out.groupidlist)
		+sizeof(out.groupidlist[0])*out.count;

	STD_RETURN_WITH_BUF(ret,(char*)&out , private_size );
}

int Croute_func::user_join_group(DEAL_FUN_ARG)
{
	user_join_group_in *p_in=PRI_IN_POS; 
	if(p_in->is_add_group==0){
		ret=this->user_group.jion_group(RECVBUF_USERID,p_in->groupid);
	}else{
		ret=this->user_group.add_group(RECVBUF_USERID,p_in->groupid);
	}
	STD_RETURN(ret);
}



int Croute_func::userinfo_leave_group(DEAL_FUN_ARG)
{
	userinfo_leave_group_in *p_in=PRI_IN_POS; 
	ret=this->user_group.del_group(RECVBUF_USERID,p_in->groupid );
	STD_RETURN(ret);
}

int Croute_func::user_leave_group(DEAL_FUN_ARG)
{
	user_leave_group_in *p_in=PRI_IN_POS; 
	ret=this->user_group.del_group(RECVBUF_USERID,p_in->groupid );
	STD_RETURN(ret);
}


int Croute_func::group_del_group(DEAL_FUN_ARG)
{
	group_del_group_in *p_in=PRI_IN_POS; 
	group_del_group_out out; 

	uint32_t db_groupownerid;

	ret=this->group.get_member( RECVBUF_GROUPID , &out,& db_groupownerid);
	if(ret!=SUCC) return ret;

	ret=this->group.del(RECVBUF_GROUPID,p_in->groupownerid);

	uint32_t  private_size;
	private_size=sizeof(out)-sizeof(out.memberlist)
		+sizeof(out.memberlist[0])*out.membercount ;
	STD_RETURN_WITH_BUF(ret,(char*)&out , private_size );
}

int Croute_func::user_check_friend_existed(DEAL_FUN_ARG)
{
	user_check_friend_existed_in *p_in=PRI_IN_POS; 
	user_check_friend_existed_out out={};
	ret=this->user_ex.check_friend(RECVBUF_USERID,p_in->friendid,&(out.is_existed));
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::group_check_group(DEAL_FUN_ARG)
{
	group_check_group_out out={};
	ret=this->group.id_is_existed(RECVBUF_GROUPID,(bool*)&(out.is_existed));
	STD_RETURN_WITH_STRUCT(ret,out);
}


int Croute_func::userinfo_add_group(DEAL_FUN_ARG)
{
	userinfo_add_group_in *p_in=PRI_IN_POS; 
	ret=this->user_group.add_group(RECVBUF_USERID,p_in->groupid);
	STD_RETURN(ret);
}
int Croute_func::userinfo_del_group(DEAL_FUN_ARG)
{
	userinfo_del_group_in *p_in=PRI_IN_POS; 
	ret=this->user_group.del_group(RECVBUF_USERID,p_in->groupid);
	STD_RETURN(ret);
}

int Croute_func::user_del_group(DEAL_FUN_ARG)
{
	user_del_group_in *p_in=PRI_IN_POS; 
	ret=this->user_group.del_group(RECVBUF_USERID,p_in->groupid);
	STD_RETURN(ret);
}

int Croute_func::group_get_ownerid(DEAL_FUN_ARG)
{
	group_get_ownerid_out out={};
	ret=this->group.get_ownerid(RECVBUF_GROUPID, &(out.groupownerid) );
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::group_get_memberlist(DEAL_FUN_ARG)
{
	group_get_memberlist_out out={};
	userid_t ownerid;
	ret=this->group.get_member(RECVBUF_GROUPID,&out,&ownerid );

	uint32_t  private_size;
	private_size=sizeof(out)-sizeof(out.memberlist)
		+sizeof(out.memberlist[0])*out.membercount ;
	STD_RETURN_WITH_BUF(ret,(char*)&out , private_size );
}

int Croute_func::mms_get_info(DEAL_FUN_ARG)
{
	mms_get_info_out out={};
	ret=this->mms.get_mms( RECVBUF_USERID,&out );
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::mms_opt(DEAL_FUN_ARG)
{
	mms_opt_in *p_in=PRI_IN_POS; 
	ret=this->mms.mms_opt(RECVBUF_USERID,p_in->mms_type, &(p_in->opt_item) );
	//返回特殊的返回值
	if (p_in->mms_type==2 && ret==MMS_OPT_DAY_COUNT_MAX_ERR ){
		return GUIDE_OPT_DAY_COUNT_MAX_ERR;
	}

	mms_opt_out out={};
	mms_get_info_by_type_in type_in;
	type_in.mms_type=p_in->mms_type;

	ret=this->mms.get_value_by_type(RECVBUF_USERID,&type_in,&out );

	STD_RETURN_WITH_STRUCT(ret,out );
}
int Croute_func::mms_get_optlist(DEAL_FUN_ARG)
{
	mms_get_optlist_in *p_in=PRI_IN_POS; 
	mms_get_optlist_out out;
	uint32_t db_opt_time,db_opt_count;
	ret=this->mms.get_opt_list(p_in->mms_type,
			RECVBUF_USERID,&db_opt_time,& db_opt_count,&out  );

	uint32_t  private_size;
	private_size=sizeof(out)-sizeof(out.item)
		+sizeof(out.item[0])*out.count;
	STD_RETURN_WITH_BUF(ret,(char*)&out , private_size );
}
int Croute_func::mms_pick_one_fruit(DEAL_FUN_ARG)
{
	ret=this->mms.mms_gen_one_fruit(RECVBUF_USERID );
	STD_RETURN(ret);
}

int Croute_func::mms_get_type_list(DEAL_FUN_ARG)
{
	mms_get_type_list_out_header  out_header;
	mms_get_type_list_out_item *p_list;
	ret=this->mms.get_list(RECVBUF_USERID,
			&(out_header.count) ,&p_list  );
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_list,out_header.count);
}
int Croute_func::mms_get_type_list_ex(DEAL_FUN_ARG)
{
	mms_get_type_list_ex_out_header  out_header;
	mms_get_type_list_ex_out_item *p_list;
	ret=this->mms.get_list_ex(RECVBUF_USERID,
			&(out_header.count) ,&p_list  );
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_list,out_header.count);
}
int Croute_func::roominfo_del_mud(DEAL_FUN_ARG)
{
	ret=this->roominfo.del_mud(RECVBUF_USERID );
	STD_RETURN(ret);
}

//int Croute_func::mms_set_water_list(DEAL_FUN_ARG)
//{
//	mms_set_water_list_in *p_in=PRI_IN_POS; 
//	ret=this->mms.set_water_list(RECVBUF_USERID, p_in->type, p_in->userid);
//	STD_RETURN(ret);

//}



int Croute_func::roommsg_add_msg(DEAL_FUN_ARG)
{
    roommsg_add_msg_in *p_in=PRI_IN_POS; 
    ret=this->roommsg.add_msg(RECVBUF_USERID, p_in);
    STD_RETURN(ret);
}

int Croute_func::roommsg_show_msg(DEAL_FUN_ARG)
{
    roommsg_show_msg_in *p_in=PRI_IN_POS;
    ret=this->roommsg.show_msg(RECVBUF_USERID, p_in);
    STD_RETURN(ret);
}

int Croute_func::roommsg_list_msg(DEAL_FUN_ARG)
{
    roommsg_list_msg_in *p_in=PRI_IN_POS;
    roommsg_list_msg_out_header  out_header;
    roommsg_list_msg_out_item *p_out_item;
    ret=this->roommsg.list_msg(RECVBUF_USERID, p_in, &out_header.msg_total, &out_header.msg_count,&p_out_item);
    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.msg_count);
}

int Croute_func::roommsg_del_msg(DEAL_FUN_ARG)
{
    roommsg_del_msg_in *p_in=PRI_IN_POS;
    ret=this->roommsg.del_msg(RECVBUF_USERID, p_in);
    STD_RETURN(ret);
}

int Croute_func::roommsg_res_msg(DEAL_FUN_ARG)
{
    roommsg_res_msg_in *p_in=PRI_IN_POS;
    ret=this->roommsg.res_msg(RECVBUF_USERID, p_in);
    STD_RETURN(ret);
}
int Croute_func::mms_set_value(DEAL_FUN_ARG)
{
	mms_set_value_in *p_in=PRI_IN_POS; 
	ret=this->mms.set_value(RECVBUF_USERID, p_in );
	STD_RETURN(ret);
}
int Croute_func::roominfo_set_info(DEAL_FUN_ARG)
{
	roominfo_set_info_in *p_in=PRI_IN_POS; 
	ret=this->roominfo.set_value(RECVBUF_USERID, p_in );
	STD_RETURN(ret);
}

int Croute_func::user_get_type_item_list(DEAL_FUN_ARG)
{
	user_get_type_item_list_in_header *p_in = PRI_IN_POS;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count) * sizeof(user_get_type_item_list_in_item));
	user_get_type_item_list_in_item * p_in_item = (user_get_type_item_list_in_item*)(RCVBUF_PRIVATE_POS + sizeof(*p_in)) ;
	char out[PROTO_MAX_LEN] = {0};
	user_get_type_item_list_out_header *p_out_header = (user_get_type_item_list_out_header*)out;
//	user_get_type_item_list_out_item *p_out_item = NULL;
	
	char *p_offset = out + sizeof(*p_out_header);
	attire_count *list = NULL;
	for (uint32_t i = 0; i < p_in->count; i++) {
		uint32_t itemid = (p_in_item + i)->itemid;
		uint32_t type = (p_in_item + i)->type;
		uint32_t out_count = 0;
		if (itemid == 1351056) {
			type = 99;
		}
		switch (type) {
		case 0://是装扮
			ret = this->user_attire.get_all_list_by_attireid_interval(RECVBUF_USERID, itemid, itemid + 1,
							p_in->flag, &out_count, &list);
			break;
		case 1://是小屋
			ret = this->user.home_get_attire_count(RECVBUF_USERID, itemid, p_in->flag, &out_count);
			break;
		case 2://家园
			ret = this->user.get_attire_count(JY_STR, RECVBUF_USERID, itemid, p_in->flag, &out_count);
			break;
		case 3://卡片
			ret = this->user_card.check_id(RECVBUF_USERID, itemid, &out_count);
			break;
		case 4://牧场
			ret = this->user_farm.get_attire_count(FARM_STR, RECVBUF_USERID, itemid, p_in->flag, &out_count);
			break;
		case 5://牧场
			ret = this->user_farm.get_attire_count(FEEDSTUFF_STR, RECVBUF_USERID, itemid, p_in->flag, &out_count);
			break;
		case 6://吉吉乐
			ret = this->user_swap_card.get_card_interval(RECVBUF_USERID, itemid, itemid + 1, &list, &out_count);
			break;
		case 7://班级物品
			ret = this->user_class.get_attire_list_count(RECVBUF_USERID, itemid, p_in->flag, &out_count);
			break;
		case 8://得到每个汽车种类的数目 
			ret = this->user_auto.get_auto_num_by_class(RECVBUF_USERID, &list, &out_count, itemid, itemid + 1);
			break;
		case 11://机器狗
			ret = this->user_mdog.get_mdog(RECVBUF_USERID, itemid, out_count);
			break;
		case 99://临时物品
			ret = this->user_temp_item.get_items_count(RECVBUF_USERID, itemid, itemid + 1, &out_count, &list);
			break;
		case 32://战斗物品
			ret = this->user_battle_articles.get_items_range(RECVBUF_USERID, itemid, itemid + 1,
							p_in->flag, &out_count, &list);
			break;
		case 36://猪仔馆物品
			ret = this->user_piglet_attire.get_items_range(RECVBUF_USERID, itemid, itemid+1, p_in->flag, &out_count, &list);
			break;
		case 110: //拉姆装扮
			ret = this->user_pet_attire.get_pet_items(RECVBUF_USERID, itemid, itemid+1, &out_count, &list);
			break;
		default:
			break;
		}
			
		if (type == 0 || type == 6 || type == 8 || type == 99 || type == 32 || type == 36 || type == 110) {
			if (out_count == 0) {
				free(list);
				list = NULL;
			}
		} else {
			if (out_count > 0) {
				if ((list = (attire_count*)malloc(sizeof(attire_count)))) {
					list->attireid = itemid; 
					list->count = out_count;
				} else {
					return SYS_ERR;
				}
			} 
		}
		
		if (list != NULL) {
			p_out_header->count += 1;
			memcpy(p_offset, (char*)list, sizeof(*list));
			p_offset += sizeof(*list);

			free(list);
			list = NULL;
		}
	}

	DEBUG_LOG("------------list count: all_count[%u]", p_out_header->count);
	ret = SUCC;
	STD_RETURN_WITH_BUF(ret, out, p_offset - out);
}

int Croute_func::user_check_attirelist(DEAL_FUN_ARG)
{
	user_check_attirelist_in_header *p_in=PRI_IN_POS;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_check_attirelist_in_item));
	id_list *p_idlist=(id_list*)(PRI_IN_POS);
	user_check_attirelist_out_header  out_header;
	user_check_attirelist_out_item *p_out_item;
	ret=this->user_attire.get_list_by_idlist(RECVBUF_USERID,p_idlist,&(out_header.count),&p_out_item  );
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::user_set_group_flag(DEAL_FUN_ARG)
{
	userinfo_set_group_flag_in *p_in=PRI_IN_POS; 
	ret=this->user_group.set_group_flag(RECVBUF_USERID,p_in );
	STD_RETURN(ret);
}

int Croute_func::user_set_birthday(DEAL_FUN_ARG)
{
	user_set_birthday_in *p_in=PRI_IN_POS; 
	ret=this->user.set_birthday(RECVBUF_USERID,p_in->birthday );
	STD_RETURN(ret);
}
int Croute_func::user_isset_birthday(DEAL_FUN_ARG)
{
	user_isset_birthday_out out;
	ret=this->user.isset_birthday(RECVBUF_USERID, &out );
	STD_RETURN_WITH_STRUCT(ret,out);
}
int Croute_func::userinfo_check_paypasswd(DEAL_FUN_ARG)
{
	userinfo_check_paypasswd_in *p_in=PRI_IN_POS; 
	ret=this->user_info.user_check_paypasswd(RECVBUF_USERID,p_in->paypasswd  );
	STD_RETURN(ret);
}

int Croute_func::userinfo_set_paypasswd(DEAL_FUN_ARG)
{
	userinfo_set_paypasswd_in *p_in=PRI_IN_POS; 
	ret=this->user_info.set_paypasswd(RECVBUF_USERID,p_in->paypasswd  );
	if (ret == SUCC) {
		passwd_change_item item;
		item.userid = RECVBUF_USERID;
		item.opt_type=2001;
		item.time = time(NULL);
		memcpy(&item.passwd, &p_in->paypasswd, PASSWD_LEN);
		this->send_log.send_passwd(&item);
	}
	STD_RETURN(ret);
}

int Croute_func::userinfo_isset_paypasswd(DEAL_FUN_ARG)
{
	userinfo_isset_paypasswd_out out={};
	ret=this->user_info.check_flag(RECVBUF_USERID , FLAG1_STR, 
			USER_FLAG1_ISSET_PAYPASSWD, (bool*)(&out.is_seted));	
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::userinfo_set_qa(DEAL_FUN_ARG)
{
	userinfo_set_qa_in *p_in=PRI_IN_POS; 
	ret=this->user_info.update_qa(RECVBUF_USERID,p_in );
	STD_RETURN(ret);
}

int Croute_func::christmas_add_msg(DEAL_FUN_ARG)
{
	christmas_add_msg_in *p_in=PRI_IN_POS; 
	ret=this->christmas.add(RECVBUF_USERID,p_in );
	STD_RETURN(ret);
}

int Croute_func::christmas_get_msg(DEAL_FUN_ARG)
{
	christmas_get_msg_out out={};
	ret=this->christmas.get_msg(RECVBUF_USERID,&out );
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::christmas_is_get_msg(DEAL_FUN_ARG)
{
	christmas_is_get_msg_out out={};
	ret=this->christmas.is_get_msg(RECVBUF_USERID, &out );
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::christmas_is_add_msg(DEAL_FUN_ARG)
{
	christmas_is_add_msg_out out={};
	bool existed;
	ret=this->christmas.id_is_existed(RECVBUF_USERID,&existed );
	if (existed){
		out.is_seted=1;
	}else{
		out.is_seted=0;
	}	
	STD_RETURN_WITH_STRUCT(ret,out);
}
int Croute_func::userinfo_clean_paypasswd(DEAL_FUN_ARG)
{
	char paypasswd[PASSWD_LEN]={};
	//paypasswd空
	ret=this->user_info.set_paypasswd(RECVBUF_USERID, paypasswd );


	//标志位置清空
	this->user_info.set_flag(RECVBUF_USERID,FLAG1_STR,USER_FLAG1_ISSET_PAYPASSWD ,false );
	STD_RETURN(ret);
}

int Croute_func::userinfo_get_question(DEAL_FUN_ARG)
{
	userinfo_get_question_out out={};
	ret=this->user_info.get_question(RECVBUF_USERID,out.question);
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::mms_get_info_by_type(DEAL_FUN_ARG)
{
	mms_get_info_by_type_in *p_in=PRI_IN_POS; 
	mms_get_info_by_type_out out={};
	ret=this->mms.get_value_by_type(RECVBUF_USERID,p_in,&out );
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::passwd_add_change(DEAL_FUN_ARG)
{
	passwd_add_change_in *p_in=PRI_IN_POS; 
	ret=this->change_passwd.insert(RECVBUF_USERID, p_in);
	STD_RETURN(ret);
}



int Croute_func::log_add_chat(DEAL_FUN_ARG)
{
	log_add_chat_in_header *p_in=PRI_IN_POS;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER_EX(p_in->msglen,1023 );
	chat_item* p_item=(chat_item *) p_in;
	ret=this->chat.add(p_item);
	STD_RETURN(ret);
}
int Croute_func::log_add_change(DEAL_FUN_ARG)
{
	log_add_change_in *p_in=PRI_IN_POS; 
	ret=this->change_log.add(p_in);
	STD_RETURN(ret);
}

int Croute_func::user_card_add_card(DEAL_FUN_ARG)
{
	user_card_add_card_in *p_in=PRI_IN_POS; 
	ret=this->user_card.addCard(RECVBUF_USERID,p_in->cardid );
	STD_RETURN(ret);
}

int Croute_func::user_card_add_win_lose(DEAL_FUN_ARG)
{
	user_card_add_win_lose_in *p_in=PRI_IN_POS; 
	ret=this->user_card.addWinLose(RECVBUF_USERID,p_in->win_lose_flag);
	STD_RETURN(ret);
}

int Croute_func::user_card_getinfo(DEAL_FUN_ARG)
{
	user_card_getinfo_out out={};
	ret=this->user_card.getCardGameInfo_ex(RECVBUF_USERID,&out );

	uint32_t  private_size;
	private_size=sizeof(out)-sizeof(out.cardList)+4
		+sizeof(out.cardList.cards[0])*out.cardList.count;
	STD_RETURN_WITH_BUF(ret,(char*)&out , private_size );
}


/*int Croute_func::log_change(change_log_item * p_item  )
{
	char buf[2000];
	PROTO_HEADER* ph=(PROTO_HEADER*)buf;
	ph->cmd_id=0xF103;
	ph->id=p_item->userid;
	ph->proto_length=sizeof (PROTO_HEADER)+ sizeof(*p_item) ;
	memcpy(buf+sizeof (PROTO_HEADER),p_item, sizeof(*p_item) );
	sendto(this->change_log_fd,buf,ph->proto_length,0,(const struct sockaddr *)&(this->change_log_addr),sizeof(this->change_log_addr));
	return SUCC;
}*/

int Croute_func::admin_add_admin(DEAL_FUN_ARG)
{
	admin_add_admin_in *p_in=PRI_IN_POS; 
	ret=this->admin_all.insert(p_in);
	STD_RETURN(ret);
}

int Croute_func::admin_get_adminlist(DEAL_FUN_ARG)
{
	admin_get_adminlist_in *p_in=PRI_IN_POS; 
	admin_get_adminlist_out_header  out_header;
	admin_get_adminlist_out_item *p_out_item;
	ret=this->admin_all.get_admin_alllist(p_in->index,&(out_header.count),
		 &p_out_item	);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::admin_change_passwd(DEAL_FUN_ARG)
{
	admin_change_passwd_in *p_in=PRI_IN_POS; 
	ret=this->admin_all.change_passwd(RECVBUF_USERID ,p_in->oldpasswd,p_in->newpasswd );
	STD_RETURN(ret);
}

int Croute_func::admin_del_admin(DEAL_FUN_ARG)
{
	admin_del_admin_in *p_in=PRI_IN_POS;
	ret=this->admin_all.del(p_in->adminid );
	ret=this->admin_power.del_by_adminid(p_in->adminid);
	STD_RETURN(ret);
}

int Croute_func::admin_login(DEAL_FUN_ARG)
{
	admin_login_in *p_in=PRI_IN_POS; 
	admin_login_out_header  out_header={};
	admin_login_out_item *p_out_item;
	ret=this->admin_all.user_check(RECVBUF_USERID,p_in->passwd,out_header.nick);
	if (ret!=SUCC) return ret;
	ret=this->admin_power.get_powerlist(RECVBUF_USERID,&(out_header.count),&p_out_item  ); 	

	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::party_add_party(DEAL_FUN_ARG)
{
	party_add_party_in *p_in=PRI_IN_POS; 
	ret=this->party.add(p_in);
	STD_RETURN(ret);
}
int Croute_func::party_get_partylist(DEAL_FUN_ARG)
{
	party_get_partylist_in *p_in=PRI_IN_POS; 
	party_get_partylist_out_header  out_header={};
	party_get_partylist_out_item *p_out_item=NULL;
	ret=this->party.get_partylist(p_in->serverid,p_in->startindex,p_in->pagecount, 
			&(out_header.count),&p_out_item  );
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::party_getlist_by_ownerid(DEAL_FUN_ARG)
{
	party_getlist_by_ownerid_in *p_in=PRI_IN_POS; 
	party_getlist_by_ownerid_out_header  out_header;
	party_getlist_by_ownerid_out_item *p_out_item;
	ret=this->party.get_partylist_by_ownerid(p_in->ownerid,
			&(out_header.count),&p_out_item  );
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::userserial_gen_serial(DEAL_FUN_ARG)
{
	userserial_gen_serial_in *p_in=PRI_IN_POS; 
	userserial_gen_serial_out out={};
	ret=this->user_serial.add_serial(RECVBUF_USERID,p_in->type, out.serialid);
	STD_RETURN_WITH_STRUCT(ret,out);
}
int Croute_func::userserial_del_serial(DEAL_FUN_ARG)
{
	userserial_del_serial_in *p_in=PRI_IN_POS; 
	ret=this->user_serial.del(RECVBUF_USERID, p_in->type );
	STD_RETURN(ret);
}
int Croute_func::userserial_get_serial(DEAL_FUN_ARG)
{
	userserial_get_serial_in *p_in=PRI_IN_POS; 
	userserial_get_serial_out out={};
	ret=this->user_serial.get_serialid(RECVBUF_USERID, p_in->type ,&out );
	STD_RETURN_WITH_STRUCT(ret,out);
}


int Croute_func::userinfo_set_passwdemail(DEAL_FUN_ARG)
{
	userinfo_set_passwdemail_in *p_in=PRI_IN_POS; 
	ret=this->user_info.set_passwdemail(RECVBUF_USERID,p_in->email);
	STD_RETURN(ret);
}

int Croute_func::userinfo_isset_passwdemail(DEAL_FUN_ARG)
{
	userinfo_isset_passwdemail_out out={};
	ret=this->user_info.check_flag(RECVBUF_USERID , FLAG1_STR, 
			USER_FLAG1_ISSET_PASSWDEMAIL ,(bool*)(&out.is_seted));	
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::userinfo_isconfirm_passwdemail(DEAL_FUN_ARG)
{
	userinfo_isconfirm_passwdemail_out out={};
	ret=this->user_info.check_flag(RECVBUF_USERID , FLAG1_STR, 
			USER_FLAG1_ISCONFIRM_PASSWDEMAIL ,(bool*)(&out.is_seted));	
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::userinfo_confirm_passwdemail(DEAL_FUN_ARG)
{
	bool isset_flag;
	//查看是否设置过.
	ret=this->user_info.check_flag(RECVBUF_USERID , FLAG1_STR, 
			USER_FLAG1_ISSET_PASSWDEMAIL ,&isset_flag );	
	if (ret !=SUCC ) return ret;
	if (! isset_flag){
		//没有设置
		return USER_PASSWDEMAIL_NOTSET_ERR;		
	}

	ret=this->user_info.set_flag(RECVBUF_USERID , FLAG1_STR, 
		             USER_FLAG1_ISCONFIRM_PASSWDEMAIL ,true);
	STD_RETURN(ret);
}

int Croute_func::userinfo_get_passwdemail(DEAL_FUN_ARG)
{
	userinfo_get_passwdemail_out out={};
	ret=this->user_info.get_passwdemail(RECVBUF_USERID, out.email );
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::admin_add_power(DEAL_FUN_ARG)
{
	admin_add_power_in *p_in=PRI_IN_POS; 
	ret=this->admin_power.add_powerid( p_in->adminid,p_in->powerid );
	STD_RETURN(ret);
}

int Croute_func::admin_del_power(DEAL_FUN_ARG)
{
	admin_del_power_in *p_in=PRI_IN_POS; 
	ret=this->admin_power.del_powerid( p_in->adminid,p_in->powerid );
	STD_RETURN(ret);
}

int Croute_func::party_get_count_by_server(DEAL_FUN_ARG)
{
	party_get_count_by_server_in *p_in=PRI_IN_POS; 
	party_get_count_by_server_out out={};
	ret=this->party.get_count_by_time(time(NULL),p_in->serverid,&(out.count));
	STD_RETURN_WITH_STRUCT(ret,out);
}
int Croute_func::admin_get_powerlist(DEAL_FUN_ARG)
{
	admin_get_powerlist_out_header  out_header;
	admin_get_powerlist_out_item *p_out_item;
	ret=this->admin_power.get_powerlist(RECVBUF_USERID,&(out_header.count),&p_out_item  ); 	
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
int Croute_func::admin_root_change_passwd(DEAL_FUN_ARG)
{
	admin_root_change_passwd_in *p_in=PRI_IN_POS; 
	ret=this->admin_all.update_passwd(p_in->adminid,p_in->passwd );
	STD_RETURN(ret);
}
int Croute_func::user_card_add_lower_card(DEAL_FUN_ARG)
{
	user_card_add_lower_card_out out={};
	ret=this->user_card.add_lower_card(RECVBUF_USERID,&out);
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_card_init(DEAL_FUN_ARG)
{
	user_card_init_in *p_in=PRI_IN_POS; 
	//user_card_init_out out={};
	//memcpy(&out, p_in,sizeof(*p_in));

	uint32_t lower_count=p_in->init_lowercard_count;
	//
	user_cardlist * p_list= (user_cardlist*)p_in;
	p_list->count=CARDLIST_INIT_LEN;
	ret=this->user_card.init(RECVBUF_USERID, lower_count, p_list );
	STD_RETURN(ret);
	/*
	if (ret!=SUCC){
		out.init_lowercard_count=0;
	}
	uint32_t  private_size;
	private_size=sizeof(out)-(sizeof(out.cards))
		+out.init_lowercard_count *sizeof(out.cards[0]);
	STD_RETURN_WITH_BUF(ret,(char*)&out , private_size );
	*/
}
int Croute_func::user_card_is_inited(DEAL_FUN_ARG)
{
	user_card_is_inited_out out={};
	ret=this->group.id_is_existed(RECVBUF_GROUPID,(bool*)&( out.is_inited ));
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_card_get_enable_count(DEAL_FUN_ARG)
{
	user_card_get_enable_count_out out={};
	ret=this->user_card.get_enable_count(RECVBUF_USERID,&out );
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::pic_add_pic(DEAL_FUN_ARG)
{
	pic_add_pic_in *p_in=PRI_IN_POS; 
	pic_add_pic_out out={};
	ret=this->user_picture.add(RECVBUF_USERID,p_in,&out );
	STD_RETURN_WITH_STRUCT(ret,out);
}
int Croute_func::pic_get_user_ablum_piclist(DEAL_FUN_ARG)
{
	pic_get_user_ablum_piclist_in *p_in=PRI_IN_POS; 
	pic_get_user_ablum_piclist_out_header  out_header;
	pic_get_user_ablum_piclist_out_item *p_out_item;
	ret=this->user_picture.get_filelist(RECVBUF_USERID,p_in,&(out_header.count),&p_out_item );
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
int Croute_func::pic_get_pic_by_photoid_userid(DEAL_FUN_ARG)
{
	pic_get_pic_by_photoid_userid_in *p_in=PRI_IN_POS; 
	pic_get_pic_by_photoid_userid_out out={};
	ret=this->user_picture.get_file(RECVBUF_USERID,p_in,&out );
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::pic_del_pic_by_photoid_userid(DEAL_FUN_ARG)
{
	pic_del_pic_by_photoid_userid_in *p_in=PRI_IN_POS; 
	pic_del_pic_by_photoid_userid_out out={};
	pic_get_pic_by_photoid_userid_out info={};
	ret=this->user_picture.get_file(RECVBUF_USERID,p_in,&info);
	if(ret!=SUCC) return ret;
	ret=this->user_picture.remove(RECVBUF_USERID,p_in->photoid );
	if(ret!=SUCC) return ret;
	memcpy(out.fileid,info.fileid,sizeof(out.fileid));
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::sysarg_day_clean_by_type(DEAL_FUN_ARG)
{
	sysarg_day_clean_by_type_in *p_in=PRI_IN_POS; 
	ret=this->usermap_day.remove_by_type(RECVBUF_USERID,p_in->type);
	STD_RETURN(ret);
}

int Croute_func::msgboard_reset_msg(DEAL_FUN_ARG)
{
	msgboard_reset_msg_in_header *p_in=PRI_IN_POS;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER_EX(p_in->msglen,1000);
	msg_item *p_msg_item = (msg_item*)(&p_in->msglen);
	//保证有\0结尾
	if(p_in->msglen > 0){
		p_msg_item->msg[p_in->msglen-1]='\0';
		ret=this->msgboard.update_msg(p_in->msgid,p_msg_item->msg);
	}
			
	STD_RETURN(ret);
}

int Croute_func::spring_get_value(DEAL_FUN_ARG)
{
	spring_get_value_out out={};
	spring_info info;
	ret=this->spring.get_value_ex(RECVBUF_USERID,&info);
	if (ret!=SUCC) return ret;
	if (info.flag==0)
		return  SPRING_GOLD_SILVER_NOT_INIT_ERR;
	out.gold=info.gold;	
	out.silver=info.silver;	
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::spring_change_value(DEAL_FUN_ARG)
{
	spring_change_value_in *p_in=PRI_IN_POS; 
	spring_change_value_out out;
	ret=this->spring.change_count(RECVBUF_USERID,p_in,&out);
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::spring_set_msg(DEAL_FUN_ARG)
{
	spring_set_msg_in *p_in=PRI_IN_POS; 
	spring_set_msg_out out;

	spring_info info={};
	ret=this->spring.get_value_ex(RECVBUF_USERID,&info);
	if (ret!=SUCC) return ret;
	if ( info.spring_msg[0]=='\0'){
		out.is_first_set=1;
	}else{
		out.is_first_set=0;
	}
	
	ret=this->spring.update_msg(RECVBUF_USERID,p_in);
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::admin_set_use_flag(DEAL_FUN_ARG)
{
	admin_set_use_flag_in *p_in=PRI_IN_POS; 
	ret=this->admin_all.set_flag(p_in->adminid,
		ADMIN_FLAG_STR,ADMIN_USED_FLAG, bool(p_in->useflag));
	STD_RETURN(ret);
}
int Croute_func::user_card_set_win_lose(DEAL_FUN_ARG)
{
	user_card_set_win_lose_in *p_in=PRI_IN_POS; 
	ret=this->user_card.update_win_lose(RECVBUF_USERID,p_in );
	STD_RETURN(ret);
}
int Croute_func::spring_get_msg(DEAL_FUN_ARG)
{
	spring_get_msg_out out={};
	spring_info info;
	ret=this->spring.get_value_ex(RECVBUF_USERID,&info);
	if (ret!=SUCC) return ret;

	memcpy(out.spring_msg,info.spring_msg,sizeof(out.spring_msg));
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::spring_init_gold_silver(DEAL_FUN_ARG)
{
	ret=this->spring.set_init(RECVBUF_USERID);
	STD_RETURN(ret);
}

int Croute_func::spring_get_flag(DEAL_FUN_ARG)
{
	spring_get_flag_out out={};
	spring_info info;
	ret=this->spring.get_value_ex(RECVBUF_USERID,&info);
	if (ret!=SUCC) return ret;
	out.flag=info.flag;	
	out.gold=info.gold;	
	out.silver=info.silver;	
	STD_RETURN_WITH_STRUCT(ret,out);
}
int Croute_func::spring_get_spring(DEAL_FUN_ARG)
{
	spring_get_spring_out out={};
	ret=this->spring.get_value(RECVBUF_USERID,&out );
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::spring_set_spring(DEAL_FUN_ARG)
{
	spring_set_spring_in *p_in=PRI_IN_POS; 
	ret=this->spring.update_count(RECVBUF_USERID,p_in );
	ret=this->spring.update_flag(RECVBUF_USERID,p_in->flag );
	spring_set_msg_in msg_in;
	memcpy(msg_in.spring_msg,p_in->spring_msg,sizeof(msg_in.spring_msg));
	ret=this->spring.update_msg(RECVBUF_USERID,&msg_in );
	STD_RETURN(ret);
}
int Croute_func::roommsg_add_diary(DEAL_FUN_ARG)
{
	roommsg_add_diary_in_header *p_in=PRI_IN_POS;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER(4000);
	STD_RETURN(ret);
}

int Croute_func::roommsg_set_diary(DEAL_FUN_ARG)
{
	roommsg_set_diary_in_header *p_in=PRI_IN_POS;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER(4000);
	STD_RETURN(ret);
}

int Croute_func::roommsg_set_diary_pub_flag(DEAL_FUN_ARG)
{
	roommsg_set_diary_pub_flag_in *p_in=PRI_IN_POS; 
	STD_RETURN(ret);
}

int Croute_func::roommsg_get_diary_list(DEAL_FUN_ARG)
{
	roommsg_get_diary_list_in *p_in=PRI_IN_POS; 
	roommsg_get_diary_list_out_header  out_header;
	roommsg_get_diary_list_out_item *p_out_item;
	//ret=this->
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}


int Croute_func::roommsg_get_diary(DEAL_FUN_ARG)
{
	roommsg_get_diary_in *p_in=PRI_IN_POS; 
	//roommsg_get_diary_out_header  out_header;
	//roommsg_get_diary_out_item *p_out_item;
	//ret=this->
	//STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
	STD_RETURN(ret);
}

int Croute_func::admin_get_adminid_by_nick(DEAL_FUN_ARG)
{
	admin_get_adminid_by_nick_in *p_in=PRI_IN_POS; 
	admin_get_adminid_by_nick_out out={};
	ret=this->admin_all.get_adminid_by_nick(p_in->nick,&(out.adminid));
	STD_RETURN_WITH_STRUCT(ret,out);
}
int Croute_func::admin_get_adminlist_by_powerid(DEAL_FUN_ARG)
{
	admin_get_adminlist_by_powerid_in *p_in=PRI_IN_POS; 
	admin_get_adminlist_by_powerid_out_header  out_header;
	admin_get_adminlist_by_powerid_out_item *p_out_item;
	ret=this->admin_power.get_adminlist_by_powerid(p_in->powerid,&(out_header.count),&p_out_item );
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}


int Croute_func::msgboard_qa_add_msg(DEAL_FUN_ARG)
{
	msgboard_qa_add_msg_in *p_in=PRI_IN_POS; 
	ret=this->qa.insert(p_in);
	STD_RETURN(ret);
}
int Croute_func::msgboard_qa_get_list(DEAL_FUN_ARG)
{
	msgboard_qa_get_list_in *p_in=PRI_IN_POS; 
	msgboard_qa_get_list_out_header  out_header;
	msgboard_qa_get_list_out_item *p_out_item;
	ret=this->qa.getmsglist(p_in->startindex,p_in->count,&(out_header.count),&p_out_item  );
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
int Croute_func::msgboard_qa_del_msg(DEAL_FUN_ARG)
{
	msgboard_qa_del_msg_in *p_in=PRI_IN_POS; 
	ret=this->qa.del(p_in->msgid);
	STD_RETURN(ret);
}


int Croute_func::msgboard_qa_get_list_ex(DEAL_FUN_ARG)
{
	msgboard_qa_get_list_ex_in *p_in=PRI_IN_POS; 
	msgboard_qa_get_list_ex_out_header  out_header;
	msgboard_qa_get_list_ex_out_item *p_out_item;
	ret=this->qa.getmsglist_ex(p_in->startindex,p_in->count,&(out_header.count),&p_out_item  );
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
int Croute_func::msgboard_qa_get_count(DEAL_FUN_ARG)
{
	msgboard_qa_get_count_out out={};
	ret=this->qa.get_count(&(out.count));
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_buy_pet_attire_by_xiaomee(DEAL_FUN_ARG)
{
	user_buy_pet_attire_by_xiaomee_in * p_in= PRI_IN_POS;   
	user_buy_pet_attire_by_xiaomee_out out={};
	int xiaomee;	

	ret=this->user.change_xiaomee(
			RECVBUF_USERID, -p_in->usexiaomee,
			XIAOMEE_USE_DEL_BUY_ATTIRE ,p_in->attireid,
		  	&xiaomee);

	if (ret!=SUCC) return ret;

	//加东西
	user_set_attire_in set_info;
	user_set_attire_out set_out;
	set_info.attireid=p_in->attireid;
	set_info.maxvalue=p_in->maxcount;
	set_info.value=p_in->count;
	set_info.operatetype=0x01; //add + no used
	ret=this->user_pet_attire.update_common(RECVBUF_USERID,p_in->petid,&set_info, &set_out);
	if (ret!=SUCC){ //没有增加成功 ,设置xiaomee为原值 
			int tmp_ret=this->user.change_xiaomee(
				RECVBUF_USERID ,p_in->usexiaomee,
				XIAOMEE_USE_ADD_BACK,p_in-> attireid,&xiaomee);
			if (tmp_ret!=SUCC){
				//回滚出现严重 ,需要手工处理
				ERROR_LOG("ERROR:xiaomee route back error ret[%d],userid[%u],xiaomee[%d]",
					 tmp_ret ,RECVBUF_USERID,p_in->usexiaomee);
			}
	}
	out.leave_xiaomee=xiaomee;
	out.buy_attireid=p_in->attireid;
	out.buy_count=p_in->count;
	if (ret==SUCC){
		//log_change
		change_log_item c_item;
		c_item.userid=RECVBUF_USERID;
		c_item.change_type=1;
		c_item.logtime=time(NULL);
		c_item.change_value=-p_in->usexiaomee;
		c_item.change_v1=p_in->attireid;
		c_item.change_v2=out.leave_xiaomee;
		this->send_log.send(&c_item );
	}
	msglog(this->msglog_file, 0x04040105,time(NULL), &(RECVBUF_USERID), 4);
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_get_pet_attire_list(DEAL_FUN_ARG)
{
	user_get_pet_attire_list_in *p_in=PRI_IN_POS; 
	user_get_pet_attire_list_out_header  out_header;
	user_get_pet_attire_list_out_item *p_out_item;
	out_header.petid=p_in->petid;
	ret=this->user_pet_attire.get_list_by_attireid_interval(
				RECVBUF_USERID , p_in->petid, p_in->startattireid,p_in->endattireid,
				p_in->attire_usedflag, &(out_header.count),&p_out_item);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::user_set_pet_attire(DEAL_FUN_ARG)
{
	user_set_pet_attire_in *p_in=PRI_IN_POS; 
	user_set_pet_attire_out out={};
	ret=this->user_pet_attire.update_common(RECVBUF_USERID,p_in->petid,&(p_in->item),&out );
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_temp_get_value(DEAL_FUN_ARG)
{
	user_temp_get_value_out out={};
	uint32_t flag;
	ret=this->user.get_tmp_value(RECVBUF_USERID,&flag,&(out.cur_count) );
	if (ret==SUCC){
		if (flag!=USER_TEMP_USER_FLAG ) {
			out.cur_count=0;
		}
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_temp_add_value(DEAL_FUN_ARG)
{
	user_temp_add_value_out out={};
	ret=this->user.add_tmp_value(RECVBUF_USERID,USER_TEMP_USER_FLAG, &(out.cur_count));
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::temp_pet_sports_get_list(DEAL_FUN_ARG)
{
	temp_pet_sports_get_list_out_header  out_header;
	temp_pet_sports_get_list_out_item *p_out_item;
	ret=this->sports_count.get_count_list(&(out_header.count), &p_out_item );
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::user_get_pet_attire_used_all(DEAL_FUN_ARG)
{
	user_get_pet_attire_used_all_out_header  out_header;
	user_get_pet_attire_used_all_out_item *p_out_item;
	ret=this->user_pet_attire.get_used_list(RECVBUF_USERID,&(out_header.count), &p_out_item);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::temp_pet_user_reported(DEAL_FUN_ARG)
{
	temp_pet_user_reported_out out={};
	ret=SUCC;
	uint32_t count=0;
	ret=this->pet_sports.get_petcount(RECVBUF_USERID,&count );
	if (count==0){
		out.bool_value=0;
	}else{
		out.bool_value=1;
	}
	
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::temp_pet_get_pet_list(DEAL_FUN_ARG)
{
	temp_pet_get_pet_list_out_header  out_header;
	temp_pet_get_pet_list_out_item *p_out_item;
	ret=this->pet_sports.get_petlist(RECVBUF_USERID,&(out_header.count), &p_out_item);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::temp_pet_report(DEAL_FUN_ARG)
{
	temp_pet_report_in *p_in=PRI_IN_POS; 
	ret=this->pet_sports.init(RECVBUF_USERID,p_in->petid,p_in->pet_groupid );
	STD_RETURN(ret);
}

int Croute_func::user_get_pet_attire_all(DEAL_FUN_ARG)
{
	user_get_pet_attire_all_out_header  out_header;
	user_get_pet_attire_all_out_item *p_out_item;
	ret=this->user_pet_attire.get_all(RECVBUF_USERID,&(out_header.count), &p_out_item);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::user_pet_attire_update_ex(DEAL_FUN_ARG)
{
	user_pet_attire_update_ex_in *p_in=PRI_IN_POS; 
	ret=this->user_pet_attire.update_ex(RECVBUF_USERID, p_in->petid,p_in->attireid,p_in->usedcount,p_in->allcount);
	STD_RETURN(ret);
}

int Croute_func::user_card_getinfo_ex(DEAL_FUN_ARG)
{
	user_card_getinfo_ex_out out={};
	ret=this->user_card.getCardGameInfo(RECVBUF_USERID,&out);
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::temp_pet_get_score_list(DEAL_FUN_ARG)
{
	temp_pet_get_score_list_out_header  out_header;
	temp_pet_get_score_list_out_item *p_out_item;

	ret=this->pet_sports.get_scorelist(RECVBUF_USERID,&(out_header.count), &p_out_item);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::temp_pet_sports_set_score(DEAL_FUN_ARG)
{
	temp_pet_sports_set_score_in *p_in=PRI_IN_POS; 
	temp_pet_sports_set_score_out out={};
	if (p_in->score<10  ){
		return ENUM_OUT_OF_RANGE_ERR;
	}
	if (p_in->sportstype==0 || p_in->sportstype>5  ){
		return ENUM_OUT_OF_RANGE_ERR;
	}

	uint32_t db_score ,db_groupid;
	ret=this->pet_sports.get_score(RECVBUF_USERID,p_in->petid, p_in->sportstype,
		  &db_groupid,	&db_score );
	db_groupid-=1200000;

	if(ret!=SUCC) return ret;
	if ( db_score==0){
		out.is_first_set=true;		
		//首次的话，对应组的完成数加1
		this->sports_count.add_count( db_groupid  );
	}else{
		out.is_first_set=false;		
	}


	//更新分数
	bool update_flag=false;
	if ( db_score==0 ){
		//没有值
		update_flag=true;
	}

	if ( p_in->score>db_score && p_in->sportstype ==3 ){
		update_flag=true;
	}

	if ((p_in->sportstype==1 || p_in->sportstype==2) && p_in->score<db_score ){
		update_flag=true;
	}

	if(update_flag ){
		ret=this->pet_sports.set_score(RECVBUF_USERID,p_in->petid, p_in->sportstype,p_in->score);
		if (ret!=SUCC) return ret;
		out.best_score=p_in->score;
	}else{
		out.best_score=db_score;
	}

	//设置最高分数 
	this->pet_max_score.set_score(p_in->sportstype , p_in->score,
		db_groupid-1 , p_in->usernick,p_in->petnick 	);
	
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::temp_pet_sports_get_max_score(DEAL_FUN_ARG)
{
	temp_pet_sports_get_max_score_in *p_in=PRI_IN_POS; 
	temp_pet_sports_get_max_score_out out={};
	ret=this->pet_max_score.get_score(p_in->sportstype,&out );
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::hope_get_hope_all(DEAL_FUN_ARG)
{
	hope_get_hope_all_out_header  out_header;
	hope_get_hope_all_out_item *p_out_item;
	ret=this->hope_history.get_hope_list_ex(RECVBUF_USERID , &(out_header.count),&p_out_item );
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
int Croute_func::temp_pet_get_group_allcount(DEAL_FUN_ARG)
{
	temp_pet_get_group_allcount_in *p_in=PRI_IN_POS; 
	temp_pet_get_group_allcount_out out={};
	ret=this->sports_count.get_all_count(p_in->pet_groupid,&(out.count)  );
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_get_info_ex(DEAL_FUN_ARG)
{
	char out[PROTO_MAX_LEN]={ };
	user_get_info_ex_out_header  * p_out_header=(user_get_info_ex_out_header*)out ;
	user_get_info_ex_out_item_1  * p_out_item_1;
	user_get_info_ex_out_item_2  * p_out_item_2;
	user_get_info_ex_out_item_3  * p_out_item_3;
	user_get_info_ex_out_item_4  * p_out_item_4;
	
	ret = this->user_farm_animal.update_outgo_zero(RECVBUF_USERID);	
	ret = this->user_farm_fairy.update_state_outgo(RECVBUF_USERID);
	ret = this->user_paradise_contract.clear_used_count_no_dragon(RECVBUF_USERID);
	ret = this->user_piglet.clear_carry_flag(RECVBUF_USERID);
 	char * p_offset=&(out[0])+sizeof(* p_out_header);
	uint32_t cpy_len;
	
	//得到用户穿在身上的装扮
	ret=this->user_attire.get_list_by_attireid_interval(
				RECVBUF_USERID , 12001,15999, 1,
			  	&(p_out_header->item1_count),&p_out_item_1 );
	if (ret!=SUCC){ return ret; }
	cpy_len=(sizeof(*p_out_item_1)* p_out_header->item1_count) ;
	memcpy(p_offset,p_out_item_1,cpy_len);
	free(p_out_item_1);
	p_offset+=cpy_len;


	//得到宠物信息
	ret=this->user_pet.get( RECVBUF_USERID, 0,
		  	&(p_out_header->item2_count), &p_out_item_2);	
	if (ret!=SUCC){ return ret; }
	cpy_len=(sizeof(*p_out_item_2)* p_out_header->item2_count) ;
	memcpy(p_offset,p_out_item_2,cpy_len);
//	free(p_out_item_2);
	p_offset+=cpy_len;

	//得到宠物装扮列表信息
	ret=this->user_pet_attire.get_used_list(RECVBUF_USERID,
			&(p_out_header->item3_count), &p_out_item_3);
	if (ret!=SUCC){ return ret; }

	cpy_len=(sizeof(*p_out_item_3)* p_out_header->item3_count) ;
	memcpy(p_offset,p_out_item_3,cpy_len);
	free(p_out_item_3);
	p_offset+=cpy_len;
	p_out_header->item4_count = p_out_header->item2_count;	
	pet_task_state *p_task_out = NULL;
	uint32_t task_count = 0;
	p_out_item_4 = (user_get_info_ex_out_item_4 *)(p_offset);
	for(uint32_t i=0; i < p_out_header->item2_count; i++) {
		task_count = 0;
		ret = this->user_task.get_taskid_state(RECVBUF_USERID, (p_out_item_2 + i)->petid,
				&p_task_out, &task_count);
		if (ret != SUCC) {
			return ret;
		}

		if (task_count > 20) {
			task_count = 20;
		}
		p_out_item_4->petid = (p_out_item_2 + i)->petid; 
		for(uint32_t j=0; j<task_count; j++) {
			p_out_item_4->item[j].taskid = (p_task_out + j)->taskid;
			p_out_item_4->item[j].state = (p_task_out + j)->state;
		}
		free(p_task_out);
		p_out_item_4++;
		p_offset+=sizeof(user_get_info_ex_out_item_4);
	}
	
	free(p_out_item_2);

	//登入ONLINE ,标志: 该函数一次登入中只会调用一次
	{
		//进入统计数据
		TUSER_ON_OFF_LINE t;
		t.flag=3;
		t.logtime=time(NULL);
		t.userid=RECVBUF_USERID;
		SAVE_PROTOLOG_USER_ON_OFF_LINE(t);
	}
	STD_RETURN_WITH_BUF(ret, out , p_offset -&(out[0]));
	return SUCC;
}

//bank
//插入存款记录
int Croute_func::user_bank_add(DEAL_FUN_ARG)
{

	user_bank_add_in *p_in=PRI_IN_POS;
	uint32_t count;
	int temp;
	user_bank_add_out out;

	memcpy(&out, p_in, sizeof(user_bank_add_out));
	out.time = time(NULL);

	//存款是否大于一千
	if (p_in->xiaomee < XIAOMEE_THRESHOLD || p_in->xiaomee > XIAOMEE_UP_THRESHOLD) {
		return XIAOMEE_LESS_THRESHOLD_ERR;
	}

	//判断最大存款记录数
	ret = this->user_bank.get_record_num(RECVBUF_USERID, &count);
	if (ret  != DB_SUCC) {
		return DB_ERR;
	}
	if (count >= RECORD_MAX) {
		return RECORD_BIG_MAX_ERR;
	}

	//修改豆豆
	ret=this->user.change_xiaomee(RECVBUF_USERID, -p_in->xiaomee,XIAOMEE_USE_DEL_BANK, 0, &temp);
	if (ret != SUCC) {
		DEBUG_LOG("Fail to change xiaomee : userid %u, money %u", RECVBUF_USERID, p_in->xiaomee);
		return ret;
	}

	{
		change_log_item c_item;
		c_item.userid=RECVBUF_USERID;
		c_item.change_type=4;
		c_item.logtime=time(NULL);
		c_item.change_value=-p_in->xiaomee;
		c_item.change_v1=0;
		c_item.change_v2=temp;
		this->send_log.send(&c_item );
	}

	//插入存款记录
	ret=this->user_bank.insert_bank_money(RECVBUF_USERID, p_in, out.time);
	if (ret!=DB_SUCC) {
		if (this->user.change_xiaomee(RECVBUF_USERID, p_in->xiaomee, 4, 0, &temp) != SUCC) {
			ERROR_LOG("Fail to change_xiomee, userid %u , money %u", RECVBUF_USERID, p_in->xiaomee);
		}	
	}	
	STD_RETURN_WITH_STRUCT(ret,out);
}


//得到全部的存款记录
int Croute_func::user_bank_get_account(DEAL_FUN_ARG)
{
	user_bank_get_account_out_header  out_header;
	user_bank_get_account_out_item *p_out_item;
	out_header.now_time = time(NULL);
	ret=this->user_bank.get_all_record(RECVBUF_USERID, &p_out_item, &(out_header.count));
	STD_RETURN_WITH_STRUCT_LIST(ret, out_header, p_out_item, out_header.count);
}

//删除存款记录，返还利息和本金
int Croute_func::user_bank_delete_account(DEAL_FUN_ARG)
{
	user_bank_delete_account_in *p_in=PRI_IN_POS; 
	user_bank_delete_account_out out={};
	user_bank_add_in info;
	int temp;

	//得到存款的信息
	if (this->user_bank.get_record_info(RECVBUF_USERID, p_in->time, &info) != DB_SUCC) {
		return RECORD_NOT_EXIST_ERR;
	}
	uint32_t total_money = 0;
	this->user_bank.get_total_money_in_bank(RECVBUF_USERID, &total_money);
	uint32_t pocket_money = 0;
	this->user.get_xiaomee(RECVBUF_USERID, &pocket_money);

	//if(total_money + pocket_money >= MOLE_XIAOMEE_MAX){
		//out.xiaomeeinterest = 0;
		//out.totalmoney = info.xiaomee;
		//out.tax = 0;
		//ret = this->user_bank.get_record_ret(&info, &out.flag);

	//}
	//else{
	//得到总数和利息
	ret = this->user_bank.get_record_total_money(&info, &(out.xiaomeeinterest), &(out.totalmoney), &out.tax, &out.flag); 
	if (ret != SUCC){
		return ret;
	}
	if(out.totalmoney + pocket_money >= MOLE_XIAOMEE_MAX){
		out.xiaomeeinterest = 0;
		out.totalmoney = info.xiaomee;
		out.tax = 0;
		ret = this->user_bank.get_record_ret(&info, &out.flag);
	}
		//}

	//开启事务
    STD_CLOSE_AUTOCOMMIT(ret);
    if(ret!=SUCC) return ret;

	//删除存款记录
	ret = this->user_bank.delete_bank_money(RECVBUF_USERID, p_in->time);
	if (ret == SUCC) {
		//把存款返回
		ret = this->user.change_xiaomee(RECVBUF_USERID, out.totalmoney, XIAOMEE_USE_ADD_BANK , 0, &temp);
		if (ret != SUCC) {
			ERROR_LOG("BANK:Fail to gvie back xiaomee, userid %u, xiaomee %u ", RECVBUF_USERID,
				out.totalmoney	);
		}

	}
   if(ret==SUCC){
        //提交
        STD_COMMIT(ret);
    }else{
        //回滚
        STD_ROLLBACK();
    }
    //关闭事务
    STD_OPEN_AUTOCOMMIT() ;

	if(ret == SUCC){
		change_log_item c_item;
		c_item.userid=RECVBUF_USERID;
		c_item.change_type=4;
		c_item.logtime=time(NULL);
		c_item.change_value=out.totalmoney;
		c_item.change_v1=0;
		c_item.change_v2=temp;
		this->send_log.send(&c_item );
	}

	STD_RETURN_WITH_STRUCT(ret, out);
}

//更新用户信息
int Croute_func::user_bank_set_account(DEAL_FUN_ARG)
{
	user_bank_set_account_in *p_in=PRI_IN_POS; 
	ret=this->user_bank.set_info(RECVBUF_USERID,p_in );
	STD_RETURN(ret);
}

//更新用户信息
int Croute_func::user_set_task(DEAL_FUN_ARG)
{
	user_set_task_in *p_in=PRI_IN_POS; 
	DEBUG_LOG("p_in->taskid: %u, p_in->taskvalue: %u", p_in->taskid, p_in->value);
	ret=this->user.set_task_value(RECVBUF_USERID,p_in);
	STD_RETURN(ret);
}


int Croute_func::userinfo_login_ex(DEAL_FUN_ARG)
{

	userinfo_login_ex_in *p_in=PRI_IN_POS; 
	userinfo_login_ex_out out={};
	ret=this->user_info.login_ex(RECVBUF_USERID,p_in->passwd, &(out.gameflag));

	STD_RETURN_WITH_STRUCT(ret,out);
}


//种植种子
int Croute_func::user_add_seed(DEAL_FUN_ARG)
{
	user_add_seed_in *p_in=PRI_IN_POS; 
	user_add_seed_out out={};
	user_del_attire_in del_item;
	uint32_t count;

	this->user_jy.get_count(RECVBUF_USERID, &count);
	if (count > MAX_SEED_NUM) {
		return OUT_MAX_SEED_NUM_ERR;
	}

	ret = this->user_jy.get_xy_count(RECVBUF_USERID, &count, p_in->x, p_in->y);
	if (ret != SUCC) {
		return ret;
	}

	if (count != 0) {
		return OUT_MAX_SEED_NUM_ERR;
	}

	del_item.attireid=p_in->attireid;
	del_item.attiretype=0;
	del_item.count=1;
	del_item.maxcount=99999;
	ret=this->user_del_attire(RECVBUF_USERID ,&del_item);
	if (ret!=SUCC) return ret;
	uint32_t now=time(NULL);
	out.item.attireid=p_in->attireid;
	out.item.x=p_in->x;
	out.item.y=p_in->y;
	out.item.cal_value_time=now;
	out.item.water_time=now;
	out.item.kill_bug_time=now;
	out.item.sickflag = 1;
	out.item.value = 0;
	out.item.mature_time = 0;

	ret=this->user_jy.add(RECVBUF_USERID ,now ,p_in, &(out.item.id));
	if (ret != SUCC) {
		return ret;
	}
	ret = this->user_jy.fill_attribute(&out.item);
	STD_RETURN_WITH_STRUCT(ret,out);
}



//删除种子
int Croute_func::user_del_seed(DEAL_FUN_ARG)
{
	user_del_seed_in *p_in=PRI_IN_POS; 
	ret=this->user_jy.del(RECVBUF_USERID,p_in->id );
	STD_RETURN(ret);
}



//得到种子信息
int Croute_func::user_get_seed(DEAL_FUN_ARG)
{
	user_get_seed_in *p_in=PRI_IN_POS; 
	user_get_seed_out out={};
	ret=this->user_jy.get_ex(RECVBUF_USERID, p_in->id, &out);
	STD_RETURN_WITH_STRUCT(ret,out);
}



//收获果实
int Croute_func::user_catch_fruit(DEAL_FUN_ARG)
{
	user_catch_fruit_in *p_in=PRI_IN_POS; 
	user_catch_fruit_out out={};
	jy_item item ={};
	ret=this->user_jy.get(RECVBUF_USERID, p_in->id, &item);
	if(ret!=SUCC) return ret;
	if ( item.fruitnum==0 ) {
		return	USER_NOFIND_FRUIT_ERR;
	}
	if (item.earth == 1) {
		return USER_NOFIND_FRUIT_ERR;
	}
	//判断果实是否过期
	ret = this->user_jy.fruit_is_bad(&item);
	if (ret != SUCC) {
		return ret;
	}
	/* 检查是否有人偷取过这个果实，如没有不能采 */
	if (item.attireid == 1230032) {
		thiever_info poach = {};
		ret = this->user_jy.get_thiever(RECVBUF_USERID, p_in->id, &poach);
		if (ret != SUCC) {
			return ret;
		}
		if (poach.count < 1) {
			return THIS_TREE_NOT_THIEVER_ERR;
		}
	}
	//得到对应成熟水果ID
	uint32_t fruitid = 0;
	ret=this->user_jy.get_fruitid(item.attireid, item.pollinate_num, &fruitid);
	if(ret!=SUCC) return ret;
	DEBUG_LOG("====fruitid %u", fruitid);
	out.attireid=fruitid;
	out.fruitnum = item.fruitnum;

	//增加物品
	user_add_attire_in	add_item ={ };
	add_item.attiretype=0;
	add_item.attireid=fruitid;
	add_item.count=item.fruitnum;

	//最多99999个
	add_item.maxcount=99999;
	/*
	if (add_item.attireid == 190601) {
		add_item.maxcount=150;
	}
	else if (add_item.attireid == 190602) {
		add_item.maxcount=250;
	}
	else if (add_item.attireid == 190662) {
		add_item.maxcount=99999;
	}
	*/
	ret=this->user_add_attire(RECVBUF_USERID,&add_item );
	if (ret==VALUE_OUT_OF_RANGE_ERR){
		//果实个数超过最大数
		return	USER_FRUIT_MAX_ERR	;
	}else if (ret!=SUCC){
		return ret;
	}
	uint32_t exp = 0;
	this->user_jy.get_exp(item.attireid, &exp);
	ret = this->user_farm.catch_get_exp(RECVBUF_USERID, 1, exp, &out.exp);
	ret = this->user_jy.update_earth(RECVBUF_USERID, p_in->id);
	STD_RETURN_WITH_STRUCT(ret,out);
}


//收获单个果实
int Croute_func::user_catch_fruit_single(userid_t userid, jy_item *p_item, uint32_t& exp_out)
{
	//判断果实是否过期
	ret = this->user_jy.fruit_is_bad(p_item);
	if (ret != SUCC) {
		return ret;
	}
	/* 检查是否有人偷取过这个果实，如没有不能采 */
	if (p_item->attireid == 1230032) {
		thiever_info poach = {};
		ret = this->user_jy.get_thiever(userid, p_item->id, &poach);
		if (ret != SUCC) {
			return ret;
		}
		if (poach.count < 1) {
			return THIS_TREE_NOT_THIEVER_ERR;
		}
	}
	//得到对应成熟水果ID
	uint32_t fruitid = 0;
	ret=this->user_jy.get_fruitid(p_item->attireid, p_item->pollinate_num, &fruitid);
	if(ret!=SUCC) return ret;

	//增加物品
	user_add_attire_in	add_item ={ };
	add_item.attiretype=0;
	add_item.attireid=fruitid;
	add_item.count=p_item->fruitnum;

	//最多99999个
	add_item.maxcount=99999;
	/* 
	if (add_item.attireid == 190601) {
		add_item.maxcount=150;
	}
	else if (add_item.attireid == 190602) {
		add_item.maxcount=250;
	}
	else if (add_item.attireid == 190662) {
		add_item.maxcount=99999;
	}
	*/
	ret=this->user_add_attire(userid, &add_item );
	if (ret==VALUE_OUT_OF_RANGE_ERR){
		//果实个数超过最大数
		return	USER_FRUIT_MAX_ERR	;
	}else if (ret!=SUCC){
		return ret;
	}
	uint32_t exp = 0;
	this->user_jy.get_exp(p_item->attireid, &exp);
	ret = this->user_farm.catch_get_exp(userid, 1, exp, &exp_out);
	ret = this->user_jy.update_earth(userid, p_item->id);

	return ret;

}


int Croute_func::user_get_jy_noused_list(DEAL_FUN_ARG)
{
	char out[PROTO_MAX_LEN]={ };
	user_get_jy_noused_list_in *p_in=PRI_IN_POS; 

	user_get_jy_noused_list_out_header * p_out_header=
		(user_get_jy_noused_list_out_header *)out ;
	user_get_jy_noused_list_out_item  * p_out_item=
		( user_get_jy_noused_list_out_item  * ) (out+sizeof(*p_out_header )) ;

	//得到种子列表
	user_get_jy_noused_list_out_item *p_noused_item; 
	ret=this->user_attire.get_list_by_attireid_interval(
			RECVBUF_USERID , p_in->seed_startid,p_in->seed_endid,
			0, &(p_out_header->count	),&p_noused_item );
	if(ret!=SUCC)return ret;
	//复制数据
	memcpy(p_out_item,p_noused_item ,sizeof(*p_noused_item)* p_out_header->count);
	p_out_item =p_out_item +p_out_header->count;
	free(p_noused_item);


	//得到家园列表
	noused_homeattirelist 	nousedlist={};

	ret =this->user.get_noused_home_attirelist(JY_STR,RECVBUF_USERID,
			&nousedlist);
	if(ret!=SUCC)return ret;
	//复制数据
	p_out_header->count+=nousedlist.count;	
	memcpy(p_out_item ,&(nousedlist.item[0]),
			sizeof(nousedlist.item[0] )* nousedlist.count  );


	STD_RETURN_WITH_BUF(ret, out ,
			sizeof(*p_out_header)+sizeof(*p_out_item)* p_out_header->count);

}

int Croute_func::user_get_seed_list(DEAL_FUN_ARG)
{
	user_get_seed_list_out_header  out_header;
	user_get_seed_list_out_item *p_out_item;
	ret=this->user_jy.get_list_db_diff(RECVBUF_USERID,  &(out_header.count),&p_out_item);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::user_set_seed_ex(DEAL_FUN_ARG)
{
	user_set_seed_ex_in *p_in=PRI_IN_POS; 
	ret=this->user_jy.update_seed_info_ex(RECVBUF_USERID, p_in );
	STD_RETURN(ret);
}

int Croute_func::user_get_access_jylist(DEAL_FUN_ARG)
{
	user_get_access_jylist_out out={};
	ret=this->user_ex.get_jyaccess_list(RECVBUF_USERID,&out );

	if(ret!=SUCC) return ret;
	uint32_t  private_size;
	private_size=sizeof(out.count)+sizeof(out.item[0])*out.count  ;
	STD_RETURN_WITH_BUF(ret,(char*)&out , private_size );
}
int Croute_func::user_access_jy(DEAL_FUN_ARG)
{
	user_access_jy_in *p_in=PRI_IN_POS; 
	ret=this->user_ex.access_jy(RECVBUF_USERID,p_in );
	STD_RETURN(ret);
}
int Croute_func::userinfo_get_gameflag(DEAL_FUN_ARG)
{
	userinfo_get_gameflag_out out={};
	ret=this->user_info.get_gameflag(RECVBUF_USERID,&(out.gameflag) );
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::userinfo_add_game(DEAL_FUN_ARG)
{
	userinfo_add_game_in *p_in=PRI_IN_POS; 
	ret=this->user_info.add_game(RECVBUF_USERID ,p_in->gameid_flag );
	STD_RETURN(ret);
}
int Croute_func::userinfo_del_game(DEAL_FUN_ARG)
{
	userinfo_del_game_in *p_in=PRI_IN_POS; 
	ret=this->user_info.set_int_value_bit(RECVBUF_USERID,"game",p_in->gameid_flag,false);
	STD_RETURN(ret);
}


int Croute_func::user_get_friend_list(DEAL_FUN_ARG)
{
	id_list out;
	ret=this->user_ex.get_idlist(RECVBUF_USERID ,FRIEND_LIST_STR,&out);

	uint32_t  private_size;
	private_size=sizeof(out)-(FRIEND_COUNT_MAX -out.count)*sizeof(out.item[0]);
	STD_RETURN_WITH_BUF(ret,(char*)&out , private_size );
}


int Croute_func::user_login_ex(DEAL_FUN_ARG)
{
	user_login_ex_out out={};
	ret=this->user.user_check(RECVBUF_USERID );
	if(ret!=SUCC) return ret;

	//日志
	{
		TLOGIN t;
		t.userid=RECVBUF_USERID;
		t.logintime=time(NULL);
		t.onlinetime=0;
		t.usertype=0;
		t.logtime=time(NULL);
		t.addr_type=0;
		t.ip=0;
		//save log
		SAVE_PROTOLOG_LOGIN(t);
	}


	ret=this->user_ex.login(RECVBUF_USERID, &out );

	if (ret==SUCC &&  out.friendcount>FRIEND_COUNT_MAX ) {
		return DB_DATA_ERR;
	}

	uint32_t  private_size;
	private_size=sizeof(out)-(FRIEND_COUNT_MAX -out.friendcount)*sizeof(out.frienditem[0]);
	STD_RETURN_WITH_BUF(ret,(char*)&out , private_size );

	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_register_ex2(DEAL_FUN_ARG)
{
	user_register_ex2_in *p_in=PRI_IN_POS; 
	user_get_user_all_out user_msg; 
	memset(&user_msg,0,sizeof(user_msg) );
	user_msg.flag=this->cfg.userflag;
	user_msg.petcolor=p_in->petcolor;
	//init value
	user_msg.xiaomee=this->cfg.xiaomee;
	user_msg.petbirthday=time(NULL);

	ret=this->user.insert( RECVBUF_USERID ,&user_msg );
	if(ret!=SUCC) return ret;

	ret=this->user_ex.init(RECVBUF_USERID,p_in->nick  );
	if (ret != SUCC) {
		return ret;
	}

	//user_add_attire_in temp;
	//for (int i = 12760; i <= 12761; i++) {
		//temp.attireid = i;
		//temp.attiretype = 0;
		//temp.count = 1;
		//temp.maxcount = 1;
		//ret = this->user_add_attire(RECVBUF_USERID, &temp);
		//if (ret != SUCC) {
			//return ret;
		//}
	//}

	if (ret==SUCC )
	{
		{//更新昵称
			//同步论坛数据
			dv_change_nick_in t;  
			memcpy(t.newnick, p_in->nick,NICK_LEN);
			this->send_log.dv_change_nick(RECVBUF_USERID,&t );	
		}

		{
			//更新昵称 同步论坛数据,台湾版本需要
			TDV_CHANGE_NICK t;  
			t.msg_flag=DV_CHANGE_NICK_CMD;
			t.sendcount=0;  
			t.userid=RECVBUF_USERID;
			memcpy(t.newnick,   p_in->nick ,NICK_LEN);
			this->sync_user.send((char*) &t, sizeof(t) );
		}
	}


	STD_RETURN(ret);
}

int Croute_func::user_home_noused_attire_type_count(DEAL_FUN_ARG)
{
	user_home_noused_attire_type_count_out out={};
	stru_noused_attirelist list; 
	ret=this->user.home_get_noused_attirelist(RECVBUF_USERID,&list );
	out.count=list.count;
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_check_existed_ex(DEAL_FUN_ARG)
{
	user_check_existed_ex_out out={};
	ret=this->user.id_is_existed(RECVBUF_GROUPID,
			(bool*)&( out.is_existed ));
	STD_RETURN_WITH_STRUCT(ret,out);
}


int Croute_func::user_get_tempbuf(DEAL_FUN_ARG)
{
	user_get_tempbuf_out out={};
	ret=this->user_ex.get_tmpbuf(RECVBUF_USERID,&out );
	STD_RETURN_WITH_STRUCT(ret,out);
}


int Croute_func::user_set_tempbuf(DEAL_FUN_ARG)
{
	user_set_tempbuf_in *p_in=PRI_IN_POS; 
	ret=this->user_ex.update_tmpbuf(RECVBUF_USERID,p_in );
	STD_RETURN(ret);
}

int Croute_func::user_get_ip_history(DEAL_FUN_ARG)
{
	user_get_ip_history_out out={};
	ret=this->user.get_history_ip(RECVBUF_USERID,&out );
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::userinfo_get_passwd_history(DEAL_FUN_ARG)
{
	userinfo_get_passwd_history_out out={};
	ret=this->user_info.get_history_passwd(RECVBUF_USERID,&out );
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::roominfo_add_hot(DEAL_FUN_ARG)
{
	roominfo_add_hot_in *p_in = PRI_IN_POS;
	roominfo_hot_list hot_list;
	memset(&hot_list, 0, sizeof(roominfo_hot_list));
	uint32_t date = 0, today = get_date(time(0));
	ret = this->roominfo.get_hotlist_date(RECVBUF_USERID, date, &hot_list);
	DEBUG_LOG("!!!!!!!!!!!!!!!!count: %u", hot_list.count);
	if(date != today){
		ret=this->roominfo.add_hot(RECVBUF_USERID);
		memset(&hot_list, 0, sizeof(roominfo_hot_list));
		hot_list.count = 1;
		hot_list.visitors[0] = p_in->userid;
		ret = this->roominfo.set_int_value(RECVBUF_USERID, "date", today);
		ret = this->roominfo.update_hotlist(RECVBUF_USERID, &hot_list);
	}
	else{
		if(hot_list.count < 500){
			uint32_t *iter = std::find(hot_list.visitors, hot_list.visitors + hot_list.count, p_in->userid);
			if(iter == hot_list.visitors + hot_list.count){
				ret=this->roominfo.add_hot(RECVBUF_USERID);
				hot_list.visitors[hot_list.count] = p_in->userid;
				++hot_list.count;
				ret = this->roominfo.update_hotlist(RECVBUF_USERID, &hot_list);
			}
		}//if(hot_list)
	}
	ret = SUCC;
	STD_RETURN(ret);
}

int Croute_func::user_get_xiaomee(DEAL_FUN_ARG)
{
	user_get_xiaomee_out out={};
	ret=this->user.get_xiaomee(RECVBUF_USERID,&(out.xiaomee));
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_get_vip_nick(DEAL_FUN_ARG)
{
	user_get_vip_nick_out out={};
	ret=this->user_ex.get_vip_nick(RECVBUF_USERID,&out );
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_get_nick_color(DEAL_FUN_ARG)
{
	uint32_t color = 0;
	user_get_nick_color_out out={};
	ret=this->user.get_mole_color(RECVBUF_USERID, color);
	if(ret == SUCC)
	{
		out.color = color;
		ret=this->user_ex.get_nick(RECVBUF_USERID, out.nick);
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

/**
 * @brief 设置FLAG标志
 */
int Croute_func::user_pet_set_flag(DEAL_FUN_ARG)
{
	user_pet_set_flag_in *p_in=PRI_IN_POS; 
	user_pet_set_flag_out out;
	ret=this->user_pet.set_flag(RECVBUF_USERID, p_in->petid, p_in->flag);
	if (ret != SUCC) {
		return ret;
	}
	ret = this->user_pet.get_one_pet(RECVBUF_USERID, p_in->petid, &out);
	STD_RETURN_WITH_STRUCT(ret, out);
}

/**
 * @brief 设置FLAG2标志
 */
int Croute_func::user_pet_set_flag2(DEAL_FUN_ARG)
{
	user_pet_set_flag2_in *p_in=PRI_IN_POS; 
	user_pet_set_flag2_out out;
	ret=this->user_pet.set_flag2(RECVBUF_USERID, p_in->petid, p_in->flag2);
	if (ret != SUCC) {
		return ret;
	}
	ret = this->user_pet.get_one_pet(RECVBUF_USERID, p_in->petid, &out);
	STD_RETURN_WITH_STRUCT(ret, out);
}


/**
 * @brief 设置宠物的名称
 */
int Croute_func::user_pet_set_nick(DEAL_FUN_ARG)
{
	user_pet_set_nick_in *p_in=PRI_IN_POS; 
	user_pet_set_nick_out out;
	ret = this->user_pet.set_nick(RECVBUF_USERID, p_in->petid, p_in->nickname);
	if (ret != SUCC) {
		return ret;
	}
	ret = this->user_pet.get_one_pet(RECVBUF_USERID, p_in->petid, &out);
	STD_RETURN_WITH_STRUCT(ret, out);
}

/**
 * @brief 设置宠物的生日
 */
int Croute_func::user_pet_set_birthday(DEAL_FUN_ARG)
{
	user_pet_set_birthday_in *p_in=PRI_IN_POS; 
	user_pet_set_birthday_out out;
	ret = this->user_pet.set_birthday(RECVBUF_USERID, p_in->petid, p_in->birthday);
	if (ret != SUCC) {
		return ret;
	}
	ret = this->user_pet.get_one_pet(RECVBUF_USERID, p_in->petid, &out);
	STD_RETURN_WITH_STRUCT(ret, out);
}


/**
 * @brief 设置宠物的颜色
 */
int Croute_func::user_pet_set_color(DEAL_FUN_ARG)
{
	user_pet_set_color_in *p_in=PRI_IN_POS; 
	user_pet_set_color_out out;
	ret=this->user_pet.set_color(RECVBUF_USERID, p_in->petid, p_in->color);
	if (ret != SUCC) {
		return ret;
	}
	ret = this->user_pet.get_one_pet(RECVBUF_USERID, p_in->petid, &out);
	STD_RETURN_WITH_STRUCT(ret, out);

}

/**
 * @brief 设置宠物的生病时间
 */
int Croute_func::user_pet_set_sicktime(DEAL_FUN_ARG)
{
	user_pet_set_sicktime_in *p_in=PRI_IN_POS; 
	user_pet_set_sicktime_out out;
	ret=this->user_pet.set_sicktime(RECVBUF_USERID, p_in->petid, p_in->sicktime);
	if (ret != SUCC) {
		return ret;
	}
	ret = this->user_pet.get_one_pet(RECVBUF_USERID, p_in->petid, &out);
	STD_RETURN_WITH_STRUCT(ret, out);
}

/**
 * @brief 设置终止时间
 */
int Croute_func::user_pet_set_endtime(DEAL_FUN_ARG)
{
	user_pet_set_endtime_in *p_in=PRI_IN_POS; 
	user_pet_set_endtime_out out;
	ret=this->user_pet.set_endtime(RECVBUF_USERID, p_in->petid, p_in->endtime);
	if (ret != SUCC) {
		return ret;
	}
	ret = this->user_pet.get_one_pet(RECVBUF_USERID, p_in->petid, &out);
	STD_RETURN_WITH_STRUCT(ret, out);
}

/**
 * @brief 设置心情值等
 */
int Croute_func::user_pet_set_life(DEAL_FUN_ARG)
{
	user_pet_set_life_in *p_in=PRI_IN_POS; 
	user_pet_set_life_out out={};
	ret = this->user_pet.set_life(RECVBUF_USERID, p_in->petid, p_in, &out);
	if (ret != SUCC) {
		return ret;
	}
	ret = this->user_pet.get_one_pet(RECVBUF_USERID, p_in->petid, &out);
	STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * @brief 喂养宠物
 */
int Croute_func::user_pet_feed_pet(DEAL_FUN_ARG)
{
	user_pet_feed_pet_in *p_in=PRI_IN_POS; 
	user_pet_feed_pet_out out={	};
	user_pet_set_life_in  pet_in;

	pet_in.change_hungry = p_in->change_hungry;
	pet_in.change_sanitary = p_in->change_sanitary;
	pet_in.change_spirit = p_in->change_spirit;
	pet_in.change_thirsty  =p_in->change_thirsty;
	pet_in.stamp = p_in->stamp;
	pet_in.petid = p_in->petid; 

	ret=this->user_pet.feed_pet(RECVBUF_USERID, p_in);
	if (ret != SUCC) {
		return ret;
	}
	ret = this->user_pet.set_get_pet(RECVBUF_USERID,  &pet_in, &out);
	if (ret != SUCC) {
		return ret;
	}
	if (p_in->feed_userid != RECVBUF_USERID) {
		ret = this->user_ex.jy_accesslist_set_opt(RECVBUF_USERID, p_in->feed_userid, FEED_PET_OPT_FLAG);
	}
	STD_RETURN_WITH_STRUCT(ret, out);
}


/*
 * @brief 宠物托管/领回
 */
int Croute_func::user_pet_retrieve_pet(DEAL_FUN_ARG)
{
	user_pet_retrieve_pet_in *p_in=PRI_IN_POS; 
	user_pet_retrieve_pet_out out;
	user_pet_set_life_in  pet_in;

	pet_in.change_hungry= p_in->change_hungry;
	pet_in.change_sanitary= p_in->change_sanitary;
	pet_in.change_spirit= p_in->change_spirit;
	pet_in.change_thirsty =p_in->change_thirsty;
	pet_in.stamp = p_in->stamp;
	pet_in.petid= p_in->petid;

	ret=this->user_pet.retrieve_pet(RECVBUF_USERID, p_in);
	if (ret != SUCC) {
		return ret;
	}
	ret = this->user_pet.set_get_pet(RECVBUF_USERID, &pet_in, &out);
	STD_RETURN_WITH_STRUCT(ret, out);
}


/*
 * @brief 接宠物任务
 */
int Croute_func::user_pet_get_pet(DEAL_FUN_ARG)
{
	user_pet_get_pet_in *p_in=PRI_IN_POS; 
	user_pet_get_pet_out out;
	user_pet_set_life_in  pet_in;

	pet_in.change_hungry= p_in->change_hungry;
	pet_in.change_sanitary= p_in->change_sanitary;
	pet_in.change_spirit= p_in->change_spirit;
	pet_in.change_thirsty=p_in->change_thirsty;
	pet_in.stamp = p_in->stamp;
	pet_in.petid = p_in->petid;

	ret=this->user_pet.get_pet(RECVBUF_USERID, p_in);
	if (ret != SUCC) {
		return ret;
	}
	ret = this->user_pet.set_get_pet(RECVBUF_USERID, &pet_in, &out);
	STD_RETURN_WITH_STRUCT(ret, out);
}

/* 
 * @brief  宠物出游等
 */
int Croute_func::user_pet_travel_pet(DEAL_FUN_ARG)
{
	user_pet_travel_pet_in *p_in=PRI_IN_POS; 
	user_pet_travel_pet_out out;
	ret=this->user_pet.travel_pet(RECVBUF_USERID, p_in);
	if (ret != SUCC) {
		return ret;
	}
	ret = this->user_pet.get_one_pet(RECVBUF_USERID, p_in->petid, &out);
	STD_RETURN_WITH_STRUCT(ret, out);
}


//user_task_ex

int Croute_func::user_task_set(DEAL_FUN_ARG)
{
	user_task_set_in *p_in=PRI_IN_POS; 
	//user_task_set_out out = {};

	ret = this->user_task_ex.update(RECVBUF_USERID, p_in);
	if (ret != SUCC) {
		ret = this->user_task_ex.insert(RECVBUF_USERID, p_in);
	}

	STD_RETURN_WITH_STRUCT(ret, *p_in);
}


int Croute_func::user_task_del(DEAL_FUN_ARG)
{
	user_task_del_in *p_in=PRI_IN_POS; 
	user_task_del_out out = {};
	out.taskid = p_in->taskid;
	ret=this->user_task_ex.del(RECVBUF_USERID, p_in->taskid);
	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::user_task_get(DEAL_FUN_ARG)
{
	user_task_get_in *p_in=PRI_IN_POS; 
	user_task_get_out out={};

	out.taskid = p_in->taskid;
	ret = this->user_task_ex.get(RECVBUF_USERID, p_in->taskid, &out);
	if (ret != SUCC) {
		memset(out.data, 0, TASK_LIST_EX_LEN);
		ret = SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}


int Croute_func::appeal_add_appeal(DEAL_FUN_ARG)
{
	appeal_add_appeal_in *p_in=PRI_IN_POS; 
	appeal_add_appeal_out out={};
	for(;;){
		p_in->id=100000000+ random()%10000000;
		ret=this->appeal.insert(p_in,&(out.id) );
		if (ret==SUCC){
			out.id=p_in->id;
			break;	
		}

	}
	STD_RETURN_WITH_STRUCT(ret,out);
}
int Croute_func::appeal_ex_add_appeal(DEAL_FUN_ARG)
{
	appeal_ex_add_appeal_in *p_in=PRI_IN_POS; 
	appeal_ex_add_appeal_out out={};
	for(;;){
		p_in->id=100000000+ random()%100000000;
		ret=this->appeal_ex.insert(p_in,&(out.id) );
		if (ret==SUCC){
			out.id=p_in->id;
			break;	
		}
		if(ret==DB_ERR) return ret;

	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::appeal_get_list(DEAL_FUN_ARG)
{
	appeal_get_list_in *p_in=PRI_IN_POS; 
	appeal_get_list_out_header  out_header;
	appeal_get_list_out_item *p_out_item;
	ret=this->appeal.getlist( p_in,&(out_header.count),&(p_out_item) );
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
int Croute_func::appeal_get_appeal(DEAL_FUN_ARG)
{
	appeal_get_appeal_in *p_in=PRI_IN_POS; 
	appeal_get_appeal_out out={};
	ret=this->appeal.get(p_in->id, &out );
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_swap_list(DEAL_FUN_ARG)
{
	user_swap_list_in_header *p_in=PRI_IN_POS;
	user_swap_list_in_item_1 *p_item_1;  	
	user_swap_list_in_item_2 *p_item_2;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER( 
			p_in->item1_count* sizeof (*p_item_1) +
			p_in->item2_count*sizeof (*p_item_2 ));

	p_item_1=(user_swap_list_in_item_1*)(RCVBUF_PRIVATE_POS+sizeof(*p_in) );
	p_item_2 =(user_swap_list_in_item_2 * ) (p_item_1+p_in->item1_count);

	DEBUG_LOG("count_1: %u, count_2: %u, sub_item: %u, add_item: %u",  p_in->item1_count,  p_in->item2_count, p_item_1->attireid, p_item_2->attireid);

	//开启事务
	STD_CLOSE_AUTOCOMMIT(ret); 
	if(ret!=SUCC) return ret;

	ret=this->do_user_swap_list(RECVBUF_USERID, p_in->reason, p_in->reason_ex, p_in->item1_count,p_item_1, 
			p_in->item2_count,p_item_2);
	if(ret==SUCC){
		//提交
		STD_COMMIT(ret); 
	}else{
		//回滚
		STD_ROLLBACK();
	}

	//关闭事务
	STD_OPEN_AUTOCOMMIT() ; 
	STD_RETURN(ret);
}
/*
 * 客服使用的交换协议
 */
int Croute_func::su_user_swap_list(DEAL_FUN_ARG)
{
	su_user_swap_list_in_header *p_in=PRI_IN_POS;
	su_user_swap_list_in_item_1 *p_item_1;  	
	su_user_swap_list_in_item_2 *p_item_2;
	uint32_t item1_count = *((uint32_t*)(RCVBUF_PRIVATE_POS + sizeof(*p_in)));
	uint32_t item2_count = *((uint32_t*)(RCVBUF_PRIVATE_POS + sizeof(*p_in) + 4 + item1_count*sizeof(su_user_swap_list_in_item_1)));

	CHECK_PRI_IN_LEN_WITHOUT_HEADER( 
			item1_count* sizeof (*p_item_1) +
			item2_count*sizeof (*p_item_2 ) + 8);

	p_item_1=(su_user_swap_list_in_item_1*)(RCVBUF_PRIVATE_POS+sizeof(*p_in) + 4);
	p_item_2 =(su_user_swap_list_in_item_2*)((char*)(p_item_1 + item1_count)+ 4);


	//开启事务
	STD_CLOSE_AUTOCOMMIT(ret); 
	if(ret!=SUCC) return ret;

	ret=this->do_user_swap_list(RECVBUF_USERID, p_in->reason, p_in->reason_ex, item1_count, p_item_1, 
			item2_count,p_item_2);
	if(ret==SUCC){
		//提交
		STD_COMMIT(ret); 
	}else{
		//回滚
		STD_ROLLBACK();
	}

	//关闭事务
	STD_OPEN_AUTOCOMMIT() ; 
	STD_RETURN(ret);
}

int Croute_func::do_user_swap_list(userid_t userid,uint32_t reason,uint32_t reason_ex,
		uint32_t in_item_1_count, user_swap_list_in_item_1 *p_item_1,
		uint32_t in_item_2_count, user_swap_list_in_item_2  *p_item_2)
{

	uint32_t i;
	//保存小米是否已增加到最大值的错误
	//	uint32_t xiaomee_enough_a_day_err=SUCC ;

	user_swap_list_in_item_1 *p_temp_item_1; 
	user_del_attire_in in_item; 
	in_item.maxcount=99999999;
	for  (i=0;i<in_item_1_count ;i++)
	{
		p_temp_item_1=p_item_1+i;
		if (p_temp_item_1->attireid == 1351056) {//修正商城积分问题
			p_temp_item_1->attiretype = 0;
		}
		if ( p_temp_item_1->attiretype==0 && p_temp_item_1->attireid < 100) {
			//扣钱
			if (p_temp_item_1->attireid==0){
				int ret_xiaomee;
				ret=this->user.change_xiaomee(userid, 
						-((int)p_temp_item_1->count),reason ,0,&ret_xiaomee );
				if(ret!=SUCC) return ret;
			} else if(p_temp_item_1->attireid==10) {
				ret = this->user_ex.add_bonus_used(userid,p_temp_item_1->count);
				if(ret!=SUCC) return ret;
			} else if( p_temp_item_1->attireid == 14){
				uint32_t exp = 0;
				ret = this->user_piglet_house.get_int_value(userid, "exp", &exp);
				if(ret == SUCC){
					ret = this->user_piglet_house.set_int_value(userid, "exp", exp - p_temp_item_1->count);
				}
				else{
					return ret;
				}
			}else if( p_temp_item_1->attireid == 16){
				uint32_t coin = 0;
				ret = this->user_ocean_info.get_coin(userid, &coin);
				if(coin > p_temp_item_1->count){
					uint32_t val = coin -  p_temp_item_1->count;
					ret = this->user_ocean_info.set_coin(userid, val);
				}
			}
			else {

				return ENUM_OUT_OF_RANGE_ERR; 	
			}

		}else{
			in_item.attiretype=p_temp_item_1->attiretype;
			in_item.attireid=p_temp_item_1->attireid;
			in_item.count=p_temp_item_1->count;
			ret=this->user_del_attire(userid, &in_item, 0);
			if(ret!=SUCC) return ret;
		}
	}

	user_swap_list_in_item_2 *p_temp_item_2; 
	user_change_user_value_in change_value_item ; 
	user_change_user_value_out change_value_out ; 

	user_add_attire_in out_item;
	uint32_t build_level = 0;	
	for  (i=0;i<in_item_2_count; i++)
	{
		p_temp_item_2=p_item_2+i;
		if ( p_temp_item_2->attiretype==0 && p_temp_item_2->attireid <= 16 ) {
			memset(&change_value_item,0,sizeof(change_value_item));
			change_value_item.reason=reason;

			switch ( p_temp_item_2->attireid  ){
				case 0:change_value_item.addxiaomee+=p_temp_item_2->count;
					  break;
				case 1:change_value_item.addexp+=p_temp_item_2->count;
					  break;
				case 2:change_value_item.addstrong+=p_temp_item_2->count;
					  break;
				case 3:change_value_item.addiq+=p_temp_item_2->count;
					  break;
				case 4:change_value_item.addcharm+=p_temp_item_2->count;
					  break;
				case 5:
					  {
						  build_level = p_temp_item_2->count;
						  ret = this->user_ex.update_build_level_inc(userid, build_level);
						  if(ret!=SUCC)
						  {
							  return ret;
						  }
						  continue; 
					  }
					  break;
				case 6:
					  {
						  uint32_t exp = p_temp_item_2->count;
						  ret = this->user_diningroom.update_exp_inc(userid, exp);
						  if(ret!=SUCC)
						  {
							  return ret;
						  }
						  continue; 
					  }
				case 7:
					  {
						  uint32_t growth = p_temp_item_2->count;
						  this->user_dragon.add_current_growth(userid,growth);
						  continue;
					  }
				case 9:
					  {
						  uint32_t add_exp = p_temp_item_2->count;
						  this->user_lamu_classroom.add_teacher_exp(userid,add_exp);
						  continue;
					  }
				case 10:
					  {
						  uint32_t add_count = p_temp_item_2->count;
						  this->user_ex.inc_months(userid, add_count);
						  continue;
					  }
				case 11:
					  {
						  uint32_t nourish_level = p_temp_item_2->count;
						  this->user_ex.update_nourish_level_inc(userid, nourish_level);
						  continue;
					  }
				case 12:
					  {
						  uint32_t angel_exp = p_temp_item_2->count;
						  this->user_paradise.add_paradise_exp(userid, angel_exp);
						  uint32_t plant_level = 0;
						  this->user_paradise.update_level(userid, plant_level);
							//更新种植上限
							bool is_vip;
							ret = this->user_ex.get_vip(userid, &is_vip);
							ret=this->user_paradise.update_limit_count_inc(userid, plant_level, is_vip);	
						  continue;
					  }
				case 14://猪倌经验
					  {
						 uint32_t exp_inc = p_temp_item_2->count;
						  ret = this->user_piglet_house.update_inc_col(userid, "exp", exp_inc);
						  if(ret != SUCC){
							  return ret;
						  }
						  continue;
					  }
				case 15://超拉成长值
					  {
						  uint32_t change_val = p_temp_item_2->count;
						  this->user_ex.inc_login_vip_mark(userid, change_val);
						  continue;
					  }
				case 16://海底世界贝壳币
					  {
						 this->user_ocean_info.update_coin(userid, p_temp_item_2->count);	
						 continue;
					  }
			}
			ret=this->user.change_user_value(userid,&change_value_item,&change_value_out );
			change_log_item c_item;
			c_item.userid=userid;
			c_item.change_type=10004;
			c_item.logtime=time(NULL);
			c_item.change_value=p_temp_item_2->count;
			c_item.change_v1=p_temp_item_2->attireid;
			c_item.change_v2=ret;
			DEBUG_LOG("ACTION REWARD [uid: %u; itemid: %u; count: %u]",userid, p_temp_item_2->attireid, p_temp_item_2->count);
			this->send_log.send(&c_item );
			if(ret!=SUCC) 
				return ret;
		}else{
			out_item.attiretype=p_temp_item_2->attiretype;
			out_item.attireid=p_temp_item_2->attireid;
			out_item.count=p_temp_item_2->count;
			out_item.maxcount=p_temp_item_2->maxcount;
			ret=this->user_add_attire(userid, &out_item, reason_ex);
			if(ret!=SUCC && (reason_ex != USER_SWAP_ATTIRE_NO_LIMIT || in_item_1_count != 0)) 
				return ret;
		}

	}

	return SUCC;
}
int Croute_func::hope_set_hope_ex(DEAL_FUN_ARG)
{
	hope_set_hope_ex_in *p_in=PRI_IN_POS; 
	ret=this->hope_history.set_ex(p_in->send_id,p_in->recv_id,p_in->old_hopedate,
			p_in->new_hopedate,p_in->recv_type);
	STD_RETURN(ret);
}

int Croute_func::userinfo_su_set_passwd(DEAL_FUN_ARG)
{
	userinfo_su_set_passwd_in *p_in=PRI_IN_POS; 
	ret=this->user_info.update_passwd(RECVBUF_USERID,p_in->passwd );
	if (ret == SUCC) {
		passwd_change_item item;
		item.userid = RECVBUF_USERID;
		item.opt_type=1003;
		item.time = time(NULL);
		memcpy(&item.passwd, &p_in->passwd, PASSWD_LEN);
		this->send_log.send_passwd(&item);

		{
			//同步论坛数据
			dv_change_passwd_in t; 		
			memcpy(t.newpasswd,	p_in->passwd,PASSWD_LEN);
			this->send_log.dv_change_passwd(RECVBUF_USERID, &t);
		}

		{
			//同步论坛数据,台湾版本需要
			TDV_CHANGE_PASSWD t;	
			t.msg_flag=DV_CHANGE_PASSWD_CMD;
			t.sendcount=0;	
			t.userid=RECVBUF_USERID;
			memcpy(t.newpasswd,	p_in->passwd,PASSWD_LEN);
			this->sync_user.send((char*) &t, sizeof(t) );
		}

	}

	STD_RETURN(ret);
}

int Croute_func::userinfo_su_set_paypasswd(DEAL_FUN_ARG)
{
	userinfo_su_set_paypasswd_in *p_in=PRI_IN_POS; 
	ret=this->user_info.set_paypasswd(RECVBUF_USERID, p_in->passwd	);
	if (ret == SUCC) {
		passwd_change_item item;
		item.userid = RECVBUF_USERID;
		item.opt_type=2003;
		item.time = time(NULL);
		memcpy(&item.passwd, &p_in->passwd, PASSWD_LEN);
		this->send_log.send_passwd(&item);
	}
	STD_RETURN(ret);
}
int Croute_func::appeal_deal(DEAL_FUN_ARG)
{
	appeal_deal_in *p_in=PRI_IN_POS; 
	ret=this->appeal.set_deal(p_in->id,p_in->state,p_in->dealflag,p_in->adminid );
	STD_RETURN(ret);
}
int Croute_func::appeal_ex_deal(DEAL_FUN_ARG)
{
	appeal_ex_deal_in *p_in=PRI_IN_POS; 
	ret=this->appeal_ex.set_deal(p_in);
	STD_RETURN(ret);
}

int Croute_func::user_pet_get_info(DEAL_FUN_ARG)
{
	user_pet_get_info_in *p_in=PRI_IN_POS; 
	user_pet_get_info_out_header  out_header;
	user_pet_get_info_out_item *p_out_item;
	ret=this->user_pet.get_one_pet(RECVBUF_USERID,p_in->petid,&(out_header.pet_info));
	if(ret!=SUCC) return ret;


	ret=this->user_pet_attire.get_list_by_attireid_interval(
			RECVBUF_USERID , p_in->petid, 0,0xFFFFFFFF,
			1, &(out_header.attirecount),&p_out_item);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.attirecount);
}

//question
/**
 * @param 如没有记录插入记录，否则更新相关的记录
 */

int Croute_func::roominfo_question_set(DEAL_FUN_ARG)
{
	roominfo_question_set_in *p_in=PRI_IN_POS; 
	if (p_in->right > 1 ) {
		return VALUE_OUT_OF_RANGE_ERR;
	}

	ret=this->roominfo_question.set(RECVBUF_USERID, p_in->right, p_in->question_id);
	STD_RETURN(ret);
}

/**
 * @param 得到用户记录的相关信息
 */
int Croute_func::roominfo_question_get(DEAL_FUN_ARG)
{
	roominfo_question_get_out out={};
	ret=this->roominfo_question.get(RECVBUF_USERID, out);
	if (ret == RECORD_NOT_EXIST_ERR) {
		ret = this->roominfo_question.insert(RECVBUF_USERID);
	}
	/*	
		if(out.question_id>999){
		out.question_id=999;
		}
		*/

	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::roominfo_box_get_list(DEAL_FUN_ARG)
{
	roominfo_pug_list_out out={};
	ret=this->roominfo.get_vote_list(RECVBUF_USERID ,STR_ROOM_PUGLIST , &out  );
	STD_RETURN_WITH_BUF(ret,(char*) &out,
			sizeof(out)-(ROOMINFO_PUG_LIST_LEN-out.count)*sizeof(out.item[0]));
}

/* 
 * @brief 设置家园的着火状态
 */

//int Croute_func::roominfo_set_jy_state(DEAL_FUN_ARG)
//{
//        roominfo_set_jy_state_in *p_in=PRI_IN_POS; 
//        roominfo_set_jy_state_out out={};
//
//        ret=this->roominfo_fire.set_state(p_in->state, p_in->fire, p_in->pos, RECVBUF_USERID);
//		if (ret != SUCC) {
//			return ret;
//		}
//		//ret = this->roominfo_fire.get(RECVBUF_USERID, out);
//        STD_RETURN_WITH_STRUCT(ret,out);
//}
//

/* 
 * @brief 设置家园的火势的大小
 */
/*int Croute_func::roominfo_set_jy_fire(DEAL_FUN_ARG)
  {
  roominfo_set_jy_fire_in *p_in=PRI_IN_POS; 
  roominfo_set_jy_fire_out out={};
  uint32_t temp;
  uint32_t die_flag = 0;
  ret=this->roominfo_fire.die_first(die_flag, p_in->fire, RECVBUF_USERID);
  if (ret != SUCC) {
  return ret;
  }

  out.alive_die = die_flag;
  ret = this->roominfo_fire.get_record(out, temp, RECVBUF_USERID);
  STD_RETURN_WITH_STRUCT(ret,out);
  }*/


/* 
 * @brief 得到家园火势的情况
 */
/* int Croute_func::roominfo_jy_fire_get(DEAL_FUN_ARG)
   {
   roominfo_jy_fire_get_out out={};
   ret=this->roominfo_fire.get(RECVBUF_USERID, out);
   DEBUG_LOG("===state %u",out.state);
   DEBUG_LOG("===alive %u", out.alive_die);
   STD_RETURN_WITH_STRUCT(ret,out);
   }*/

/* 
 * @brief 设置谁帮忙家园灭火
 */
int Croute_func::user_jy_access_set_opt(DEAL_FUN_ARG)
{
	user_jy_access_set_opt_in *p_in=PRI_IN_POS; 

	ret = this->user_ex.jy_accesslist_set_opt(RECVBUF_USERID, 
			p_in->opt_userid, p_in->opt_type );
	STD_RETURN(ret);
}


int Croute_func::dwg_sendmsg_to_friends(DEAL_FUN_ARG)
{
	dwg_sendmsg_to_friends_in_header *p_in=PRI_IN_POS; 
	CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(dwg_sendmsg_to_friends_in_item));
	dwg_sendmsg_to_friends_in_item * p_in_item=(dwg_sendmsg_to_friends_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;

	//保证最后有'\0'
	p_in->msg[sizeof(p_in->msg)-1]='\0';
	uint32_t now=time(NULL);

	//写数据
	for (uint32_t i=0;i<p_in->count ;i++ ){
		this->dwg_user_msg.insert((p_in_item +i)->id,RECVBUF_USERID,p_in->msg,now,p_in->flag  );
	}
	STD_RETURN(SUCC);
}

int Croute_func::user_profession_get(DEAL_FUN_ARG)
{
	user_profession_get_out out={};
	ret=this->user_ex.get_professionlist(RECVBUF_USERID,&out );
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_profession_set(DEAL_FUN_ARG)
{
	user_profession_set_in *p_in=PRI_IN_POS; 
	ret=this->user_ex.set_professionlist(RECVBUF_USERID,p_in);
	STD_RETURN(ret);
}

int Croute_func::sysarg_get_questionnaire_list(DEAL_FUN_ARG)
{
	sysarg_get_questionnaire_list_in *p_in=PRI_IN_POS; 
	sysarg_get_questionnaire_list_out_header  out_header;
	sysarg_get_questionnaire_list_out_item *p_out_item;
	ret=this->questionnaire.get_value_list(p_in->type ,&(out_header.count),&p_out_item );
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::sysarg_day_get_list_by_userid(DEAL_FUN_ARG)
{
	sysarg_day_get_list_by_userid_out_header  out_header;
	sysarg_day_get_list_by_userid_out_item *p_out_item;
	ret=this->usermap_day.get_value_list(RECVBUF_USERID, &(out_header.count),&p_out_item );
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::sysarg_day_set(DEAL_FUN_ARG)
{
	sysarg_day_set_in *p_in=PRI_IN_POS; 
	ret=this->usermap_day.insert(p_in->type,RECVBUF_USERID,p_in->count  );
	if (ret!=SUCC){
		ret=this->usermap_day.update(p_in->type,RECVBUF_USERID,p_in->count  );
	}

	STD_RETURN(ret);
}

int Croute_func::user_set_passwdemail_ex(DEAL_FUN_ARG)
{
	user_set_passwdemail_ex_in *p_in=PRI_IN_POS; 
	ret=this->user_info.update_passwdemail(RECVBUF_USERID,p_in->email  );
	STD_RETURN(ret);
}

int Croute_func::su_changelist_add(DEAL_FUN_ARG)
{
	su_changelist_add_in *p_in=PRI_IN_POS; 
	ret=this->changelist.insert(p_in);
	STD_RETURN(ret);
}

int Croute_func::roominfo_presentlist_add(DEAL_FUN_ARG)
{
	roominfo_presentlist_add_in *p_in=PRI_IN_POS; 
	ret=this->roominfo_list.presentlist_add(RECVBUF_USERID,p_in );
	STD_RETURN(ret);
}

int Croute_func::user_class_create(DEAL_FUN_ARG)
{
	user_class_create_in *p_in=PRI_IN_POS; 
	//创建班级
	ret=this->user_class.insert(RECVBUF_USERID,p_in);
	if (ret!=SUCC) return ret;
	//将班级ID,加入自己的班级列表
	ret=this->user_ex.add_id(RECVBUF_USERID,CLASS_LIST_STR ,RECVBUF_USERID, JOIN_CLASS_MAX);
	if (ret!=SUCC){
		//回滚
		this->user_class.del(RECVBUF_USERID);
	}
	STD_RETURN(ret);
}

int Croute_func::user_class_change_info(DEAL_FUN_ARG)
{
	user_class_change_info_in *p_in=PRI_IN_POS; 
	ret=this->user_class.change_info(RECVBUF_USERID,p_in );
	STD_RETURN(ret);
}

int Croute_func::user_class_get_info(DEAL_FUN_ARG)
{
	char out[PROTO_MAX_LEN]={ 0 };
	user_class_get_info_out_header * p_out_header=(user_class_get_info_out_header *)out ;
	stru_user_class_info info;
	memset(&info, 0, sizeof(stru_user_class_info));
	ret=this->user_class.get_info( RECVBUF_USERID, &info  );
	if (ret!=SUCC){ return ret; }

	//得到所有者的nick
	ret=this->user_ex.get_nick( RECVBUF_USERID, info.simple_info.onwernick  );
	if (ret!=SUCC){ return ret; }

	//复制simple_info
	memcpy(&(p_out_header->simple_info),&(info.simple_info),sizeof(p_out_header->simple_info )  );

	char * p_offset=&(out[0])+sizeof(* p_out_header);
	uint32_t cpy_len = 0;


	//复制成员数据
	p_out_header->item1_count=info.memberlist.count;
	cpy_len=(sizeof(user_class_get_info_out_item_1)* p_out_header->item1_count) ;
	memcpy(p_offset,&(info.memberlist.item[0]) ,cpy_len);
	p_offset+=cpy_len;


	//复制家具列表
	p_out_header->item2_count=info.home_used_list.count;
	cpy_len=(sizeof(user_class_get_info_out_item_2)* p_out_header->item2_count) ;
	memcpy(p_offset,&(info.home_used_list.item[0]) ,cpy_len);
	p_offset+=cpy_len;


	STD_RETURN_WITH_BUF(ret, out , p_offset -&(out[0]));

}
int Croute_func::su_user_class_get_info(DEAL_FUN_ARG)
{
	char out[PROTO_MAX_LEN]={ 0 };
	su_user_class_get_info_out_header* p_out_header=(su_user_class_get_info_out_header *)out ;
	stru_user_class_info info ;
	memset(&info, 0,sizeof(stru_user_class_info));
	ret=this->user_class.get_info( RECVBUF_USERID, &info  );
	if (ret!=SUCC){ return ret; }

	//得到所有者的nick
	ret=this->user_ex.get_nick( RECVBUF_USERID, info.simple_info.onwernick  );
	if (ret!=SUCC){ return ret; }

	//复制simple_info
	memcpy(&(p_out_header->simple_info),&(info.simple_info),sizeof(p_out_header->simple_info )  );

	char * p_offset=&(out[0])+sizeof(* p_out_header) - 8;
	uint32_t cpy_len = 0;


	//复制成员数据
	uint32_t item1_count = info.memberlist.count;
	cpy_len = (sizeof(su_user_class_get_info_out_item_1)* item1_count) ;
	*((uint32_t*)p_offset) = item1_count; 
	p_offset += 4;
	if(cpy_len != 0){
		memcpy(p_offset,&(info.memberlist.item[0]) ,cpy_len);
		p_offset+=cpy_len;
	}

	cpy_len = 0;
	//复制家具列表
	uint32_t item2_count = info.home_used_list.count;
	cpy_len = (sizeof(su_user_class_get_info_out_item_2) * item2_count) ;
	*((uint32_t*)p_offset) = item2_count; 
	p_offset += 4;
	if(cpy_len != 0){
		memcpy(p_offset,&(info.home_used_list.item[0]) ,cpy_len);
		p_offset+=cpy_len;
	}

	STD_RETURN_WITH_BUF(ret, out , p_offset -&(out[0]));

}


int Croute_func::roominfo_presentlist_get(DEAL_FUN_ARG)
{
	stru_presentlist list;

	ret=this->roominfo_list.get_presentlist( RECVBUF_USERID,&list);
	if (ret!=SUCC) return ret;
	STD_RETURN_WITH_BUF(ret,(char*) &list,
			4+sizeof(list.items[0])*(list.count));
}


int Croute_func::user_class_add_member(DEAL_FUN_ARG)
{
	user_class_add_member_in *p_in=PRI_IN_POS; 
	ret=this->user_class.add_id(RECVBUF_USERID,CLASS_MEMBERLIST_STR,p_in->memberid );
	if (ret==LIST_ID_EXISTED_ERR ){
		ret=SUCC;
	}else if (ret==LIST_ID_MAX_ERR) {
		ret=CLASS_MEMBER_MAX_COUNT_ERR;
	}


	STD_RETURN(ret);
}

int Croute_func::user_class_del_member(DEAL_FUN_ARG)
{
	user_class_del_member_in *p_in=PRI_IN_POS; 
	ret=this->user_class.del_id(RECVBUF_USERID,CLASS_MEMBERLIST_STR,p_in->memberid );
	if (ret==LIST_ID_NOFIND_ERR){
		ret=CLASS_MEMBER_NOFIND_ERR;
	}

	STD_RETURN(ret);
}

int Croute_func::user_class_add_attire(DEAL_FUN_ARG)
{
	user_class_add_attire_in *p_in=PRI_IN_POS; 
	ret=this->user_class.add_home_attire( CLASS_HOME_STR,RECVBUF_USERID,&(p_in->opt_item));
	if(ret!=SUCC) return ret;
	stru_opt_log_item item;
	item.userid=p_in->memberid;
	item.id_ex=p_in->opt_item.attireid;
	memcpy(&(item.value[0]),&(p_in->value[0]),sizeof(p_in->value)  );

	ret=this->user_class.benefactor_list_add(RECVBUF_USERID,&item );

	STD_RETURN(ret);
}

int Croute_func::user_add_class(DEAL_FUN_ARG)
{
	user_add_class_in *p_in=PRI_IN_POS; 
	ret=this->user_ex.add_id(RECVBUF_USERID,CLASS_LIST_STR ,p_in->classid, JOIN_CLASS_MAX);
	if (ret==LIST_ID_EXISTED_ERR ){
		ret=SUCC;
	}else if (ret==LIST_ID_MAX_ERR) {
		ret=CLASSID_MAX_COUNT_ERR;
	}

	STD_RETURN(ret);
}

int Croute_func::user_del_class(DEAL_FUN_ARG)
{
	user_del_class_in *p_in=PRI_IN_POS; 
	ret=this->user_ex.del_id(RECVBUF_USERID,CLASS_LIST_STR ,p_in->classid );

	if (ret==LIST_ID_NOFIND_ERR){
		ret=CLASSID_NOFIND_ERR;
	}
	if (ret!=SUCC) return ret;

	//---------------------
	uint32_t first_classid;
	ret=this->user_ex.get_int_value(RECVBUF_USERID,CLASS_FIRSTID_STR,&first_classid);
	if (first_classid==p_in->classid ){
		ret=this->user_ex.set_int_value(RECVBUF_USERID,CLASS_FIRSTID_STR,0);
	}

	STD_RETURN(ret);
}

int Croute_func::user_class_get_flag_info(DEAL_FUN_ARG)
{
	user_class_get_flag_info_out out={};
	ret=this->user_class.get_flag_info(RECVBUF_USERID,&out );
	STD_RETURN_WITH_STRUCT(ret,out);
}



int Croute_func::user_class_edit_home(DEAL_FUN_ARG)
{
	user_class_edit_home_in_header *p_in= PRI_IN_POS;
	home_attirelist  usedlist;


	CHECK_PRI_IN_LEN_WITHOUT_HEADER(
			sizeof (home_attire_item)* p_in->item1_count);


	if (p_in->item1_count>HOME_ATTIRE_ITEM_MAX){
		return VALUE_OUT_OF_RANGE_ERR; 
	}

	//构造结构
	usedlist.count=p_in->item1_count;
	memcpy(usedlist.item, ((char*)p_in)+sizeof(*p_in),
			sizeof(usedlist.item[0] )*usedlist .count);

	ret=this->user_class.update_homeattire_all(CLASS_HOME_STR,RECVBUF_USERID,
			&usedlist);
	STD_RETURN (ret );

}

int Croute_func::user_change_xiaomee(DEAL_FUN_ARG)
{
	user_change_xiaomee_in *p_in=PRI_IN_POS; 
	user_change_xiaomee_out out={};
	int xiaomee ;
	ret=this->user.change_xiaomee(RECVBUF_USERID,p_in->change_xiaomee,p_in->reason,
			p_in->reason_ex,&xiaomee);
	out.left_xiaomee=xiaomee;
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_class_del(DEAL_FUN_ARG)
{

	id_list out;
	ret=this->user_class.get_idlist(RECVBUF_USERID ,CLASS_MEMBERLIST_STR ,&out);
	if (ret!=SUCC) return ret;

	ret=this->user_class.del(RECVBUF_USERID);
	if (ret!=SUCC) return ret;
	ret=this->user_classmsg.del_class(RECVBUF_USERID);
	if (ret!=SUCC) return ret;

	uint32_t  private_size;
	private_size=sizeof(out)-(ID_LIST_MAX -out.count)*sizeof(out.item[0]);
	STD_RETURN_WITH_BUF(ret,(char*)&out , private_size );
}
int Croute_func::sysarg_month_task_get_list(DEAL_FUN_ARG)
{
	sysarg_month_task_get_list_out_header  out_header;
	sysarg_month_task_get_list_out_item *p_out_item;
	ret=this->month_task.get_value_list(RECVBUF_USERID,&(out_header.count), &p_out_item);	
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::sysarg_month_task_add(DEAL_FUN_ARG)
{
	sysarg_month_task_add_in *p_in=PRI_IN_POS; 
	sysarg_month_task_add_out out = {};
	ret=this->month_task.add(p_in->type,RECVBUF_USERID, p_in->maxvalue );
	out.type = p_in->type;
	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::user_set_first_class(DEAL_FUN_ARG)
{
	user_set_first_class_in *p_in=PRI_IN_POS; 
	ret=this->user_ex.set_int_value(RECVBUF_USERID,CLASS_FIRSTID_STR,p_in->class_firstid );
	STD_RETURN(ret);
}

int Croute_func::user_class_set_access_flag(DEAL_FUN_ARG)
{
	user_class_set_access_flag_in *p_in=PRI_IN_POS; 
	ret=this->user_class.set_int_value(RECVBUF_USERID,CLASS_ACCESS_FLAG_STR,p_in->class_jion_flag);
	STD_RETURN(ret);
}

int Croute_func::ff_login_add(DEAL_FUN_ARG)
{
	ff_login_add_in *p_in=PRI_IN_POS; 
	ret=this->login_info.add(RECVBUF_USERID,p_in);
	STD_RETURN(ret);
}

int Croute_func::user_class_get_attirelist(DEAL_FUN_ARG)
{

	noused_homeattirelist noused_homeattirelist ; 	
	ret =this->user_class.get_noused_home_attirelist(CLASS_HOME_STR ,RECVBUF_USERID,
			&noused_homeattirelist);
	if (ret!=SUCC) return ret;

	uint32_t  private_size;
	if (ret==SUCC&& noused_homeattirelist.count>HOME_NOUSE_ATTIRE_ITEM_MAX ){
		ERROR_LOG(" __ERROR__  DB_DATA_ERR %u ",noused_homeattirelist.count);
		return USER_ATTIRE_MAX_ERR;		
	}
	private_size= sizeof(noused_homeattirelist )-
		(HOME_NOUSE_ATTIRE_ITEM_MAX -noused_homeattirelist.count)*
		sizeof(noused_homeattirelist .item[0]);

	STD_RETURN_WITH_BUF(ret,&noused_homeattirelist,private_size);
}

int Croute_func::user_classmsg_add(DEAL_FUN_ARG)
{
	user_classmsg_add_in *p_in=PRI_IN_POS; 
	ret=this->user_classmsg.add_msg(RECVBUF_USERID,p_in);
	STD_RETURN(ret);
}


int Croute_func::user_classmsg_set_show_flag(DEAL_FUN_ARG)
{
	user_classmsg_set_show_flag_in *p_in=PRI_IN_POS; 
	ret=this->user_classmsg.show_msg(RECVBUF_USERID,p_in );
	STD_RETURN(ret);
}

int Croute_func::user_classmsg_get_list(DEAL_FUN_ARG)
{
	user_classmsg_get_list_in *p_in=PRI_IN_POS; 
	user_classmsg_get_list_out_header  out_header;
	user_classmsg_get_list_out_item *p_out_item;
	ret=this->user_classmsg.get_list(RECVBUF_USERID, p_in, &out_header.msg_total, &out_header.msg_count,&p_out_item);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.msg_count);
}

int Croute_func::user_classmsg_del(DEAL_FUN_ARG)
{
	user_classmsg_del_in *p_in=PRI_IN_POS; 
	ret=this->user_classmsg.del_msg(RECVBUF_USERID,p_in );
	STD_RETURN(ret);
}

int Croute_func::user_classmsg_report(DEAL_FUN_ARG)
{
	user_classmsg_report_in *p_in=PRI_IN_POS; 
	ret=this->user_classmsg.res_msg(RECVBUF_USERID,p_in);
	STD_RETURN(ret);
}

int Croute_func::user_class_reduce_attire(DEAL_FUN_ARG)
{
	user_class_reduce_attire_in *p_in=PRI_IN_POS; 
	attire_count_with_max item={ };
	item.attireid=p_in->attireid;
	item.count=p_in->count;
	ret=this->user_class.del_home_attire_noused(CLASS_HOME_STR,RECVBUF_USERID,&item );
	STD_RETURN(ret);
}

int Croute_func::user_class_get_simple_info(DEAL_FUN_ARG)
{
	user_class_get_simple_info_out out={};
	ret=this->user_class.get_simple_info(RECVBUF_USERID,&out );
	if(ret!=SUCC) return ret;

	//得到所有者的nick
	ret=this->user_ex.get_nick( RECVBUF_USERID, out.onwernick  );

	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_get_first_class(DEAL_FUN_ARG)
{

	user_get_first_class_out out={};
	ret=this->user_ex.get_int_value(RECVBUF_USERID, CLASS_FIRSTID_STR,&(out.class_firstid) );
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_class_get_memberlist(DEAL_FUN_ARG)
{
	id_list out;
	ret=this->user_class.get_idlist(RECVBUF_USERID ,CLASS_MEMBERLIST_STR ,&out);
	if (ret!=SUCC) return ret;

	uint32_t  private_size;
	private_size=sizeof(out)-(ID_LIST_MAX -out.count)*sizeof(out.item[0]);
	STD_RETURN_WITH_BUF(ret,(char*)&out , private_size );
}

int Croute_func::user_get_classlist(DEAL_FUN_ARG)
{
	stru_user_class_list out;
	ret=this->user_ex.get_classlist( RECVBUF_USERID ,&out);
	if (ret!=SUCC) return ret;

	uint32_t  private_size;
	private_size=sizeof(out)-(JOIN_CLASS_MAX -out.classlist.count)*sizeof(out.classlist.classid[0]);
	STD_RETURN_WITH_BUF(ret,(char*)&out , private_size );
}

/* 偷取果实 */
int Croute_func::user_thieve_fruit(DEAL_FUN_ARG)
{
	user_thieve_fruit_in *p_in=PRI_IN_POS; 
	user_thieve_fruit_out out={};
	uint32_t fruitid;
	//jy_item item = {};
	ret=this->user_jy.thieve_fruit(RECVBUF_USERID, p_in->thiever_id, p_in->id, &out.item);
	if (ret != SUCC) {
		return ret;
	}
	ret=this->user_jy.get_fruitid(out.item.attireid, out.item.pollinate_num, &fruitid);	
	if (ret != SUCC) {
		return ret;
	}
	out.fruitid = fruitid;
	ret = this->user_ex.jy_accesslist_set_opt(RECVBUF_USERID, 
			p_in->thiever_id, 0x10);

	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::roominfo_check_if_gen_vip(DEAL_FUN_ARG)
{
	roominfo_check_if_gen_vip_out out={};
	ret=this->roominfo_gen_vip.check_done_today(RECVBUF_USERID, &out.vip_flag);
	STD_RETURN_WITH_STRUCT(ret,out);
}


int Croute_func::croominfo_gen_vip(DEAL_FUN_ARG)
{
	//croominfo_gen_vip_in *p_in=PRI_IN_POS; 
	croominfo_gen_vip_out out={};
	ret=this->roominfo_gen_vip.gen_vip(RECVBUF_USERID, &out.vip_flag);
	STD_RETURN_WITH_STRUCT(ret,out);
}
int Croute_func::roominfo_class_qa_add_score(DEAL_FUN_ARG)
{
	roominfo_class_qa_add_score_in *p_in=PRI_IN_POS; 
	roominfo_class_qa_add_score_out out={};
	ret=this->class_qa.add_score(RECVBUF_USERID,p_in ,&out  );
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::roominfo_class_qa_check_add(DEAL_FUN_ARG)
{
	roominfo_class_qa_check_add_in *p_in=PRI_IN_POS; 
	roominfo_class_qa_check_add_out out={};
	ret=this->class_qa.check_add(RECVBUF_USERID,p_in,&out);
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_class_get_random_top(DEAL_FUN_ARG)
{
	//user_class_get_random_top_out_header  out_header;
	//user_class_get_random_top_out_item *p_out_item;
	////ret=this->
	//STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
	return SUCC;
}

int Croute_func::roominfo_class_qa_get_info(DEAL_FUN_ARG)
{
	roominfo_class_qa_get_info_out out={};
	ret=this->class_qa.get_int_value(RECVBUF_USERID,"score",&(out.all_score));
	if (ret!=SUCC){
		out.all_score=0;
		ret=SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}



/* 删除一个动物的信息，并且把它放到收集品中 */
int Croute_func::user_del_animal(DEAL_FUN_ARG)
{
	user_del_animal_in *p_in=PRI_IN_POS; 
	user_del_animal_out out={};
	animal_select animal;
	uint32_t animal_type = 0;
	ret = this->user_farm_animal.get_one_animal_info(RECVBUF_USERID, p_in->id, &animal, &animal_type);
	if (ret != SUCC) {
		return ret;
	}
	if(animal.level > 0){ //如果摩摩仓库星级动物如果大于上线，则不能再捕获星级动物
		uint32_t count_in_fairy = 0;
		ret = this->user_farm_fairy.get_warehouse_count(RECVBUF_USERID, count_in_fairy);
		if(ret != SUCC){
			return ret;
		}else{
			if(count_in_fairy >= 300){
				return  REACHED_MAX_CAPTURE_FAIRY_ERR;
			}
		}
	}
	out.level =animal.level;
	if ((animal.outgo & 0x08) == 0x08) {
		return ANIMAL_IS_NOT_EXIST_ERR;
	}

	if (animal.mature_time == 0) {
		return ANIMAL_NOT_ADULT_ERR;
	}
	if (animal_type == 0) {
		bool is_vip = 0;
		ret=this->user_ex.get_vip(RECVBUF_USERID, &is_vip);
		if (ret != SUCC) {
			return ret;
		}
		int32_t range = 5;
		if (is_vip) {
			range = 20;
		}
		if ((rand() % 100) < range) {
			//池塘里增加龙虾
			uint32_t count = 0;
			ret = this->user_farm_animal.get_one_animal_count_sql(RECVBUF_USERID, 1270021, &count);
			if (ret != SUCC) {
				return ret;
			}
			if (count < 5 ) {
				uint32_t id = 0;
				uint32_t max_output = 0;
				ret = this->user_farm_animal.insert(RECVBUF_USERID, 1270021, 0, &id, &max_output);
				if (ret != SUCC) {
					return ret;
				}
			}
		}
	}


	//得到对应的成年动物ID
	uint32_t adult_id;
	ret = this->user_farm_animal.get_adult_id(animal.animal_id, &adult_id);
	if (ret != SUCC) {
		return ret;
	}
	out.animal_id = adult_id;
	if (p_in->userid == RECVBUF_USERID) {
		if(animal.level == 0){//普通动物
			uint32_t animal_usedcount = 0;
			uint32_t animal_count = 0;
			uint32_t chest = 0;
			uint32_t mode = 0;
			ret = this->user_attire.get(RECVBUF_USERID, adult_id, &animal_usedcount, &animal_count, &chest, &mode);
			if (ret != SUCC && ret != ATTIRE_COUNT_NO_ENOUGH_ERR) {
				return ret;
			}
			//增加物品
			user_add_attire_in	add_item = { };
			if (animal_count + 1 > 99999) {
				return ADULT_ANIMAL_THAN_MAX_ERR;
			}
			add_item.attiretype = 0;
			add_item.attireid = adult_id;
			add_item.count = 1;

			//最多99999个
			add_item.maxcount = 99999;

			ret = this->user_add_attire(RECVBUF_USERID,&add_item);
			if (ret==VALUE_OUT_OF_RANGE_ERR){
				//果实个数超过最大数
				return	USER_ATTIRE_MAX_ERR;
			} else if (ret != SUCC) {
				return ret;
			}
		}else{//星级动物                                                               //34代表星级动物捕获到仓库中状态
			ret = this->user_farm_fairy.update_state_by_id(RECVBUF_USERID,animal.id, 34);
			if(ret != SUCC){
				user_farm_fairy_in fairy_info={ 0 };
				fairy_info.id = animal.id;
				fairy_info.animal_id = animal.animal_id;
				fairy_info.adult_id = adult_id;
				fairy_info.state = 34;
				fairy_info.level = animal.level;
				ret = this->user_farm_fairy.insert(RECVBUF_USERID, &fairy_info);
				if(ret != SUCC)
					return ret;
			}
			if(animal.level == 3){
				ret = this->user_farm.update_count(RECVBUF_USERID, 1);
			}
		}
	} else {
		uint32_t type;
		ret = this->user_farm_animal.get_animal_type(animal.animal_id, &type);
		if (ret != SUCC) {
			return ret;
		}
		if (animal_type != 0) {
			return THIS_ANIMAL_NOT_WATER_ANIMAL_ERR;
		}
		ret = this->user_farm.thiever_animal(RECVBUF_USERID, p_in->userid, p_in->id, type);
		if (ret != SUCC) {
			return ret;
		}
		ret = this->user_farm.jy_accesslist_set_opt(RECVBUF_USERID, p_in->userid, 0X01);
		if (ret != SUCC) {
			return ret;
		}
	}
	uint32_t exp = 0;
	this->user_farm_animal.get_exp(adult_id, &exp);
	ret = this->user_farm.catch_get_exp(RECVBUF_USERID, 2, exp, &out.exp);
	ret=this->user_farm_animal.del(RECVBUF_USERID, p_in->id);
	//把相应的动物放到图鉴中去

	if(attire_id_in_pic_list(animal.animal_id)
			|| attire_id_is_mature_id_in_pic_list(animal.animal_id))
	{
		//把装扮加入图鉴列表中，为每一个用户
		this->user_pic_book.insert(RECVBUF_USERID, animal.animal_id);
	}

	STD_RETURN_WITH_STRUCT(ret, out);
}


int Croute_func::do_user_farm_feedstuff_add( userid_t userid , 
		user_farm_feedstuff_add_in *p_in,
		stru_user_farm_feedstuff_add_out_buf * p_out    )
{
	if (p_in->type == userid) {
		user_del_attire_in temp;
		temp.attiretype = 0;
		temp.attireid = p_in->goods.type;
		temp.count = p_in->goods.food_num;
		temp.maxcount = 99999;
		//从个人装扮里删除要添加的物品
		ret=this->user_del_attire(userid, &temp);
		if (ret != SUCC) { 
			return ret; 
		}

	} else {
		ret = user_farm.jy_accesslist_set_opt(userid, p_in->type, 0X02);
		if (ret != SUCC) {
			return ret;
		}
	}
	//this->user_farm.add_other(userid, p_in->goods.food_num * 2, 2, &p_out->exp);
	attire_count_with_max temp;
	temp.attireid = p_in->goods.type;
	temp.count = p_in->goods.food_num;
	temp.maxcount = 99999;
	return this->user_farm.add_feedstuff(&temp, userid, &(p_out->noused_list));
}

/* 向饲料房里增加物品 */
int Croute_func::user_farm_feedstuff_add(DEAL_FUN_ARG)
{
	user_farm_feedstuff_add_in *p_in=PRI_IN_POS; 
	stru_user_farm_feedstuff_add_out_buf out;

	STD_CLOSE_AUTOCOMMIT(ret); 
	if(ret!=SUCC) return ret;

	ret=this->do_user_farm_feedstuff_add(RECVBUF_USERID, p_in, &out);
	if(ret==SUCC){
		//提交
		STD_COMMIT(ret); 
	}else{
		//回滚
		STD_ROLLBACK();
	}
	//关闭事务
	STD_OPEN_AUTOCOMMIT() ; 
	out.type = p_in->type;
	STD_RETURN_WITH_BUF(ret, &out, 8 + sizeof(out. noused_list.item[0]) *out. noused_list.count);
}

/* 把仓库里的动物放到农场里 */
int Croute_func::user_farm_put_animal(DEAL_FUN_ARG)
{
	user_farm_put_animal_in *p_in=PRI_IN_POS; 
	user_farm_put_animal_out out = {};
	user_del_attire_in temp;
	uint32_t now =time(0);
	uint32_t type = 0;
	uint32_t level = 0;
	const uint32_t animal_egg_start_id = 1270076;//天使蛋起始id
	const uint32_t animal_egg_end_id = 1270125;// 天使蛋终止id
	uint32_t primitive_id = p_in->animal_id;
	if(p_in->animal_id >= animal_egg_start_id && p_in->animal_id <= animal_egg_end_id)
	{
		uint32_t animal = p_in->animal_id;
		ret=this->user_farm_animal.judge_egg(animal, level);
		p_in->animal_id = animal;
	}
	ret = this->user_farm_animal.get_animal_kind(p_in->animal_id, &type);
	if (ret != SUCC) {
		return ret;
	}
	ret = this->user_farm_animal.special_animal_check(RECVBUF_USERID, p_in->animal_id);
	if (ret != SUCC) {
		return ret;
	}
	ret = this->user_farm_animal.check_animal_max_limit(RECVBUF_USERID, type);
	if (ret != SUCC) {
		return ret;
	}
	temp.attiretype = 0;
	//temp.attireid = p_in->animal_id;
	temp.attireid =  primitive_id;
	temp.count = 1;
	temp.maxcount = 999;

	//开启事务
    STD_CLOSE_AUTOCOMMIT(ret);
    if(ret!=SUCC) return ret;

	//从个人装扮里删除要添加的物品
	ret = this->user_del_attire(RECVBUF_USERID, &temp);
	if (ret == SUCC) {
		ret = this->user_farm_animal.insert(RECVBUF_USERID, p_in->animal_id, type, &(out.item.id), &out.item.max_output,level);
		if(ret == SUCC){
			if(primitive_id >= animal_egg_start_id && primitive_id <= animal_egg_end_id && level != 0){
				user_farm_fairy_in fairy_info={0};
				fairy_info.id = out.item.id;
				fairy_info.animal_id = p_in->animal_id;
				ret = this->user_farm_animal.get_adult_id(p_in->animal_id, &(fairy_info.adult_id));
				
				fairy_info.level = level;
				out.item.level = level;
				fairy_info.state = 17;//17代表星级动物进入牧场
				if(ret == SUCC){
					ret = this->user_farm_fairy.insert(RECVBUF_USERID, &fairy_info);
				}
			}else{
				out.item.level = 0;
			}
		}// 内部if(ret==SUCC)
	}
    if(ret==SUCC){
        //提交
        STD_COMMIT(ret);
    }else{
        //回滚
        STD_ROLLBACK();
    }
    //关闭事务
    STD_OPEN_AUTOCOMMIT() ;	

	out.item.animal_id = p_in->animal_id;
	out.item.state = 0;
	out.item.growth = 0;
	out.item.eat_time = now;
	out.item.drink_time = now;
	out.item.total_output = 0;
	out.item.lastcal_time = now;
	out.item.mature_time = 0;
	out.item.animal_type = type;
	out.item.favor = 100;
	out.item.favor_time = now;
	out.item.outgo = 0;
	ret = this->user_farm_animal.fill_attribute(&out.item);
	out.item.favor = 100;
	STD_RETURN_WITH_STRUCT(ret, out );
}

/* 水池里加水 */
int Croute_func::user_farm_water(DEAL_FUN_ARG)
{

	char out[PROTO_MAX_LEN];
	user_farm_water_out_header *p_out=(user_farm_water_out_header *)out;
	animal_select *p_list;
	uint32_t count = 0;
	ret = SUCC;
	ret=this->user_farm_animal.animal_drink(RECVBUF_USERID, &p_list, &count);
	if (ret != SUCC) {
		free(p_list);
		return ret;
	}
	for (uint32_t i = 0; i < count; i++) {
		ret = this->user_farm_animal.fill_attribute(p_list + i);
		if (ret != SUCC) {
			return ret;
		}
	}
	ret = this->user_farm.set_water_time(RECVBUF_USERID);
	if (ret != SUCC) {
		free(p_list);
		return ret;
	}
	p_out->item1_out = count;
	char *p_offset = out;
	p_offset += sizeof(user_farm_water_out_header);
	memcpy(p_offset, p_list, sizeof(animal_select) * count);
	p_offset += sizeof(animal_select) * count;
	free(p_list);
	STD_RETURN_WITH_BUF(ret, out, p_offset - out);
}

/* 得到鱼的状态 */
int Croute_func::user_farm_get_fish(DEAL_FUN_ARG)
{
	user_farm_get_fish_in *p_in = PRI_IN_POS;
	char out[PROTO_MAX_LEN];
	animal_select *p_list;
	uint32_t count;
	user_farm_get_fish_out_header *p_out = (user_farm_get_fish_out_header*)out;
	//0表示水生动物，1表示陆生动物,2表示昆虫
	ret = this->user_farm_animal.get_animal_by_type_ex(RECVBUF_USERID, p_in->animal_type, &p_list, &count);
	if (ret != SUCC) {
		free(p_list);
		return ret;
	}
	for (uint32_t i = 0; i < count; i++) {
		this->user_farm_animal.fill_attribute(p_list + i);
		if ((p_list + i)->animal_id == 1270021) {
			(p_list + i)->state = 0;
		}
	}
	p_out->animal_type = p_in->animal_type;
	p_out->item1_out = count;
	memcpy(out + sizeof(user_farm_get_fish_out_header), p_list, sizeof(animal_select) * count);
	uint32_t len = sizeof(user_farm_get_fish_out_header) + sizeof(animal_select) * count;
	free(p_list);
	STD_RETURN_WITH_BUF(ret, out, len);
}

int Croute_func::user_connect_set_childcount(DEAL_FUN_ARG)
{
	user_connect_set_childcount_in *p_in=PRI_IN_POS; 
	ret=this->user_connect.set_int_value(RECVBUF_USERID,STR_USER_CONNECT_CHILDCOUNT,p_in->childcount );
	if (ret==USER_ID_NOFIND_ERR){
		ret=this->user_connect.init(RECVBUF_USERID,0,0);
		ret=this->user_connect.set_int_value(RECVBUF_USERID,STR_USER_CONNECT_CHILDCOUNT,p_in->childcount );
	}
	STD_RETURN(ret);
}

int Croute_func::roominfo_gen_vip_del(DEAL_FUN_ARG)
{
	ret=this->roominfo_gen_vip.del(RECVBUF_USERID);
	STD_RETURN(ret);
}


int Croute_func::user_farm_set_accestlist(DEAL_FUN_ARG)
{
	user_farm_set_accestlist_in *p_in=PRI_IN_POS;
	if (p_in->opt_type == 0) {
		ret=this->user_farm.access_jy(RECVBUF_USERID, p_in);
		if (ret != SUCC) {
			return ret;
		}
	} else {
		ret = this->user_farm.jy_accesslist_set_opt(RECVBUF_USERID, p_in->userid, p_in->opt_type);
		if (ret != SUCC) {
			return ret;
		}
	}

	if ((p_in->opt_type & 0x04) == 0x04) {
		uint32_t value = 0;
		ret = this->user_farm.change_int_field_without_max_check(RECVBUF_USERID, "sheep", 1, &value);
	}
	STD_RETURN(ret);
}

int Croute_func::user_farm_get_accestlist(DEAL_FUN_ARG)
{
	access_jylist temp;
	ret=this->user_farm.get_jyaccess_list(RECVBUF_USERID, &temp);
	if (ret != SUCC) {
		return ret;
	}
	STD_RETURN_WITH_BUF(ret, &temp, 4 + sizeof(temp.item[0]) * temp.count);
}

int Croute_func::user_card_set_flag_bit(DEAL_FUN_ARG)
{
	user_card_set_flag_bit_in *p_in=PRI_IN_POS; 
	ret=this->user_card.set_int_value_bit(RECVBUF_USERID,"flag",p_in->bitid,p_in->value  );
	STD_RETURN(ret);
}
//编辑农场
int Croute_func::user_farm_edit(DEAL_FUN_ARG)
{
	user_farm_edit_in_header *p_in= PRI_IN_POS;
	attire_count *oldlist;  	
	attire_count_with_max *newlist;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER( 
			p_in->oldcount* sizeof (attire_count) +
			p_in->newcount*sizeof (attire_count_with_max));

	oldlist=(attire_count*)(RCVBUF_PRIVATE_POS+sizeof(*p_in) );
	newlist=( attire_count_with_max* ) (oldlist +p_in->oldcount);
	ret=this->user_farm.swap_homeattire(FARM_STR, RECVBUF_USERID, 
			p_in->oldcount,oldlist, p_in->newcount,newlist );
	STD_RETURN(ret);
}


int Croute_func::user_farm_set_attirelist(DEAL_FUN_ARG)
{
	user_farm_set_attirelist_in_header *p_in= PRI_IN_POS;
	home_attirelist  usedlist;
	noused_homeattirelist nousedlist; 


	CHECK_PRI_IN_LEN_WITHOUT_HEADER(
			sizeof (home_attire_item)* p_in->usedcount+
			sizeof (attire_noused_item )* p_in->nousedcount);

	if (p_in->nousedcount>HOME_NOUSE_ATTIRE_ITEM_MAX){
		return USER_ATTIRE_MAX_ERR; 
	}	

	if (p_in->usedcount>HOME_ATTIRE_ITEM_MAX){
		return VALUE_OUT_OF_RANGE_ERR; 
	}

	//构造结构
	nousedlist.count=p_in->nousedcount;
	memcpy(nousedlist.item, ((char*)p_in)+sizeof(*p_in),
			sizeof(attire_noused_item)*nousedlist.count);

	usedlist.count=p_in->usedcount;
	memcpy(usedlist.item,
			(((char*)p_in)+sizeof(*p_in)+sizeof(attire_noused_item)*nousedlist.count),
			sizeof(home_attire_item)*usedlist.count);

	ret=this->user_farm.update_homeattire_all("farm",RECVBUF_USERID,
			&usedlist,&nousedlist);
	STD_RETURN (ret );
}


/// @brief 进入牧场拉取信息
int Croute_func::user_get_farm( DEAL_FUN_ARG)
{
	char out[PROTO_MAX_LEN] = { };
	user_get_farm_out_header *p_out = (user_get_farm_out_header *)out;
	user_get_farm_out_item_1 *p_list=NULL;

	farm_noused_attirelist noused_list = { };
	farm_used_attirelist used_list = { };
	uint32_t water_time = 0;

	//得到USER_EX表中农场相关的信息
	ret = this->user_farm.get_user_farm_table_info(RECVBUF_USERID, p_out, &noused_list, &used_list, water_time);
	if (ret != SUCC)
	{
		return ret;
	}
	p_out->item2_count = used_list.count;

	uint32_t count = 0; 
	ret = this->user_farm_animal.get_animal(RECVBUF_USERID, &p_list, &count);
	if (ret != SUCC)
	{
		free(p_list);
		return ret;
	}
	p_out->item1_count = count;

	uint32_t have_child = 0;
	this->user_farm_animal.check_both_buck_doe(&p_list, count, &have_child);

	uint32_t mdog = 1320001;
	uint32_t imi_mdog = 1320002;
	uint32_t end_time = 0;
	uint32_t imi_end_time =0;
	this->user_mdog.get_mdog_end_time(RECVBUF_USERID, mdog, end_time);
	this->user_mdog.get_mdog_end_time(RECVBUF_USERID, imi_mdog, imi_end_time);
	if(end_time < imi_end_time){
		mdog = imi_mdog;
		end_time = imi_end_time;
	}
	uint32_t animal_drink = 0;
	uint32_t animal_catch = 0;

	uint32_t now_time = time(NULL);

	if (end_time >= now_time)
	{
		this->user_farm.set_water_time(RECVBUF_USERID);
	}

	if ((end_time < now_time) && (end_time > water_time) )
	{
		this->user_farm.set_water_time(RECVBUF_USERID, end_time);
	}


	for (uint32_t index = 0; index < count; ++index)
	{
		/*if (now  - p_list[0].lastcal_time < 900) {
		 return SUCC;
		 }*/
		uint32_t output = 0;
		uint32_t runout = 0;
		ret = this->user_farm_animal.cal_list(RECVBUF_USERID, p_list + index, &noused_list, p_out->pool_state, 
				&output, &runout, have_child, end_time, animal_drink, animal_catch);
		if (ret != SUCC)
		{
			free(p_list);
			return ret;
		}

		//是否有动物逃跑
		p_out->runout_num += runout;
		if (output != 0)
		{
			ret = this->user_get_farm_inner(RECVBUF_USERID, p_list, index, output);
			if(ret != SUCC){
				return ret;
			}
		}
	}//for
	uint32_t cur_time = time(NULL);
	if (end_time >= cur_time)
	{
		this->user_mdog.update_drink_catch(RECVBUF_USERID, mdog, animal_drink, animal_catch);
		if (p_out->runout_num > 0)
		{
			p_out->runout_num = 1000;
		}
	}

	for (uint32_t i = 0; i < noused_list.count; i++)
	{
		if (noused_list.item[i].count == 0)
		{
			for (uint32_t j = i; j < noused_list.count - 1; j++)
			{
				memcpy(&noused_list.item[j], &noused_list.item[j + 1], sizeof(noused_list.item[0]));
			}
			noused_list.count--;
		}
	}

	p_out->item3_count = noused_list.count;
	ret = this->user_farm.update_noused_homeattirelist("feedstuff", RECVBUF_USERID, &noused_list);
	if (ret != SUCC) {
		free(p_list);
		return ret;
	}
	if(PROTO_MAX_LEN <= (sizeof(user_farm_get_out_header)) + (sizeof(animal_select) * p_out->item1_count) ){
		ret = this->user_farm_animal.del_insect(RECVBUF_USERID,1270008);//	
		user_add_attire_in  temp={0, 1270008, 200, 99999};
     	ret= this->user_add_attire(RECVBUF_USERID, &temp);
		if(ret == SUCC){	
          //log_change
			change_log_item c_item;
			c_item.userid=RECVBUF_USERID;
			c_item.change_type=200;
			c_item.logtime=time(NULL);
			c_item.change_value=1;
			c_item.change_v1= 1270008;
			this->send_log.send(&c_item );
		}
		free(p_list);
		return INSECT_THAN_MAX_ERR;
	}
	char *p_offset = out + sizeof(user_farm_get_out_header);
	memcpy(p_offset, p_list, sizeof(animal_select) * p_out->item1_count);
	p_offset += sizeof(animal_select) * p_out->item1_count; 
	memcpy(p_offset, used_list.item, sizeof(used_list.item[0]) * used_list.count);
	p_offset += sizeof(used_list.item[0]) * used_list.count;
	memcpy(p_offset, noused_list.item, sizeof(food_info) * noused_list.count);
	p_offset += sizeof(food_info) * noused_list.count;
	free(p_list);
	stru_user_egg_ex *p_egg = NULL;
	uint32_t egg_count = 0;
	ret = this->user_egg.get_all_record(RECVBUF_USERID, &p_egg, &egg_count);
	if (ret != SUCC) {
		return ret;
	}
	for (uint32_t i = 0; i < egg_count; i++) {
		ret = this->user_egg.get_brood_num((p_egg + i)->attireid, &(p_egg + i)->total_num);
		if (ret != SUCC) {
			return ret;
		}
	}
	memcpy(p_offset, p_egg, sizeof(stru_user_egg_ex) * egg_count);
	free(p_egg);
	p_out->item4_count = egg_count;
	p_offset += sizeof(stru_user_egg_ex) * egg_count;
	STD_RETURN_WITH_BUF(ret, out, p_offset - out);
}
int Croute_func::user_get_farm_inner(userid_t userid, user_get_farm_out_item_1 *p_list,
	  	uint32_t index, uint32_t &output)
{
	//增加物品
			uint32_t output_id = 0;
			ret = this->user_farm_animal.get_output_id((p_list + index)->animal_id, &output_id);
			if (ret != SUCC)
			{
				free(p_list);
				return ret;
			}
			uint32_t animal_usedcount = 0;
			uint32_t animal_count = 0;
			uint32_t chest = 0;
			uint32_t mode = 0;
			uint32_t loop_count = 1;
			uint32_t add_id[2][2] = {};
			add_id[0][0] = output_id;
			add_id[0][1] = output;
			if ((p_list + index)->animal_id == 1270007) {
				loop_count = 2;
				add_id[0][0] = 190248;//母
				add_id[0][1] = (output * 4) / 10;
				add_id[1][0] = 190246;//公
				add_id[1][1] = output - add_id[0][1];
			} 
			else if ((p_list + index)->animal_id == 1270015) {
				loop_count = 1;
				if (rand() % 10 < 4) {
					//小白兔
					add_id[0][0] = 190253;
					add_id[0][1] = output;
				} else {
					//小灰兔
					add_id[0][0] = 190255;
					add_id[0][1] = output;
				}
			} else if ((p_list + index)->animal_id == 1270041) {
				uint32_t female = 0;
				uint32_t male = 0;
				if ((p_list + index)->total_output == 0)
				{
					output = output -1;
					female = female + 1;
				}
				for (uint32_t i = 0; i < output; i++)
				{
					if (rand()%10 < 3)
					{
						female = female + 1;
					}
					else
					{
						male = male + 1;
					}
				}
				if (male > 0 && female > 0)
				{
					add_id[0][0] = 190295;//母
					add_id[0][1] = female;
					add_id[1][0] = 190296;//公
					add_id[1][1] = male;
					loop_count = 2;
				}
				else
				{
					if (male > 0)
					{
						add_id[0][0] = 190296;//公
						add_id[0][1] = male;						
					}
					if (female > 0)
					{
						add_id[0][0] = 190295;//母
						add_id[0][1] = female;
					}
					loop_count = 1;
				}	
			} else if((p_list + index)->animal_id == 1270059) {
				loop_count = 1;
				if (rand() % 10 < 3) {
					add_id[0][0] = 190323;
					add_id[0][1] = output;
				} else {
					add_id[0][0] = 190322;
					add_id[0][1] = output;
				}	
			} else if((p_list + index)->animal_id == 1270064) {
				loop_count = 1;
				if (rand() % 10 < 3) {
					add_id[0][0] = 190325;
					add_id[0][1] = output;
				} else {
					add_id[0][0] = 190326;
					add_id[0][1] = output;
				}	
			}

			for (uint32_t i = 0; i < loop_count; i++) {
				ret = this->user_attire.get(userid, add_id[i][0], &animal_usedcount, &animal_count, &chest, &mode);
				if (ret != SUCC && ret != ATTIRE_COUNT_NO_ENOUGH_ERR) {
					return ret;
				}
				user_add_attire_in add_item ={ };
				if (animal_count + add_id[i][1] > 99999) {
					add_item.count = 99999 - animal_count;
				} else {
					add_item.count = add_id[i][1];
				}
				if (add_item.count > 99999) {
					add_item.count = 0;
				}
				add_item.attiretype=0;
				add_item.attireid = add_id[i][0];
				//最多99999个
				add_item.maxcount=99999;
				ret=this->user_add_attire(userid, &add_item);
				if (ret==VALUE_OUT_OF_RANGE_ERR) {
					//果实个数超过最大数
					free(p_list);
					return	USER_ATTIRE_MAX_ERR;
				} else if (ret!=SUCC) {
					free(p_list);
					return ret;
				}		
			}		

			return SUCC;
}
//得到动物的信息
int Croute_func::user_farm_get_all_animal_info(DEAL_FUN_ARG)
{
	char out[PROTO_MAX_LEN];
	user_farm_get_all_animal_info_out_header *p_out=(user_farm_get_all_animal_info_out_header*)out;
	stru_farm *p_list;
	uint32_t count = 0;
	ret=this->user_farm_animal.get_all_animal(RECVBUF_USERID, &p_list, &count);
	if (ret != SUCC) {
		free(p_list);
		return ret;
	}
	p_out->item1_out = count;

	//为了满足返回值的剩余产值
	//for(uint32_t i=0; i < count; ++i)
	//{
	//p_list[i].total_output = this->user_farm_animal.fruit_max(p_list[i].animalid) - p_list[i].total_output;
	//}

	memcpy(out + 4, p_list, sizeof(stru_farm) * p_out->item1_out);
	free(p_list);
	STD_RETURN_WITH_BUF(ret, out, 4 + sizeof(stru_farm) * p_out->item1_out);
}

//更新动物的信息
int Croute_func::user_farm_update_animal_info(DEAL_FUN_ARG)
{
	user_farm_update_animal_info_in *p_in=PRI_IN_POS; 
	ret=this->user_farm_animal.update_all(RECVBUF_USERID, p_in);
	STD_RETURN(ret);

}

//增加使用的物品
int Croute_func::user_get_used_attierlist(DEAL_FUN_ARG)
{
	user_get_used_attierlist_in *p_in=PRI_IN_POS; 
	user_get_jy_ex_out out={};
	memset( &out,0,sizeof(out));
	switch ( p_in->attiretype )
	{
		case 2 :
			ret=this->user.get_attirelist( JY_STR, RECVBUF_USERID ,&(out.attirelist) );
			break;
		case 4 :
			ret=this->user_farm.get_attirelist( FARM_STR, RECVBUF_USERID ,&(out.attirelist) );
			break;
		default :
			return ENUM_OUT_OF_RANGE_ERR;
			break;
	}

	if (ret!=SUCC) return ret;
	if (ret==SUCC&& out.attirelist.count >HOME_ATTIRE_ITEM_MAX) {
		DEBUG_LOG("ERR:DB_DATA_ERR black count %u ", out.attirelist.count );
		return DB_DATA_ERR;
	}
	STD_RETURN_WITH_BUF( ret, (char*) &out, 
			sizeof(out)- sizeof(home_attire_item)*
			(HOME_ATTIRE_ITEM_MAX-out.attirelist.count));
}	

//得到农场未使用列表
int Croute_func::user_farm_get_nousedlist(DEAL_FUN_ARG)
{
	char out[PROTO_MAX_LEN]={ };
	user_farm_get_nousedlist_in *p_in=PRI_IN_POS; 

	user_get_jy_noused_list_out_header * p_out_header=
		(user_get_jy_noused_list_out_header *)out ;
	user_get_jy_noused_list_out_item  * p_out_item=
		( user_get_jy_noused_list_out_item  * ) (out+sizeof(*p_out_header )) ;

	user_get_jy_noused_list_out_item *p_noused_item; 
	ret=this->user_attire.get_list_by_attireid_interval(
			RECVBUF_USERID , p_in->animal_startid,p_in->animal_endid,
			0, &(p_out_header->count	),&p_noused_item );
	if(ret!=SUCC)return ret;
	//复制数据
	memcpy(p_out_item,p_noused_item ,sizeof(*p_noused_item)* p_out_header->count);
	p_out_item =p_out_item +p_out_header->count;
	free(p_noused_item);


	//得到家园列表
	noused_homeattirelist 	nousedlist={};

	ret =this->user_farm.get_noused_home_attirelist(FARM_STR,RECVBUF_USERID,
			&nousedlist);
	if(ret!=SUCC)return ret;
	//复制数据
	p_out_header->count+=nousedlist.count;	
	memcpy(p_out_item ,&(nousedlist.item[0]),
			sizeof(nousedlist.item[0] )* nousedlist.count  );


	STD_RETURN_WITH_BUF(ret, out ,
			sizeof(*p_out_header)+sizeof(*p_out_item)* p_out_header->count);

}


//更新农场的锁的状态
int Croute_func::user_farm_set_state(DEAL_FUN_ARG)
{
	user_farm_set_state_in *p_in=PRI_IN_POS; 
	user_farm_set_state_out out = {	};
	ret=this->user_farm.update_state(RECVBUF_USERID, p_in->state);
	if (ret != SUCC) {
		return ret;
	}
	out.state = p_in->state;
	STD_RETURN_WITH_STRUCT(ret, out);
}

//card
//搜索卡牌
int Croute_func::user_swap_card_search(DEAL_FUN_ARG)
{
	char out[PROTO_MAX_LEN];
	user_swap_card_search_in *p_in=PRI_IN_POS; 
	user_swap_card_search_out_header *p_out = (user_swap_card_search_out_header *)out; 
	ret = this->user_swap_card.get_swap_card(RECVBUF_USERID, p_in->swap_id, p_in->need_id, out + 4, &p_out->count);
	STD_RETURN_WITH_BUF(ret, out, 4 + sizeof(user_swap_card_search_out_item_1) * p_out->count);
}
//设置卡牌的交换状态
int Croute_func::user_swap_card_set_swap(DEAL_FUN_ARG)
{
	user_swap_card_set_swap_in *p_in=PRI_IN_POS; 
	ret=this->user_swap_card.set_swap_flag(RECVBUF_USERID, p_in->swap_card, p_in->swap_flag,
			p_in->need_card, p_in->user_attire);
	STD_RETURN(ret);
}

//两个用户交换卡牌
int Croute_func::user_swap_card_swap(DEAL_FUN_ARG)
{
	user_swap_card_swap_in *p_in=PRI_IN_POS; 
	ret = this->user_swap_card.change(RECVBUF_USERID, p_in->type, p_in->swap_card, p_in->need_card);
	if (ret==SUCC){
		//log_change
		change_log_item c_item;
		c_item.userid=RECVBUF_USERID;
		c_item.change_type=10;
		c_item.logtime=time(NULL);
		c_item.change_value=1;
		c_item.change_v1=p_in->swap_card ;
		c_item.change_v2=p_in->need_card;
		this->send_log.send(&c_item );
	}


	STD_RETURN(ret);
}
int Croute_func::user_swap_card_add_clothe(userid_t userid)
{
	user_add_attire_in temp;
		temp.attireid = 12712;
		temp.attiretype = 0;
		temp.count = 1;
		temp.maxcount = 99999;
		ret = this->user_add_attire(userid, &temp);
		if (ret != SUCC) {
			return ret;
		}
		temp.attireid = 12725;
		temp.attiretype = 0;
		temp.count = 1;
		temp.maxcount = 99999;
		ret = this->user_add_attire(userid, &temp);
		if (ret != SUCC) {
			return ret;
		}
		temp.attireid = 12726;
		temp.attiretype = 0;
		temp.count = 1;
		temp.maxcount = 99999;
		ret = this->user_add_attire(userid, &temp);
		if (ret != SUCC) {
			return ret;
		}
		return SUCC;
}

//兑换服装或者一万豆豆
int Croute_func::user_swap_card_get_super(DEAL_FUN_ARG)
{
	user_swap_card_get_super_out out={	};
	int index = this->user_swap_card.get_max_num();
	ret = this->user_swap_card.swap_super_card(RECVBUF_USERID, 1290020 + index, 0);
	if (ret != SUCC) {
		return ret;
	}
	uint32_t count = 0;
	uint32_t used_count = 0;
	uint32_t chest = 0;
	uint32_t mode = 0;
	ret = user_attire.get(RECVBUF_USERID, 12712, &used_count, &count, &chest, &mode);
	if (ret != SUCC && ret != ATTIRE_COUNT_NO_ENOUGH_ERR) {
		return ret;
	}
	if (count >= 1) {
		int temp;
		ret=this->user.change_xiaomee(RECVBUF_USERID, 10000, 4, 0,   &temp);
		if (ret != SUCC) {
			DEBUG_LOG("Fail to change xiaomee : userid %u, money %u", RECVBUF_USERID, 10000);
			return ret;
		}

		if (ret==SUCC){
			//log_change
			change_log_item c_item;
			c_item.userid=RECVBUF_USERID;
			c_item.change_type=1;
			c_item.logtime=time(NULL);
			c_item.change_value=10000;
			c_item.change_v1=0;
			c_item.change_v2=temp;
			this->send_log.send(&c_item );
		}
		out.attireid = 0;
		out.count = 10000;
	} else {
		STD_CLOSE_AUTOCOMMIT(ret); 
		if(ret!=SUCC) return ret;
		ret = this->user_swap_card_add_clothe(RECVBUF_USERID);
		if(ret==SUCC){
			//提交
			STD_COMMIT(ret); 
		}else{
			//回滚
			STD_ROLLBACK();
		}
		//关闭事务
		STD_OPEN_AUTOCOMMIT() ; 
	
		out.attireid = 12712;
		out.count = 1;
	}
	STD_RETURN_WITH_STRUCT(ret ,out);
}

//得到卡牌
int Croute_func::user_swap_card_get_card(DEAL_FUN_ARG)
{
	user_swap_card_get_card_out_header  out_header;
	user_swap_card_get_card_out_item *p_out_item= NULL;
	ret=this->user_swap_card.get_card_all(RECVBUF_USERID, &p_out_item, &out_header.count);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/* 设置卡牌信息 */
int Croute_func::user_swap_card_set_card(DEAL_FUN_ARG)
{
	user_swap_card_set_card_in *p_in=PRI_IN_POS; 
	ret = this->user_swap_card.set_card(RECVBUF_USERID, p_in->card_type, p_in->num, p_in->swap_flag, p_in->need_card);
	STD_RETURN(ret);
}


int Croute_func::user_farm_animal_add(DEAL_FUN_ARG)
{
	uint32_t id;
	uint32_t max_output = 0;
	ret=this->user_farm_animal.insert(RECVBUF_USERID,1270001,0,&id, &max_output);
	STD_RETURN(ret);
}

int Croute_func::user_farm_animail_del_ex(DEAL_FUN_ARG)
{
	user_farm_animail_del_ex_in *p_in=PRI_IN_POS; 
	ret=this->user_farm_animal.del(RECVBUF_USERID,p_in->id);
	STD_RETURN(ret);
}

int Croute_func::user_task_get_list(DEAL_FUN_ARG)
{
	user_task_get_list_out_header  out_header;
	user_task_get_list_out_item *p_out_item;
	ret=this->user_task_ex.get_list(RECVBUF_USERID,&p_out_item,&(out_header.count));
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
//得到衣服的损耗值
int Croute_func::roominfo_get_clothe_waste(DEAL_FUN_ARG)
{
	roominfo_get_clothe_waste_out out = {	};
	ret=this->roominfo_clothe_waste.get_value_all(RECVBUF_USERID, out.clothe_waste, &out.clothe_count);
	DEBUG_LOG("COLTHE:%u,%u,%u,%u, %u",
			out.clothe_waste[0].clothe_value,
			out.clothe_waste[1].clothe_value,
			out.clothe_waste[2].clothe_value,
			out.clothe_waste[3].clothe_value,
			out.clothe_waste[4].clothe_value
			);
	STD_RETURN_WITH_STRUCT(ret,out);
}
//设置衣服的损耗值
int Croute_func::roominfo_set_clothe_waste(DEAL_FUN_ARG)
{
	roominfo_set_clothe_waste_in *p_in=PRI_IN_POS; 
	roominfo_set_clothe_waste_out out={};
	DEBUG_LOG("update clothe %u, %u, %u, %u, %u",
			out.clothe_waste[0].clothe_value,
			out.clothe_waste[1].clothe_value,
			out.clothe_waste[2].clothe_value,
			out.clothe_waste[3].clothe_value,
			out.clothe_waste[4].clothe_value
			);
	ret=this->roominfo_clothe_waste.set_value_ex(RECVBUF_USERID, p_in, &out);
	STD_RETURN_WITH_STRUCT(ret,out);
}
//得到point值
int Croute_func::roominfo_get_point(DEAL_FUN_ARG)
{
	roominfo_get_point_out out={};
	ret=this->roominfo_point.get_value(RECVBUF_USERID, out.point_value, POINT_VALUE);
	STD_RETURN_WITH_STRUCT(ret,out);
}

//设置point值
int Croute_func::roominfo_set_point(DEAL_FUN_ARG)
{
	roominfo_set_point_in *p_in=PRI_IN_POS; 
	roominfo_set_point_out out={};
    ret = this->roominfo_point.set_value(RECVBUF_USERID, p_in->value, POINT_VALUE);
	if (ret != SUCC) {
		return ret;
	}
	ret = this->roominfo_point.get_value(RECVBUF_USERID, out.point_value, POINT_VALUE);
    STD_RETURN_WITH_STRUCT(ret,out);
}

//得到POS的值
int Croute_func::roominfo_get_pos(DEAL_FUN_ARG)
{
	roominfo_get_pos_out out={};
	out.count = 5;
    ret=this->roominfo_point.get_value(RECVBUF_USERID, out.pos_value, POS_VALUE);
	if (ret != SUCC) {
		return ret;
	}
    STD_RETURN_WITH_STRUCT(ret,out);
}
//设置POS的值
int Croute_func::roominfo_set_pos(DEAL_FUN_ARG)
{
	roominfo_set_pos_in *p_in=PRI_IN_POS; 
	roominfo_set_pos_out out={};
    ret=this->roominfo_point.set_value(RECVBUF_USERID, p_in->index, POS_VALUE);
	if (ret != SUCC) {
		return ret;
	}
	out.count = 5;
    ret=this->roominfo_point.get_value(RECVBUF_USERID, out.pos_value, POS_VALUE);
	if (ret != SUCC) {
		return ret;
	}
    STD_RETURN_WITH_STRUCT(ret, out);
}
//清除POS的相应的位
int Croute_func::roominfo_clear_pos(DEAL_FUN_ARG)
{
	roominfo_clear_pos_in *p_in=PRI_IN_POS; 
	uint32_t value = 0;
	ret = this->roominfo_point.get(RECVBUF_USERID, &value, POS_VALUE);
	value &= (~(0x01 << (p_in->index - 1)));
	ret=this->roominfo_point.update(RECVBUF_USERID, value, POS_VALUE);
	STD_RETURN(ret);
}

int Croute_func::user_set_xiaomee_max_info(DEAL_FUN_ARG)
{
	user_set_xiaomee_max_info_in *p_in=PRI_IN_POS; 
	ret=this->user.set_xiaomee_max_info(RECVBUF_USERID, p_in);
	STD_RETURN(ret);
}

/* 设置是否领取过奖章的标志位检查 */
int Croute_func::roominfo_set_class_medal_flag(DEAL_FUN_ARG)
{
	roominfo_set_class_medal_flag_in *p_in=PRI_IN_POS; 
	ret=this->class_qa.set_class_flag(RECVBUF_USERID, p_in->memberid, p_in->index);
	STD_RETURN(ret);
}
/* 得到班级的荣誉榜 */
int Croute_func::user_class_get_medal_list(DEAL_FUN_ARG)
{
	char out[PROTO_MAX_LEN];
	user_class_get_medal_list_out_header *p_out = (user_class_get_medal_list_out_header *)out;
	class_medal temp = {};
	memset(&temp, 0, sizeof(class_medal));
	ret=this->user_class.get_medal(RECVBUF_USERID, &temp);
	p_out->count = temp.count;
	memcpy(out, &temp, 4 + sizeof(temp.items[0]) * p_out->count);
	STD_RETURN_WITH_BUF(ret, out, 4 + sizeof(user_class_get_medal_list_out_item_1) * p_out->count);
}
/* 设置班级的荣誉榜 */
int Croute_func::user_class_set_medal_list(DEAL_FUN_ARG)
{
	user_class_set_medal_list_in *p_in=PRI_IN_POS;
	ret=this->user_class.add_medal(RECVBUF_USERID, p_in->type, p_in->attire_id);
	STD_RETURN(ret);
}

/* 设置封号相应的位 */
int Croute_func::user_set_punish_flag( DEAL_FUN_ARG )
{
	user_set_punish_flag_in *p_in=PRI_IN_POS;


	ret = this->user.set_flag(RECVBUF_USERID,
			VIP_FLAG_STR , p_in->flag_bit, bool(p_in->bool_set));
	STD_RETURN (ret );
}
/* 设置PET的得病类型 */
int Croute_func::user_set_pet_sick_type(DEAL_FUN_ARG)
{
	user_set_pet_sick_type_in *p_in=PRI_IN_POS; 
	DEBUG_LOG("===sick_type %u %u", p_in->pet_id, p_in->sick_type);
	ret=this->user_pet.set_sick_type(RECVBUF_USERID, p_in->pet_id, p_in->sick_type);
	STD_RETURN(ret);
}

int Croute_func::user_class_set_medal_info(DEAL_FUN_ARG)
{
	user_class_set_medal_info_in *p_in=PRI_IN_POS; 
	user_class_set_medal_info_out out={};
	ret=this->user_class.set_medal_info(RECVBUF_USERID, p_in,&out );
	STD_RETURN_WITH_STRUCT(ret,out);
}


int Croute_func::userinfo_log_with_stat(DEAL_FUN_ARG)
{
	userinfo_log_with_stat_in *p_in=PRI_IN_POS; 
	userinfo_log_with_stat_out out={};
	ip_history_item ctiem;
	ctiem.userid = RECVBUF_USERID;
	ctiem.which_game = p_in->login_channel;
	ctiem.ip = p_in->ip;
	ret=this->send_log.send_ip(&ctiem);
	ret=this->user_info.login_ex_with_stat(RECVBUF_USERID, p_in, &(out.gameflag));
	STD_RETURN_WITH_STRUCT(ret,out);
}
//火神杯报名
int Croute_func::roominfo_sig_fire_cup(DEAL_FUN_ARG)
{
	roominfo_sig_fire_cup_in *p_in=PRI_IN_POS; 
	//if (p_in->teamid > 4 || p_in->teamid < 1) {
	//return VALUE_OUT_OF_RANGE_ERR;
	//}
	ret=this->roominfo_fire_cup.insert(RECVBUF_USERID, p_in->teamid);
	if (ret != SUCC) {
		ret = this->roominfo_fire_cup.update_team(RECVBUF_USERID, p_in->teamid);
		//ret = YOU_HAVE_SIG_FIRE_CUP_ERR;
	}
	STD_RETURN(ret);
}
//得到参加的队伍
int Croute_func::roominfo_get_fire_cup_team(DEAL_FUN_ARG)
{
	roominfo_get_fire_cup_team_out out={};
	ret=this->roominfo_fire_cup.get_team(RECVBUF_USERID, &out);
	if (ret == 1105) {
		out.teamid = 0;
		ret = 0;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}


//得到火神杯的信息
int Croute_func::roominfo_fire_cup_get(DEAL_FUN_ARG)
{
	roominfo_fire_cup_update_out out={};
	ret = this->roominfo_fire_cup.getinfo(RECVBUF_USERID,&out);
	if(ret != SUCC){
		ret = SUCC;
		memset(&out,0,sizeof(out));
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

//增加奖牌数
int Croute_func::roominfo_fire_cup_update(DEAL_FUN_ARG)
{
	roominfo_fire_cup_update_in *p_in=PRI_IN_POS;
	roominfo_fire_cup_update_out out={};

	ret = this->roominfo_fire_cup.getinfo(RECVBUF_USERID,&out);
	if(ret == SUCC) {
		if(p_in->addnum > 0) {
			uint32_t today = get_date(time(NULL));
			if(out.today != today) {
				out.today = today;
				out.day_left = p_in->daymax;
				this->roominfo_fire_cup.update_today(RECVBUF_USERID,today,p_in->daymax);
			}

			if(out.day_left == 0)
				return MEDAL_LIMIT_ERR;
			if((uint32_t)p_in->addnum >= out.day_left)
				out.day_left = 0;
			else
				out.day_left -= p_in->addnum;
		} else {
			if(out.count + p_in->addnum < 0)
				return NOT_ENOUGH_MEDAL_ERR; 
		}

		ret = this->roominfo_fire_cup.addnum(RECVBUF_USERID,p_in->addnum,out.day_left);
		out.count += p_in->addnum;
	}


	STD_RETURN_WITH_STRUCT(ret,out);
}

//火神杯获得奖品
int Croute_func::roominfo_get_fire_cup_prize(DEAL_FUN_ARG)
{
	roominfo_get_fire_cup_prize_out out = {};
	ret = this->roominfo_fire_cup.setflag(RECVBUF_USERID, &out);
	STD_RETURN_WITH_STRUCT(ret, out);
}

//得到浇水人数
int Croute_func::mms_get_water_list(DEAL_FUN_ARG)
{
	mms_get_water_list_out out={};
	mms_water_list temp = {	};
	ret=this->roominfo_point.get_water_list(RECVBUF_USERID, &temp);
	out.count = temp.count;
	STD_RETURN_WITH_STRUCT(ret,out);
}

//随机生成报名队伍
int Croute_func::sysarg_get_team(DEAL_FUN_ARG)
{
	sysarg_get_team_out out={};
	ret=this->sys_arg.get_team(&out.team);
	STD_RETURN_WITH_STRUCT(ret,out);
}

//设置任务
int Croute_func::roominfo_set_task(DEAL_FUN_ARG)
{
	roominfo_set_task_in *p_in=PRI_IN_POS; 
	if (p_in->task_id < 0 || p_in->task_id > 14) {
		return VALUE_OUT_OF_RANGE_ERR;
	}
	ret=this->roominfo_point.set_task(RECVBUF_USERID, p_in->task_id, p_in->opt);
	STD_RETURN(ret);
}

//得到任务
int Croute_func::roominfo_get_task(DEAL_FUN_ARG)
{
	roominfo_get_task_out out={	};
	ret=this->roominfo_point.get(RECVBUF_USERID, &out.task, "task");
	STD_RETURN_WITH_STRUCT(ret,out);
}

//返回NPC的位置信息, 110~119表示红蓝黄绿黑及相关的任务
int Croute_func::sysarg_get_fire_cup(DEAL_FUN_ARG)
{
	sysarg_get_fire_cup_in *p_in=PRI_IN_POS;
	sysarg_get_fire_cup_out out={};
	ret = this->sys_arg.get_npc_and_task(&out, p_in->team);
	if (ret != SUCC) {
		return ret;
	}
	ret = this->usermap_day.get(136, RECVBUF_USERID, &out.email);
	if (ret == 1105) {
		ret = SUCC;
		out.email = 0;
	}
	ret = this->usermap_day.get(1000000011, RECVBUF_USERID, &out.email_air);
	if (ret == 1105) {
		ret = SUCC;
		out.email_air = 0;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

//给队增加奖牌
int Croute_func::sys_add_team_medal(DEAL_FUN_ARG)
{
	sys_add_team_medal_in *p_in=PRI_IN_POS;
/*    
	if (p_in->count >= 20)
	{
		ret = 0;
		return ret;
	}
*/	
	ret=this->sys_fire_cup.update(p_in->teamid, p_in->count);
	if(ret != SUCC) {
		ret = this->sys_fire_cup.insert(p_in->teamid, p_in->count);
	}
	STD_RETURN(ret);
}

//得到所有排行榜信息
int Croute_func::sys_get_all_medal_list(DEAL_FUN_ARG)
{
	sys_get_all_medal_list_out_header out_header={};
	sys_get_all_medal_list_out_item *p_item = NULL;
	ret = this->sys_fire_cup.get_list_medal(&p_item, &out_header.count);

	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_item,out_header.count);
}

//设置毛毛数浇水
int Croute_func::mms_set_water_list(DEAL_FUN_ARG)
{
	mms_set_water_list_in *p_in=PRI_IN_POS; 
	ret=this->roominfo_point.set_water_list(RECVBUF_USERID, p_in->userid);
	STD_RETURN(ret);
}

int Croute_func::history_ip_record(DEAL_FUN_ARG)
{
	history_ip_record_in *p_in=PRI_IN_POS; 
	ret=this->ip_history.add_ip(p_in->userid, p_in->which_game, p_in->ip);
	//ret=this->user_ip_map.add_ip(p_in->userid, p_in->which_game, p_in->ip);

	STD_RETURN(ret);

}
int Croute_func::game_set_score(DEAL_FUN_ARG)
{
	game_set_score_in *p_in=PRI_IN_POS; 
	ret=this->user_game.set(p_in);
	if (ret != SUCC) {
		return ret;
	}
	ret = this->game.set(p_in);
	STD_RETURN(ret);
}

int Croute_func::game_user_get_list(DEAL_FUN_ARG)
{
	game_user_get_list_in_header *p_in=PRI_IN_POS;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(game_user_get_list_in_item));
	game_user_get_list_out_header  out_header = {};
	if (p_in->count == 0) {
		ret = 0;
		uint32_t count = 0;
		STD_RETURN_WITH_STRUCT(ret, count);
	}
	game_user_get_list_out_item *p_out_item;
	stru_idlist *p_idlist=(stru_idlist *)((char *)PRI_IN_POS + 4);
	ret=this->game.get_list_by_idlist(p_in->gameid,p_idlist,&(out_header.count),&p_out_item  );
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::game_get_list(DEAL_FUN_ARG)
{
	game_get_list_in *p_in=PRI_IN_POS; 
	game_get_list_out_header  out_header = {};
	game_get_list_out_item *p_out_item;
	ret=this->user_game.get_list(p_in->userid,&(out_header.count),&p_out_item);
	STD_RETURN_WITH_STRUCT_LIST(ret, out_header, p_out_item, out_header.count);
}

int Croute_func::game_set_pk_info(DEAL_FUN_ARG)
{
	game_set_pk_info_in *p_in=PRI_IN_POS; 
	game_set_pk_info_out out={};
	out.userid_score=p_in->score;

	ret=this->user_game.get(p_in->gameid,p_in->userid_pk,&(out.userid_pk_score));
	if(ret!=SUCC) return ret;
	uint32_t game_limit = 0;
	ret = this->user_game.get_game_thread(p_in->gameid, &game_limit);
	if (ret != SUCC) {
		return ret;
	}
	if (out.userid_pk_score < game_limit) {
		return PK_GAME_SCORE_TOO_SMALL_ERR;
	}
	if ( p_in->score>out.userid_pk_score ){//胜
		//this->user_game.set_pkflag(p_in->gameid,p_in->userid,0x01 );
		this->user_game.set_pkflag(p_in->gameid,p_in->userid_pk,0x02);
		this->user_game_pk.add_win_lose(p_in->userid,true );
		//this->user_game_pk.add_win_lose(p_in->userid_pk,false);
		out.is_win_flag=1;//赢了被挑战者
	}else{
		//this->user_game.set_pkflag(p_in->gameid,p_in->userid,0x02 );
		this->user_game.set_pkflag(p_in->gameid,p_in->userid_pk,0x01);
		this->user_game_pk.add_win_lose(p_in->userid,false);
		//this->user_game_pk.add_win_lose(p_in->userid_pk,true);
		out.is_win_flag=2;
	}
	
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::roominfo_pk_add(DEAL_FUN_ARG)
{
	roominfo_pk_add_in *p_in=PRI_IN_POS; 
	ret=this->roominfo_list.pk_add(RECVBUF_USERID,p_in );
	STD_RETURN(ret);
}

int Croute_func::roominfo_pk_get_list(DEAL_FUN_ARG)
{
	stru_pk_list out={};
	ret=this->roominfo_list.get_pk_list(RECVBUF_USERID , &out);
	if (out.count > PK_LIST_MAX_COUNT) {
		out.count = PK_LIST_MAX_COUNT;
	}
	if (ret == USER_ID_NOFIND_ERR) {
		ret = SUCC;
	}
	STD_RETURN_WITH_BUF(ret, (char*) &out,
			sizeof(out)-(PK_LIST_MAX_COUNT-out.count)*sizeof(out.items[0]));
}
int Croute_func::game_get_pk_info(DEAL_FUN_ARG)
{
	game_get_pk_info_in *p_in=PRI_IN_POS; 
	game_get_pk_info_out out={};
	ret=this->user_game_pk.get(p_in->userid,&out);
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 游戏王加分 */
int Croute_func::user_update_game_score(DEAL_FUN_ARG)
{
	user_update_game_score_in *p_in=PRI_IN_POS; 
	ret=this->user.add_game(RECVBUF_USERID, p_in->score);
	STD_RETURN(ret);
}
/* 编辑拉姆日记 */
int Croute_func::user_lamu_diary_edit(DEAL_FUN_ARG)
{
	user_lamu_diary_edit_in *p_in=PRI_IN_POS; 
	user_lamu_diary_edit_out out={}; 
	if (p_in->id == 0) {
		ret=this->user_lamu_diary.insert(RECVBUF_USERID, p_in, &out.id);
		if (ret != SUCC) {
			return ret;
		}
	} else {
		ret = this->user_lamu_diary.update(RECVBUF_USERID, p_in);
		out.id = p_in->id;
	}
	STD_RETURN_WITH_STRUCT(ret, out);
}
/* 得到拉姆日记的目录信息 */
int Croute_func::user_lamu_catalog_get(DEAL_FUN_ARG)
{
	user_lamu_catalog_get_in *p_in=PRI_IN_POS; 
	uint32_t lock = 0;
	ret = user_ex.get_lock(RECVBUF_USERID, &lock);
	if (ret != SUCC) {
		return ret;
	}
	if ((lock == 2) && (RECVBUF_USERID != p_in->userid)) {
		return YOU_HAVE_NOT_RIGHT_TO_READ_ERR;
	}
	user_lamu_catalog_get_out_header out_header;
	user_lamu_catalog_get_out_item *p_out_item = NULL;

	ret=this->user_lamu_diary.get_catalog_list(RECVBUF_USERID, 
			p_in->start, p_in->end, &p_out_item, &(out_header.count));

	STD_RETURN_WITH_STRUCT_LIST(ret, out_header, p_out_item, out_header.count);
}

/* 删除拉姆日记  */
int Croute_func::user_lamu_diary_delete(DEAL_FUN_ARG)
{
	user_lamu_diary_delete_in *p_in=PRI_IN_POS; 
	ret=this->user_lamu_diary.delete_diary(RECVBUF_USERID, p_in->id);
	STD_RETURN(ret);
}
/* 更新单篇日记的锁状态 */
int Croute_func::user_lamu_diary_state_update(DEAL_FUN_ARG)
{
	user_lamu_diary_state_update_in *p_in=PRI_IN_POS; 
	ret=this->user_lamu_diary.update_state(RECVBUF_USERID, p_in->id, p_in->state);
	STD_RETURN(ret);
}
/* 拉姆日志投花 */
int Croute_func::user_lamu_diary_flower_update(DEAL_FUN_ARG)
{
	user_lamu_diary_flower_update_in *p_in=PRI_IN_POS; 
	ret=this->user_lamu_diary.update_flower(RECVBUF_USERID, p_in->id);
	STD_RETURN(ret);
}
/* 得到拉姆日记的内容 */
int Croute_func::user_lamu_diary_content_get(DEAL_FUN_ARG)
{
	user_lamu_diary_content_get_in *p_in=PRI_IN_POS; 
	user_lamu_diary_content_get_out out={};
	uint32_t lock = 0;
	ret = user_ex.get_lock(RECVBUF_USERID, &lock);
	if (ret != SUCC) {
		return ret;
	}
	if ((lock == 2) && (RECVBUF_USERID != p_in->userid)) {
		return YOU_HAVE_NOT_RIGHT_TO_READ_ERR;
	}
	uint32_t state = 0;
	ret=this->user_lamu_diary.get_content(RECVBUF_USERID, p_in->id, &out, &state);
	if ((state == 2) && (RECVBUF_USERID != p_in->userid)) {
		return YOU_HAVE_NOT_RIGHT_TO_READ_ERR;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}
/* 增加打工的次数 */
int Croute_func::roominfo_work_set(DEAL_FUN_ARG)
{
	roominfo_work_set_in *p_in=PRI_IN_POS; 
	roominfo_work_set_out out={};
	ret=this->roominfo_work.set_value(RECVBUF_USERID, p_in->type);
	if (ret != SUCC) {
		return ret;
	}
	ret = roominfo.update_work_time(RECVBUF_USERID);
	if (ret != SUCC) {
		return ret;
	}
	ret = this->roominfo.get_work_time(RECVBUF_USERID, &out.time_total);
	STD_RETURN_WITH_STRUCT(ret, out);
}
/* 得到打工的次数 */
int Croute_func::roominfo_work_get(DEAL_FUN_ARG)
{
	roominfo_work_get_out out={	};
	ret = this->roominfo.get_total_time(RECVBUF_USERID, &out.time_total);
	if (ret != SUCC) {
		return ret;
	}
	ret=this->roominfo_work.get_value_last(RECVBUF_USERID, &out.time_tom, &out.time_nick);
	if (ret == 1173) {
		ret =SUCC;
	}
	ret=this->roominfo_work.get_value_this(RECVBUF_USERID, &out.this_tom, &out.this_nick);
	if (ret == 1173) {
		ret =SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}
/* 设置整个日记的锁 */
int Croute_func::user_ex_set_diary_lock(DEAL_FUN_ARG)
{
	user_ex_set_diary_lock_in *p_in=PRI_IN_POS; 
	ret=this->user_ex.set_lock(RECVBUF_USERID, p_in->lock);
	STD_RETURN(ret);
}
/* 得到整个日记锁的状态 */
int Croute_func::user_ex_diary_lock_get(DEAL_FUN_ARG)
{
	user_ex_diary_lock_get_out out={};
	ret=this->user_ex.get_lock(RECVBUF_USERID, &out.lock);
	STD_RETURN_WITH_STRUCT(ret,out);
}
/* 得到日志总的条数 */
int Croute_func::user_lamu_diary_count(DEAL_FUN_ARG)
{
    user_lamu_diary_count_out out={	};
	ret=this->user_lamu_diary.get_count(RECVBUF_USERID, &out.count);
	STD_RETURN_WITH_STRUCT(ret,out);
}
/* 得到打工的等级数 */
int Croute_func::user_set_work_level(DEAL_FUN_ARG)
{
	user_set_work_level_in *p_in=PRI_IN_POS; 
	ret=this->user.update_work(RECVBUF_USERID, p_in->work_level);
	STD_RETURN(ret);
}

/* 拉姆接任务 */
int Croute_func::user_pet_task_set_ex(DEAL_FUN_ARG)
{
	user_pet_task_set_ex_in *p_in=PRI_IN_POS; 
	user_pet_task_set_ex_out out={};
	uint32_t flag = 0;
	ret = this->user_pet.get_flag2(RECVBUF_USERID, p_in->petid, &flag);
	if (ret != SUCC) {
		return ret;
	}
	ret=this->user_task.add_magic(RECVBUF_USERID, p_in, flag);
	out.petid = p_in->petid;
	out.taskid = p_in->taskid;
	STD_RETURN_WITH_STRUCT(ret,out);
}
/* 设置某阶段任务结束 */
int Croute_func::user_task_pet_first_stage_set(DEAL_FUN_ARG)
{
	user_task_pet_first_stage_set_in *p_in=PRI_IN_POS; 
	user_task_pet_first_stage_set_out out = {}; 
	ret=this->user_task.set_stage_flag(RECVBUF_USERID, p_in, &out.count);
	STD_RETURN_WITH_STRUCT(ret, out);
}
/* 删除某一任务 */
int Croute_func::user_task_taskid_del(DEAL_FUN_ARG)
{
	user_task_taskid_del_in *p_in=PRI_IN_POS; 
	user_task_taskid_del_out out={ };
	ret=this->user_task.del(RECVBUF_USERID, p_in->petid, p_in->taskid, &out.count);
	STD_RETURN_WITH_STRUCT(ret, out);
}
/* 设置字段 */
int Croute_func::user_task_set_client_data(DEAL_FUN_ARG)
{
	user_task_set_client_data_in *p_in=PRI_IN_POS; 
	ret=this->user_task.update_magic(RECVBUF_USERID, p_in->petid, p_in->taskid, "client", p_in->value);
	STD_RETURN(ret);
}
/* 得到字段 */
int Croute_func::user_task_get_client_data(DEAL_FUN_ARG)
{
	user_task_get_client_data_in *p_in=PRI_IN_POS; 
	user_task_get_client_data_out out={	};
	ret=this->user_task.get_client(RECVBUF_USERID, p_in->petid, p_in->taskid, &out.out);
	STD_RETURN_WITH_STRUCT(ret,out);

}
/* 得到拉姆魔法课的信息 */
int Croute_func::user_task_get_pet_task(DEAL_FUN_ARG)
{
	user_task_get_pet_task_in *p_in=PRI_IN_POS; 
	user_task_get_pet_task_out_header  out_header;
	user_task_get_pet_task_out_item *p_out_item = NULL;
	ret=this->user_task.get_pet_magic(RECVBUF_USERID, p_in, &out_header.count, &p_out_item);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}


int Croute_func::user_reset_home(DEAL_FUN_ARG)
{
	user_reset_home_in *p_in=PRI_IN_POS; 
	stru_home_used_attirelist used_list;
	used_list.count=1;
	memcpy(&(used_list.item[0]),p_in,sizeof(*p_in) );

	stru_noused_attirelist noused_list;
	ret=this->user.home_edit_reset_all(RECVBUF_USERID,&used_list ,&noused_list );

	//确定返回长度
	uint32_t  private_size;
	private_size= sizeof(noused_list)-
					(HOME_NOUSE_ATTIRE_ITEM_MAX_EX -noused_list.count)*
					sizeof(noused_list .item[0]);
	STD_RETURN_WITH_BUF(ret, &noused_list, private_size );
}

/* 背包的物品放到衣柜里 */
int Croute_func::user_attire_put_chest(DEAL_FUN_ARG)
{
	user_attire_put_chest_in *p_in=PRI_IN_POS; 
	ret=this->user_attire.put_attire_chest(RECVBUF_USERID, p_in->attireid);
	STD_RETURN(ret);
}

/* 把衣柜的物品放到个人背包里 */
int Croute_func::user_attire_del_chest(DEAL_FUN_ARG)
{
	user_attire_del_chest_in *p_in=PRI_IN_POS; 
	ret=this->user_attire.get_chest(RECVBUF_USERID, p_in->attireid);
	STD_RETURN(ret);
}
/*  得到衣柜里的物品 */
int Croute_func::user_attire_get_chest_list(DEAL_FUN_ARG)
{
	user_attire_get_chest_list_out_header  out_header = {};
	user_attire_get_chest_list_out_item *p_out_item = NULL;
	ret=this->user_attire.get_chest_list(RECVBUF_USERID, &out_header.count, &p_out_item);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/* 改变礼物的数目 */
int Croute_func::roominfo_change_present(DEAL_FUN_ARG)
{
	roominfo_change_present_in *p_in=PRI_IN_POS; 
	uint32_t value = 0;
    ret=this->roominfo.change_int_field(RECVBUF_USERID, "present_num", p_in->change_value, 1000000, &value);
	if (ret == VALUE_NOENOUGH_E) {
		ret = PRESENT_IS_NOT_ENOUGH_ERR;
	}
    STD_RETURN(ret);
}
/* 得到礼品的数目 */
int Croute_func::roominfo_get_present_num(DEAL_FUN_ARG)
{
	roominfo_get_present_num_out out={};
	ret=this->roominfo.get_int_value(RECVBUF_USERID, "present_num", &out.num);
	STD_RETURN_WITH_STRUCT(ret,out);
}
/* 得到某一用户的宠物的信息(PHP用) */
int Croute_func::user_magic_task_pet_get_all(DEAL_FUN_ARG)
{
	user_magic_task_pet_get_all_out_header  out_header;
	user_magic_task_pet_get_all_out_item *p_out_item;
	ret=this->user_task.get_all_field(RECVBUF_USERID, &p_out_item, &out_header.count);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/* 设置宠物某一任务的信息(PHP用) */
int Croute_func::user_magic_task_pet_update(DEAL_FUN_ARG)
{
	user_magic_task_pet_update_in *p_in=PRI_IN_POS; 
	ret=this->user_task.update_all_field(RECVBUF_USERID, p_in);
	STD_RETURN(ret);
}

int Croute_func::user_attire_get_list_ex(DEAL_FUN_ARG)
{
	user_attire_get_list_ex_in *p_in=PRI_IN_POS; 
	user_attire_get_list_ex_out_header  out_header;
	user_attire_get_list_ex_out_item *p_out_item;
	ret=this->user_attire.get_list_ex(RECVBUF_USERID,p_in->start,p_in->count,
			&(out_header.count),&p_out_item  );
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::user_get_attire_list_all(DEAL_FUN_ARG)
{
	stru_count out_header; 	
	user_get_attire_list_out_item * list; 	
	user_get_attire_list_in *p_in=PRI_IN_POS;
	const char * type_str;
	DEBUG_LOG("attiretype: %u =============", p_in->attiretype);
	if(p_in->startattireid == 1351392){
		p_in->attiretype = 0;
	}
	switch ( p_in->attiretype ){
		case 0 ://装扮
			ret=this->user_attire.get_all_list_by_attireid_interval(
				RECVBUF_USERID , p_in->startattireid,p_in->endattireid,
				p_in->attire_usedflag, &(out_header.count),&list );
 				STD_RETURN_WITH_STRUCT_LIST(ret, out_header ,list,out_header.count );
		case 1://小屋
			stru_noused_attirelist home_noused_attirelist;	
			if (p_in->attire_usedflag==0 && p_in->startattireid+1 != p_in->endattireid ){ //未使用
				ret =this->user.home_get_noused_attirelist(RECVBUF_USERID,
						&home_noused_attirelist);
				if (ret!=SUCC) return ret;

				if (ret==SUCC&& home_noused_attirelist.count>HOME_NOUSE_ATTIRE_ITEM_MAX_EX ){
					ERROR_LOG(" __ERROR__  DB_DATA_ERR %u ",home_noused_attirelist .count);
					return USER_ATTIRE_MAX_ERR;		
				}
				DEBUG_LOG("====count:%u",home_noused_attirelist .count );
				uint32_t  private_size;
				private_size= sizeof(home_noused_attirelist )-
					(HOME_NOUSE_ATTIRE_ITEM_MAX_EX -home_noused_attirelist .count)*
					sizeof(home_noused_attirelist .item[0]);
				STD_RETURN_WITH_BUF(ret,&home_noused_attirelist ,private_size);

			} else if (p_in->attire_usedflag == 2 && p_in->startattireid + 1 != p_in->endattireid) {//所有
				stru_home_used_attirelist usedlist_1;
		   	stru_home_used_attirelist usedlist_2;
		   	stru_home_used_attirelist usedlist_3;	
				ret = this->user.home_get_all(RECVBUF_USERID, &home_noused_attirelist, &usedlist_1, &usedlist_2,&usedlist_3);
				if (ret != SUCC) return ret;

				for (uint32_t i = 0; i < usedlist_1.count; i++) {
					uint32_t j;
					for (j = 0; j < home_noused_attirelist.count; j++) {
						if (usedlist_1.item[i].attireid == home_noused_attirelist.item[j].attireid) {
							home_noused_attirelist.item[j].count += usedlist_1.get_attire_count(usedlist_1.item[i].attireid);
							break;
						}
					}
					if (j == home_noused_attirelist.count) {
						home_noused_attirelist.count += 1;
						if (home_noused_attirelist.count>HOME_NOUSE_ATTIRE_ITEM_MAX_EX ) {
							ERROR_LOG(" __ERROR__  DB_DATA_ERR %u ",home_noused_attirelist .count);
							return USER_ATTIRE_MAX_ERR;		
						}

						home_noused_attirelist.item[j].attireid = usedlist_1.item[i].attireid;
						home_noused_attirelist.item[j].count = usedlist_1.get_attire_count(usedlist_1.item[i].attireid);
					}
				}
				for (uint32_t i = 0; i < usedlist_2.count; i++) {
					uint32_t j;
					for (j = 0; j < home_noused_attirelist.count; j++) {
						if (usedlist_2.item[i].attireid == home_noused_attirelist.item[j].attireid) {
							home_noused_attirelist.item[j].count += usedlist_2.get_attire_count(usedlist_2.item[i].attireid);
							break;
						}
					}
					if (j == home_noused_attirelist.count) {
						home_noused_attirelist.count += 1;
						if (home_noused_attirelist.count>HOME_NOUSE_ATTIRE_ITEM_MAX_EX ) {
							ERROR_LOG(" __ERROR__  DB_DATA_ERR %u ",home_noused_attirelist .count);
							return USER_ATTIRE_MAX_ERR;		
						}

						home_noused_attirelist.item[j].attireid = usedlist_2.item[i].attireid;
						home_noused_attirelist.item[j].count = usedlist_2.get_attire_count(usedlist_2.item[i].attireid);
					}
				}
				for (uint32_t i = 0; i < usedlist_3.count; i++) {
					uint32_t j;
					for (j = 0; j < home_noused_attirelist.count; j++) {
						if (usedlist_3.item[i].attireid == home_noused_attirelist.item[j].attireid) {
							home_noused_attirelist.item[j].count += usedlist_3.get_attire_count(usedlist_3.item[i].attireid);
							break;
						}
					}
					if (j == home_noused_attirelist.count) {
						home_noused_attirelist.count += 1;
						if (home_noused_attirelist.count>HOME_NOUSE_ATTIRE_ITEM_MAX_EX ) {
							ERROR_LOG(" __ERROR__  DB_DATA_ERR %u ",home_noused_attirelist .count);
							return USER_ATTIRE_MAX_ERR;		
						}

						home_noused_attirelist.item[j].attireid = usedlist_3.item[i].attireid;
						home_noused_attirelist.item[j].count = usedlist_3.get_attire_count(usedlist_3.item[i].attireid);
					}
				}
				uint32_t  private_size;
				private_size = sizeof(home_noused_attirelist )-
								(HOME_NOUSE_ATTIRE_ITEM_MAX_EX - home_noused_attirelist.count)*
								sizeof(home_noused_attirelist .item[0]);
				STD_RETURN_WITH_BUF(ret,&home_noused_attirelist ,private_size);
			} else if ( p_in->startattireid+1 == p_in->endattireid){//只取一个
				uint32_t count;  
				uint32_t buf[3];
				ret=this->user.home_get_attire_count(RECVBUF_USERID,
						p_in->startattireid,p_in->attire_usedflag, &count  );
				if (count==0){
					buf[0]=0;
					STD_RETURN_WITH_BUF(ret,buf,4);
				}else{
					buf[0]=1;
					buf[1]=p_in->startattireid;
					buf[2]=count;
					STD_RETURN_WITH_BUF(ret,buf,12);
				}
			}else{
				return ENUM_OUT_OF_RANGE_ERR;
			}

		case 2://庄园
			type_str=JY_STR;		

			noused_homeattirelist noused_homeattirelist ; 	
			if (p_in->attire_usedflag==0 && p_in->startattireid+1 != p_in->endattireid ){ //未使用
				ret =this->user.get_noused_home_attirelist(type_str ,RECVBUF_USERID,
						&noused_homeattirelist);
				if (ret!=SUCC) return ret;

				uint32_t  private_size;
				if (ret==SUCC&& noused_homeattirelist.count>HOME_NOUSE_ATTIRE_ITEM_MAX ){
					ERROR_LOG(" __ERROR__  DB_DATA_ERR %u ",noused_homeattirelist.count);
					return USER_ATTIRE_MAX_ERR;		
				}
				private_size= sizeof(noused_homeattirelist )-
					(HOME_NOUSE_ATTIRE_ITEM_MAX -noused_homeattirelist.count)*
					sizeof(noused_homeattirelist .item[0]);

				STD_RETURN_WITH_BUF(ret,&noused_homeattirelist,private_size);

			} else if ( p_in->startattireid+1 == p_in->endattireid){//只取一个
				uint32_t count;  
				uint32_t buf[3];
				ret=this->user.get_attire_count(type_str ,RECVBUF_USERID,
						p_in->startattireid, p_in->attire_usedflag, &count);
				if (count==0){
					//DEBUG_LOG("attireid %u null",p_in->startattireid );
					buf[0]=0;
					STD_RETURN_WITH_BUF(ret,buf,4);
				}else{
					//DEBUG_LOG("attireid %u count %u ",p_in->startattireid,count );
					buf[0]=1;
					buf[1]=p_in->startattireid;
					buf[2]=count;
					STD_RETURN_WITH_BUF(ret,buf,12);
				}
			}else{
				return ENUM_OUT_OF_RANGE_ERR;
			}
		case 3://卡片
			if ( p_in->startattireid+1 == p_in->endattireid){//只取一个
				uint32_t is_existed;  
				uint32_t buf[3];
				ret=this->user_card.check_id(RECVBUF_USERID,p_in->startattireid,&is_existed);
				if (is_existed==0){
					buf[0]=0;
					STD_RETURN_WITH_BUF(ret,buf,4);
				}else{
					buf[0]=1;
					buf[1]=p_in->startattireid;
					buf[2]=1;
					STD_RETURN_WITH_BUF(ret,buf,12);
				}
			}else{
				return ENUM_OUT_OF_RANGE_ERR;
			}
		case 4://牧场
		case 5://牧场
			if (p_in->attiretype==4){
				type_str=FARM_STR;		
			}else{
				type_str=FEEDSTUFF_STR;		
			}


			if (p_in->attire_usedflag==0 && p_in->startattireid+1 != p_in->endattireid ){ //未使用
				ret =this->user_farm.get_noused_home_attirelist(type_str ,RECVBUF_USERID,
						&noused_homeattirelist);
				if (ret!=SUCC) return ret;

				uint32_t  private_size;
				if (ret==SUCC&& noused_homeattirelist.count>HOME_NOUSE_ATTIRE_ITEM_MAX ){
					ERROR_LOG(" __ERROR__  DB_DATA_ERR %u ",noused_homeattirelist.count);
					return USER_ATTIRE_MAX_ERR;		
				}
				private_size= sizeof(noused_homeattirelist )-
					(HOME_NOUSE_ATTIRE_ITEM_MAX -noused_homeattirelist.count)*
					sizeof(noused_homeattirelist .item[0]);

				STD_RETURN_WITH_BUF(ret,&noused_homeattirelist,private_size);

			}else if ( p_in->startattireid+1 == p_in->endattireid){//只取一个
				uint32_t count;  
				uint32_t buf[3];
				ret=this->user_farm.get_attire_count(type_str ,RECVBUF_USERID,
						p_in->startattireid,p_in->attire_usedflag, &count  );
				if (count==0){
					//DEBUG_LOG("attireid %u null",p_in->startattireid );
					buf[0]=0;
					STD_RETURN_WITH_BUF(ret,buf,4);
				}else{
					//DEBUG_LOG("attireid %u count %u ",p_in->startattireid,count );
					buf[0]=1;
					buf[1]=p_in->startattireid;
					buf[2]=count;
					STD_RETURN_WITH_BUF(ret,buf,12);
				}
			}else{
				return ENUM_OUT_OF_RANGE_ERR;
			}

		case 6://吉吉乐
			ret  = this->user_swap_card.get_card_interval(RECVBUF_USERID, p_in->startattireid,
					    p_in->endattireid, &list, &out_header.count);
			STD_RETURN_WITH_STRUCT_LIST(ret, out_header ,list,out_header.count);
		case 7://得到班级物品
			{
			char out[PROTO_MAX_LEN] = {	};
			uint32_t *p_count = (uint32_t *)out;
			user_get_attire_list_all_out_item *p_attire = (user_get_attire_list_all_out_item *)(out + 4);
			if (p_in->startattireid >= p_in->endattireid) {
				return VALUE_OUT_OF_RANGE_ERR;
			}
			for(uint32_t i = p_in->startattireid; i < p_in->endattireid; i++) {
				uint32_t count = 0;
				ret = this->user_class.get_attire_list_count(RECVBUF_USERID, i, p_in->attire_usedflag, &count);
				if (ret != SUCC) {
					return ret;
				}
				if (count != 0) {
					(p_attire + *p_count)->attireid = i;
					(p_attire + *p_count)->count = count;
					(*p_count)++;
				}
			}
			STD_RETURN_WITH_BUF(ret, out , 4 + (*p_count) * sizeof(user_get_attire_list_all_out_item));
			}
		case 8://得到每个汽车种类的数目 
			{
			ret = this->user_auto.get_auto_num_by_class(RECVBUF_USERID, &list, &(out_header.count),
				 p_in->startattireid, p_in->endattireid);
 			STD_RETURN_WITH_STRUCT_LIST(ret, out_header, list, out_header.count);
			}
		case 11:
		{
			if (p_in->startattireid + 1 != p_in->endattireid) {
				return ENUM_OUT_OF_RANGE_ERR;
			}
			uint32_t count = 0;
			ret = this->user_mdog.get_mdog(RECVBUF_USERID, p_in->startattireid, count);
			if (count > 0) {
				out_header.count = 1;
				if ((list = (user_get_attire_list_out_item*)malloc(sizeof(user_get_attire_list_out_item)))) {
					list->attireid = p_in->startattireid;
					list->count = out_header.count;
				} else {
					return SYS_ERR;
				}
				STD_RETURN_WITH_STRUCT_LIST(ret, out_header ,list,out_header.count);
			} else {
				if (ret != SUCC) {
					return ret;
				} else {
					uint32_t buff[1] = {0};
					STD_RETURN_WITH_BUF(ret, buff, 4);
				}
			}
		}
		case 99:
		{
			if(p_in->startattireid == 1351056){//商城积分特殊处理
				ret=this->user_attire.get_all_list_by_attireid_interval(
					RECVBUF_USERID , p_in->startattireid,p_in->endattireid,
					p_in->attire_usedflag, &(out_header.count),&list );
				STD_RETURN_WITH_STRUCT_LIST(ret, out_header ,list,out_header.count );
			}
			else{

				ret = this->user_temp_item.get_items_count(RECVBUF_USERID, p_in->startattireid,
					p_in->endattireid, &out_header.count,&list);
				STD_RETURN_WITH_STRUCT_LIST(ret, out_header ,list,out_header.count);
			}
		}
		case 32:
			ret = this->user_battle_articles.get_items_range(RECVBUF_USERID, p_in->startattireid,
				  p_in->endattireid, p_in->attire_usedflag, &out_header.count, &list);	
			STD_RETURN_WITH_STRUCT_LIST(ret, out_header ,list,out_header.count);
		case 36:
			ret = this->user_piglet_attire.get_items_range(RECVBUF_USERID, p_in->startattireid,
                  p_in->endattireid, p_in->attire_usedflag, &out_header.count, &list);
            STD_RETURN_WITH_STRUCT_LIST(ret, out_header ,list,out_header.count);
		default :
			return  ENUM_OUT_OF_RANGE_ERR;
	}
}


/* 得到本牧场被领的羊的数目 */
int Croute_func::user_farm_get_sheep_num(DEAL_FUN_ARG)
{
	user_farm_get_sheep_num_out out={};
	ret=this->user_farm.get_int_value(RECVBUF_USERID, "sheep", &out.num);
	STD_RETURN_WITH_STRUCT(ret,out);
}


int Croute_func::pp_set_vip(DEAL_FUN_ARG)
{
	pp_set_vip_in *p_in=PRI_IN_POS; 
	ret=this->send_email.pp_sync_vip(RECVBUF_USERID,p_in->flag);
	STD_RETURN(ret);
}

/* 购买汽车事务 */
int Croute_func::do_user_auto_insert(userid_t userid, user_auto_insert_in *p_in, user_auto_insert_out *p_out, int *p_temp)
{
	ret = this->user_auto.add(userid, p_in, &p_out->id);
	if (ret != SUCC) {
		return ret;
	}
	//修改豆豆
	ret = this->user.change_xiaomee(userid, -p_in->xiaomee, XIAOMEE_BUY_CAR, 0, p_temp);
	if (ret != SUCC) {
		DEBUG_LOG("Fail to change xiaomee : userid %u, money %u", userid, p_in->xiaomee);
		return ret;
	}
	return SUCC;
}

/* 插入汽车记录 */
int Croute_func::user_auto_insert(DEAL_FUN_ARG)
{
	user_auto_insert_in *p_in=PRI_IN_POS; 
	user_auto_insert_out out = {};
	//开启事务
	STD_CLOSE_AUTOCOMMIT(ret); 
	if(ret!=SUCC) return ret;
	int temp = 0;
	ret=this->do_user_auto_insert(RECVBUF_USERID, p_in, &out, &temp);
	if(ret==SUCC){
		//提交
		STD_COMMIT(ret); 
	}else{
		//回滚
		STD_ROLLBACK();
	}
			
	//关闭事务
	STD_OPEN_AUTOCOMMIT() ; 
	{
	change_log_item c_item;
	c_item.userid=RECVBUF_USERID;
	c_item.change_type=11;
	c_item.logtime=time(NULL);
	c_item.change_value=-p_in->xiaomee;
	c_item.change_v1=0;
	c_item.change_v2=temp;
	this->send_log.send(&c_item );
	}
	
	STD_RETURN_WITH_STRUCT(ret, out);
}

/* 更新引擎，颜色属性，返回旧值  */
int Croute_func::user_auto_change_attire(DEAL_FUN_ARG)
{
	user_auto_change_attire_in *p_in=PRI_IN_POS; 
	user_auto_change_attire_out out={};
	/* 删除要更换的物品 */
	if (p_in->type == 1) {
		user_del_attire_in p_del = {	};
		p_del.attireid = p_in->new_value;
		p_del.count = 1;
		p_del.maxcount = 1;
		ret=this->user_del_attire(RECVBUF_USERID, &p_del);
		if (ret != SUCC) {
			return ret;
		}
	}
	ret=this->user_auto.update_attire(p_in->id, RECVBUF_USERID, p_in->type, p_in->new_value, &out.id);
	if (ret != SUCC) {
		return ret;
	}
	/*把替换出来的物品加到个人收集品里 */
	if (out.id != 0) {
		//增加物品
		user_add_attire_in	add_item ={ };
		add_item.attiretype=0;
		add_item.attireid=out.id;
		add_item.count=1;
		//最多99999个
		add_item.maxcount=99999;
		ret=this->user_add_attire(RECVBUF_USERID,&add_item );
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 更新道具孔和道具信息 */
int Croute_func::user_auto_change_propery(DEAL_FUN_ARG)
{
	user_auto_change_propery_in *p_in=PRI_IN_POS; 
	user_auto_change_propery_out out={};
	/* 删除要更换的物品 */
	if ((p_in->type == 2) || (p_in->type == 4)) {
	
		user_del_attire_in p_del = {	};
		p_del.attireid = p_in->new_propery;
		p_del.count = 1;
		p_del.maxcount = 1;
		ret=this->user_del_attire(RECVBUF_USERID, &p_del);
		if (ret != SUCC) {
			return ret;
		}
	}
	ret=this->user_auto.change_propery(p_in->id, RECVBUF_USERID, p_in->type, p_in->propery_id,
			p_in->new_propery, &out.old_attire);
	/* 添加到个人收集品中 */
	if (out.old_attire != 0) {
		//增加物品
		user_add_attire_in	add_item ={ };
		add_item.attiretype=0;
		add_item.attireid=out.old_attire;
		add_item.count=1;
		//最多99999个
		add_item.maxcount=99999;
		ret=this->user_add_attire(RECVBUF_USERID,&add_item );
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 得到汽车的全部信息 */
int Croute_func::user_auto_get_all(DEAL_FUN_ARG)
{
	user_auto_get_all_out_header  out_header;
	user_auto_get_all_out_item *p_out_item = NULL;
	ret=this->user_auto.get_all_auto(RECVBUF_USERID, &p_out_item, &out_header.count);
	if (ret != SUCC) {
		return ret;
	}
	uint32_t now = time(NULL);
	for (uint32_t i = 0; i < out_header.count; i++) {
		DEBUG_LOG("====oil %u", (p_out_item + i)->auto_id);	
		ret = this->user_auto.get_init_oil((p_out_item + i)->auto_id, &(p_out_item + i)->total_oil);
		if (ret != SUCC) {
			return ret;
		}
		if ((now - (p_out_item + i)->oil_time) < 3600 * 24) {
			continue;
		}
		ret = this->user_auto.cal_oil((p_out_item + i)->id, RECVBUF_USERID, (p_out_item + i)->auto_id,
				&(p_out_item + i)->oil_time, &(p_out_item + i)->oil, (p_out_item + i)->engine);
		if (ret != SUCC) {
			return ret;
		}
	}
	STD_RETURN_WITH_STRUCT_LIST(ret, out_header, p_out_item, out_header.count);
}

/* 加油的事物 */
int Croute_func::do_user_auto_add_oil(userid_t userid, user_auto_add_oil_in *p_in, 
				user_auto_add_oil_out *p_out, int *p_temp)
{
	/* 给车加油，并计算出加油所需的豆豆 */
	ret = this->user_auto.add_oil(p_in->id, userid, &p_out->xiaomee);
	if (ret != SUCC) {
		return ret;
	}
	int change_xiaomee = (int)p_out->xiaomee;
	//扣除加油需要的豆豆
	ret = this->user.change_xiaomee(userid, -change_xiaomee, XIAOMEE_ADD_OIL , 0, p_temp);
	if (ret != SUCC) {
		ERROR_LOG("BANK:Fail to gvie back xiaomee, userid %u, xiaomee %u ", userid,
			p_out->xiaomee);
	}
	return ret;
}

/* 给汽车加油 */
int Croute_func::user_auto_add_oil(DEAL_FUN_ARG)
{
	user_auto_add_oil_in *p_in=PRI_IN_POS; 
	user_auto_add_oil_out out={};
	//开启事务
	STD_CLOSE_AUTOCOMMIT(ret); 
	if(ret!=SUCC) return ret;
	int temp = 0;
	ret = this->do_user_auto_add_oil(RECVBUF_USERID, p_in, &out, &temp);
	if(ret==SUCC){
		//提交
		STD_COMMIT(ret); 
	}else{
		//回滚
		STD_ROLLBACK();
	}
			
	//关闭事务
	STD_OPEN_AUTOCOMMIT() ; 
	{
		change_log_item c_item;
		c_item.userid=RECVBUF_USERID;
		c_item.change_type=11;
		c_item.logtime=time(NULL);
		c_item.change_value=-out.xiaomee;
		c_item.change_v1=0;
		c_item.change_v2=temp;
		this->send_log.send(&c_item );
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 得到单辆汽车的信息*/
int Croute_func::user_auto_get_one_info(DEAL_FUN_ARG)
{
	user_auto_get_one_info_in *p_in=PRI_IN_POS; 
	user_auto_get_one_info_out out={};
	/* 得到单辆汽车的信息 */
	ret=this->user_auto.get_one_auto_info(RECVBUF_USERID, p_in->id, &out);
	if (ret != SUCC) {
		return ret;
	}
	/* 计算油耗 */
	ret = this->user_auto.cal_oil(out.id, RECVBUF_USERID, out.auto_id,
				&out.oil_time, &out.oil, out.engine);
	if (ret != SUCC) {
		return ret;
	}
	ret = this->user_auto.get_init_oil(out.auto_id, &out.total_oil);
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 设置获取驾照时间 */
int Croute_func::user_ex_set_driver_time(DEAL_FUN_ARG)
{
	uint32_t value = 0;
	ret = this->user_ex.get_int_value(RECVBUF_USERID, "driver", &value);
	if (ret != SUCC) {
		return ret;
	}
	if (value == 0) {
    	ret=this->user_ex.set_int_value(RECVBUF_USERID, "driver", 1);
	}
	STD_RETURN(ret);
}

/* 设置展示的车 */
int Croute_func::user_ex_set_show_auto(DEAL_FUN_ARG)
{
	user_ex_set_show_auto_in *p_in=PRI_IN_POS; 
	if (p_in->type == 1) {
		bool exist = false;
		ret = this->user_auto.check_id_exist(RECVBUF_USERID, p_in->id, &exist);
		if (exist == false) {
			return YOU_HAVE_NOT_THIS_ID_ERR;
		}
		ret=this->user_ex.set_int_value(RECVBUF_USERID, "show_auto", p_in->id);
	} else {
		ret = this->user_ex.set_int_value(RECVBUF_USERID, "show_auto", 0);
	}
	STD_RETURN(ret);
}

/* 得到展示车的信息 */
int Croute_func::user_ex_get_show_auto(DEAL_FUN_ARG)
{
	user_ex_get_show_auto_out out={};
	uint32_t id = 0;
	/* 得到展示的车的ID号 */
	ret=this->user_ex.get_int_value(RECVBUF_USERID, "show_auto", &id);
	if (ret != SUCC) {
		return ret;
	}
	/* 得到展示车的信息 */
	ret = this->user_auto.get_one_auto_info(RECVBUF_USERID, id, &out);
	if (ret != SUCC) {
		return ret;
	}
	/* 计算油耗 */
	ret = this->user_auto.cal_oil(out.id, RECVBUF_USERID, out.auto_id,
				&out.oil_time, &out.oil, out.engine);
	if (ret != SUCC) {
		return ret;
	}
	ret = this->user_auto.get_init_oil(out.auto_id, &out.total_oil);
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 增加熟练程度 */
int Croute_func::user_ex_set_auto_skill(DEAL_FUN_ARG)
{
	user_ex_set_auto_skill_in *p_in=PRI_IN_POS; 
	uint32_t value = 0;
	ret=this->user_ex.change_int_field_without_max_check(RECVBUF_USERID, "skill", p_in->skill_value, &value);
	STD_RETURN(ret);
}

/* 更改汽车的装饰 */
int Croute_func::user_auto_change_adron(DEAL_FUN_ARG)
{
	user_auto_change_adron_in *p_in=PRI_IN_POS; 
	user_auto_change_adron_out out={};
	/* 从个人收集品中去除  */
	if ((p_in->type == 1) || (p_in->type == 3)) {
		user_del_attire_in p_del = {	};
		p_del.attireid = p_in->new_adron;
		p_del.count = 1;
		p_del.maxcount = 1;
		ret=this->user_del_attire(RECVBUF_USERID, &p_del);
		if (ret != SUCC) {
			return ret;
		}
	}
	ret=this->user_auto.change_adron(p_in->id, RECVBUF_USERID, p_in->type,
			       p_in->adron_id, p_in->new_adron, &out.old_attire);
	/*  加到个人收集品中 */
	if (out.old_attire != 0) {
		//增加物品
		user_add_attire_in	add_item ={ };
		add_item.attiretype=0;
		add_item.attireid=out.old_attire;
		add_item.count=1;
		//最多99999个
		add_item.maxcount=99999;
		ret=this->user_add_attire(RECVBUF_USERID,&add_item );
	}
	STD_RETURN_WITH_STRUCT(ret, out);
}

/* 班级增加分数 */
int Croute_func::user_class_add_score(DEAL_FUN_ARG)
{
	user_class_add_score_in *p_in=PRI_IN_POS; 
	user_class_add_score_out out={};
	ret=this->user_class.change_int_field_without_max_check(RECVBUF_USERID,
			"score", p_in->add_score, &out.score);
	STD_RETURN_WITH_STRUCT(ret,out);
}
/* 得到班级分数  */
int Croute_func::user_class_get_score(DEAL_FUN_ARG)
{
	user_class_get_score_out out={};
	ret=this->user_class.get_int_value(RECVBUF_USERID, "score", &out.score);
	STD_RETURN_WITH_STRUCT(ret,out);
}
/* 增加糖果的数目 */
int Croute_func::roominfo_add_candy(DEAL_FUN_ARG)
{
	roominfo_add_candy_in *p_in=PRI_IN_POS; 
	roominfo_add_candy_out out={};
	ret=this->roominfo.add_field(RECVBUF_USERID,
			"candy", p_in->add_candy, &out.candy_num);
	STD_RETURN_WITH_STRUCT(ret,out);
}
/* 得到糖果的数目 */
int Croute_func::roominfo_get_candy(DEAL_FUN_ARG)
{
	roominfo_get_candy_out out={};
	ret=this->roominfo.get_int_value(RECVBUF_USERID, "candy", &out.candy_num);
	if (ret == 1105) {
		out.candy_num = 0;
		ret = SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 得到设置密码的FLAG */
int Croute_func::user_info_get_set_passwd_flag(DEAL_FUN_ARG)
{
	user_info_get_set_passwd_flag_out out={};
	ret=this->user_info.get_bit_flag(RECVBUF_USERID,
			FLAG1_STR ,USER_FLAG1_CHANGE_PASSWD, &out.flag);
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 增加为班级贡献的分数,包括当天的和全部的 */
int Croute_func::roominfo_add_class_score(DEAL_FUN_ARG)
{
	roominfo_add_class_score_in *p_in=PRI_IN_POS; 
	ret=this->roominfo.add_score(RECVBUF_USERID, p_in->add_score);
	STD_RETURN(ret);
}

/* 得到为班级贡献班级的分数 */
int Croute_func::roominfo_get_class_score(DEAL_FUN_ARG)
{
	roominfo_get_class_score_out out={};
	ret=this->roominfo.get_int_value(RECVBUF_USERID, "score", &out.score);
	if (ret == 1105) {
		out.score = 0;
		ret =SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 得到为班级贡献的分数和糖果的数目 */
int Croute_func::roominfo_get_score_candy(DEAL_FUN_ARG)
{
	roominfo_get_score_candy_out out={};
	ret=this->roominfo.get_score_candy(RECVBUF_USERID, &out);
	if (ret == 1105) {
		ret = SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 增加被抓的糖果数量 */
int Croute_func::roominfo_add_catch_candy(DEAL_FUN_ARG)
{
	roominfo_add_catch_candy_in *p_in=PRI_IN_POS; 
	roominfo_add_catch_candy_out out={};
	ret=this->roominfo.add_field(RECVBUF_USERID,
			"candy",p_in->add_candy, &out.candy); 
	STD_RETURN_WITH_STRUCT(ret,out);
}
/* 炫风拉力赛报名 */
int Croute_func::roominfo_rally_sign(DEAL_FUN_ARG)
{
	roominfo_rally_sign_out out={};
	ret=this->roominfo_rally.sign_up(RECVBUF_USERID, &out.team);
	STD_RETURN_WITH_STRUCT(ret,out);
}
/* 旋风拉力赛 个人增加分数 */
int Croute_func::roominfo_rally_add_score(DEAL_FUN_ARG)
{
	roominfo_rally_add_score_in *p_in=PRI_IN_POS; 
	roominfo_rally_add_score_out out={};
	ret=this->roominfo_rally.add_score(RECVBUF_USERID, p_in->add_score, p_in->race_num, &out.finish);
	STD_RETURN_WITH_STRUCT(ret, out);
}
/* 得到个人分数 */
int Croute_func::roominfo_rally_get_score(DEAL_FUN_ARG)
{
	roominfo_rally_get_score_out out={};
	ret=this->roominfo_rally.get_int_value(RECVBUF_USERID, "score", &out.score);
	STD_RETURN_WITH_STRUCT(ret,out);
}
/* 增加队的分数 */
int Croute_func::sys_rally_update_score(DEAL_FUN_ARG)
{
	sys_rally_update_score_in *p_in=PRI_IN_POS; 
	ret=this->sys_rally.update_add(p_in->team, p_in->add_score);
	STD_RETURN(ret);
}
/* 更新赛道的时间 */
int Croute_func::sys_rally_update_race(DEAL_FUN_ARG)
{
	sys_rally_update_race_in *p_in=PRI_IN_POS; 
	if (p_in->index > 4 || p_in->index <= 0) {
		return VALUE_OUT_OF_RANGE_ERR;
	}
	if ((p_in->index == 2) || (p_in->index == 3)) {
		ret = SUCC;
		STD_RETURN(ret);
	}
	ret=this->sys_rally.update_race(p_in->team, p_in->index, p_in->value);
	STD_RETURN(ret);
}
/*  得到各个队的RACE值 */
int Croute_func::sys_get_team_race_list(DEAL_FUN_ARG)
{
	sys_get_team_race_list_out_header  out_header;
	sys_get_team_race_list_out_item *p_out_item;
	ret=this->sys_rally.get_list_race(&p_out_item, &out_header.count);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/* 得到各个队的分数 */
int Croute_func::sys_get_team_score_list(DEAL_FUN_ARG)
{
	sys_get_team_score_list_out_header  out_header;
	sys_get_team_score_list_out_item *p_out_item;
	ret=this->sys_rally.get_list_score(&p_out_item, &out_header.count);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/* 得到四个赛道参加的次数 */
int Croute_func::roominfo_rally_get_race_info(DEAL_FUN_ARG)
{
	roominfo_rally_get_race_info_out out={};
	ret=this->roominfo_rally.get_races(RECVBUF_USERID, &out.race1_num, &out.race2_num,
			 &out.race3_num, &out.race4_num);
	STD_RETURN_WITH_STRUCT(ret,out);
}
/* 得到当天获取的分数 */
int Croute_func::roominfo_rally_get_today_score(DEAL_FUN_ARG)
{
	roominfo_rally_get_today_score_out out={};
	ret=this->roominfo_rally.get_today_score(RECVBUF_USERID, &out.today_score);
	STD_RETURN_WITH_STRUCT(ret,out);
}
/* 各个赛道数减一 */
int Croute_func::roominfo_rally_desc_race(DEAL_FUN_ARG)
{
	ret=this->roominfo_rally.change_race(RECVBUF_USERID);
	STD_RETURN(ret);
}
/* 用户是属于哪个队 */
int Croute_func::roominfo_rally_get_team(DEAL_FUN_ARG)
{
	roominfo_rally_get_team_out out={};
	ret=this->roominfo_rally.get_team_medal(RECVBUF_USERID, &out.score, &out.team, &out.medal);
	if (ret == 1105) {
		ret = SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}
/* 某类汽车的数量 */
int Croute_func::user_auto_get_one_kind_num(DEAL_FUN_ARG)
{
	user_auto_get_one_kind_num_in *p_in=PRI_IN_POS; 
	user_auto_get_one_kind_num_out out={};
	ret=this->user_auto.get_auto_class(RECVBUF_USERID, p_in->auto_id, &out.auto_count);
	STD_RETURN_WITH_STRUCT(ret,out);
}
/* 增加徽章数 */
int  Croute_func::roominfo_rally_add_medal(DEAL_FUN_ARG)
{
	roominfo_rally_add_medal_in *p_in=PRI_IN_POS; 
	uint32_t value = 0;
	ret=this->roominfo_rally.change_int_field_without_max_check(RECVBUF_USERID,
			               "day_medal", p_in->add_medal, &value);
	STD_RETURN(ret);
}
/* 设置绵羊的带出或者放回 */
int Croute_func::user_farm_set_outgo(DEAL_FUN_ARG)
{
	user_farm_set_outgo_in *p_in=PRI_IN_POS; 
	user_farm_set_outgo_out_header  out_header = {};
	user_farm_set_outgo_out_item *p_out_item;
	char out[PROTO_MAX_LEN] = { };
	/* 校验 */
	if (p_in->flag > 1) {
		return VALUE_OUT_OF_RANGE_ERR;
	}
	if (p_in->flag == 1) {
		uint32_t count_in_animal = 0;
		uint32_t count_in_fairy = 0;
		uint32_t count_in_contract = 0;
		uint32_t count_in_piglet = 0;
		ret  = this->user_farm_fairy.get_state_out_count(RECVBUF_USERID, count_in_fairy);
		ret = this->user_farm_animal.get_outgo_count(RECVBUF_USERID, &count_in_animal);
		ret = this->user_paradise_contract.get_count_type2(RECVBUF_USERID, count_in_contract);
		ret = this->user_piglet.get_outgo_count(RECVBUF_USERID, &count_in_piglet);
		if (count_in_fairy > 0 || count_in_animal > 0 || count_in_contract > 0 || count_in_piglet > 0) {
			return YOU_HAVE_ANIMAL_OUTGO_ERR;
		}
	}
	uint32_t  animalid = 0;
	uint32_t is_in_fairy = 0;
	ret = this->user_farm_animal.get_animal_id(RECVBUF_USERID, p_in->id, &animalid);
	if(animalid != 0){
		uint32_t flag_out = 0;
		uint32_t state = 0;
		ret = this->user_farm_animal.get_outgo(RECVBUF_USERID, p_in->id, &flag_out);
		if (p_in->flag == 1) {
			flag_out |= 0x01;
			state = 20;//20表示星级动动物从牧场中带到身边的状态
		}
		if (p_in->flag == 0) {
			flag_out &= 0xFFFE;
			state = 17;//17表示在牧场中
		}
		/* 设置动物的带出状态 */
		ret = this->user_farm_animal.set_or_cancel_outgo(RECVBUF_USERID, p_in->id, flag_out);
		if (ret != SUCC) {
			return ret;
		}
		ret = this->user_farm_fairy.update_state_by_id(RECVBUF_USERID, p_in->id, state);
		if(ret == USER_ID_NOFIND_ERR){
			ret = SUCC;
		}
	}else{
		uint32_t state = 0;
		if (p_in->flag == 1) {
        	state = 36; //36表示星级动物是从农副产品中带到身边的状态
        }
        if (p_in->flag == 0) {
            state = 34; // 34 表示在仓库中
        }	
		ret = this->user_farm_fairy.update_state_by_id(RECVBUF_USERID, p_in->id, state);
		if(ret != SUCC){
			return ret;
		}
		is_in_fairy = 1;
	}
	/* 返回陆生动物信息 */
	ret = this->user_farm_animal.get_land_animal_insect(RECVBUF_USERID, &p_out_item, &out_header.count);
	for (uint32_t i = 0; i < out_header.count; i++) {
		uint32_t ret = this->user_farm_animal.fill_attribute(p_out_item + i);
		if (ret != SUCC) {
			return ret;
		}
	}
	user_farm_set_outgo_out_header *p_out_header = (user_farm_set_outgo_out_header *)out;
	p_out_header->count = out_header.count;
	char *p_out_content = out + 4;
	memcpy(p_out_content,(char *)p_out_item, sizeof(user_farm_set_outgo_out_item) * out_header.count);
	if(is_in_fairy == 1){
		uint32_t animal_id = 0;
		uint32_t level = 0;
		ret = this->user_farm_fairy.get_fairy(RECVBUF_USERID, p_in->id, animal_id, level);
		p_out_header->count =out_header.count + 1;
		user_farm_set_outgo_out_item *p_final = (user_farm_set_outgo_out_item *)(out + 
				sizeof(user_farm_set_outgo_out_item) * out_header.count + 4);
		p_final->id = p_in->id;
		p_final->animal_id = animal_id;
		p_final->outgo = 0x01;
		p_final->state = 0;
		p_final->growth = 99999;
		p_final->eat_time = 0;
		p_final->drink_time = 0;
		p_final->total_output = 0;
		p_final->output_time = 0;
		p_final->lastcal_time = 0;
		p_final->mature_time = (uint32_t)get_date(time(0)); 
		p_final->animal_type = 0;
		p_final->favor_time = 0;
		p_final->favor = 0;
		p_final->animal_flag = 0;
		p_final->pollinate_num = 0;///<  授粉次数
		p_final->pollinate_tm = 0;
		p_final->max_output = 0;
		p_final->diff_mature = 0;///< 还有多长时间成年
		p_final->cur_grow = 0; ///<  目前的成长数据室多少
        p_final->level = level;	
	}
	STD_RETURN_WITH_BUF(ret ,out, sizeof(user_farm_set_outgo_out_item) * p_out_header->count + 4);	
	//STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/*带出去，设置吃饭时间,并且把好感度设置为满 */
int Croute_func::user_farm_set_eattime(DEAL_FUN_ARG)
{
	user_farm_set_eattime_in *p_in=PRI_IN_POS; 
	user_farm_set_eattime_out out = { };
	ret=this->user_farm_animal.set_eat_time(RECVBUF_USERID, p_in->id);
	if (ret != SUCC) {
		return ret;
	}
	uint32_t animal_type = 0;
	ret = this->user_farm_animal.get_one_animal_info(RECVBUF_USERID, p_in->id, &out, &animal_type);
	//为了满足返回值的剩余产值
	out.total_output = this->user_farm_animal.fruit_max(out.animal_id) - out.total_output;
	
	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::user_ex_set_int_value(DEAL_FUN_ARG)
{
	user_ex_set_int_value_in *p_in=PRI_IN_POS; 
	ret=this->user_ex.set_int_value(RECVBUF_USERID,p_in->field_name,p_in->value );
	STD_RETURN(ret);
}
int Croute_func::user_set_int_value(DEAL_FUN_ARG)
{
	user_set_int_value_in *p_in=PRI_IN_POS; 
	ret=this->user.set_int_value(RECVBUF_USERID,p_in->field_name,p_in->value );
	STD_RETURN(ret);
}
/* 删除某个汽车 */
int Croute_func::user_auto_del(DEAL_FUN_ARG)
{
	user_auto_del_in *p_in=PRI_IN_POS; 
	ret=this->user_auto.del_auto(RECVBUF_USERID, p_in->id);
	STD_RETURN(ret);
}

/* 得到用户的对应的物品的个数 */
int Croute_func::user_attire_get_some_attire_count(DEAL_FUN_ARG)
{
	char out[PROTO_MAX_LEN]={ };
	user_attire_get_some_attire_count_in_header *p_in=PRI_IN_POS;
	if (p_in->count  >= 2000) {
		return VALUE_OUT_OF_RANGE_ERR;
	}
	CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_attire_get_some_attire_count_in_item));
	user_attire_get_some_attire_count_in_item * p_in_item=(user_attire_get_some_attire_count_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
	user_attire_get_some_attire_count_out_header  out_header = {};
	user_attire_get_some_attire_count_out_item *p_out_item = NULL;
	user_attire_get_some_attire_count_out_header *p_out_header  = (user_attire_get_some_attire_count_out_header *)out; 
	user_attire_get_some_attire_count_out_item *p_out =  (user_attire_get_some_attire_count_out_item*)(out + 4); 
	for (uint32_t i = 0; i < p_in->count; i++) {
		(p_out + i)->attireid = (p_in_item + i)->attireid;
	}
	p_out_header->count = p_in->count;
	ret=this->user_attire.get_discontinuous_attire(RECVBUF_USERID, p_in_item,
		p_in->count, &p_out_item, &out_header.count);
	if (ret == VALUE_OUT_OF_RANGE_ERR) {
		ret = SUCC;
		out_header.count=0 ;
		p_out_item=NULL;	
	}
	for (uint32_t i = 0; i < out_header.count; i++) {
		for (uint32_t j = 0; j < p_in->count; j++) {
			if ((p_out + j)->attireid == (p_out_item + i)->attireid) {
				(p_out + j)->count = (p_out_item + i)->count;
				break;
			}
		}
	}
	free(p_out_item);
	STD_RETURN_WITH_BUF(ret, out, sizeof(user_attire_get_some_attire_count_out_item) * (p_out_header->count) + 4);
	//STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/* 得到某个用户的全部汽车的信息，WEB页面用 */
int Croute_func::user_auto_get_all_web(DEAL_FUN_ARG)
{
	user_auto_get_all_web_out_header  out_header;
	user_auto_get_all_web_out_item *p_out_item;
	ret=this->user_auto.get_all_auto(RECVBUF_USERID, &p_out_item, &out_header.count);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/* 设置或者插入用户的某个汽车，WEB页面用 */
int Croute_func::user_auto_set_auto_web(DEAL_FUN_ARG)
{
	user_auto_set_auto_web_in *p_in=PRI_IN_POS; 
	user_auto_insert_in temp = {};
	temp.auto_id = p_in->autoid;
	if (p_in->id == 0) {
		uint32_t id = 0;
		ret = this->user_auto.insert(RECVBUF_USERID, &temp, &id);
	} else {
		ret = this->user_auto.update_web(RECVBUF_USERID, p_in->id, p_in->oil, p_in->engine,
			 p_in->color, p_in->oil_time);
	}
	STD_RETURN(ret);
}
/* 得到合成列表 */
int Croute_func::roominfo_get_merge(DEAL_FUN_ARG)
{
	roominfo_get_merge_buf out={};
	ret=this->roominfo.get_merge(RECVBUF_USERID, &out);
	if (ret == USER_ID_NOFIND_ERR) {
		ret = SUCC;
	}
	STD_RETURN_WITH_BUF(ret, &out, 4 + sizeof(roominfo_get_merge_out_item) * out.count);
}

/* 保存合成的物品数 */
int Croute_func::roominfo_merge_update(DEAL_FUN_ARG)
{
	roominfo_merge_update_in *p_in=PRI_IN_POS;
	roominfo_get_merge_buf out = {};
	ret=this->roominfo.get_merge(RECVBUF_USERID, &out);
	if (ret != SUCC && ret != 1105) {
		return ret;
	}
	if (out.count >= 10) {
		return VALUE_OUT_OF_RANGE_ERR;
	}
	uint32_t i = 0;
	for (i = 0; i < out.count; i++) {
		if (out.item[i].attireid == p_in->attireid) {
			out.item[i].count += p_in->count;
			break;
		}
	}
	if (i == out.count) {
		out.item[out.count].attireid = p_in->attireid;
		out.item[out.count].count += p_in->count;
		out.count++;
	}
	/* 更新了，如不存在就插入一条记录 */
	ret = this->roominfo.insert_merge(RECVBUF_USERID, &out);
	STD_RETURN(ret);
}

/* 得到合成的物品总数（未取出的） */
int Croute_func::roominfo_merge_set_get(DEAL_FUN_ARG)
{
	roominfo_get_merge_buf buf = {};
	ret=this->roominfo.get_merge(RECVBUF_USERID, &buf);
	if (ret == 1105) {
		return SUCC;
	} else if (ret != SUCC) {
		return ret;
	} 
	roominfo_get_merge_buf temp = { };
	ret = this->roominfo.update_merge(RECVBUF_USERID, &temp);
	STD_RETURN_WITH_BUF(ret, (char *)&buf, 4 + 8 * buf.count);
}

/* 返回email地址的登入 */
int Croute_func::userinfo_log_for_blw(DEAL_FUN_ARG)
{
	userinfo_log_for_blw_in *p_in=PRI_IN_POS; 
	userinfo_log_for_blw_out out={};

	ip_history_item ctiem;
	ctiem.userid = RECVBUF_USERID;
	ctiem.which_game = 21;
	ctiem.ip = p_in->ip;
	ret=this->send_log.send_ip(&ctiem);
	
	ret=this->user_info.login_ex_with_email(RECVBUF_USERID, p_in->passwd, &out.gameflag, out.email);
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 设置道具在身上 */
int Croute_func::user_attire_set_used(DEAL_FUN_ARG)
{
	user_attire_set_used_in_header *p_in=PRI_IN_POS;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_attire_set_used_in_item));
	user_attire_set_used_in_item * p_in_item=(user_attire_set_used_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
	user_attire_set_used_out_header out_header;
	user_attire_set_used_out_item *p_out_item;
	/* 返回mole原来身上穿的衣服 */
	ret = this->user_attire.get_mole_clothe(RECVBUF_USERID, &p_out_item, &out_header.count);
	if (ret != SUCC) {
		return ret;
	}
	ret=this->user_attire.set_used_attire(RECVBUF_USERID, p_in_item, p_in->count);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/* 检查是否有合成的物品 */
int Croute_func::roominfo_check_candy(DEAL_FUN_ARG)
{
	roominfo_check_candy_out out={};
	ret=this->roominfo.check_candy(RECVBUF_USERID, &out.flag);
	STD_RETURN_WITH_STRUCT(ret,out);
}
/* 得到拉力赛的个人信息，WEB页面用 */
int Croute_func::roominfo_rally_get_user_all_info_web(DEAL_FUN_ARG)
{
	roominfo_rally_get_user_all_info_web_out out={};
	ret=this->roominfo_rally.get_all_info(RECVBUF_USERID, &out);
	STD_RETURN_WITH_STRUCT(ret,out);
}
/* 得到糖果数和分数，WEB页面用 */
int Croute_func::roominfo_get_user_all_info_web(DEAL_FUN_ARG)
{
	roominfo_get_user_all_info_web_out out={};
	ret=this->roominfo.get_candy_score(RECVBUF_USERID, &out);
	out.flag = (out.prop_count & 0X80000000) ? 1 : 0;
	out.prop_count = out.prop_count & 0X7FFFFFFF;
	STD_RETURN_WITH_STRUCT(ret,out);
}
/* 用渔网捕鱼 */
int Croute_func::do_user_farm_net_catch_fish(userid_t userid, user_farm_net_catch_fish_out_header *p_out_header, 
		       user_farm_net_catch_fish_out_item **pp_out_item)
{
	uint32_t net_count = 0;
	ret = this->user_farm.get_int_value(userid, "net", &net_count);
	if (ret != SUCC) {
		return ret;
	}
	if (net_count == 0) {
		return YOU_HAVE_NOT_NET_ERR;
	}
	if (net_count == 1) {
		return YOU_NET_HAVE_BROKEN_ERR;
	}
	ret = this->user_farm_animal.net_catch_fish(userid, pp_out_item, &p_out_header->count);
	if (ret != SUCC) {
		return ret;
	}
	for (uint32_t i = 0; i < p_out_header->count; i++) {
		//增加物品
		user_add_attire_in	add_item ={ };
		add_item.attiretype=0;
		add_item.attireid=(*pp_out_item + i)->fish_type;
		add_item.count=(*pp_out_item + i)->count;

		//最多99999个
		add_item.maxcount=99999;
		ret=this->user_add_attire(userid, &add_item );
		if (ret==VALUE_OUT_OF_RANGE_ERR){
			//果实个数超过最大数
			return	USER_FRUIT_MAX_ERR	;
		}else if (ret!=SUCC){
			return ret;
		}
	}
	if (p_out_header->count != 0) {
		ret = this->user_farm.change_int_field_without_max_check(userid, "net", -1, &net_count);
		p_out_header->net = net_count;
	} else {
		p_out_header->net = net_count;
	}
	uint32_t count_exp = 0;
	for (uint32_t i = 0; i < p_out_header->count; i++) {
		uint32_t exp = 0;
		this->user_farm_animal.get_exp((*pp_out_item + i)->fish_type, &exp);
		count_exp += exp * (*pp_out_item + i)->count; 
	}
	ret = this->user_farm.catch_get_exp(userid, 2, count_exp, &p_out_header->exp);
	return ret;
}

/* 用渔网捕鱼 */
int Croute_func::user_farm_net_catch_fish(DEAL_FUN_ARG)
{
	user_farm_net_catch_fish_out_header  out_header = { };
	user_farm_net_catch_fish_out_item *p_out_item;
	//开启事务
	STD_CLOSE_AUTOCOMMIT(ret); 
	if(ret!=SUCC) return ret;
	ret = this->do_user_farm_net_catch_fish(RECVBUF_USERID, &out_header, &p_out_item);
	if(ret==SUCC){
		//提交
		STD_COMMIT(ret); 
	}else{
		//回滚
		STD_ROLLBACK();
	}
	//结束事务
	STD_OPEN_AUTOCOMMIT() ; 
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/* 购买渔网，设置渔网的初始值 */
int Croute_func::user_farm_set_net(DEAL_FUN_ARG)
{
	ret=this->user_farm.set_int_value(RECVBUF_USERID, "net", 21);
	if (ret == USER_ID_NOFIND_ERR) {
		this->user_farm.insert(RECVBUF_USERID);
		ret = this->user_farm.set_int_value(RECVBUF_USERID, "net", 21);
	}
	STD_RETURN(ret);
}

/* 得到渔网的数值 */
int Croute_func::user_farm_get_net(DEAL_FUN_ARG)
{
	user_farm_get_net_out out={};
	ret=this->user_farm.get_int_value(RECVBUF_USERID, "net", &out.net);
	if (ret == USER_ID_NOFIND_ERR) {
		ret = SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}
/* 增加糖果说数和道具数 */
int Croute_func::roominfo_change_candy_ex(DEAL_FUN_ARG)
{
	roominfo_change_candy_ex_in *p_in=PRI_IN_POS; 
	roominfo_change_candy_ex_out out = { };
	ret = this->roominfo.change_candy_prop(RECVBUF_USERID, p_in->flag, p_in->change_candy,
		 p_in->change_prop, &out.flag, &out.prop);
	STD_RETURN_WITH_STRUCT(ret, out);
}
/* 得到糖果说数和道具数量 */
int Croute_func::roominfo_change_candy(DEAL_FUN_ARG)
{
	roominfo_change_candy_out out={};
	ret=this->roominfo.get_candy_prop(RECVBUF_USERID, &out.candy_num, &out.prop_num);
	out.prop_num &= 0x3FFFFFFF;
	if (ret == USER_ID_NOFIND_ERR) {
		ret = SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}
/*  设置roominfo表里的信息，web页面用 */
int Croute_func::roominfo_set_user_all_info_web(DEAL_FUN_ARG)
{
	roominfo_set_user_all_info_web_in *p_in=PRI_IN_POS; 
	ret=this->roominfo.update_user_info(RECVBUF_USERID, p_in);
	STD_RETURN(ret);
}
/* 检查领取的糖果数是否达到上限 */
int Croute_func::roominfo_check_candy_list(DEAL_FUN_ARG)
{
	roominfo_check_candy_list_in *p_in=PRI_IN_POS; 
	ret=this->roominfo.check_candy_list(RECVBUF_USERID, p_in->userid);
	STD_RETURN(ret);
}
/* 暂时未上------------------------------------------- */
int Croute_func::roommsg_insert_bibo(DEAL_FUN_ARG)
{
	roommsg_insert_bibo_in *p_in=PRI_IN_POS; 
	ret=this->roommsg_bibo.bibo_edit(RECVBUF_USERID, p_in);
	STD_RETURN(ret);
}

int Croute_func::roommsg_del_bibo(DEAL_FUN_ARG)
{
	roommsg_del_bibo_in *p_in=PRI_IN_POS; 
	ret=this->roommsg_bibo.del(RECVBUF_USERID, p_in->date);
	STD_RETURN(ret);
}

int Croute_func::roommsg_get_bibo_list(DEAL_FUN_ARG)
{
	roommsg_get_bibo_list_in *p_in=PRI_IN_POS; 
	roommsg_get_bibo_list_out_header  out_header;
	roommsg_get_bibo_list_out_item *p_out_item;
	ret=this->roommsg_bibo.get_list(RECVBUF_USERID, p_in, &p_out_item, &out_header.count);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::sysarg_db_msg_edit(DEAL_FUN_ARG)
{
	sysarg_db_msg_edit_in *p_in=PRI_IN_POS; 
	ret=this->sys_msg.msg_edit(p_in);
	STD_RETURN(ret);
}

int Croute_func::sysarg_db_msg_del(DEAL_FUN_ARG)
{
	sysarg_db_msg_del_in *p_in=PRI_IN_POS; 
	ret=this->sys_msg.del(p_in->date, p_in->start);
	STD_RETURN(ret);
}

int Croute_func::sysarg_db_msg_get(DEAL_FUN_ARG)
{
	sysarg_db_msg_get_in *p_in=PRI_IN_POS; 
	sysarg_db_msg_get_out_header  out_header;
	sysarg_db_msg_get_out_item *p_out_item;
	ret=this->sys_msg.get_list(p_in, &p_out_item, &out_header.count);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::sysarg_db_msg_get_all_web(DEAL_FUN_ARG)
{
	sysarg_db_msg_get_all_web_out_header  out_header;
	sysarg_db_msg_get_all_web_out_item *p_out_item;
	ret=this->sys_msg.get_all(&p_out_item, &out_header.count);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/* 暂时未上------------------------------------------- */


/* 改变家园的种植的等级,打兔子用,使值加2 */
int Croute_func::user_jy_add_exp(DEAL_FUN_ARG)
{
	user_jy_add_exp_in *p_in=PRI_IN_POS;
	user_jy_add_exp_out out = { };
	ret=this->user_farm.add_other(RECVBUF_USERID, p_in->exp, p_in->type, &out.exp);
	STD_RETURN_WITH_STRUCT(ret, out);
}
/* 改变NPC的好感度 */
int Croute_func::user_npc_change(DEAL_FUN_ARG)
{
	user_npc_change_in *p_in=PRI_IN_POS; 
	ret=this->user_npc.change_npc(RECVBUF_USERID, p_in->change_value, p_in->index);
	STD_RETURN(ret);
}

/* 得到牧场的信息，WEB页面用 */
int Croute_func::user_farm_get_web(DEAL_FUN_ARG)
{
	user_farm_get_web_out out={};
	ret=this->user_farm.get_farm_web(RECVBUF_USERID, &out);
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 设置牧场的信息，WEB页面用 */
int Croute_func::user_farm_set_web(DEAL_FUN_ARG)
{
	user_farm_set_web_in *p_in=PRI_IN_POS; 
	ret=this->user_farm.set_farm_web(RECVBUF_USERID, p_in);
	STD_RETURN(ret);
}

/* 得到NPC的信息，WEB页面用 */
int Croute_func::user_npc_get_web(DEAL_FUN_ARG)
{
	user_npc_get_web_out out={};
	ret=this->user_npc.get_npc(RECVBUF_USERID, &out);
	if (ret == 1105) {
		ret = SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 更新NPC的信息，WEB页面用 */
int Croute_func::user_npc_update_web(DEAL_FUN_ARG)
{
	user_npc_update_web_in *p_in=PRI_IN_POS; 
	ret=this->user_npc.update_all_npc(RECVBUF_USERID, p_in);
	STD_RETURN(ret);
}

/* 设置放到yidi那边的兔子，并且设置为不在牧场, 暂时没上*/
int Croute_func::user_farm_rabbit_foster(DEAL_FUN_ARG)
{
	user_farm_rabbit_foster_in *p_in=PRI_IN_POS; 
	ret=this->user_farm.foster_rabbit(RECVBUF_USERID, p_in->id);
	if (ret != SUCC) {
		return ret;
	}
	ret = this->user_farm_animal.set_or_cancel_outgo(RECVBUF_USERID, p_in->id, 3);
	STD_RETURN(ret);
}

/* 删除已经到期的兔子，并且放回牧场, 暂时没上 */
int Croute_func::user_farm_rabbit_del(DEAL_FUN_ARG)
{
	user_farm_rabbit_del_out out={};
	uint32_t foster_array[15] = { };
	ret=this->user_farm.del_foster_rabbit(RECVBUF_USERID, foster_array, &out.count_2);
	if (ret != SUCC) {
		return ret;
	}
	uint32_t i = 0;
	for (i = 0; i < 15; i++) {
		if (foster_array[i] != 0) {
			ret = this->user_farm_animal.set_or_cancel_outgo(RECVBUF_USERID, foster_array[i], 0);
		} else {
			break;
		}
	}
	out.count_1 = i;
	STD_RETURN_WITH_STRUCT(ret,out);
}
/* 得到每天任务某个范围的值 */
int Croute_func::sysarg_day_get_list(DEAL_FUN_ARG)
{
	sysarg_day_get_list_in *p_in=PRI_IN_POS; 
	sysarg_day_get_list_out_header  out_header;
	sysarg_day_get_list_out_item *p_out_item;
	ret=this->usermap_day.get_value_list_by_type(RECVBUF_USERID, p_in->start_type, p_in->end_type,
			&out_header.count, &p_out_item);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/* 得到某个用户的农场和牧场的等级 */
int Croute_func::user_farm_get_plant_breed(DEAL_FUN_ARG)
{
	user_farm_get_plant_breed_out out={};
	ret=this->user_farm.get_plant_breed(RECVBUF_USERID, &out.plant_lv, &out.breed_lv);
	if (ret == USER_ID_NOFIND_ERR){
		ret = SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 放置蛋去孵化 */
int Croute_func::user_egg_insert(DEAL_FUN_ARG)
{
	user_egg_insert_in *p_in=PRI_IN_POS; 
	uint32_t check = 0;
	this->user_egg.check_id(p_in->attireid, &check);
	if (!check) {
		return VALUE_OUT_OF_RANGE_ERR;
	}

	if (p_in->attireid == 1270029) {
		uint32_t count = 0;
		ret = this->user_farm_animal.get_one_animal_count_sql(RECVBUF_USERID, 1270028, &count);
		if (count >= 1) {
			return EGG_MORE_THAN_LIMIT_ERR;
		}
		count = 0;
		ret = this->user_egg.get_one_egg_count(RECVBUF_USERID, 1270029, &count);
		if (count >= 1) {
			return EGG_MORE_THAN_LIMIT_ERR;
		}
	}
	/* 个人收集品里删除一个蛋 */
	user_del_attire_in del_item;
	del_item.attireid = p_in->attireid;
	del_item.attiretype = 0;
	del_item.count=1;
	del_item.maxcount = 99999;
	ret=this->user_del_attire(RECVBUF_USERID ,&del_item);
	if (ret != SUCC) {
		return ret;
	}
	/*蛋放到去孵化 */
	ret=this->user_egg.insert_record(RECVBUF_USERID, p_in->pos, p_in->attireid);
	if (ret != SUCC) {
		user_add_attire_in add_item = {};
		add_item.attiretype = 0;//装扮
		add_item.attireid = p_in->attireid;
		add_item.count = 1;
		//最多99999个
		add_item.maxcount=99999;
		ret=this->user_add_attire(RECVBUF_USERID, &add_item);
		if (ret==VALUE_OUT_OF_RANGE_ERR) {
			ret = SUCC;
		} else if (ret!=SUCC) {
			return ret;
		
		}
	}
	STD_RETURN(ret);
}

/* 交互孵蛋 */
int Croute_func::user_egg_fudan(DEAL_FUN_ARG)
{
	user_egg_fudan_in *p_in=PRI_IN_POS; 
	uint32_t attireid = 0;
	ret=this->user_egg.add_num(RECVBUF_USERID, p_in->userid, p_in->pos, &attireid);
	if(SUCC!=ret)
	{
		return ret;
	}

	if(RECVBUF_USERID!=p_in->userid)
	{
		ret = this->user_farm.jy_accesslist_set_opt(RECVBUF_USERID, p_in->userid, 0X08);
	}
	STD_RETURN(ret);
}

/* 得到蛋孵化的次数 */
int Croute_func::user_egg_get_info(DEAL_FUN_ARG)
{
	user_egg_get_info_in *p_in=PRI_IN_POS; 
	user_egg_get_info_out out={};
	stru_user_egg_all list = { };
	ret=this->user_egg.get_one_info(RECVBUF_USERID, p_in->pos, &list);
	if (ret != SUCC) {
		return ret;
	}
	out.num = list.num;
	ret = this->user_egg.get_brood_num(list.attireid, &out.total_num);
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 领取画卷，暂时不上 */
int Croute_func::roominfo_pic_insert(DEAL_FUN_ARG)
{
	roominfo_pic_insert_in *p_in=PRI_IN_POS; 
	uint32_t pic_time = 0;
	ret = this->roominfo.get_int_value(RECVBUF_USERID, "pic_time", &pic_time);
	if (ret != SUCC) {
		return ret;
	}
	uint32_t now = time(NULL);
	//领回
	if (p_in->type == 1) {
		if (pic_time + 3600 * 24 > (uint32_t)time(NULL)) {
			return YOU_HAVE_NOT_ENOUGH_TIME_ERR;
		}
		now = 0;
	}
	//领取
	if (p_in->type == 0) {
		if (pic_time != 0) {
			return YOU_HAVE_PIC_ERR;
		}
	}
	ret=this->roominfo.set_int_value(RECVBUF_USERID, "pic_time", now);
	STD_RETURN(ret);
}

/* 剪羊毛 */
int Croute_func::user_farm_animal_get_wool(DEAL_FUN_ARG)
{
	user_farm_animal_get_wool_in *p_in=PRI_IN_POS; 
	ret=this->user_farm_animal.get_wool(RECVBUF_USERID, p_in->id);
	STD_RETURN(ret);
}

/* 更新动物每天领取的上限 */
int Croute_func::sysarg_db_update_animal_limit(DEAL_FUN_ARG)
{
	sysarg_db_update_animal_limit_in *p_in=PRI_IN_POS; 
	ret=this->sys_animal.change_value(p_in->attireid, p_in->change_value, p_in->maxvalue);
	STD_RETURN(ret);
}

/* 得到动物当天领取的数目 */
int Croute_func::sysarg_get_animal_limit(DEAL_FUN_ARG)
{
	sysarg_get_animal_limit_in *p_in=PRI_IN_POS; 
	sysarg_get_animal_limit_out out={};
	ret=this->sys_animal.get_col_value(p_in->attireid, &out.count);
	if (ret == KEY_NOFIND_ERR) {
		ret = SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 接任务 */
int Croute_func::user_npc_task_recv(DEAL_FUN_ARG)
{
	user_npc_task_recv_in *p_in=PRI_IN_POS; 
	user_npc_task_recv_out out = { }; 
	int32_t npc_favor = 0;
	ret = this->user_npc.get_one_npc(RECVBUF_USERID, p_in->npc, &npc_favor);
	if (ret != SUCC) {
		if (ret == USER_ID_NOFIND_ERR) {
			ret = SUCC;
		} else {
			return ret;
		}
	}
	if (npc_favor < p_in->npc_favor) {
		return YOU_NPC_FAVOR_NOT_ENOUGH_ERR;
	}
	if ((p_in->week_day != 0) && (p_in->week_day != 1) && (p_in->week_day != 2) && (p_in->week_day != 4)) {
		return VALUE_OUT_OF_RANGE_ERR;
	}
	ret=this->user_npc_task.recv_task(RECVBUF_USERID, p_in->npc, p_in->taskid, p_in->maxnum, p_in->week_day, &out.num);
	out.taskid = p_in->taskid;
	out.state = 1;
	STD_RETURN_WITH_STRUCT(ret, out);
}

/* 设置任务完成 */
int Croute_func::user_npc_task_finish(DEAL_FUN_ARG)
{
	user_npc_task_finish_in *p_in=PRI_IN_POS; 
	user_npc_task_finish_out out={ }; 
	ret=this->user_npc_task.finish_task(RECVBUF_USERID, p_in->npc, p_in->taskid, &out.num);
	out.state = 2; //1表示接任务，2表示任务完成
	STD_RETURN_WITH_STRUCT(ret, out);
}

/**
 * @brief 把指定任务取消
 */
int Croute_func::user_npc_task_delete_npc_task(DEAL_FUN_ARG)
{
	user_npc_task_delete_npc_task_in* p_in=PRI_IN_POS;
	ret=this->user_npc_task.delete_task(RECVBUF_USERID, p_in->npc, p_in->taskid);
	STD_RETURN(ret);
}

/* 得到客户端填写的buf的内容 */
int Croute_func::user_npc_task_get_buf(DEAL_FUN_ARG)
{
	user_npc_task_get_buf_in *p_in=PRI_IN_POS; 
	user_npc_task_get_buf_out out={};
	ret=this->user_npc_task.get_buf(RECVBUF_USERID, p_in->npc, p_in->taskid, out.buf);
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 填写客户端的内容 */
int Croute_func::user_npc_task_set_buf(DEAL_FUN_ARG)
{
	user_npc_task_set_buf_in *p_in=PRI_IN_POS; 
	ret=this->user_npc_task.update_buf(RECVBUF_USERID, p_in->npc, p_in->taskid, p_in->buf);
	STD_RETURN(ret);
}

/* 得到某个NPC某个任务的信息 */
int Croute_func::user_npc_one_task_get_info(DEAL_FUN_ARG)
{
	user_npc_one_task_get_info_in *p_in=PRI_IN_POS; 
	user_npc_one_task_get_info_out out={};
	uint32_t check_same = 0;
	uint32_t old_tm = 0;
	uint32_t flag = 0;
	uint32_t now = 0;
	ret=this->user_npc_task.get_task_info(RECVBUF_USERID, p_in->npc, p_in->taskid, &out.state, &out.num, &flag, &old_tm);
	if (ret == TASKID_NOT_EXIST_ERR) {
		ret = SUCC;
	}
	if (flag != 0) {
		ret = this->user_npc_task.check_same_time(old_tm, flag, &check_same, &now);
		if (ret != SUCC) {
			return ret;
		}
		if (check_same) {
			out.num = 0;
		}
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 得到某个用户某个NPC的任务列表 */
int Croute_func::user_npc_task_get_npc_task(DEAL_FUN_ARG)
{
	user_npc_task_get_npc_task_in *p_in=PRI_IN_POS; 
	user_npc_task_get_npc_task_out_header  out_header;
	user_npc_task_get_npc_task_out_item *p_out_item;
	ret=this->user_npc_task.get_list(RECVBUF_USERID, p_in->npc, &p_out_item, &out_header.count);
	for(uint32_t i = 0; i < out_header.count; i++) {
		uint32_t check_same = 0;
		uint32_t now = 0;
		ret = this->user_npc_task.check_same_time((p_out_item + i)->recv_tm, (p_out_item + i)->flag, &check_same, &now);
		if (check_same) {
			(p_out_item + i)->num = 0;
		}
	}
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int user_npc_task_delete_npc_task(DEAL_FUN_ARG);

/* 暖房 *-----------------------------------------------------------------------------------------*/
//向暖房表中插入一条记录，表示存在一个配对实体
int Croute_func::user_greenhouse_insert(DEAL_FUN_ARG)
{
	user_greenhouse_insert_in *p_in=PRI_IN_POS;

	//更新outgo
	{
		uint32_t outgo=0;
		ret=user_farm_animal.get_outgo(RECVBUF_USERID, p_in->animal_id, &outgo);
		if(SUCC!=ret)
		{
			return ret;
		}

		//可能出现外挂等非正常情况，数据库层应当加入少许逻辑
		if((outgo & 0x02) || (outgo & 0x08) || (outgo & 0x10))
		{
			return VALUE_OUT_OF_RANGE_ERR; 
		}
		outgo |= 0x08;
		ret=user_farm_animal.set_or_cancel_outgo(RECVBUF_USERID, p_in->animal_id, outgo);
		if(SUCC!=ret)
		{
			return ret;
		}
	}

	ret=this->user_greenhouse.insert(RECVBUF_USERID, p_in->animal_id, p_in->animal_type);
	STD_RETURN(ret);
}

//从暖房表中删除一个记录，表示已经领取一个动物，
//此时还会自动更新新生动物
int Croute_func::user_greenhouse_drop(DEAL_FUN_ARG)
{
	//这里的p_in是animal_id
	user_greenhouse_drop_in *p_in=PRI_IN_POS;
	//检查是否到达时间
	uint32_t remain_time = 0;
	uint32_t ret=this->user_greenhouse.get_remain_time(RECVBUF_USERID, p_in->animal_id, &remain_time);
	if(SUCC!=ret)
	{
		return ret;
	}
	if(0!=remain_time)
	{
		return USER_GREENHOUSE_DROP_NOT_TOUCH_TIME_ERR;
	}

	//更新outgo
	{
		uint32_t outgo=0;
		uint32_t ret=user_farm_animal.get_outgo(RECVBUF_USERID, p_in->animal_id, &outgo);
		if(SUCC!=ret)
		{
			return ret;
		}
		
		outgo &= ~0x09;//放回到牧场，同时去除正在配对的状态
		uint32_t animalid = 0;
	  	ret = this->user_farm_animal.get_animal_id(RECVBUF_USERID, p_in->animal_id, &animalid);
		if (animalid == 1270054 || animalid == 1270058 ) { 	//狗只能配对1次
			outgo |= 0x10;
		}
		ret=user_farm_animal.set_or_cancel_outgo(RECVBUF_USERID, p_in->animal_id, outgo);
		if(SUCC!=ret)
		{
			return ret;
		}
	}
	bool is_vip=0;
	ret=this->user_ex.get_vip(RECVBUF_USERID, &is_vip);
	if(SUCC!=ret)
	{
		return ret;
	}
	//const uint32_t baby_id=user_greenhouse.get_rabbit_baby_id(is_vip);
	const uint32_t baby_id = this->user_greenhouse.user_get_baby_id(RECVBUF_USERID, p_in->animal_id, is_vip);
	//更新user_xx.t_user_attire_x，因为生出了兔宝宝
	{
		const uint32_t rabbit_num=1;

		user_add_attire_in add_item ={};
		add_item.attiretype=0;//装扮
		add_item.attireid=baby_id;
		add_item.count=rabbit_num;
		add_item.maxcount=99999;
		ret=this->user_add_attire(RECVBUF_USERID, &add_item);
		if (ret==VALUE_OUT_OF_RANGE_ERR)
		{
			ret = SUCC;
		}else if (ret!=SUCC){
			return ret;
		}
	}
	DEBUG_LOG("====babyid %u", baby_id);
	user_greenhouse_drop_out out = {};
	out.animal_type=baby_id;
	ret=this->user_greenhouse.drop(RECVBUF_USERID, p_in->animal_id);
	STD_RETURN_WITH_STRUCT(ret, out);
}

//查询指定动物离配对结束时间还有多久，即剩余时间
int Croute_func::user_greenhouse_remain_time(DEAL_FUN_ARG)
{
	user_greenhouse_remain_time_in *p_in=PRI_IN_POS;
	user_greenhouse_remain_time_out out={};
	ret=this->user_greenhouse.get_remain_time(RECVBUF_USERID, p_in->animal_id, &out.remain_time);
	STD_RETURN_WITH_STRUCT(ret,out);
}

//查询指定用户是否已有动物正在配对，如果有返回1,否则返回0
int Croute_func::user_greenhouse_user_exist(DEAL_FUN_ARG)
{
	user_greenhouse_user_exist_out status={};
	ret=user_greenhouse.user_exist(RECVBUF_USERID, &status.exist);
	STD_RETURN_WITH_STRUCT(ret,status);
}

//返回指定用户所有配对的动物列表，这个列表中包括所关心的所有信息
int Croute_func::user_greenhouse_user_all_animal(DEAL_FUN_ARG)
{
	user_greenhouse_user_all_animal_out_header out_header;
	user_greenhouse_user_all_animal_out_item *p_out_item;
	ret=this->user_greenhouse.user_all_animal(RECVBUF_USERID, &p_out_item, &out_header.count);
	if(SUCC!=ret)
	{
		return ret;
	}

	//把取出的起始时间转换为剩余时间
	for(uint32_t i=0; i < out_header.count; ++i)
	{
		uint32_t tmp=p_out_item[i].remain_time;
		p_out_item[i].remain_time=user_greenhouse.married_to_remain_time(tmp);
	}

	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/* 孵蛋 *-----------------------------------------------------------------------------------------*/
/* 孵出蛋,并且把动物放到仓库里 */
int Croute_func::user_egg_brood_egg(DEAL_FUN_ARG)
{
	user_egg_brood_egg_in *p_in=PRI_IN_POS; 
	user_egg_brood_egg_out out={};
	stru_user_egg_all list = { };
	ret=this->user_egg.get_one_info(RECVBUF_USERID, p_in->pos, &list);
	if (ret != SUCC) {
		return ret;
	}
	uint32_t brood_num = 0;
	ret = this->user_egg.get_brood_num(list.attireid, &brood_num);
	if (ret != SUCC) {
		return ret;
	}
	if (list.num < brood_num) {
		return EGG_HAVE_NOT_BROOD_NUM_ERR;
	}
	uint32_t child = 0;
	ret = this->user_egg.get_child(list.attireid, &child);
	if (ret != SUCC) {
		return ret;
	}
	ret = this->user_egg.del(RECVBUF_USERID, p_in->pos);
	if (ret != SUCC) {
		return ret;
	}
	user_add_attire_in add_item = {};
	add_item.attiretype = 0;//装扮
	add_item.attireid = child;
	add_item.count = 1;
	//最多99999个
	add_item.maxcount=99999;
	ret=this->user_add_attire(RECVBUF_USERID, &add_item);
	if (ret==VALUE_OUT_OF_RANGE_ERR) {
		ret = SUCC;
	} else if (ret!=SUCC) {
		return ret;
	}
	out.animal_id = child;
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 得到个人孵蛋的全部信息，WEB页面用 */
int Croute_func::user_egg_get_all_web(DEAL_FUN_ARG)
{
	user_egg_get_all_web_out_header  out_header;
	user_egg_get_all_web_out_item *p_out_item;
	ret=this->user_egg.get_all_record_web(RECVBUF_USERID, &p_out_item, &out_header.count);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/* 更新孵蛋的信息，WEB页面用 */
int Croute_func::user_egg_update_web(DEAL_FUN_ARG)
{
	user_egg_update_web_in *p_in=PRI_IN_POS; 
	ret=this->user_egg.update_egg_web(RECVBUF_USERID, p_in);
	STD_RETURN(ret);
}

/* 服装打分 *------------------------------------------------------------------------------------*/
//取得某一服装组合的打分
int Croute_func::roominfo_roominfo_dressing_mark_get(DEAL_FUN_ARG)
{
	roominfo_roominfo_dressing_mark_get_in* p_in=PRI_IN_POS;
	db_utility::DressingUnit dress=(*(db_utility::DressingUnit*)(p_in));
	db_utility::dress_clean(dress);
	roominfo_roominfo_dressing_mark_get_out out={};
	ret=this->roominfo.dressing_mark_get(RECVBUF_USERID, dress, out);
	if(ROOMINFO_ROOMINFO_DRESSING_MARK_NO_UNIT_ERR==ret)//缓存没有命中
	{
		ret=SUCC;
	}

	STD_RETURN_WITH_STRUCT(ret, out);
}

//设置某一服装组合的打分
int Croute_func::roominfo_roominfo_dressing_mark_set(DEAL_FUN_ARG)
{
	const roominfo_roominfo_dressing_mark_set_in* p_in=PRI_IN_POS;

	//准备调用参数
	DressingMarkUnit dmu;
	db_utility::DressingUnit& dress=dmu.dress;
	dress.num=p_in->num;
	std::memcpy(dress.colth, p_in->colth, sizeof(dress.colth));
	db_utility::dress_clean(dress);
	std::memcpy(dmu.mark.mark, p_in->mark, sizeof(dmu.mark.mark));

	ret=this->roominfo.dressing_mark_set(RECVBUF_USERID, dmu);
	if(1105==ret)
	{
		//这里会把值设置为0
		ret=this->roominfo.insert(RECVBUF_USERID);
		if(SUCC!=ret)
		{
			STD_RETURN(ret);
		}
		ret=this->roominfo.dressing_mark_set(RECVBUF_USERID, dmu);
	}

	STD_RETURN(ret);
}


/* 拍照 *------------------------------------------------------------------------------------*/
/* 设置拍照的衣服 */
int Croute_func::user_ex_update_pic_clothe(DEAL_FUN_ARG)
{
	user_ex_update_pic_clothe_in *p_in=PRI_IN_POS; 
	ret=this->user_ex.update_pic_clothe(RECVBUF_USERID, p_in);
	STD_RETURN(ret);
}

/* 得到拍照时的衣服 */
int Croute_func::user_ex_get_pic_clothe(DEAL_FUN_ARG)
{
	user_ex_get_pic_clothe_out out={};
	ret=this->user_ex.get_pic_clothe(RECVBUF_USERID, &out);
	if (ret == USER_ID_NOFIND_ERR) {
		ret = SUCC;
	}
	DEBUG_LOG("count***********: %u", out.type_count[1]);
	STD_RETURN_WITH_STRUCT(ret,out);
}
/* 设置mole时尚的分数 */
int Croute_func::user_mode_level_set(DEAL_FUN_ARG)
{
	user_mode_level_set_in *p_in=PRI_IN_POS; 
	uint32_t temp = 0;
	ret=this->user.change_int_field_without_max_check(RECVBUF_USERID, "fashion", p_in->mode_score, &temp);
	STD_RETURN(ret);
}

/* 鸭子 *------------------------------------------------------------------------------------*/
//取得鸭子的状态
int Croute_func::roominfo_roominfo_duck_statu_get(DEAL_FUN_ARG)
{
	uint32_t statu=0;	
	ret=roominfo.duck_statu_get(RECVBUF_USERID, statu);
	roominfo_roominfo_duck_statu_get_out out={statu};
	if(USER_ID_NOFIND_ERR==ret)
	{
		ret = SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret, out);
}

//设置鸭子的状态
int Croute_func::roominfo_roominfo_duck_statu_set(DEAL_FUN_ARG)
{
	roominfo_roominfo_duck_statu_set_in *p_in=PRI_IN_POS;
	ret=this->roominfo.duck_statu_set(RECVBUF_USERID, p_in->statu);
	//如果当前用户没有记录
	if(1105==ret)
	{
		//这里会把值设置为0
		ret=this->roominfo.insert(RECVBUF_USERID);
		if(SUCC!=ret)
		{
			return ret;
		}
		ret=this->roominfo.duck_statu_set(RECVBUF_USERID, p_in->statu);
	}
	STD_RETURN(ret);
}

/* 设置模特身上的衣服 */
int Croute_func::user_attire_set_mode_attire(DEAL_FUN_ARG)
{
	user_attire_set_mode_attire_in_header *p_in=PRI_IN_POS;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_attire_set_mode_attire_in_item));
	user_attire_set_mode_attire_in_item * p_in_item =
		(user_attire_set_mode_attire_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
	ret=this->user_attire.set_mode_attire(RECVBUF_USERID, p_in_item, p_in->count, p_in->index);
	STD_RETURN(ret);
}

/*得到所有模特身上的衣服 */
int Croute_func::user_attire_get_mode_attire(DEAL_FUN_ARG)
{
	char out[PROTO_MAX_LEN]={ };
	//user_attire_get_mode_attire_out_header  out_header;
	//user_attire_get_mode_attire_out_item *p_out_item;
	user_attire_all_mode_clothe temp = { };
	ret=this->user_attire.get_mode_attire(RECVBUF_USERID, &temp);
	if (ret != SUCC) {
		return ret;
	}
	uint32_t offset = 0;
	memcpy(out, (char *)&temp, 4);
	offset += 4;
	/* 最多50个模特 */
	for (uint32_t i = 0; i < 50; i++) {
		if (temp.item[i].count != 0) {
			/* 如果模特穿了衣服，就拷贝回去,模特号+衣服的总数+衣服的总共ID号 */
			memcpy(out + offset, (char *)&temp.item[i], 4 + 4 + temp.item[i].count * 4);
			offset += 4 + 4 + temp.item[i].count * 4;
		}
	}
	STD_RETURN_WITH_BUF(ret, out, offset);
}

/* 把模特身上的衣服放到到mole身上 */
int Croute_func::user_attire_set_mode_to_mole(DEAL_FUN_ARG)
{
	user_attire_set_mode_to_mole_in *p_in=PRI_IN_POS; 
    user_attire_set_mode_to_mole_out_item *p_item = NULL;
	user_attire_one_mode_clothe out = { };
	uint32_t count = 0;
	/* 返回模特身上原来穿的衣服 */
	ret = this->user_attire.get_one_mode_clothe(RECVBUF_USERID, p_in->mode_index, &p_item, &count);
	if (ret != SUCC) {
		return ret;
	}
	out.mode_index = p_in->mode_index;
	out.count = count;
	memcpy((char *)&out + 8, p_item, out.count * sizeof(uint32_t));
	/* 把模特的衣服穿到mole身上 */
	ret = this->user_attire.update_set_all_noused(RECVBUF_USERID);
	if (ret != SUCC) {
		return ret;
	}
	ret=this->user_attire.update_set_mode_mole(RECVBUF_USERID, p_in->mode_index);
	STD_RETURN_WITH_BUF(ret, &out, 8 + out.count * sizeof(user_attire_set_mode_to_mole_out_item));
}

/* 设置mole的衣服到模特身上  */
int Croute_func::user_attire_set_clothe_mole_to_mode(DEAL_FUN_ARG)
{
	user_attire_set_clothe_mole_to_mode_in *p_in=PRI_IN_POS; 
	//user_attire_set_clothe_mole_to_mode_out_header  out_header;
	//user_attire_set_clothe_mole_to_mode_out_item *p_out_item;
	ret = this->user_attire.update_set_mode_noused(RECVBUF_USERID, p_in->mode_index);
	if (ret != SUCC) {
		return ret;
	}
	/* 把mole的衣服穿到模特身上 */
	ret=this->user_attire.update_set_clothe_mole_mode(RECVBUF_USERID, p_in->mode_index);
	//STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
	STD_RETURN(ret);
}

/* 得到蛋糕的数目 */
int Croute_func::roominfo_cake_gift_swap_get_cake_num(DEAL_FUN_ARG)
{
	userid_t uid=RECVBUF_USERID;
	uint32_t num=0;
	ret=roominfo_cake_gift_swap.cake_get(uid, num);

	roominfo_cake_gift_get_out out={num};

	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 使蛋糕数加一或者有蛋糕兑换物品 */
int Croute_func::roominfo_cake_gift_swap_do_swap(DEAL_FUN_ARG)
{
	userid_t uid=RECVBUF_USERID;
	roominfo_cake_gift_swap_do_swap_in *p_in=PRI_IN_POS;
	const int32_t in_num=p_in->cake_num;

	roominfo_cake_gift_swap_do_swap_out out={};
	if(in_num>0)//添加蛋糕的数量
	{
		//逻辑上不会数据，除非系统错误
		ret=roominfo_cake_gift_swap.cake_add(uid, in_num);
		out.statu=0;
		STD_RETURN_WITH_STRUCT(ret, out);
	}

	//能到这里，说明进行交换，减少蛋糕的数量
	ret=roominfo_cake_gift_swap.cake_subtract(uid, -in_num);
	if(ROOMINFO_CAKE_GIFT_SWAP_NOT_ENOUGH_ERR==ret)
	{
		out.statu=0;
		ret=SUCC;
		//STD_RETURN_WITH_STRUCT(ret, out);
	} else {
		out.statu = 1;
	}

	STD_RETURN_WITH_STRUCT(ret, out);
}

/* 加模特 */
int Croute_func::user_home_add_mode(DEAL_FUN_ARG)
{
	user_home_add_mode_out out={};
	ret=this->user.home_get_mode_index(RECVBUF_USERID, &out.mode_index);
	if (ret != SUCC) {
		return ret;
	}
	if (out.mode_index != 0) {
			user_add_attire_in add_item = {};
		add_item.attiretype = 1;//小屋
		add_item.attireid = out.mode_index;
		add_item.count = 1;
		//最多99个
		add_item.maxcount=1;
		ret=this->user_add_attire(RECVBUF_USERID, &add_item);
		if (ret==VALUE_OUT_OF_RANGE_ERR) {
			ret = SUCC;
		} else if (ret!=SUCC) {
			return ret;
		}
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

/**
 * @brief 得到指定用户所有的图鉴或指定数目的图鉴
 */
int Croute_func::user_pic_book_get(DEAL_FUN_ARG)
{
	user_pic_book_get_out_header  out_header;
	user_pic_book_get_out_item *p_out_item;
	ret=this->user_pic_book.get(RECVBUF_USERID, &p_out_item, &out_header.count);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/* 钓鱼 *-----------------------------------------------------------------------------------------*/
//取得某一用户的所有的鱼的重量
int Croute_func::roominfo_fish_weight_get(DEAL_FUN_ARG)
{
	uint32_t weight=0;	
	ret=roominfo_animal_weight.fish_get_weight(RECVBUF_USERID, weight);
	roominfo_fish_weight_get_out out={weight};
	if(USER_ID_NOFIND_ERR==ret)
	{
		ret = SUCC;
	}

	STD_RETURN_WITH_STRUCT(ret, out);
}

/* 设置称鱼的重量 */
int Croute_func::roominfo_fish_weight_set(DEAL_FUN_ARG)
{
	roominfo_fish_weight_set_in *p_in=PRI_IN_POS;
	ret=roominfo_animal_weight.fish_set_weight(RECVBUF_USERID, p_in->type, p_in->weight); 
	if(USER_ID_EXISTED_ERR==ret)
	{
		ret=SUCC;
	}
	uint32_t total_weight=0;
	ret=roominfo_animal_weight.fish_get_weight(RECVBUF_USERID, total_weight);
	roominfo_fish_weight_set_out out={total_weight};

	STD_RETURN_WITH_STRUCT(ret, out);
}

/* 更新花的信息 */
int Croute_func::roominfo_flower_update(DEAL_FUN_ARG)
{
	roominfo_flower_update_in *p_in=PRI_IN_POS; 
	ret=this->roominfo_flower.update(RECVBUF_USERID, p_in->flag, p_in->type, p_in->value);
	if (ret != SUCC) {
		ret = this->roominfo_flower.insert(RECVBUF_USERID, p_in->flag, p_in->type, p_in->value);
	}
	STD_RETURN(ret);
}

/* 得到花的信息 */
int Croute_func::roominfo_flower_get(DEAL_FUN_ARG)
{
	roominfo_flower_get_out out={};
	ret=this->roominfo_flower.get_value(RECVBUF_USERID, &out.flag, &out.type, &out.count);
	if (ret == RECORD_NOT_EXIST_ERR) {
		ret = SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 得到谁拥有的鱼重量最重 */
int Croute_func::sysarg_animal_get_max_weight_fish(DEAL_FUN_ARG)
{
	sysarg_animal_get_max_weight_fish_in *p_in=PRI_IN_POS; 
	sysarg_animal_get_max_weight_fish_out out={};
	ret=this->sys_animal.set_max_weight(RECVBUF_USERID, p_in->weight, &out.max_weight, &out.userid);
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 宠物穿衣服 */
int Croute_func::user_pet_attire_set_used(DEAL_FUN_ARG)
{
	user_pet_attire_set_used_in_header* p_in=PRI_IN_POS;
	const uint32_t count=p_in->count;
	const uint32_t petid=p_in->petid;
	const bool is_colth = p_in->is_colth;

	CHECK_PRI_IN_LEN_WITHOUT_HEADER(count*sizeof(user_pet_attire_set_used_in_item));
	user_pet_attire_set_used_in_item * p_in_item=(user_pet_attire_set_used_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;

	user_pet_attire_set_used_out_header out_header;
	user_pet_attire_set_used_out_item *p_out_item;

	out_header.petid = p_in->petid;
	/* 返回宠物拉姆原来身上穿的衣服 */
	ret = this->user_pet_attire.get_pet_now_colth(RECVBUF_USERID, p_in->petid, &(out_header.count), &p_out_item, is_colth);
	if (ret != SUCC) {
		return ret;
	}

	//把新衣服穿上
	ret=this->user_pet_attire.set_pet_used_attire(RECVBUF_USERID, petid, count, p_in_item, is_colth);
	if (ret != SUCC)
	{
		return ret;
	}
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/* 设置USER_FARM表的一个字段 */
int Croute_func::user_farm_set_col(DEAL_FUN_ARG)
{
	user_farm_set_col_in *p_in=PRI_IN_POS; 
	ret=this->user_farm.update_col(RECVBUF_USERID, p_in->type, p_in->value);
	STD_RETURN(ret);
}

/* 设置是否拿过袜子 */
int Croute_func::roominfo_get_sockes(DEAL_FUN_ARG)
{
	roominfo_get_sockes_in *p_in=PRI_IN_POS; 
	ret=this->roominfo.get_socks(RECVBUF_USERID, p_in->userid);
	STD_RETURN(ret);
}

/* 保存用户登入的online信息 */
int Croute_func::ff_login_get_list(DEAL_FUN_ARG)
{
    ff_login_get_list_in *p_in=PRI_IN_POS;
    ff_login_get_list_out_header  out_header;
    ff_login_get_list_out_item *p_out_item;
    ret = this->login_info.get_list(RECVBUF_USERID,p_in,&p_out_item,&(out_header.count) );

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/* 放生昆虫 */
int Croute_func::user_animal_release_insect(DEAL_FUN_ARG)
{
	user_animal_release_insect_in *p_in=PRI_IN_POS; 
	if (p_in->type != 2 && p_in->type != 4) {
		return VALUE_OUT_OF_RANGE_ERR;
	}
	ret=this->user_farm_animal.release_insect(RECVBUF_USERID, p_in->id, p_in->type);
	STD_RETURN(ret);
}

/* 设置动物的标志位 */
int Croute_func::user_animal_set_animal_flag(DEAL_FUN_ARG)
{
	user_animal_set_animal_flag_in *p_in=PRI_IN_POS; 
	ret=this->user_farm_animal.update_animal_flag_sql(RECVBUF_USERID, p_in->index, p_in->id);
	STD_RETURN(ret);
}

/* 蝴蝶给花朵授粉,改变花朵的授粉次数 */
int Croute_func::user_jy_butterfly_pollinate_flower(DEAL_FUN_ARG)
{
	user_jy_butterfly_pollinate_flower_in *p_in=PRI_IN_POS; 
	user_jy_butterfly_pollinate_flower_out out={};
	ret=this->user_jy.butterfly_pollinate(RECVBUF_USERID, p_in->plant_id, &out);
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::appeal_ex_get_state(DEAL_FUN_ARG)
{
	appeal_ex_get_state_in *p_in=PRI_IN_POS; 
	appeal_ex_get_state_out out={};
	ret=this->appeal_ex.get_state(p_in->id,&(out.state) );
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::appeal_ex_get_list(DEAL_FUN_ARG)
{
	appeal_ex_get_list_in *p_in=PRI_IN_POS; 
	appeal_ex_get_list_out_header  out_header;
	appeal_ex_get_list_out_item *p_out_item;
	ret=this->appeal_ex.getlist(p_in,&(out_header.count),&p_out_item );
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/* 增加蝴蝶授粉的次数 */
int Croute_func::user_animal_pollinate(DEAL_FUN_ARG)
{
	user_animal_pollinate_in *p_in=PRI_IN_POS; 
	//user_animal_pollinate_out out={};
	ret=this->user_farm_animal.butterfly_pollinate(RECVBUF_USERID, p_in->insect_id);
	STD_RETURN(ret);
}

int Croute_func::ip_history_get_lastip(DEAL_FUN_ARG)
{
	ip_history_get_lastip_out out={};
	ret=this->ip_history.get_last_ip(RECVBUF_USERID,&(out.ip) );
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::userinfo_set_paypasswd_with_check(DEAL_FUN_ARG)
{
	userinfo_set_paypasswd_with_check_in *p_in=PRI_IN_POS; 
	ret=this->user_info.user_check_paypasswd(RECVBUF_USERID,p_in->oldpasswd);
	if(ret!=SUCC) return ret;
	ret=this->user_info.set_paypasswd(RECVBUF_USERID, p_in->newpasswd);

	STD_RETURN(ret);
}

/* 设置心愿的值 */
int Croute_func::roominfo_update_wish(DEAL_FUN_ARG)
{
	roominfo_update_wish_in *p_in=PRI_IN_POS; 
	ret=this->roominfo.update_wish_sql(RECVBUF_USERID, p_in);
	if (ret != SUCC) {
		ret = this->roominfo.insert(RECVBUF_USERID);
		if (ret != SUCC) {
			return ret;
		}
		ret = this->roominfo.update_wish_sql(RECVBUF_USERID, p_in);
	}
	STD_RETURN(ret);
}

/* 得到心愿的值 */
int Croute_func::roominfo_get_wish(DEAL_FUN_ARG)
{
	roominfo_get_wish_out out={};
	ret=this->roominfo.select_wish_sql(RECVBUF_USERID, &out);
	if (ret == USER_ID_NOFIND_ERR) {
		ret = SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 改变圣诞礼物的数目 */
int Croute_func::roominfo_change_gift_num(DEAL_FUN_ARG)
{
	roominfo_change_gift_num_in *p_in=PRI_IN_POS; 
	roominfo_change_gift_num_out out={ }; 
	ret=this->roominfo.change_int_field_without_max_check(RECVBUF_USERID, "gift_num", p_in->change_value, &out.num);
	if (ret == USER_ID_NOFIND_ERR) {
		ret = this->roominfo.insert(RECVBUF_USERID);
		if (ret != SUCC) {
			return ret;
		}
		ret=this->roominfo.change_int_field_without_max_check(RECVBUF_USERID, "gift_num", p_in->change_value, &out.num);
	}
	if (ret == VALUE_NOENOUGH_E) {
		return GIFT_IS_NOT_ENOUGH_ERR;
	}
	STD_RETURN_WITH_STRUCT(ret, out);
}

/* 得到可送礼物的数目 */
int Croute_func::roominfo_get_gift_num(DEAL_FUN_ARG)
{
	roominfo_get_gift_num_out out={};
	ret=this->roominfo.get_int_value(RECVBUF_USERID, "gift_num", &out.gift_num);
	if (ret == USER_ID_NOFIND_ERR) {
		ret = SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 记录谁送过生日礼物 */
int Croute_func::roominfo_record_give_gift_userid(DEAL_FUN_ARG)
{
	roominfo_record_give_gift_userid_in *p_in=PRI_IN_POS; 
	ret=this->roominfo.add_gift_userid(RECVBUF_USERID, p_in);
	STD_RETURN(ret);
}

/* 获取送礼物的USERI信息 */
int Croute_func::roominfo_get_give_gift_userid(DEAL_FUN_ARG)
{
	roominfo_get_give_gift_userid_out out={};
	ret=this->roominfo.del_gift_userid(RECVBUF_USERID, &out);
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::userinfo_get_login_info(DEAL_FUN_ARG)
{
	userinfo_get_login_info_out out={};
	ret=this->user_info.get_login_info(RECVBUF_USERID,&out);
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 增加能量之星 */
int Croute_func::roominfo_add_energy_star(DEAL_FUN_ARG)
{
	roominfo_add_energy_star_in *p_in=PRI_IN_POS; 
	roominfo_add_energy_star_out out={};
	ret = this->roominfo.add_energy_star(RECVBUF_USERID, p_in->add_num, p_in->vip_flag, &out);
	STD_RETURN_WITH_STRUCT(ret,out);
}

/* 得到能量之星的数目 */
int Croute_func::roominfo_get_energy_star(DEAL_FUN_ARG)
{
	roominfo_get_energy_star_out out={};
	ret=this->roominfo.select_two_col_sql(RECVBUF_USERID, "energy_star", "day_star", &out.total_star, &out.day_star);
	if (ret == USER_ID_NOFIND_ERR) {
		ret = SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

/// @brief 新年相片服装设置
int Croute_func::user_dress_in_photo_set(DEAL_FUN_ARG)
{
	user_dress_in_photo_set_in_header* p_in=PRI_IN_POS;
	db_utility::DressingUnit indata={};
	std::memcpy(&indata, PRI_IN_POS, PRI_IN_LEN);

	db_utility::dress_clean(indata);
	ret=user.home_dress_in_photo_set(RECVBUF_USERID, indata);
	STD_RETURN(ret);
}

/// @brief 新年相片服装获取
int Croute_func::user_dress_in_photo_get(DEAL_FUN_ARG)
{
	db_utility::DressingUnit out={};
	ret=user.home_dress_in_photo_get(RECVBUF_USERID, out);
	STD_RETURN_WITH_BUF(ret, (char*)&out, sizeof(uint32_t)*(out.num+1));
}

/* 删除某个范围的装扮 */
int Croute_func::user_attire_delete_attire_list(DEAL_FUN_ARG)
{
	user_attire_delete_attire_list_in *p_in=PRI_IN_POS; 
	ret=this->user_attire.delete_attirelist(RECVBUF_USERID, p_in->start_index, p_in->end_index);
	STD_RETURN(ret);
}

/* 得到用户包月的数目 */
int Croute_func::user_get_vip_month(DEAL_FUN_ARG)
{
	user_get_vip_month_out out={};
	ret=this->user_ex.get_int_value(RECVBUF_USERID, "level", &out.month);
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::appeal_ex_get_user_last_state(DEAL_FUN_ARG)
{
	appeal_ex_get_user_last_state_in *p_in=PRI_IN_POS; 
	appeal_ex_get_user_last_state_out out={};
	ret=this->appeal_ex.get_user_last_info(p_in->userid,&out );
	STD_RETURN_WITH_STRUCT(ret,out);
}

/**
 * @brief 给一个植物施肥，本命令做了许多应该做的事
 * @details 读取植物信息看是可以施肥
 */
int Croute_func::user_plant_growth_add_by_hour(DEAL_FUN_ARG)
{
	user_plant_growth_add_by_hour_in* p_in=PRI_IN_POS;
	user_plant_growth_add_by_hour_out out={};

	jy_item_muck tmp={};
	ret=this->user_jy.get(RECVBUF_USERID, p_in->auto_id, &tmp);
	if(ret==SEEDID_NOFIND_ERR)//找不到时作为植物状态异常处理
	{
		return PLANT_MUCK_ERR;
	}
	if (ret != SUCC) { return ret; }

	if(tmp.item.mature_time > 0 || tmp.item.earth==1) //当前已成熟或正在耕地
	{
		return PLANT_MUCK_ERR;
	}

	if(tmp.muck_times==5) //已经达到今天施肥的上限
	{
		return PLANT_MUCK_TIMES_OVER_ERR;
	}

	//进行施肥动作
	this->user_jy.plant_muck_clean(tmp, *p_in);

	//不是自己给自己施肥，在被施肥者家园设置标志
	if(p_in->user_id!= RECVBUF_USERID )
	{
		ret=this->user_ex.jy_accesslist_set_opt(RECVBUF_USERID, p_in->user_id,PLANT_MUCK_OPT_FLAG);
	}

	//更新成长值
	ret=this->user_jy.update_seed_info(RECVBUF_USERID, &tmp);

	out.item=tmp.item;
	STD_RETURN_WITH_STRUCT(ret,out);
}

/// @brief 设置不需要验证旧支付密码可以设置新支付密码标志位
int Croute_func::user_info_set_falg_change_paypasswd(DEAL_FUN_ARG)
{
	user_info_set_falg_change_paypasswd_in *p_in=PRI_IN_POS; 
	ret=this->user_info.set_flag(RECVBUF_USERID,
			FLAG1_STR ,USER_FLAG1_CHANGE_PAYPASSWD,bool(p_in->flag));
	STD_RETURN(ret);
}

/**
 * @brief 设置不需要验证旧支付密码可以设置新支付密码,并且修改标志位
 */
int Croute_func::user_info_change_paypasswd_nocheck(DEAL_FUN_ARG)
{
	user_info_change_paypasswd_nocheck_in *p_in=PRI_IN_POS; 

	ret=this->user_info.set_flag(RECVBUF_USERID,
			FLAG1_STR ,USER_FLAG1_CHANGE_PAYPASSWD,false);
	if (ret!=SUCC) return ret;
	ret=this->user_info.update_paypasswd(RECVBUF_USERID , p_in->new_paypasswd);
	if (ret == SUCC) {
		passwd_change_item item;
		item.userid = RECVBUF_USERID;
		item.opt_type=1003;
		item.time = time(NULL);
		memcpy(&item.passwd, &p_in->new_paypasswd, PASSWD_LEN);
		this->send_log.send_passwd(&item);
	}
	STD_RETURN(ret);
}

/**
 * @brief 得到植物的果实ID号
 */
int Croute_func::user_jy_get_mature_fruit_id(DEAL_FUN_ARG)
{
	user_jy_get_mature_fruit_id_in *p_in=PRI_IN_POS; 
	user_jy_get_mature_fruit_id_out out={};
	ret=this->user_jy.get_mature_fruit(RECVBUF_USERID, p_in->id, &out.fruit_id);
	STD_RETURN_WITH_STRUCT(ret,out);
}

/**
 * @brief 批量购买物品，通过摩尔豆
 */
int Croute_func::user_buy_many_thing_in_one_time(DEAL_FUN_ARG)
{
	user_buy_many_thing_in_one_time_in_header* p_in=PRI_IN_POS;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER(p_in->number_of_thing*sizeof(user_buy_many_thing_in_one_time_in_item));
	uint32_t xiaomee=0;
	this->user.get_xiaomee(RECVBUF_USERID, &xiaomee);
	if(xiaomee < p_in->need_xiaomee_value)
	{
		return XIAOMEE_NOT_ENOUGH_ERR;
	}

	//构造插入用map
	db_utility::UserAttireBuyMap buy_map;
	db_utility::to_buy_map(p_in->number_of_thing, (user_buy_many_thing_in_one_time_in_item*)(PRI_IN_POS+1), buy_map);

	//依类别进行数据插入
	switch(p_in->attire_in_where)
	{
		case 0 ://装扮
		{
			this->user_attire.userid(RECVBUF_USERID);
			ret=this->user_attire.user_buy_many_thing_in_one_time(buy_map);
			break;
		}
		case 1://小屋
		{
			this->user.userid(RECVBUF_USERID);
			ret=this->user.user_home_buy_many_thing_in_one_time(buy_map);
			break;
		}
		case 2://家园
		{
			this->user.userid(RECVBUF_USERID);
			ret=this->user.user_jiayuan_buy_many_thing_in_one_time(buy_map);
			break;
		}
		default://其它的情况
		{
			return BUY_THING_UNKOWN_PLACE_ERR;
		}
	}

	int leave_xiaomee=0;
	if(SUCC==ret) //一切者正常的时候减去米币
	{
		ret=this->user.change_xiaomee(RECVBUF_USERID, -p_in->need_xiaomee_value, XIAOMEE_USE_DEL_BUY_ATTIRE, 0, &leave_xiaomee);
	}

	user_buy_many_thing_in_one_time_out out={leave_xiaomee};
	STD_RETURN_WITH_STRUCT(ret, out);
}

/**
 * @brief 当用户宠物完成一个任务时，可以去领取一个礼品
 */
int Croute_func::user_pet_task_attire_give(DEAL_FUN_ARG)
{
	user_pet_task_attire_give_in* p_in=PRI_IN_POS;
	this->user_task.userid(RECVBUF_USERID);

	//取出任务信息
	uint32_t state=0;
	const uint32_t task_is_complete=3;
	ret=this->user_task.get_pet_task_info_by_one(p_in->petid, p_in->taskid, state);
	if(SUCC!=ret || task_is_complete!=state)
	{
		return PET_TASK_NOT_COMPLETE_ERR;
	}

	//任务已经完成
	//ret=this->user_pet_attire.insert(RECVBUF_USERID, p_in->petid, p_in->attireid, 0, 1);
	
	user_set_attire_in item = { p_in->attireid, 0x01, 1, 1};	
	user_set_attire_out o_item = { 0 };
	ret = this->user_pet_attire.update_common(RECVBUF_USERID, p_in->petid, &item, &o_item);
	if(SUCC!=ret)
	{
		return PET_TASK_ATTIRE_HAVE_GIVEN_ERR ;
	}

	STD_RETURN(SUCC);
}

/// 用户搬石头，取得当天搬的石头和总共的石头
int Croute_func::roominfo_stone_move_get (DEAL_FUN_ARG)
{
	this->roominfo_stone_move.userid(RECVBUF_USERID);
	uint32_t today=0;
	uint32_t total=0;
	ret=this->roominfo_stone_move.stone_today_total_get(today, total);
	if(USER_ID_NOFIND_ERR==ret)
	{
		ret=0;
		today=0;
		total=0;
	}

	if(SUCC!=ret)
	{
		STD_RETURN(ret);
	}

	roominfo_stone_move_get_out out={today, total};

	STD_RETURN_WITH_STRUCT(ret, out);
}

/// 用户搬石头，设置当天搬的石头和总共的石头
int Croute_func::roominfo_stone_move_set (DEAL_FUN_ARG)
{
	this->roominfo_stone_move.userid(RECVBUF_USERID);
	uint32_t today=0;
	uint32_t total=0;
	ret=this->roominfo_stone_move.stone_today_total_get(today, total);
	if(USER_ID_NOFIND_ERR==ret)
	{
		this->roominfo_stone_move.insert();
		ret=0;
	}

	if(SUCC!=ret)
	{
		STD_RETURN(ret);
	}

	if(today>=3)
	{
		STD_RETURN(USER_STONE_MOVE_OVER_LIMIT_ERR);
	}

	ret=this->roominfo_stone_move.stone_today_total_set(++today, ++total);
	roominfo_stone_move_set_out out={today, total};
	STD_RETURN_WITH_STRUCT(ret, out);
}

/// 发现企鹅，取得用户企鹅孵蛋的次数
int Croute_func::roominfo_penguin_egg_get (DEAL_FUN_ARG)
{
	this->roominfo_stone_move.userid(RECVBUF_USERID);
	uint32_t num=0;
	uint32_t client=0;
	ret=this->roominfo_stone_move.penguin_egg_get(num, client);
	if(USER_ID_NOFIND_ERR==ret)
	{
		ret=0;
	}

	roominfo_penguin_egg_get_out out={num, client};

	STD_RETURN_WITH_STRUCT(ret, out);
}

#if 0
{
	this->roominfo_stone_move.userid(RECVBUF_USERID);

	roominfo_penguin_egg_get_in* p_in=PRI_IN_POS;
	const char* filed;
	if(p_in->user_penguin_flag==0)
	{
		filed="penguin_egg_count";
	} else {
		
		filed="penguin_from_client";
	}

	uint32_t value=0;
	ret=this->roominfo_stone_move.get_int_value(RECVBUF_USERID, filed, &value);
	if(SUCC!=ret)
	{
		STD_RETURN(ret);
	}

	roominfo_penguin_egg_get_out out={p_in->user_penguin_flag, value};

	STD_RETURN_WITH_STRUCT(ret, out);
}
#endif 

/// 发现企鹅，设置用户企鹅孵蛋的次数
int Croute_func::roominfo_penguin_egg_set (DEAL_FUN_ARG)
{
	this->roominfo_stone_move.userid(RECVBUF_USERID);

	roominfo_penguin_egg_set_in* p_in=PRI_IN_POS;

	if(p_in->user_penguin_flag==0)
	{
		ret=this->roominfo_stone_move.penguin_egg_set();
		if(USER_ID_NOFIND_ERR==ret)
		{
			this->roominfo_stone_move.insert();
			ret=this->roominfo_stone_move.penguin_egg_set();
		}
	} else {
		ret=this->roominfo_stone_move.penguin_egg_set_client(p_in->value);
		if(USER_ID_NOFIND_ERR==ret)
		{
			this->roominfo_stone_move.insert();
			ret=this->roominfo_stone_move.penguin_egg_set_client(p_in->value);
		}
	}
	if(SUCC!=ret)
	{
		STD_RETURN(ret);
	}

	uint32_t num=0;
	uint32_t client=0;
	ret=this->roominfo_stone_move.penguin_egg_get(num, client);
	if(USER_ID_NOFIND_ERR==ret)
	{
		ret=0;
	}

	roominfo_penguin_egg_get_out out={num, client};

	STD_RETURN_WITH_STRUCT(ret, out);

}

/// 勇士抽奖，查询目前的抽奖情况
int Croute_func::roominfo_warrior_lucky_draw_get(DEAL_FUN_ARG)
{
	this->roominfo_stone_move.userid(RECVBUF_USERID);

	uint32_t wt=0;
	uint32_t wit=0;
	ret=this->roominfo_stone_move.warrior_draw_get(wt, wit);
	if(USER_ID_NOFIND_ERR==ret)
	{
		ret=0;
	}

	roominfo_warrior_lucky_draw_get_out out={wt, wit};

	STD_RETURN_WITH_STRUCT(ret, out);

}

/// 勇士抽奖，给予限制等等
int Croute_func::roominfo_warrior_lucky_draw(DEAL_FUN_ARG)
{
	this->roominfo_stone_move.userid(RECVBUF_USERID);

	roominfo_warrior_lucky_draw_in* p_in=PRI_IN_POS;

	uint32_t wt=0;
	uint32_t wit=0;
	ret=this->roominfo_stone_move.warrior_draw_get(wt, wit);
	if(USER_ID_NOFIND_ERR==ret)
	{
		ret=0;
	}

	if(wt>100000)
	{
		STD_RETURN(WARRIOR_LUCK_DRAW_OVER_LIMIT_ERR);
	}

	if(wit>10)
	{
		STD_RETURN(WARRIOR_IS_LUCK_DRAW_OVER_LIMIT_ERR);
	}

	//现在开始抽奖
	++wt;
	bool is_luck=false;
	if(std::rand()%10<10) //30%的抽中概率
	{
		is_luck=true;
		++wit;
	}

	ret=this->roominfo_stone_move.warrior_draw_set(wt, wit);
	if(USER_ID_NOFIND_ERR==ret)
	{
		this->roominfo_stone_move.insert();
		ret=this->roominfo_stone_move.warrior_draw_set(wt, wit);
	}

	roominfo_warrior_lucky_draw_out out={0};
	if(is_luck) //抽中
	{
		out.attireid=p_in->attireid;
	}

	STD_RETURN_WITH_STRUCT(ret, out);
}

/// 得到宠物的对应的物品的个数
int Croute_func::user_pet_get_count_with_attireid(DEAL_FUN_ARG)
{
	char out[PROTO_MAX_LEN]={ };
	user_pet_get_count_with_attireid_in_header* p_in=PRI_IN_POS;
	if (p_in->count  >= 2000)
	{
		return VALUE_OUT_OF_RANGE_ERR;
	}

	CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_pet_get_count_with_attireid_in_item));

	user_pet_get_count_with_attireid_in_item* p_in_item=(user_pet_get_count_with_attireid_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in));

	user_pet_get_count_with_attireid_out_header  out_header = {};
	user_pet_get_count_with_attireid_out_item *p_out_item = NULL;
	user_pet_get_count_with_attireid_out_header *p_out_header  = (user_pet_get_count_with_attireid_out_header *)out; 
	user_pet_get_count_with_attireid_out_item *p_out =  (user_pet_get_count_with_attireid_out_item*)(p_out_header+1); 

	for (uint32_t i = 0; i < p_in->count; i++)
	{
		p_out[i].attireid = p_in_item[i].attireid;
	}
	p_out_header->count = p_in->count;

	ret=this->user_pet_attire.get_discontinuous_attire(RECVBUF_USERID, p_in_item,
				p_in->count, &p_out_item, &out_header.count);

	if (ret == VALUE_OUT_OF_RANGE_ERR)
	{
		ret = SUCC;
		out_header.count=0 ;
		p_out_item=NULL;	
	}

	for (uint32_t i = 0; i < out_header.count; i++)
	{
		for (uint32_t j = 0; j < p_in->count; j++)
		{
			if (p_out[j].attireid==p_out_item[i].attireid)
			{
				p_out[j].count = p_out_item[i].count;
				break;
			}
		}
	}

	free(p_out_item);

	STD_RETURN_WITH_BUF(ret, out, sizeof(user_pet_get_count_with_attireid_out_item) * (p_out_header->count) + 4);
}

/// 检查物品是否在背包里
int Croute_func::user_attire_get_attire_except_chest(DEAL_FUN_ARG)
{
	char out[PROTO_MAX_LEN]={ };
	user_attire_get_attire_except_chest_in_header *p_in=PRI_IN_POS;
	if (p_in->count  >= 2000)
	{
		return VALUE_OUT_OF_RANGE_ERR;
	}
	CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_attire_get_attire_except_chest_in_item));
	user_attire_get_attire_except_chest_in_item * p_in_item=(user_attire_get_attire_except_chest_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
	user_attire_get_attire_except_chest_out_header  out_header = {};
	user_attire_get_attire_except_chest_out_item *p_out_item = NULL;
	
	user_attire_get_attire_except_chest_out_header  *p_out_header  = (user_attire_get_some_attire_count_out_header *)out; 
	user_attire_get_attire_except_chest_out_item *p_out =  (user_attire_get_attire_except_chest_out_item *)(out + 4); 
	for (uint32_t i = 0; i < p_in->count; i++) {
		(p_out + i)->attireid = (p_in_item + i)->attireid;
	}
	p_out_header->count = p_in->count;
	ret=this->user_attire.get_discontinuous_attire_except_chest(RECVBUF_USERID, p_in_item,
		p_in->count, &p_out_item, &out_header.count);
	if (ret == VALUE_OUT_OF_RANGE_ERR) {
		ret = SUCC;
		out_header.count=0 ;
		p_out_item=NULL;	
	}
	for (uint32_t i = 0; i < out_header.count; i++) {
		for (uint32_t j = 0; j < p_in->count; j++) {
			if ((p_out + j)->attireid == (p_out_item + i)->attireid) {
				(p_out + j)->count = (p_out_item + i)->count;
				break;
			}
		}
	}
	free(p_out_item);
	STD_RETURN_WITH_BUF(ret, out, sizeof(user_attire_get_some_attire_count_out_item) * (p_out_header->count) + 4);
}

/// 宠物泡温泉，提前成熟，并消耗自己的物品
int Croute_func::user_pet_hot_spring(DEAL_FUN_ARG)
{
	user_pet_hot_spring_in* p_in=PRI_IN_POS;
	this->user_pet.cmd_init(RECVBUF_USERID, p_in->petid);

	//减去相应的物品
	user_del_attire_in itm={};
	itm.attireid=p_in->attireid;
	itm.attiretype=0;//0, 装扮
	itm.count=p_in->attire_count;
	itm.maxcount=99999;
	if (p_in->attire_count != 0) {
		ret=this->user_del_attire(RECVBUF_USERID, &itm);
		if(SUCC!=ret)
		{
			return ret;
		}
	}

	Cuser_pet::logic_birthday_t logic_birthday;

	ret=this->user_pet.template_get(logic_birthday);
	if(SUCC!=ret)
	{
		return ret;
	}

	logic_birthday.value() -= p_in->birthday_logic_shift_second;
	ret=this->user_pet.template_set(logic_birthday);
	if(SUCC!=ret)
	{
		return ret;
	}

	user_pet_hot_spring_out out={p_in->petid, logic_birthday.value()};

	STD_RETURN_WITH_STRUCT(ret, out);
}

/// 更新宠物技能点
int Croute_func::user_pet_skill_set(DEAL_FUN_ARG)
{
	user_pet_skill_set_in* p_in=PRI_IN_POS;
	user_pet_skill_set_out out={};
	this->user_pet.cmd_init(RECVBUF_USERID, p_in->petid);
	switch(p_in->type)
	{
		case 0: // 火系
		{
			Cuser_pet::fire_skill_bitflag_t flag;
			ret=this->user_pet.template_get(flag);
			if(SUCC!=ret)
			{
				return ret;
			}
			
			uint32_t v=p_in->n_value ? 1 : 0;
			v <<= p_in->n_pos;
			flag.value() |= v;

			ret=this->user_pet.template_set(flag);
			if(SUCC!=ret)
			{
				return ret;
			}

			out.value_after_update=flag.value();

			break;
		}
		case 1: // 水系
		{
			Cuser_pet::water_skill_bitflag_t flag;
			ret=this->user_pet.template_get(flag);
			if(SUCC!=ret)
			{
				return ret;
			}
			
			uint32_t v=p_in->n_value ? 1 : 0;
			v <<= p_in->n_pos;
			flag.value() |= v;

			ret=this->user_pet.template_set(flag);
			if(SUCC!=ret)
			{
				return ret;
			}

			out.value_after_update=flag.value();

			break;
		}
		case 2: // 木系
		{
			Cuser_pet::wood_skill_bitflag_t flag;
			ret=this->user_pet.template_get(flag);
			if(SUCC!=ret)
			{
				return ret;
			}
			
			uint32_t v=p_in->n_value ? 1 : 0;
			v <<= p_in->n_pos;
			flag.value() |= v;

			ret=this->user_pet.template_set(flag);
			if(SUCC!=ret)
			{
				return ret;
			}

			out.value_after_update=flag.value();

			break;
		}
		default:
		{
			return USER_PET_SKILL_SET_UNKOWN_TYPE_ERR;
		}
	}

	STD_RETURN_WITH_STRUCT(SUCC, out);
}

/// 取得用户神殿的高度
int Croute_func::user_pet_halt_get(DEAL_FUN_ARG)
{
	this->roominfo.userid(RECVBUF_USERID);

	Croominfo::fire_halt_height_t fire_height;
	Croominfo::water_halt_height_t water_height;
	Croominfo::wood_halt_height_t wood_height;

	ret=this->roominfo.template_select_by_userid(fire_height, water_height, wood_height);
	if(SUCC!=ret)
	{
		return ret;
	}

	user_pet_halt_get_out out={fire_height.value(), water_height.value(), wood_height.value()};

	STD_RETURN_WITH_STRUCT(SUCC, out);
}

/// 设置用户神殿的高度
int Croute_func::user_pet_halt_set(DEAL_FUN_ARG)
{
	user_pet_halt_set_in* p_in=PRI_IN_POS;
	user_pet_halt_set_out out={};

	this->roominfo.userid(RECVBUF_USERID);

	switch(p_in->type)
	{
		case 0: // 火系
		{
			Croominfo::fire_halt_height_t height;
			ret=this->roominfo.template_select_by_userid(height);
			if(SUCC!=ret)
			{
				return ret;
			}

			height.value() += p_in->height;
			ret=this->roominfo.template_update_by_userid(height);
			if(SUCC!=ret)
			{
				return ret;
			}

			out.height_after_set=height.value();

			break;
		}
		case 1: // 水系
		{
			Croominfo::water_halt_height_t height;
			ret=this->roominfo.template_select_by_userid(height);
			if(SUCC!=ret)
			{
				return ret;
			}

			height.value() += p_in->height;
			ret=this->roominfo.template_update_by_userid(height);
			if(SUCC!=ret)
			{
				return ret;
			}

			out.height_after_set=height.value();

			break;
		}
		case 2: // 木系
		{
			Croominfo::wood_halt_height_t height;
			ret=this->roominfo.template_select_by_userid(height);
			if(SUCC!=ret)
			{
				return ret;
			}

			height.value() += p_in->height;
			ret=this->roominfo.template_update_by_userid(height);
			if(SUCC!=ret)
			{
				return ret;
			}

			out.height_after_set=height.value();

			break;
		}
		default:
		{
			return USER_PET_SKILL_SET_UNKOWN_TYPE_ERR;
		}
	}

	STD_RETURN_WITH_STRUCT(SUCC, out);
}

 /// 设置拉姆任务
int Croute_func::user_pet_task_set_task(DEAL_FUN_ARG)
{
	user_pet_task_set_task_in *p_in=PRI_IN_POS; 
	ret=this->user_pet_task.set_task_stat(RECVBUF_USERID, p_in->petid, p_in->taskid, p_in->value);
	STD_RETURN(ret);
}

/// 宠物任务，取得指定任务状态
int Croute_func::user_pet_task_get_tasklist(DEAL_FUN_ARG)
{
	user_pet_task_get_tasklist_in *p_in=PRI_IN_POS; 
	user_pet_task_get_tasklist_out out={};
	ret=this->user_pet_task.get_task_stat(RECVBUF_USERID, p_in->petid, p_in->taskid, &out.value);
	if (ret != SUCC)
	{
		ret = SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

/// 宠物任务，设置客户端临时数据
int Croute_func::user_pet_task_set_temp_data(DEAL_FUN_ARG)
{
	user_pet_task_set_temp_data_in *p_in=PRI_IN_POS; 
	ret=this->user_pet_task.update_temp_data(RECVBUF_USERID, p_in->petid, p_in->taskid, p_in->tasktemp);
	STD_RETURN(ret);
}

/// 宠物任务，取得客户端临时数据
int Croute_func::user_pet_task_get_temp_data(DEAL_FUN_ARG)
{
	user_pet_task_get_temp_data_in *p_in=PRI_IN_POS; 
	user_pet_task_get_temp_data_out out={};
	ret=this->user_pet_task.get_temp_data(RECVBUF_USERID, p_in->petid, p_in->taskid, out.tasktemp);
	STD_RETURN_WITH_STRUCT(ret,out);
}

/// 宠物任务，取得指定用户，任务满足某一条件的所有的宠物
int Croute_func::user_pet_task_get_by_user(DEAL_FUN_ARG)
{
	user_pet_task_get_by_user_in* p_in=PRI_IN_POS;
	this->user_pet_task.cmd_init(RECVBUF_USERID, p_in->petid);

	user_pet_task_get_by_user_out_item* list;
	uint32_t ct=0;

	ret=this->user_pet_task.get_task_stat_by_user(p_in->taskstat, &list, &ct);
	if(SUCC!=ret)
	{
		return ret;
	}

	db_utility::packet_t packet;
	packet.data(p_in->petid);
	packet.data(p_in->taskstat);
	packet.data(ct);
	packet.data((const char*)list, sizeof(user_pet_task_get_by_user_out_item)*ct);

	std::free(list);

	STD_RETURN_WITH_BUF(SUCC, packet.data(), packet.size());
}

/// 用户宠物，使用一次技能
int Croute_func::user_use_skill_one(DEAL_FUN_ARG)
{
	user_use_skill_one_in* p_in=PRI_IN_POS;
	user_use_skill_one_out out={};

	this->roominfo_skill_limit.key_init(RECVBUF_USERID, p_in->skillid);
	Croominfo_skill_limit::filed_string_t fstring;

	ret=this->roominfo_skill_limit.template_select_by_userid_id(fstring);
	if(ID_NOT_EXIST_ERR==ret)
	{
		ret=this->roominfo_skill_limit.template_insert_by_userid_id();
		if(SUCC!=ret)
		{
			return ret;
		}
	}

	if (p_in->attireid > 0)
	{
		Croominfo_skill_limit::attire_list_t alist(fstring.value());

		size_t attire_count=alist.count(p_in->attireid);
		if(attire_count >= p_in->size_max)
		{
			return USER_USE_SKILL_ONE_OVER_ERR;
		}

		alist.add_count(p_in->attireid);
		fstring.value(alist.data());
		ret=this->roominfo_skill_limit.template_buf_update_by_userid_id(fstring);
		if(ret != SUCC)
		{
			return ret;
		}
	}
	uint32_t change_value = 0;
    ret = this->roominfo_day_limit.get(RECVBUF_USERID, p_in->petid, change_value);
	if (ret == RECORD_NOT_EXIST_ERR)
	{
		this->roominfo_day_limit.insert(RECVBUF_USERID, p_in->petid);
	}

	if (change_value >= p_in->limit)
	{
		out.limit_check = 1;
	}
	else
	{
		out.limit_check = 0;
		change_value = change_value + p_in->change;
    	ret = this->roominfo_day_limit.set(RECVBUF_USERID, p_in->petid, change_value);
		if (ret != SUCC)
		{
			return ret;
		}	
	}

	if (p_in->flag > 0)
	{
		uint32_t num = 1 ;
    	ret = this->roominfo_day_limit.update_num_inc(RECVBUF_USERID, p_in->petid, num);
		if (ret != SUCC)
		{
			return ret;
		}	
	}

	uint32_t count = 0 ;
    ret = this->roominfo_day_limit.get_num(RECVBUF_USERID, p_in->petid, count);
	if (ret != SUCC)
	{
		return ret;
	}
	out.num = count;

	STD_RETURN_WITH_STRUCT(ret,out);
}

/// 宠物任务，根据任务状态和任务编号，取得客户端私有数据
int Croute_func::user_pet_task_get_client_by_user_task(DEAL_FUN_ARG)
{
	user_pet_task_get_client_by_user_task_in* p_in=PRI_IN_POS;
	this->user_pet_task.userid(RECVBUF_USERID);
	this->user_pet_task.taskid(p_in->taskid);

	user_pet_task_get_client_by_user_task_out_item* list;
	uint32_t count=0;

	ret=this->user_pet_task.get_task_stat_by_user_task(p_in->taskstat, &list, &count);
	if(SUCC!=ret)
	{
		return ret;
	}

	db_utility::packet_t packet;
	packet.data(count);
	packet.data((const char*)list, sizeof(*list)*count);

	std::free(list);

	STD_RETURN_WITH_BUF(ret, packet.data(), packet.size());
}

/// 客户端私有数据，取得
int Croute_func::roominfo_client_data_get(DEAL_FUN_ARG)
{
	roominfo_client_data_get_in* p_in=PRI_IN_POS;
	this->roominfo_client_data.key_init(RECVBUF_USERID, p_in->id);
	Croominfo_client_data::data_client_t dt;
	ret=this->roominfo_client_data.template_select_by_userid_id(dt);

	if(ret==ID_NOT_EXIST_ERR)
	{
		return USER_GET_CLIENT_DATA_IS_NOT_EXIST_ERR;
	}

	if(SUCC!=ret)
	{
		return ret;
	}

	db_utility::packet_t packet;
	packet.data<uint32_t>(p_in->id);
	packet.data(dt.value());

	STD_RETURN_WITH_BUF(ret, packet.data(), packet.size());

}

/// 客户端私有数据，设置
int Croute_func::roominfo_client_data_set(DEAL_FUN_ARG)
{
	roominfo_client_data_set_in* p_in=PRI_IN_POS;
	this->roominfo_client_data.key_init(RECVBUF_USERID, p_in->id);

	Croominfo_client_data::data_client_t dt;
	dt.value(p_in->data);

	ret=this->roominfo_client_data.template_update_by_userid_id(dt);
	if(ID_NOT_EXIST_ERR==ret)
	{
		this->roominfo_client_data.template_insert_by_userid_id();
		ret=this->roominfo_client_data.template_update_by_userid_id(dt);
	}

	STD_RETURN(ret);
}

/* @brief 设置牧场动物的标志位 
 */
int Croute_func::user_animal_set_flag(DEAL_FUN_ARG)
{
	user_animal_set_flag_in *p_in=PRI_IN_POS; 
	ret=this->user_farm_animal.set_animal_flag(RECVBUF_USERID, p_in->id, p_in->index);
	STD_RETURN(ret);
}

/* @brief 设置元宵节的心愿
 */
int Croute_func::roominfo_list_set_wish(DEAL_FUN_ARG)
{
	roominfo_list_set_wish_in *p_in=PRI_IN_POS; 
	ret=this->roominfo_list.update_wish_sql(RECVBUF_USERID, p_in);
	if (ret != SUCC) {
		this->roominfo_list.insert(RECVBUF_USERID);
		ret=this->roominfo_list.update_wish_sql(RECVBUF_USERID, p_in);
	}
	STD_RETURN(ret);
}

/* @breif 得到元宵节的心愿
 */
int Croute_func::roominfo_list_get_wish(DEAL_FUN_ARG)
{
	roominfo_list_get_wish_out out={};
	this->roominfo_list.select_wish_sql(RECVBUF_USERID, &out);
	ret = SUCC;
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_pet_set_change_value(DEAL_FUN_ARG)
{
	user_pet_set_change_value_in *p_in=PRI_IN_POS; 
	ret=this->user_pet.set_change_value( RECVBUF_USERID, p_in );	
	if (ret==SUCC){
        //log_change
        change_log_item c_item;
        c_item.userid=RECVBUF_USERID;
        c_item.change_type=102;
        c_item.logtime=time(NULL);
        c_item.change_value=p_in->petid;
        c_item.change_v1=p_in->change_value;
        c_item.change_v2=0;
        this->send_log.send(&c_item );
    }
	STD_RETURN(ret);
}

int Croute_func::user_change_object_id(DEAL_FUN_ARG)
{
	user_change_object_id_in_header *p_in=PRI_IN_POS;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_change_object_id_in_item));
	user_change_object_id_in_item * p_in_item=(user_change_object_id_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
	
	switch(p_in->type)
	{
		case 0:
			{
				for (uint32_t i =0; i < p_in->count; i++)
				{
					uint32_t count;
					ret = this->user_attire.get_count(RECVBUF_USERID, (p_in_item + i)->object_id, count);
					if (ret != SUCC)
					{
						if (ret == ATTIRE_COUNT_NO_ENOUGH_ERR)
						{
							continue;
						}
						return ret;
					}
					user_add_attire_in	st_attire_add;
					st_attire_add.attireid = (p_in_item + i)->change_id;
					st_attire_add.attiretype = p_in->type;
				  	st_attire_add.count = count;
					st_attire_add.maxcount = 99999;	
					ret = this->user_add_attire(RECVBUF_USERID, &st_attire_add);
					if (ret != SUCC)
					{
						return ret;
					}
					user_del_attire_in	st_attire_del;
					st_attire_del.attireid = (p_in_item + i)->object_id;
					st_attire_del.attiretype = p_in->type;
				  	st_attire_del.count = count;
					st_attire_del.maxcount = 99999;	
					ret = this->user_del_attire(RECVBUF_USERID, &st_attire_del);
					if (ret != SUCC)
					{
						return ret;
					}
				}
	
				STD_RETURN(SUCC);
			}
		default:
			{
				return VALUE_OUT_OF_RANGE_ERR;

			}

	}

}

int Croute_func::user_noah_sn_bind_userid(DEAL_FUN_ARG)
{
	user_noah_sn_bind_userid_in *p_in=PRI_IN_POS;
	uint32_t count;
   	ret = this->user_noah.get_user_noah_user_bind(RECVBUF_USERID, count);	
	if (ret != SUCC)
	{
		return ret;
	}
	if (count > 0)
	{
		ret = USER_BIND_SN_EXIST_ERR;
		return ret ;
	}
	uint32_t user_id;
	ret = this->user_sn.getuserid(p_in->sn, &user_id);
	if (ret == SUCC)
	{
		ret = SN_BIND_USER_EXIST_ERR;
		return ret;
	}

	ret=this->user_noah.insert(RECVBUF_USERID, p_in->sn);
	if (ret != SUCC)
	{
		return ret;
	}
	ret = this->user_sn.insert(p_in->sn, RECVBUF_USERID);
	STD_RETURN(ret);
}

int Croute_func::user_noah_sn_unbind_userid(DEAL_FUN_ARG)
{
	user_noah_sn_unbind_userid_in *p_in=PRI_IN_POS; 
	ret=this->user_noah.del(RECVBUF_USERID, p_in->sn);
	if (ret != SUCC)
	{
		return ret;
	}
	ret = this->user_sn.remove(p_in->sn, RECVBUF_USERID);
	STD_RETURN(ret);
}

int Croute_func::user_noah_add_user_info(DEAL_FUN_ARG)
{
	user_noah_add_user_info_in *p_in=PRI_IN_POS;
	user_noah_add_user_info_out out={};
	user_noah_user_info st_info ={};
	ret = this->user_noah_info.get_user_noah_info_sum(RECVBUF_USERID, p_in->sn, p_in->last_time, st_info) ;
	if ((ret != SUCC) && ret != USER_ID_NOFIND_ERR)
	{
		return ret;
	}
   	
	uint32_t cur_time = time(NULL);
	uint32_t last_week = cur_time - 7*24*60*60;
	uint32_t uixiaomee = 0;
	ret = this->user_noah_info.get_user_xiaomee_sum_week(RECVBUF_USERID, p_in->sn, last_week, uixiaomee) ;
	if ((ret != SUCC) && ret != USER_ID_NOFIND_ERR)
	{
		return ret;
	}

	uint32_t flag = 1;
	if ((p_in->xiaomee < st_info.xiaomee) || (p_in->exp < st_info.exp) || (p_in->iq < st_info.iq) 
			|| (p_in->charm < st_info.charm) || (p_in->strong < st_info.strong))
	{
		flag = 0;
		out.xiaomee = 0;	
		out.exp = 0;	
		out.iq = 0;	
		out.strong = 0;	
		out.charm = 0;	
		out.last_time = p_in->last_time;	
	}
	else
	{
		p_in->xiaomee = p_in->xiaomee - st_info.xiaomee;
		p_in->exp = p_in->exp - st_info.exp;
		p_in->iq = p_in->iq - st_info.iq;
		p_in->charm = p_in->charm - st_info.charm;
		p_in->strong = p_in->strong - st_info.strong;

		if (uixiaomee >= 7000)
		{
			p_in->xiaomee = 0;
		}
		else if ((uixiaomee < 7000) && ((p_in->xiaomee + uixiaomee) > 7000))
		{
			p_in->xiaomee = 7000 - uixiaomee;
		}

		out.xiaomee = p_in->xiaomee;	
		out.exp = p_in->exp;	
		out.iq = p_in->iq;	
		out.strong = p_in->strong;	
		out.charm = p_in->charm;	
		out.last_time = cur_time;	
	}

	if (flag > 0)
	{

		ret=this->user_noah_info.insert_user_noah_info(RECVBUF_USERID, cur_time, *p_in);
	}
	
	if (ret==SUCC){
        //log_change
        change_log_item c_item;
        c_item.userid=RECVBUF_USERID;
        c_item.change_type=105;
        c_item.logtime=time(NULL);
        c_item.change_value=-1;
        c_item.change_v1=0;
        c_item.change_v2=0;
        this->send_log.send(&c_item );
    }

	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_noah_get_user_bind_info(DEAL_FUN_ARG)
{
	user_noah_get_user_bind_info_out out={};
	ret=this->user_noah.get_user_noah_bind_info(RECVBUF_USERID, out);
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_noah_get_userid_by_sn(DEAL_FUN_ARG)
{
	user_noah_get_userid_by_sn_in *p_in=PRI_IN_POS; 
	user_noah_get_userid_by_sn_out out={};
	memcpy(out.sn, p_in->sn, NOAH_SN_LEN);
	ret=this->user_sn.getuserid(p_in->sn, &(out.userid));
	if (ret != SUCC )
	{
		ret = 0;
		out.userid = 0;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_get_noah_info(DEAL_FUN_ARG)
{
	user_get_noah_info_out out={};
	ret=this->user.get_noah_info(RECVBUF_USERID, out);
	if (ret != SUCC)
	{
		return ret;
	}
	ret = this->user_ex.get_nick(RECVBUF_USERID, out.nick);
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_mdog_get_mdog(DEAL_FUN_ARG)
{
	user_mdog_get_mdog_in *p_in=PRI_IN_POS; 
	ret=this->user_mdog.insert(RECVBUF_USERID, p_in->mdog);
	if (ret != SUCC)
	{
		return ret;
	}
	
	uint32_t cur_time = time(NULL);
	uint32_t end_time = 0;
	if(p_in->mdog == 1320001){
		end_time = cur_time + 2*24*60*60;
	}
	else{
		end_time = cur_time + 3*24*60*60;
	}
	ret = this->user_mdog.set_end_time(RECVBUF_USERID, p_in->mdog, end_time);
	
	STD_RETURN(ret);
}

int Croute_func::user_mdog_del_mdog(DEAL_FUN_ARG)
{
	user_mdog_del_mdog_in *p_in=PRI_IN_POS; 
	ret=this->user_mdog.del(RECVBUF_USERID, p_in->mdog);
	if (ret==SUCC){
	//log_change
	change_log_item c_item;
	c_item.userid=RECVBUF_USERID;
	c_item.change_type=100;
	c_item.logtime=time(NULL);
	c_item.change_value=1;
	if(p_in->mdog == 1320001){
		c_item.change_v1 = 1320001;
	}else{
		c_item.change_v1 = 1320002;
	}
	c_item.change_v2=1;
	this->send_log.send(&c_item );
    }
	STD_RETURN(ret);
}

int Croute_func::user_mdog_query_mdog_info(DEAL_FUN_ARG)
{
	user_mdog_query_mdog_info_in *p_in=PRI_IN_POS; 
	user_mdog_query_mdog_info_out out={0};
	ret=this->user_mdog.get_mdog_info(RECVBUF_USERID, p_in->mdog, out);
	uint32_t cur_time = time(NULL);
	uint32_t is_del_imi_R7 = 0;//表示山寨R7是否跑掉
	if ((out.time < cur_time) && (ret != USER_ID_NOFIND_ERR))
	{
		if(p_in->mdog == 1320002){//山寨R7
			const uint32_t seven_days = 7 * 24 * 3600;
			if((out.time + seven_days) > cur_time){
				if(out.flag == 0){
					out.flag = 2;
					ret = this->user_mdog.update_flag(RECVBUF_USERID, p_in->mdog, out.flag);
				}else{
					out.flag = 0;
				}
				
			}else{
				ret = this->user_mdog.del(RECVBUF_USERID, p_in->mdog);
				out.flag = 1;
				out.plant_water = 0;
				out.insent_kill = 0;
				out.animal_drink = 0;
				out.animal_catch = 0;
				is_del_imi_R7 = 1;
				if (ret==SUCC){
				//log_change
					change_log_item c_item;
					c_item.userid=RECVBUF_USERID;
					c_item.change_type=100;
					c_item.logtime=time(NULL);
					c_item.change_value=1;
					c_item.change_v1 = 1320002;
					c_item.change_v2=0;
					this->send_log.send(&c_item );
				}
			}
		}
		out.time = 0;
		
	}
	out.mdog = p_in->mdog;
	if(is_del_imi_R7 == 1){
		out.mdog = 0;
	}

	if (ret == USER_ID_NOFIND_ERR)
	{
		out.mdog = 0;
		ret = SUCC;
	}

	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_mdog_supply_energe(DEAL_FUN_ARG)
{
    user_mdog_supply_energe_in *p_in=PRI_IN_POS;
    user_mdog_supply_energe_out out={};
    uint32_t mdog = p_in->mdog;
	uint32_t attireid = p_in->attireid;
	//          R7机器狗id           超能骨头id          善哉R7机器狗id          低能骨头id
	if(!(mdog == 1320001 && attireid == 190639) && !(mdog == 1320002 && attireid == 190813)){
		return  R7_AND_BONE_NOT_MATCH_ERR;
	}
	uint32_t count = 0;
    ret = this->user_mdog.get_mdog(RECVBUF_USERID, mdog, count);
    if (count == 0)
    {
        return ret;
    }
    user_del_attire_in st_del_attire;
    st_del_attire.attireid = p_in->attireid;
    st_del_attire.attiretype = 0;
    st_del_attire.count = p_in->count;
    st_del_attire.maxcount = 99999;
    ret = this->user_del_attire(RECVBUF_USERID, &st_del_attire);
    if (ret != SUCC)
    {
        return ret;
    }

    uint32_t add_time = 0;
	if(mdog == 1320001){
        add_time = (p_in->count)*7*24*60*60;
    }else{
        add_time = (p_in->count)*1*24*60*60;
     }	
    uint32_t last_end_time = 0;
    uint32_t end_time = 0;
    ret=this->user_mdog.get_mdog_end_time(RECVBUF_USERID, p_in->mdog, last_end_time);
    if (ret != SUCC)
    {
        return ret;
    }
    uint32_t cur_time = time(NULL);
    if (last_end_time < cur_time)
    {
        end_time = cur_time + add_time;
    }else{
        end_time = last_end_time + add_time;
    }
    out.end_time = end_time;
    ret = this->user_mdog.set_end_time(RECVBUF_USERID, p_in->mdog, end_time);
    if (ret==SUCC){
        //log_change
        change_log_item c_item;
        c_item.userid=RECVBUF_USERID;
        c_item.change_type=101;
        c_item.logtime=time(NULL);
        c_item.change_value=1;
		if(p_in->mdog == 1320001){
			c_item.change_v1=190639;
		}else{
			c_item.change_v1=190813;
		}
        c_item.change_v2=1;
        this->send_log.send(&c_item );
    }
    STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_mdog_query_user_mdog(DEAL_FUN_ARG)
{
	user_mdog_query_user_mdog_in *p_in=PRI_IN_POS; 
	user_mdog_query_user_mdog_out out={};
	ret=this->user_mdog.get_mdog_count(RECVBUF_USERID, p_in->mdog,out);
	STD_RETURN_WITH_STRUCT(ret,out);
}


int Croute_func::user_pet_set_hot_skill(DEAL_FUN_ARG)
{
	user_pet_set_hot_skill_in *p_in=PRI_IN_POS; 
	ret=this->user_pet.set_hot_skill(RECVBUF_USERID, p_in);
	STD_RETURN(ret);
}

int Croute_func::user_su_get_change_value(DEAL_FUN_ARG)
{
	user_su_get_change_value_out_header  out_header;
	user_su_get_change_value_out_item *p_out_item;
	ret=this->roominfo_day_limit.get_user_change_value_list(RECVBUF_USERID, &(out_header.count), &p_out_item);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}


int Croute_func::userinfo_set_question2(DEAL_FUN_ARG)
{
	userinfo_set_question2_in *p_in=PRI_IN_POS; 
	ret=this->user_info.set_question2(RECVBUF_USERID,p_in );
	STD_RETURN(ret);
}

int Croute_func::userinfo_get_question2(DEAL_FUN_ARG)
{
	userinfo_get_question2_out out={};
	ret=this->user_info.get_question2(RECVBUF_USERID,&out);
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::userinfo_verify_question2(DEAL_FUN_ARG)
{
	userinfo_verify_question2_in *p_in=PRI_IN_POS; 
	if (
				p_in->answer_1=='\0'
			&&	p_in->answer_2=='\0'
			&&	p_in->answer_3=='\0'
			)
		return USERINFO_VERIFY_QUESTION2_ERR; 
	ret=this->user_info.verify_question2(RECVBUF_USERID,p_in);
	STD_RETURN(ret);
}

int Croute_func::user_animal_milk_cow(DEAL_FUN_ARG)
{
	user_animal_milk_cow_in *p_in=PRI_IN_POS; 
	ret=this->user_farm_animal.milk_cow(RECVBUF_USERID,p_in->id);
	STD_RETURN(ret);
}

int Croute_func::user_ex_set_event_flag(DEAL_FUN_ARG)
{
	user_ex_set_event_flag_in *p_in=PRI_IN_POS; 
	ret=this->user_ex.set_event_flag(RECVBUF_USERID,p_in->index);
	STD_RETURN(ret);
}

int Croute_func::user_ex_set_sendmail_flag(DEAL_FUN_ARG)
{
        user_ex_set_sendmail_flag_in *p_in=PRI_IN_POS; 
        ret=this->user_ex.set_sendmail_flag(RECVBUF_USERID,p_in->index);
		//ret = this->user_ex.set_sendmail_flag(RECVBUF_USERID, p_in->index, p_in->email_flag);
        STD_RETURN(ret);
}

int Croute_func::user_ex_get_month(DEAL_FUN_ARG)
{
	user_ex_get_month_out out={};
	ret=this->user_ex.get_months(RECVBUF_USERID,&out);
/*  
	if(ret == SUCC) {
		if(get_date(time(NULL)) >= (int)out.expire) {
			out.months = 0;
			out.bonus_used = 0;
		}
	}
*/
	ret = SUCC;
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_ex_add_month(DEAL_FUN_ARG)
{
	user_ex_add_month_in *p_in=PRI_IN_POS; 
	user_ex_get_month_out out={};
	ret=this->user_ex.get_months(RECVBUF_USERID,&out);
	if(ret == SUCC) {
//		if(p_in->expire == out.expire) {
//			p_in->months+=out.months;
//		}
		p_in->months+=out.months;
		ret=this->user_ex.update_months(RECVBUF_USERID,p_in);
	}
	STD_RETURN(ret);
}

int Croute_func::roominfo_user_set_npc_score(DEAL_FUN_ARG)
{
	roominfo_user_set_npc_score_in *p_in=PRI_IN_POS; 
	roominfo_user_set_npc_score_out out={};
	uint32_t score = 0;
	uint32_t today_score = 0;
	ret=this->roominfo.get_scores(RECVBUF_USERID, score, today_score);
	if (ret != SUCC)
	{
		return ret;
	}
	
	uint32_t score_begin = score;

	if (today_score >= 9000)
	{
		return USER_VOTE_NPC_SCORE_TODAY_LIMIT_ERR;
	}

	if ( (today_score + p_in->score) > 9000)
	{
		score = score + 9000 - today_score;
		today_score = 9000;
		out.add_score = 9000 - today_score;
	}
	else
	{
		today_score = today_score + p_in->score;
		score = score + p_in->score;
		out.add_score = p_in->score;
	}

	if ((score_begin < 12000) && (score >= 12000))
	{
		out.flag = 1;
	}

	ret=this->roominfo.update_two_col_sql(RECVBUF_USERID,"score","today_score",score,today_score);
	out.score = score;
	STD_RETURN_WITH_STRUCT(ret,out);

}

int Croute_func::roominfo_user_get_npc_score(DEAL_FUN_ARG)
{
	roominfo_user_get_npc_score_out out={};
	ret=this->roominfo.get_int_value(RECVBUF_USERID,"score", &out.score);
	STD_RETURN_WITH_STRUCT(ret,out);
}


int Croute_func::userinfo_set_passwd_ex(DEAL_FUN_ARG)
{
	userinfo_set_passwd_ex_in *p_in=PRI_IN_POS; 
	if (p_in->passwd_type==1) {//登入密码

		ret=this->user_info.update_passwd(RECVBUF_USERID,p_in->newpasswd);
		if (ret!=SUCC) return ret;

		{
			//同步论坛数据
			dv_change_passwd_in t; 		
			memcpy(t.newpasswd,	p_in->newpasswd,PASSWD_LEN);
			this->send_log.dv_change_passwd(RECVBUF_USERID, &t);
		}

		{
			//同步论坛数据,台湾版本需要
			TDV_CHANGE_PASSWD t;	
			t.msg_flag=DV_CHANGE_PASSWD_CMD;
			t.sendcount=0;	
			t.userid=RECVBUF_USERID;
			memcpy(t.newpasswd,	p_in->newpasswd,PASSWD_LEN);
			this->sync_user.send((char*) &t, sizeof(t) );
		}


	}else if (p_in->passwd_type==2) {//支付密码
		ret=this->user_info.set_paypasswd(RECVBUF_USERID, p_in->newpasswd);
	}else{
		return ENUM_OUT_OF_RANGE_ERR;
	}

	if (ret == SUCC) {
		passwd_change_item item;
		item.userid = RECVBUF_USERID;
		item.opt_type=p_in->passwd_type*1000+p_in->passwd_change_way;
		item.time = time(NULL);
		memcpy(&item.passwd, &p_in->newpasswd, PASSWD_LEN);
		this->send_log.send_passwd(&item);
	}
	
	STD_RETURN(ret);
}

int Croute_func::userinfo_set_change_passwd_flag_ex(DEAL_FUN_ARG)
{
	userinfo_set_change_passwd_flag_ex_in *p_in=PRI_IN_POS; 
	if (p_in->passwd_type==1) {//登入密码
		ret=this->user_info.set_flag(RECVBUF_USERID,
				FLAG1_STR ,USER_FLAG1_CHANGE_PASSWD,true);
	}else if (p_in->passwd_type==2) {//支付密码
		ret=this->user_info.set_flag(RECVBUF_USERID,
			FLAG1_STR ,USER_FLAG1_CHANGE_PAYPASSWD,true);
	}else{
		return ENUM_OUT_OF_RANGE_ERR;
	}
	STD_RETURN(ret);
}

int Croute_func::userinfo_set_passwd_only_check_change_flag(DEAL_FUN_ARG)
{

	userinfo_set_passwd_only_check_change_flag_in *p_in=PRI_IN_POS; 
	if (p_in->passwd_type==1) {//登入密码
		ret=this->user_info.set_flag(RECVBUF_USERID,
			FLAG1_STR ,USER_FLAG1_CHANGE_PASSWD,false);
		if (ret!=SUCC) return ret;

		ret=this->user_info.update_passwd(RECVBUF_USERID , p_in->newpasswd );
		if (ret==SUCC)
		{
			{
				//同步论坛数据
				dv_change_passwd_in t; 		
				memcpy(t.newpasswd,	p_in->newpasswd,PASSWD_LEN);
				this->send_log.dv_change_passwd(RECVBUF_USERID, &t);
			}
			{
				//同步论坛数据,台湾版本需要
				TDV_CHANGE_PASSWD t;	
				t.msg_flag=DV_CHANGE_PASSWD_CMD;
				t.sendcount=0;	
				t.userid=RECVBUF_USERID;
				memcpy(t.newpasswd,	p_in->newpasswd,PASSWD_LEN);
				this->sync_user.send((char*) &t, sizeof(t));
			}
		}
	

	}else if (p_in->passwd_type==2) {//支付密码
		ret=this->user_info.set_flag(RECVBUF_USERID,
				FLAG1_STR ,USER_FLAG1_CHANGE_PAYPASSWD,false);
		if (ret!=SUCC) return ret;
		ret=this->user_info.update_paypasswd(RECVBUF_USERID , p_in->newpasswd);
	}else{
		return ENUM_OUT_OF_RANGE_ERR;
	}


	if (ret == SUCC) {
		passwd_change_item item;
		item.userid = RECVBUF_USERID;
		item.opt_type=p_in->passwd_type*1000+p_in->passwd_change_way;
		item.time = time(NULL);
		memcpy(&item.passwd, &p_in->newpasswd, PASSWD_LEN);
		this->send_log.send_passwd(&item);
	}
	
	STD_RETURN(ret);
}

int Croute_func::user_catch_fruit_all(DEAL_FUN_ARG)
{
	user_catch_fruit_all_out out={};
	
	uint32_t mdog = 1320001;
    uint32_t end_time = 0;
	uint32_t imi_mdog = 1320002;
	uint32_t end_imi_time =0;
    ret = this->user_mdog.get_mdog_end_time(RECVBUF_USERID, mdog, end_time);
	ret = this->user_mdog.get_mdog_end_time(RECVBUF_USERID, imi_mdog, end_imi_time);
	ret = SUCC;
	if(end_time < end_imi_time){
		end_time = end_imi_time;
	}
	/*
	if (ret!=SUCC)
	{
		if (ret == USER_ID_NOFIND_ERR )
		{
			return USER_MDOG_NOT_EXIST_ERR;
		}
		return ret;
	}
	*/
	uint32_t now_time = time(NULL);
	if (end_time < now_time)
	{
		return USER_MDOG_OUT_DATE_ERR;
	}

	jy_item * p_item = NULL;
	uint32_t count = 0;
	ret=this->user_jy.get_jy_item_list(RECVBUF_USERID, &count, &p_item);
	if (ret != SUCC) return ret;
	
	for (uint32_t i=0; i<count; i++)
	{
		uint32_t exp = 0;
		ret = this->user_catch_fruit_single(RECVBUF_USERID, p_item+i, exp);
		if(ret==SUCC)
		{
			out.exp = out.exp + exp;
			out.fruit_num = out.fruit_num + (p_item+i)->fruitnum;
		}
	}

	if (p_item != NULL)
	{
		free(p_item);
		p_item = NULL;
	}

	STD_RETURN_WITH_STRUCT(ret,out);
}



int Croute_func::userinfo_login_by_md5_two(DEAL_FUN_ARG)
{
	userinfo_login_by_md5_two_in *p_in=PRI_IN_POS; 
	userinfo_login_by_md5_two_out out={};
	
	ip_history_item ctiem;
	ctiem.userid = RECVBUF_USERID;
	ctiem.which_game = p_in->login_channel;
	ctiem.ip = p_in->ip;
	ret=this->send_log.send_ip(&ctiem);
	ret=this->user_info.login_by_md5_two(RECVBUF_USERID, p_in, &(out.gameflag));
	STD_RETURN_WITH_STRUCT(ret,out);
}


int Croute_func::diningroom_user_create_diningroom(DEAL_FUN_ARG)
{
	diningroom_user_create_diningroom_in *p_in=PRI_IN_POS; 
	diningroom_user_create_diningroom_out out; 
	ret=this->diningroom.insert(RECVBUF_USERID, p_in, out);
	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::diningroom_user_get_frame_diningroom(DEAL_FUN_ARG)
{
	diningroom_user_get_frame_diningroom_in *p_in=PRI_IN_POS; 
	diningroom_user_get_frame_diningroom_out_header  out_header;
	diningroom_user_get_frame_diningroom_out_item *p_out_item;
	uint32_t count = 0;
	ret = this->diningroom.get_diningroom_count(count);
	if (ret != SUCC)
	{
		return ret;
	}
	if ((p_in->frameid)*4 < count)
	{
		out_header.flag = 0;
	}
	else
	{
		out_header.flag = 1;
	}
	ret=this->diningroom.get_frame_diningrooms(p_in->frameid, &(out_header.count), &p_out_item);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::diningroom_user_set_room_name(DEAL_FUN_ARG)
{
	diningroom_user_set_room_name_in *p_in=PRI_IN_POS; 
	ret=this->diningroom.set_room_name(p_in);
	STD_RETURN(ret);
}

int Croute_func::diningroom_user_set_room_style(DEAL_FUN_ARG)
{
	diningroom_user_set_room_style_in *p_in=PRI_IN_POS; 
	ret=this->diningroom.set_room_style(p_in);
	STD_RETURN(ret);
}

int Croute_func::user_diningroom_create_room(DEAL_FUN_ARG)
{
	user_diningroom_create_room_in *p_in=PRI_IN_POS; 
	ret=this->user_diningroom.insert(RECVBUF_USERID,p_in);
	STD_RETURN(ret);
}

int Croute_func::diningroom_user_get_last_frameid(DEAL_FUN_ARG)
{
	diningroom_user_get_last_frameid_out out={};
	
	uint32_t roomid = 0;
	ret=this->diningroom.get_diningroom_roomid(RECVBUF_USERID, roomid);
	if (ret != SUCC)
	{
		ret = SUCC;
	}
	
	if (roomid > 0)
	{
		out.user_frameid  = roomid/4;
		if ((roomid%4) > 0 )
		{
			out.user_frameid = out.user_frameid + 1;
		}

	}


	uint32_t min_frame = 0;
	ret=this->diningroom.get_diningroom_min_frame(min_frame);
	if (ret!=SUCC) return  ret;
	out.begin_id = min_frame/4;
	if ((min_frame%4) > 0)
	{
		out.begin_id = out.begin_id + 1;
	}
	if (out.begin_id == 0)
	{
		out.begin_id = 1;
	}

	uint32_t count = 0;
	ret=this->diningroom.get_diningroom_count(count);
	if (ret != SUCC)
	{
		return ret;
	}
	out.frameid  = count/4;
	if ((count%4) > 0 )
	{
		out.frameid = out.frameid + 1;
	}

	if (out.frameid == 0)
	{
		out.frameid = 1;
	}


	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_diningroom_set_room_name(DEAL_FUN_ARG)
{
	user_diningroom_set_room_name_in *p_in=PRI_IN_POS; 
	ret=this->user_diningroom.set_room_name(RECVBUF_USERID,p_in);
	STD_RETURN(ret);
}

int Croute_func::user_diningroom_set_room_style(DEAL_FUN_ARG)
{
	user_diningroom_set_room_style_in *p_in=PRI_IN_POS; 
	
	int32_t temp = 0;
	ret=this->user.change_xiaomee(RECVBUF_USERID, -p_in->xiaomee,XIAOMEE_USE_DEL_BUY_ATTIRE ,
			0, &temp);
	if (ret != SUCC) return ret;

	ret=this->user_diningroom.update_xiaomee_dec(RECVBUF_USERID, p_in->xiaomee);
	
	if (ret == SUCC)
	{
		//log_change
		change_log_item c_item;
		c_item.userid=RECVBUF_USERID;
		c_item.change_type=103;
		c_item.logtime=time(NULL);
		c_item.change_value=-p_in->xiaomee;
		c_item.change_v1=p_in->style_id;
		c_item.change_v2=0;
		this->send_log.send(&c_item );
	}

	ret=this->user_diningroom.set_room_style(RECVBUF_USERID,p_in);
	STD_RETURN(ret);
}

int Croute_func::user_diningroom_set_room_inner_style(DEAL_FUN_ARG)
{
	user_diningroom_set_room_inner_style_in *p_in=PRI_IN_POS; 
	
	uint32_t bench_num = 0;
	uint32_t cooler_num = 0;

	ret = this->user_dining_dish.get_dish_bench_num(RECVBUF_USERID, p_in->max_bench, bench_num);

	ret = this->user_dining_dish.get_dish_cooler_num(RECVBUF_USERID, p_in->max_cooler, cooler_num);

	if (bench_num > 0 || cooler_num > 0)
	{
		return  USER_DINING_DISH_HAVE_DISH_ERR; 
	}

	int32_t temp = 0;
	ret=this->user.change_xiaomee(RECVBUF_USERID, -p_in->xiaomee,XIAOMEE_USE_DEL_BUY_ATTIRE ,
			0, &temp);
	if (ret != SUCC) return ret;

	ret=this->user_diningroom.update_xiaomee_dec(RECVBUF_USERID, p_in->xiaomee);
	
	if (ret == SUCC)
	{
		//log_change
		change_log_item c_item;
		c_item.userid=RECVBUF_USERID;
		c_item.change_type=103;
		c_item.logtime=time(NULL);
		c_item.change_value=-p_in->xiaomee;
		c_item.change_v1= p_in->inner_style;
		c_item.change_v2=0;
		this->send_log.send(&c_item );
	}

	ret=this->user_diningroom.set_room_inner_style(RECVBUF_USERID,p_in);
	STD_RETURN(ret);
}


int Croute_func::user_diningroom_user_off(userid_t userid, uint32_t cur_time, uint32_t eat_time, uint32_t& off_xiaomee)
{
	uint32_t evaluate = 0;
	uint32_t level = 1;
	uint32_t add_evaluate = 0;
	uint32_t dec_evaluate = 0;
	uint32_t add_xiaomee = 0;

	this->user_diningroom.update_off_xiaomee_inc(userid, 0);
	
	uint32_t em_num = 0;
	ret=this->user_dining_employer.get_user_employer_count(userid, em_num);
	if (ret!=SUCC) return ret;

	ret	= this->user_diningroom.get_level_evaluate(userid, level, evaluate);
	if (ret!=SUCC) return ret;
	if (evaluate > 1000)
	{
		evaluate = 1000;
		this->user_diningroom.set_evaluate(userid, evaluate);
	}
	
	uint32_t sec_time =  (60/((17*(evaluate/10))/95+2))+45-em_num*2;
	uint32_t eat_num = (cur_time - eat_time)/sec_time;
	if (eat_num <= 0)
	{
		this->user_diningroom.update_time(userid, cur_time);
		return SUCC;
	}
	
	if (em_num == 0)
	{
		dec_evaluate = eat_num * 1;
		if ((dec_evaluate + 50) >= evaluate)
		{
			evaluate = 50;
		}
		else
		{
			evaluate = evaluate - dec_evaluate;
		}

		this->user_diningroom.set_evaluate(userid, evaluate);
		this->user_diningroom.update_time(userid, cur_time);
		return SUCC;
	}

	uint32_t flag = 0;
	ret = this->user_diningroom_employer_time(userid, flag);
	if (!flag)
	{
		dec_evaluate = eat_num * 1;
		if ((dec_evaluate + 50) >= evaluate)
		{
			evaluate = 50;
		}
		else
		{
			evaluate = evaluate - dec_evaluate;
		}

		this->user_diningroom.set_evaluate(userid, evaluate);
		this->user_diningroom.update_time(userid, cur_time);

		return SUCC;
	}

	uint32_t num = 0;
	ret = this->user_dining_dish.get_dish_all_count(userid, num);
	if (num == 0)
	{
		dec_evaluate = eat_num * 1;
		if ((dec_evaluate + 50) >= evaluate)
		{
			evaluate = 50;
		}
		else
		{
			evaluate = evaluate - dec_evaluate;
		}

		this->user_diningroom.set_evaluate(userid, evaluate);
		this->user_diningroom.update_time(userid, cur_time);

		return SUCC;
	
	}
	
	user_dining_dish_item *p_dish_list=NULL;
	uint32_t count = 0; 
	ret = this->user_dining_dish.get_user_dish_state(userid, &p_dish_list, &count);
	if (ret != SUCC)
	{
		if(p_dish_list != NULL)
		{
			free(p_dish_list);
		}
		p_dish_list = NULL;
		return ret;
	}
	
	if (eat_num >= num)
	{
		for (uint32_t i = 0; i< count; i++)
		{
			add_xiaomee = add_xiaomee + (p_dish_list+i)->sale_xiaomee * (p_dish_list + i)->count;	
			add_evaluate = add_evaluate + 1*(p_dish_list + i)->count;
		}	

		dec_evaluate = (eat_num - num)*1;

		if (add_evaluate >= dec_evaluate)
		{
			add_evaluate = add_evaluate -dec_evaluate;
			if (evaluate + add_evaluate >= 1000)
			{
				add_evaluate = 1000 - evaluate;
			}
			
			this->user_diningroom.update_off_evaluate_inc(userid, add_evaluate);
		
		}
		else
		{
			dec_evaluate = dec_evaluate - add_evaluate;
			if (evaluate <= 50 + dec_evaluate )
			{
				evaluate = 50;
				this->user_diningroom.set_evaluate(userid, evaluate);
			}
			else
			{
				evaluate = evaluate  - dec_evaluate;
				this->user_diningroom.set_evaluate(userid, evaluate);
			}
	
		}

		this->user_dining_dish.del_all_dish(userid);
		//log_change
		change_log_item c_item;
		c_item.userid=userid;
		c_item.change_type=1030;
		c_item.logtime=time(NULL);
		c_item.change_value=add_xiaomee;
		c_item.change_v1=num;
		c_item.change_v2=eat_num;
		this->send_log.send(&c_item );
	}
	else
	{
		uint32_t dish_num = 0;
		uint32_t del_dish_num = 0;
		uint32_t del_last_num = 0;
		for (uint32_t i = 0; i< count; i++)
		{
			dish_num = dish_num + (p_dish_list+i)->count;
			if (dish_num <= eat_num)
			{
				this->user_dining_dish.del_dish(userid, (p_dish_list+i)->id);
				del_dish_num = dish_num;
				add_xiaomee = add_xiaomee + (p_dish_list+i)->sale_xiaomee * (p_dish_list + i)->count;	
				add_evaluate = add_evaluate +  1*(p_dish_list + i)->count;
				//log_change
				change_log_item c_item;
				c_item.userid=userid;
				c_item.change_type=1030;
				c_item.logtime=time(NULL);
				c_item.change_value=(p_dish_list+i)->dish_id;
				c_item.change_v1=del_dish_num;
				c_item.change_v2=eat_num;
				this->send_log.send(&c_item );
			}
			else
			{
				del_last_num = eat_num - del_dish_num;
				this->user_dining_dish.update_dish_num_dec(userid, (p_dish_list+i)->id, del_last_num);
				add_xiaomee = add_xiaomee + (p_dish_list+i)->sale_xiaomee * del_last_num;	
				add_evaluate = add_evaluate +  1*del_last_num;
				//log_change
				change_log_item c_item;
				c_item.userid=userid;
				c_item.change_type=1030;
				c_item.logtime=time(NULL);
				c_item.change_value=(p_dish_list+i)->dish_id;
				c_item.change_v1=del_last_num;
				c_item.change_v2=eat_num;
				this->send_log.send(&c_item );
				break;	
			}
		}
		
		if (evaluate + add_evaluate > 1000)
		{
			add_evaluate = 1000 - evaluate;
		}
		this->user_diningroom.update_off_evaluate_inc(userid, add_evaluate);
	}
	
	off_xiaomee = add_xiaomee;	
	uint32_t now_time = time(NULL);
	ret=this->user.update_xiaomee_inc(userid, add_xiaomee);
	ret=this->user_diningroom.update_off_xiaomee_inc(userid, add_xiaomee);
	ret=this->user_diningroom.update_time(userid, now_time);

	if(p_dish_list != NULL)
	{
		free(p_dish_list);
		p_dish_list = NULL;
	}
	
	return ret;

}

int Croute_func::user_get_diningroom(DEAL_FUN_ARG)
{
	user_get_diningroom_in *p_in=PRI_IN_POS; 
	char out[PROTO_MAX_LEN] = { };

	this->user_diningroom.set_honor_flag(RECVBUF_USERID, 64);

	uint32_t cur_time = time(NULL);
	uint32_t eat_time = 0;
	ret = this->user_diningroom.get_time(RECVBUF_USERID, eat_time);
	if (ret!=SUCC) return ret;

	uint32_t off_xiaomee = 0 ; 

	if(p_in->flag == 1 )
	{
		this->user_diningroom_user_off(RECVBUF_USERID,  cur_time, eat_time, off_xiaomee);
	}

	user_get_diningroom_out_header *p_out = (user_get_diningroom_out_header *)out;
	user_dining_dish_item *p_dish_list=NULL;
	user_dining_employer_item *p_employer_list=NULL;

	ret = this->user_diningroom.get_diningroom_info(p_in->userid, p_in->type_id, p_out);
	if (ret != SUCC)
	{
		return ret;
	}
	
	uint32_t dish_history_count = 0;
	ret = this->user_dining_dish_history.get_dish_history_count(RECVBUF_USERID, dish_history_count);
	if (ret!=SUCC) return ret;
	p_out->count = dish_history_count;
	p_out->off_xiaomee = off_xiaomee;

	uint32_t count = 0;

	ret = this->user_dining_dish_history.select_count_at_star_5(RECVBUF_USERID,count);
	p_out->level_5_count = count;

	count = 0;
	ret = this->user_dining_dish.get_user_dish(p_in->userid, &p_dish_list, &count);
	if (ret != SUCC)
	{
		if (p_dish_list != NULL)
		{
			free(p_dish_list);
		}
		p_dish_list = NULL;
		return ret;
	}
	p_out->dish_count = count;
	

	count = 0; 
	ret = this->user_dining_employer.get_user_employer(p_in->userid, &p_employer_list, &count);
	if (ret != SUCC)
	{
		if (p_employer_list != NULL)
		{
			free(p_employer_list);
		}
		p_employer_list = NULL;

		return ret;
	}
	p_out->employer_count = count;

	char *p_offset = out + sizeof(user_get_diningroom_out_header);

	memcpy(p_offset, p_dish_list, sizeof(user_dining_dish_item) * p_out->dish_count);
	p_offset += sizeof(user_dining_dish_item) * p_out->dish_count; 
	free(p_dish_list);

	memcpy(p_offset, p_employer_list, sizeof(user_dining_employer_item) * p_out->employer_count);
	p_offset += sizeof(user_dining_employer_item) * p_out->employer_count; 
	free(p_employer_list);

	STD_RETURN_WITH_BUF(ret, out, p_offset - out);

}

int Croute_func::su_user_get_diningroom(DEAL_FUN_ARG)
{
	su_user_get_diningroom_in *p_in=PRI_IN_POS; 
	char out[PROTO_MAX_LEN] = { };

	this->user_diningroom.set_honor_flag(RECVBUF_USERID, 64);

	uint32_t cur_time = time(NULL);
	uint32_t eat_time = 0;
	ret = this->user_diningroom.get_time(RECVBUF_USERID, eat_time);
	if (ret!=SUCC) return ret;

	uint32_t off_xiaomee = 0 ; 

	if(p_in->flag == 1 )
	{
		this->user_diningroom_user_off(RECVBUF_USERID,  cur_time, eat_time, off_xiaomee);
	}

	su_user_get_diningroom_out_header *p_out = (su_user_get_diningroom_out_header *)out;
	user_dining_dish_item *p_dish_list=NULL;
	user_dining_employer_item *p_employer_list=NULL;

	ret = this->user_diningroom.get_diningroom_info(p_in->userid, p_in->type_id, p_out);
	if (ret != SUCC)
	{
		return ret;
	}
	
	uint32_t dish_history_count = 0;
	ret = this->user_dining_dish_history.get_dish_history_count(RECVBUF_USERID, dish_history_count);
	if (ret!=SUCC) return ret;
	p_out->count = dish_history_count;
	p_out->off_xiaomee = off_xiaomee;

	uint32_t count = 0;

	ret = this->user_dining_dish_history.select_count_at_star_5(RECVBUF_USERID,count);
	p_out->level_5_count = count;

	count = 0;
	ret = this->user_dining_dish.get_user_dish(p_in->userid, &p_dish_list, &count);
	if (ret != SUCC)
	{
		if (p_dish_list != NULL)
		{
			free(p_dish_list);
		}
		p_dish_list = NULL;
		return ret;
	}
	char *p_offset = out + sizeof(user_get_diningroom_out_header) - 8;
	*((uint32_t*)p_offset) = count;
	//p_out->dish_count = count;
	p_offset += 4;	

	memcpy(p_offset, p_dish_list, sizeof(user_dining_dish_item) * count);
	p_offset += sizeof(user_dining_dish_item) * count; 
	free(p_dish_list);

	count = 0; 
	ret = this->user_dining_employer.get_user_employer(p_in->userid, &p_employer_list, &count);
	if (ret != SUCC)
	{
		if (p_employer_list != NULL)
		{
			free(p_employer_list);
		}
		p_employer_list = NULL;

		return ret;
	}
	*((uint32_t*)p_offset) = count;
	p_offset += 4;
	//p_out->employer_count = count;
	//char *p_offset = out + sizeof(user_get_diningroom_out_header);
	
	memcpy(p_offset, p_employer_list, sizeof(user_dining_employer_item) * count);
	p_offset += sizeof(user_dining_employer_item) * count; 
	free(p_employer_list);

	STD_RETURN_WITH_BUF(ret, out, p_offset - out);
}

int Croute_func::user_dining_add_employer(DEAL_FUN_ARG)
{
	user_dining_add_employer_in *p_in=PRI_IN_POS;
	uint32_t xiaomee = 0;
	xiaomee = p_in->xiaomee;
	
	uint32_t num = 0; 
   	ret = this->user_dining_employer.get_user_employer_count(RECVBUF_USERID, num);
	if (ret != SUCC)
	{
		return ret;
	}
	if (num >= p_in->em_num)
	{
		return	DINING_EMPLOYER_MAX_VALUE_ERR;
	}
	
	int32_t temp = 0;
	ret=this->user.change_xiaomee(RECVBUF_USERID, -xiaomee,XIAOMEE_USE_DEL_BUY_ATTIRE ,
			0, &temp);
	if (ret != SUCC) return ret;

	ret=this->user_dining_employer.add_employer(RECVBUF_USERID, p_in);
	if(ret!=SUCC) return ret;
	ret=this->user_diningroom.update_xiaomee_dec(RECVBUF_USERID, p_in->xiaomee);
	if (ret == SUCC)
	{
		//log_change
		change_log_item c_item;
		c_item.userid=RECVBUF_USERID;
		c_item.change_type=103;
		c_item.logtime=time(NULL);
		c_item.change_value=-p_in->xiaomee;
		c_item.change_v1=0;
		c_item.change_v2=0;
		this->send_log.send(&c_item );
	}
	STD_RETURN(ret);
}

int Croute_func::user_dining_del_employer(DEAL_FUN_ARG)
{
	user_dining_del_employer_in *p_in=PRI_IN_POS;
	user_dining_del_employer_out out={ };
   	uint32_t begin_time = 0;
	uint32_t pet_level = 0;
	uint32_t pet_skill = 0;
	ret = this->user_dining_employer.get_em_user_employer_time(RECVBUF_USERID ,p_in->em_userid, p_in->em_petid, begin_time,pet_level,pet_skill);
	if (ret != SUCC) return ret;

	ret=this->user_dining_employer.del_employer(RECVBUF_USERID, p_in);
	out.time = time(NULL) - begin_time;
	out.pet_level = pet_level;
	out.pet_skill = pet_skill;
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_dining_cook_dish(DEAL_FUN_ARG)
{
	user_dining_cook_dish_in *p_in=PRI_IN_POS; 
	user_dining_cook_dish_out out={};
	uint32_t state = 1;
	uint32_t id = 0;
	uint32_t count = 0;

	ret = this->user_dining_dish.get_dish_count_by_location(RECVBUF_USERID, p_in->location, count);
	if (ret != SUCC) return ret;

	if (count > 0)
	{
		return  DINING_DISH_COOKING_ERR;
	}

	if (p_in->xiaomee > 0)
	{
		int32_t temp = 0;
		ret=this->user.change_xiaomee(RECVBUF_USERID, -p_in->xiaomee,XIAOMEE_USE_DEL_BUY_ATTIRE ,
			0, &temp);
		if (ret != SUCC) return ret;
		msglog(this->msglog_file, 0x04040105,time(NULL), &(RECVBUF_USERID), 4);

	}
	else
	{
		if ( (p_in->food_one <= 0) && (p_in->food_two<=0) && (p_in->food_three <= 0) )
		{
			return USER_DINING_ATTIRE_NOENOUGH_ERR;
		}

		uint32_t count1 = 0;
		uint32_t count2 = 0;
		uint32_t count3 = 0;

		if (p_in->food_one > 0)
		{
			ret = this->user_attire.get_count(RECVBUF_USERID, p_in->food_one, count1);
			if (ret!=SUCC) return  ret;
			if (count1 < p_in->count_one)
				return USER_DINING_ATTIRE_NOENOUGH_ERR;
		}
		
	  	if (p_in->food_two >0)
		{
			ret = this->user_attire.get_count(RECVBUF_USERID, p_in->food_two, count2);
			if (ret!=SUCC) return  ret;
			if ( count2 < p_in->count_two )
				return USER_DINING_ATTIRE_NOENOUGH_ERR;
		}

		if (p_in->food_three > 0)
		{
			ret = this->user_attire.get_count(RECVBUF_USERID, p_in->food_three, count3);
			if (ret!=SUCC) return  ret;
			if ( count3 < p_in->count_three )
				return USER_DINING_ATTIRE_NOENOUGH_ERR;
		}

		user_del_attire_in del_item;
		del_item.attiretype=0;
		del_item.maxcount=99999;
		ret = this->user_del_attire(RECVBUF_USERID, &del_item);
		if(count1 > 0)
			del_item.attireid=p_in->food_one;
			del_item.count=p_in->count_one;
			ret = this->user_del_attire(RECVBUF_USERID, &del_item);
			//ret = this->user_attire.update_count(RECVBUF_USERID, p_in->food_one, -p_in->count_one);
		if(count2 > 0)
			del_item.attireid=p_in->food_two;
			del_item.count=p_in->count_two;
			ret = this->user_del_attire(RECVBUF_USERID, &del_item);
			//ret = this->user_attire.update_count(RECVBUF_USERID, p_in->food_two, -p_in->count_two);
		if(count3 > 0)
			del_item.attireid=p_in->food_three;
			del_item.count=p_in->count_three;
			ret = this->user_del_attire(RECVBUF_USERID, &del_item);
			//ret = this->user_attire.update_count(RECVBUF_USERID, p_in->food_three, -p_in->count_three);
	}

	ret=this->user_dining_dish.add_dish(RECVBUF_USERID, p_in, state, id);
	if (ret != SUCC)
	{
		return ret;
	}

	ret = this->user_diningroom.update_exp_inc(RECVBUF_USERID, p_in->exp);
	ret = this->user_diningroom.update_xiaomee_dec(RECVBUF_USERID, p_in->xiaomee);
	
	if (ret == SUCC)
	{
		//log_change
		change_log_item c_item;
		c_item.userid=RECVBUF_USERID;
		c_item.change_type=103;
		c_item.logtime=time(NULL);
		c_item.change_value=-p_in->xiaomee;
		c_item.change_v1=p_in->dish_id;
		c_item.change_v2=0;
		this->send_log.send(&c_item );
	}

	out.id = id;
	out.state = state;
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_dining_dish_in_chest(DEAL_FUN_ARG)
{
	user_dining_dish_in_chest_in *p_in=PRI_IN_POS;
	user_dining_dish_in_chest_out out={};
   	uint32_t time_begin = 0;

	uint32_t state = 0;
	uint32_t location = 0;

	ret = this->user_dining_dish.get_dish_id_state_location(RECVBUF_USERID, p_in->id, state, location);
	if (ret!=SUCC) return ret;
	if (state != 3)
	{
		return USER_DINING_DISH_TIME_EARLY_ERR;
	}

	ret = this->user_dining_dish.get_dish_id_time(RECVBUF_USERID,p_in->id,time_begin);
	if (ret!=SUCC) return ret;
	
	uint32_t cur_time = time(NULL);
	if ((cur_time - time_begin) < p_in->time)
	{
		return USER_DINING_DISH_TIME_EARLY_ERR;
	}

	if(cur_time - time_begin > p_in->timeout)
	{
		return USER_DINING_DISH_TIME_LATER_ERR;
	}
	
	uint32_t count = 0;
	ret= this->user_dining_dish.get_dish_id_count(RECVBUF_USERID,p_in->id,count);	
	if (ret!=SUCC) return ret;
	
	uint32_t num = 0;
	uint32_t id = 0;
	ret=this->user_dining_dish.get_dish_state_location_count(RECVBUF_USERID, p_in->dish_id,p_in->location, id, num);
	if (ret!=SUCC)
	{
		if (ret == DISH_NOFIND_ERR)
		{
			uint32_t state = 6;
			ret=this->user_dining_dish.put_dish_chest(RECVBUF_USERID, p_in, state);
			if ((ret != SUCC) && (ret != DISH_NOFIND_ERR) )
			{
				return USER_DINING_DISH_LOCATION_EXIST_ERR;

			}
			id = p_in->id;
			this->user_dining_dish.update_dish_id_inc(RECVBUF_USERID, id, p_in->count);
			out.dish_num = count + p_in->count;
		}
		else 
		{
			return ret;
		}
	}
	else
	{
		ret=this->user_dining_dish.update_dish_id_inc(RECVBUF_USERID, id, count + p_in->count);
		if (ret!=SUCC) return ret;
		ret=this->user_dining_dish.del_dish(RECVBUF_USERID, p_in->id);
		out.dish_num = count + num + p_in->count;
	}

	if (ret!=SUCC) return ret;

	ret=this->user_dining_dish_history.update_dish_history_inc(RECVBUF_USERID,p_in->dish_id, count + p_in->count);	
	if (ret!=SUCC)
	{
		ret = this->user_dining_dish_history.insert(RECVBUF_USERID, p_in->dish_id, 1);
	
	}
	uint32_t now_time = time(NULL);
	ret = this->user_diningroom.update_time(RECVBUF_USERID, now_time);
	ret = this->user_diningroom.update_exp_inc(RECVBUF_USERID, p_in->exp);
	if (ret == SUCC)
	{
		//log_change
		change_log_item c_item;
		c_item.userid=RECVBUF_USERID;
		c_item.change_type=10001;
		c_item.logtime=time(NULL);
		c_item.change_value=p_in->exp;
		c_item.change_v1= 103;
		c_item.change_v2=0;
		this->send_log.send(&c_item );
	}

	uint32_t history_count = 0;
	ret = this->user_dining_dish_history.get_dish_history_count(RECVBUF_USERID, history_count);
	out.count = history_count;
	out.id = id;
	STD_RETURN_WITH_STRUCT(ret,out);
}


int	Croute_func::user_diningroom_employer_time(userid_t userid, uint32_t& flag)
{
	uint32_t  count = 0; 
	user_dining_employer_item *p_employer_list=NULL;
	ret = this->user_dining_employer.get_user_employer(userid, &p_employer_list, &count);
	if (ret != SUCC)
	{
		if (p_employer_list != NULL)
		{
			free(p_employer_list);
		}
		p_employer_list = NULL;

		return ret;
	}

	for (uint32_t i = 0; i<count; i++)
	{
		if ((p_employer_list + i)->time <= (p_employer_list + i)->time_limit)
		{
			flag = 1;
		}
	}
	
	return SUCC;

}

int Croute_func::user_dining_get_dish_count(DEAL_FUN_ARG)
{
        user_dining_get_dish_count_in *p_in=PRI_IN_POS; 
        user_dining_get_dish_count_out out={};
	
	uint32_t count = 0;
        this->user_dining_dish.get_dish_count_by_dish_id(RECVBUF_USERID, p_in->dish_id, count);
	out.count = count;
        STD_RETURN_WITH_STRUCT(SUCC,out);
}

int Croute_func::user_dining_eat_dish(DEAL_FUN_ARG)
{
	user_dining_eat_dish_in *p_in=PRI_IN_POS; 
	user_dining_eat_dish_out out={}; 
	out.flag = 0;
	uint32_t flag = 0;

	ret = this->user_diningroom_employer_time(RECVBUF_USERID, flag);
	if (!flag)
	{
		return USER_DININGROOM_EMPLOYER_TIMEOUT_ERR;
	}

	uint32_t count = 0;
	ret=this->user_dining_dish.get_dish_id_state_count(RECVBUF_USERID, p_in->id, count);
	if (ret != SUCC)
	{
		return ret;
	}
	if (count <= 0)
	{
		return DINING_DISH_EAT_OUT_ERR;
	}
	else if (count == 1)
	{
		ret=this->user_dining_dish.del_dish_id_state(RECVBUF_USERID, p_in->id);
		out.flag = 1;
	}
	else
	{
		ret=this->user_dining_dish.update_dish_dec(RECVBUF_USERID, p_in);
	}

	if (ret != SUCC)
	{
		return ret;
	}	

	out.count = count -1;

	ret = this->user.update_xiaomee_inc(RECVBUF_USERID, p_in->xiaomee);
	if (ret != SUCC) return ret;

	uint32_t add_evaluate = 1;
	uint32_t cur_time = time(NULL);
	
	uint32_t evaluate = 0;
	ret	= this->user_diningroom.get_int_value(RECVBUF_USERID, "evaluate", &evaluate);
	if (ret!=SUCC) return ret;
	
	if (evaluate + add_evaluate > 1000)
	{
		add_evaluate = 1000 - evaluate;
	}

	ret = this->user_diningroom.update_evaluate_xiaomee_time_inc(RECVBUF_USERID,add_evaluate, p_in->xiaomee, cur_time);
	
	if (ret == SUCC)
	{
		//log_change
		change_log_item c_item;
		c_item.userid=RECVBUF_USERID;
		c_item.change_type=103;
		c_item.logtime=time(NULL);
		c_item.change_value=p_in->xiaomee;
		c_item.change_v1=0;
		c_item.change_v2=0;
		this->send_log.send(&c_item );
	}

	STD_RETURN_WITH_STRUCT(ret, out);

}

int Croute_func::user_dining_fall_dish(DEAL_FUN_ARG)
{
	user_dining_fall_dish_in *p_in=PRI_IN_POS; 

	int32_t temp = 0;
	ret=this->user.change_xiaomee(RECVBUF_USERID, -p_in->xiaomee,XIAOMEE_USE_DEL_BUY_ATTIRE ,
			0, &temp);
	if (ret != SUCC) return ret;

	ret=this->user_dining_dish.fall_dish(RECVBUF_USERID,p_in);
	if (ret != SUCC)
	{
		return ret;
	}

	uint32_t count = 0;
	this->user_dining_dish.get_dish_id_count(RECVBUF_USERID,p_in->id,count);
	//log_change
	change_log_item c_item;
	c_item.userid=RECVBUF_USERID;
	c_item.change_type=1031;
	c_item.logtime=time(NULL);
	c_item.change_value=p_in->dish_id;
	c_item.change_v1= count;
	c_item.change_v2= -p_in->xiaomee;

	this->send_log.send(&c_item );

	ret = this->user_diningroom.update_xiaomee_dec(RECVBUF_USERID, p_in->xiaomee);
	
	STD_RETURN(ret);
}

int Croute_func::user_dining_cook_change_state(DEAL_FUN_ARG)
{
	user_dining_cook_change_state_in *p_in=PRI_IN_POS; 
	user_dining_cook_change_state_out out={};
	uint32_t state = 0;
	uint32_t location = 0;
	ret=this->user_dining_dish.get_dish_id_state_location(RECVBUF_USERID, p_in->id, state,location);
	if (ret != SUCC)
	{
		return ret;
	}
	if (state >= 3)
	{
		return DINING_DISH_COOKING_ERR;
	}
	uint32_t cur_time = time(NULL);
	if (state == 2)
	{
		this->user_dining_dish.set_dish_id_time(RECVBUF_USERID, p_in->id, cur_time);
	}
	state = state + 1;
	ret=this->user_dining_dish.set_dish_id_state(RECVBUF_USERID, p_in->id, state);
	out.id = p_in->id;
	out.state = state;
	out.location = location;
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_dining_user_work_for_other(DEAL_FUN_ARG)
{
	user_dining_user_work_for_other_in *p_in=PRI_IN_POS; 
	uint32_t num = 0; 
   	ret = this->user_dining_employer.get_user_employer_count(p_in->userid, num);
	if (ret != SUCC)
	{
		return ret;
	}
	if (num >= 20)
	{
		return	DINING_EMPLOYER_MAX_VALUE_ERR;
	}
	ret=this->user_dining_employer.add_employer_work_for_other(RECVBUF_USERID, p_in);
	STD_RETURN(ret);
}

int Croute_func::user_dining_get_sys_employer_list(DEAL_FUN_ARG)
{
	user_dining_get_sys_employer_list_out_header  out_header={	};
	user_dining_get_sys_employer_list_out_item *p_out_item = NULL;
	user_dining_get_sys_employer_list_out_item *p_item = NULL;
	uint32_t count = 0;
	ret=this->user_dining_employer.get_sys_employer_list(RECVBUF_USERID, &p_out_item, &p_item, &(out_header.count), &count);
	if (p_item != NULL)
	{
		free(p_item);
		p_item = NULL;
	}
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::user_dining_get_user_board_info(DEAL_FUN_ARG)
{
	uint32_t count = 0;
	user_dining_get_user_board_info_in *p_in=PRI_IN_POS; 
	user_dining_get_user_board_info_out out={};

	ret=this->user_dining_dish_history.select_count_at_star_5(RECVBUF_USERID, count);
	if(ret == SUCC) {
		out.level_5_count = count;
	} else {
		out.level_5_count = 0;
	}

	count = 0;
	ret = this->user_diningroom.event_num_get(RECVBUF_USERID,count);
	if(ret == SUCC) {
		out.event_count = count;
	} else {
		out.event_count = 0;
	}

	ret=this->user_diningroom.get_board_info(RECVBUF_USERID, p_in->type_id, out);
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_dining_dec_evaluate(DEAL_FUN_ARG)
{
	user_dining_dec_evaluate_in *p_in=PRI_IN_POS; 
	user_dining_dec_evaluate_out out={};
	uint32_t evaluate = 0;
	uint32_t level = 1;
	ret=this->user_diningroom.get_level_evaluate(RECVBUF_USERID, level, evaluate);
	if (ret!=SUCC) return ret;
	if (evaluate <= (p_in->evaluate + 50))
	{
		evaluate = 50;
	}
	else
	{
		evaluate = evaluate - p_in->evaluate;
	}
	ret=this->user_diningroom.set_evaluate(RECVBUF_USERID, evaluate);

	out.evaluate = evaluate;
	
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_dining_set_level(DEAL_FUN_ARG)
{
	user_dining_set_level_in *p_in=PRI_IN_POS; 
	ret=this->user_diningroom.set_int_value(RECVBUF_USERID, "level", p_in->level);
	STD_RETURN(ret);
}

int Croute_func::user_dining_user_room_count(DEAL_FUN_ARG)
{
	user_dining_user_room_count_in *p_in=PRI_IN_POS; 
	user_dining_user_room_count_out out={};
	uint32_t count = 0;
	ret=this->user_ex.check_black(RECVBUF_USERID,p_in->friendid,&count);
	if(ret == SUCC && count) {
		out.black = 1;
	}
	count = 0;
	ret=this->user_diningroom.get_user_diningroom_count(RECVBUF_USERID, p_in->type_id, count);
	out.count = count;
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_pet_set_employ_user(DEAL_FUN_ARG)
{
	user_pet_set_employ_user_in *p_in=PRI_IN_POS; 
	ret=this->user_pet.set_pet_em_userid(RECVBUF_USERID, p_in->petid, p_in->em_userid);
	STD_RETURN(ret);
}

int Croute_func::user_pet_employ_info_list(DEAL_FUN_ARG)
{
	user_pet_employ_info_list_out_header  out_header;
	user_pet_employ_info_list_out_item *p_out_item = NULL;
	ret=this->user_pet.get_user_pet_employ_info_list(RECVBUF_USERID, &p_out_item, &out_header.count);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::user_dining_set_honor_flag(DEAL_FUN_ARG)
{
	user_dining_set_honor_flag_in *p_in=PRI_IN_POS; 
	if (p_in->index >= 64)
	{
		return VALUE_OUT_OF_RANGE_ERR;
	}
	ret=this->user_diningroom.set_honor_flag(RECVBUF_USERID, p_in->index);
	if (ret == SUCC)
	{
		ret = this->user_diningroom.update_exp_inc(RECVBUF_USERID, p_in->exp);
		if (ret != SUCC) return ret;
		ret = this->user.update_xiaomee_inc(RECVBUF_USERID, p_in->xiaomee);
		ret = this->user_diningroom.update_xiaomee_inc(RECVBUF_USERID, p_in->xiaomee);
	}
	
	if (ret == SUCC)
	{
		//log_change
		change_log_item c_item;
		c_item.userid=RECVBUF_USERID;
		c_item.change_type=103;
		c_item.logtime=time(NULL);
		c_item.change_value=p_in->xiaomee;
		c_item.change_v1=p_in->exp;
		c_item.change_v2=p_in->index;
		this->send_log.send(&c_item );
	}

	STD_RETURN(ret);
}
int Croute_func::roominfo_user_set_prove(DEAL_FUN_ARG)
{
	roominfo_user_set_prove_in *p_in=PRI_IN_POS;
   	if (p_in->prove > 0)
	{
		ret=this->roominfo_sbh.update_prove_inc(RECVBUF_USERID,p_in->prove);
		if (ret != SUCC)
		{
			ret = this->roominfo_sbh.insert(RECVBUF_USERID);
			if (ret!=SUCC)
			{
				return ret;
			}	
		}
	}
	else
	{
		uint32_t in_prove = -p_in->prove;
		uint32_t prove = 0;
		uint32_t prove_all = 0;
		ret = this->roominfo_sbh.get_prove_all(RECVBUF_USERID, prove_all, prove);
		if (ret != SUCC)
		{
			ret = this->roominfo_sbh.insert(RECVBUF_USERID);
			if (ret!=SUCC)
			{
				return ret;
			}	
		}
	
		if (prove < in_prove)
		{
			return ROOMINFO_USER_PROVE_NOT_ENOUGH_ERR;
		}
		else
		{
			ret=this->roominfo_sbh.update_prove_dec(RECVBUF_USERID, in_prove);
		}	
	}

	STD_RETURN(ret);
}

int Croute_func::roominfo_user_set_item(DEAL_FUN_ARG)
{
	roominfo_user_set_item_in *p_in=PRI_IN_POS; 
	roominfo_user_set_item_out out={ }; 
	uint32_t value1 = 0;
	uint32_t value2 = 0;
	uint32_t index1 = 2*p_in->type;
	uint32_t index2 = 2*p_in->type + 1;
	if (p_in->type > 4)
	{
		return  VALUE_OUT_OF_RANGE_ERR; 
	}
	ret=this->roominfo_sbh.get_items_value(RECVBUF_USERID, index1, index2, value1, value2);
	if (ret!=SUCC)
	{
		ret = this->roominfo_sbh.insert(RECVBUF_USERID);
		if (ret!=SUCC)
		{
			return ret;
		}
		
	}
	if (value1 < 2)
	{
		ret = this->roominfo_sbh.update_item_value_inc(RECVBUF_USERID, index1, 1);
		out.index = index1;
	}
	else if ((value1 >= 2) && (value2 < 2))
	{
		ret = this->roominfo_sbh.update_item_value_inc(RECVBUF_USERID, index2, 1);
		out.index = index2;
	}
	else if ((value1 >= 2) && (value2 >= 2))
	{
		return ROOMINFO_USER_ITEM_SET_AREADY_ERR;
	}

	STD_RETURN_WITH_STRUCT(ret,out);

}

int Croute_func::roominfo_user_get_prove(DEAL_FUN_ARG)
{
	roominfo_user_get_prove_out out={};
	ret=this->roominfo_sbh.get_prove(RECVBUF_USERID, &out);
	if (ret == RECORD_NOT_EXIST_ERR)
	{
		ret = SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_farm_animal_get_type_mature(DEAL_FUN_ARG)
{
	user_farm_animal_get_type_mature_in *p_in=PRI_IN_POS; 
	user_farm_animal_get_type_mature_out out={};
	animal_select animal;
	uint32_t animal_type = 0;
	ret = this->user_farm_animal.get_one_animal_info(RECVBUF_USERID, p_in->id, &animal, &animal_type);
	if (ret != SUCC) {
		return ret;
	}
	out.animal_id = animal.animal_id;
	out.mature = animal.mature_time;
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::userinfo_get_question2_set_flag(DEAL_FUN_ARG)
{
	userinfo_get_question2_set_flag_out out={};
	ret=this->user_info.get_question2_set_flag(RECVBUF_USERID,&(out.is_seted ));
	STD_RETURN_WITH_STRUCT(ret,out);
}


int Croute_func::roominfo_sports_meet_set(DEAL_FUN_ARG)
{
	roominfo_sports_meet_set_in *p_in = PRI_IN_POS; 
	ret = this->roominfo_sports_meet.teamid_set(RECVBUF_USERID, p_in->teamid);
	STD_RETURN(ret);
}

int  Croute_func::roominfo_sports_meet_teamid_get(DEAL_FUN_ARG)
{
	roominfo_sports_meet_teamid_get_out out = {};
	ret = this->roominfo_sports_meet.teamid_get(RECVBUF_USERID, &out.teamid, &out.medal);
	if ( ret == ROOMINFO_SPORTS_MEET_GET_ERR) {//user-team is not existed, return 0
		ret = SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::sysarg_db_sports_teaminfo_set(DEAL_FUN_ARG)
{
	sysarg_db_sports_teaminfo_set_in *p_in = PRI_IN_POS; 
	sysarg_db_sports_teaminfo_set_out out = {};
	out.score_flag = 0;

	const uint32_t SCORE_LIMIT = 1000000;
	uint32_t teamid = p_in->teamid;
	uint32_t score_tmpmax;

	ret = this->sysarg_db_sports_tmpuser.score_select(RECVBUF_USERID, &score_tmpmax);
	if (ret == SYSARG_DB_SPORTS_USER_NOFIND_ERR) {//select 没找找到userid
		ret = this->sysarg_db_sports_tmpuser.score_insert(RECVBUF_USERID, p_in->score);	
	} else if (score_tmpmax >= 5000) {
		ret = sysarg_db_sports_teaminfo.teaminfo_set(p_in, &out);
		out.score_flag = 1;//加分不成功，置1
		STD_RETURN_WITH_STRUCT(ret,out);
	} else {//一个用户最多一轮贡献1.5w分
		ret = this->sysarg_db_sports_tmpuser.score_update(RECVBUF_USERID, (score_tmpmax + p_in->score));
	} 

	sem.lock();
	ret = this->sysarg_db_sports_teaminfo.teaminfo_set(p_in, &out);
	out.score[teamid - 1] += p_in->score;
	
	if (out.score[teamid - 1] < SCORE_LIMIT) {//100w为一轮
		out.win_flag = 0;
		ret = this->sysarg_db_sports_teaminfo.update1(RECVBUF_USERID, teamid, &out);
	} else if (out.score[teamid - 1] >= SCORE_LIMIT) {
		ret = this->sysarg_db_sports_teaminfo.update2(RECVBUF_USERID, teamid, &out);
		out.score[0] = 0;
		out.score[1] = 0;
		out.score[2] = 0;
		out.win_flag = teamid;
		ret = this->sysarg_db_sports_tmpuser.tmpuser_del();
	}
	sem.unlock();
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::roominfo_set_client_buf(DEAL_FUN_ARG)
{
	roominfo_set_client_buf_in *p_in=PRI_IN_POS; 
	ret=this->roominfo_client_buf.update_client_buf(RECVBUF_USERID, p_in);
	if (ret != SUCC)
	{
		ret=this->roominfo_client_buf.insert_client_buf(RECVBUF_USERID, p_in);
	}
	STD_RETURN(ret);
}


int Croute_func::roominfo_get_client_buf(DEAL_FUN_ARG)
{
	roominfo_get_client_buf_in *p_in=PRI_IN_POS; 
	roominfo_get_client_buf_out out={};

	out.type_id = p_in->type_id;

	ret=this->roominfo_client_buf.get_client_buf(RECVBUF_USERID, p_in->type_id, &out);
	if (ret == USER_ID_NOFIND_ERR)
	{
		ret = SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_dining_inc_exp(DEAL_FUN_ARG)
{
	user_dining_inc_exp_in *p_in=PRI_IN_POS; 
	ret=this->user_diningroom.update_exp_inc(RECVBUF_USERID, p_in->exp);	
	if (ret == SUCC)
	{
		//log_change
		change_log_item c_item;
		c_item.userid=RECVBUF_USERID;
		c_item.change_type=10001;
		c_item.logtime=time(NULL);
		c_item.change_value=p_in->exp;
		c_item.change_v1= 103;
		c_item.change_v2=0;
		this->send_log.send(&c_item );
	}

	STD_RETURN(ret);
}

int Croute_func::user_dining_inc_xiaomee(DEAL_FUN_ARG)
{
	user_dining_inc_xiaomee_in *p_in=PRI_IN_POS; 
	ret=this->user.update_xiaomee_inc(RECVBUF_USERID, p_in->xiaomee);
	ret=this->user_diningroom.update_xiaomee_inc(RECVBUF_USERID, p_in->xiaomee);
	if (ret == SUCC)
	{
		//log_change
		change_log_item c_item;
		c_item.userid=RECVBUF_USERID;
		c_item.change_type=103;
		c_item.logtime=time(NULL);
		c_item.change_value=p_in->xiaomee;
		c_item.change_v1=0;
		c_item.change_v2=0;
		this->send_log.send(&c_item );
	}

	STD_RETURN(ret);
}


int Croute_func::userid_get_userid(DEAL_FUN_ARG)
{
	userid_get_userid_out out={};
	ret=this->reg_userid.get(&(out.userid));
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::userid_set_noused(DEAL_FUN_ARG)
{
	ret=this->reg_userid.set_noused(RECVBUF_USERID);
	STD_RETURN(ret);
}

int Croute_func::sysarg_db_sports_teaminfo_score_get(DEAL_FUN_ARG)
{
	sysarg_db_sports_teaminfo_score_get_out out={};
	ret = this->sysarg_db_sports_teaminfo.score_get(&out);
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::sysarg_db_sports_teaminfo_medal_get(DEAL_FUN_ARG)
{
	sysarg_db_sports_teaminfo_medal_get_out out={};
	ret = this->sysarg_db_sports_teaminfo.medal_get(&out);
	STD_RETURN_WITH_STRUCT(ret,out);
}
/*@brief : 用户获得物品权限检查
 */ 
int Croute_func::sysarg_db_sports_tmpuser_user_set(DEAL_FUN_ARG)
{
	sysarg_db_sports_tmpuser_user_set_in *p_in = PRI_IN_POS; 
	uint32_t ret;
	uint32_t win_teamid;
	uint32_t flag = 10;
	if((ret = this->sysarg_db_sports_teaminfo.win_flag_get(&win_teamid)) != SUCC){
		return ret;
	}
	if(win_teamid != p_in->teamid){
		return SYSARG_DB_SPORTS_NO_WIN_ERR;
	}
	ret = this->sysarg_db_sports_tmpuser.userid_select(RECVBUF_USERID, &flag);
	


	if(ret == SYSARG_DB_SPORTS_USER_NOFIND_ERR){//没找到userid,
		ret = this->sysarg_db_sports_tmpuser.userid_insert(RECVBUF_USERID, 1);
		STD_RETURN(ret);
	} else if (flag == 1){//用户获得物品
		STD_RETURN(SYSARG_DB_SPORTS_USER_OWN_ERR);	
	} else if (flag == 0){
		ret = this->sysarg_db_sports_tmpuser.userid_update(RECVBUF_USERID, 1);	
		STD_RETURN(ret);
	} else {
		STD_RETURN(ret);
	}
}

int Croute_func::user_dining_dec_dish(DEAL_FUN_ARG)
{
	user_dining_dec_dish_in *p_in=PRI_IN_POS;

	ret = this->user_dec_dish(RECVBUF_USERID,p_in);
	STD_RETURN(ret);
}

int Croute_func::user_dec_dish(userid_t userid,user_dining_dec_dish_in *p_in)
{
	uint32_t count = 0;
	ret=this->user_dining_dish.get_dish_count_by_dish_id(userid, p_in->dish_id, count);
	if (ret != SUCC)
	{
		return ret;
	}
	if (count < p_in->num)
	{
		return DINING_DISH_EAT_NOT_ENOUGH_ERR;
	}
	else if (count == p_in->num)
	{
		ret=this->user_dining_dish.del_dish_id_state_by_dish_id(userid, p_in->dish_id);
	}
	else
	{
		ret=this->user_dining_dish.update_dish_num_dec_by_dish_id(userid, p_in->dish_id, p_in->num);
	}

	if(ret == SUCC) {
		//log_change
		change_log_item c_item;
		c_item.userid=userid;
		c_item.change_type=103;
		c_item.logtime=time(NULL);
		c_item.change_value=p_in->num;
		c_item.change_v1=p_in->dish_id;
        c_item.change_v2=0;
		this->send_log.send(&c_item );
	}

	return ret;
}

int Croute_func::user_dining_cook_dish_list(DEAL_FUN_ARG)
{
	user_dining_cook_dish_list_out_header  out_header;
	user_dining_cook_dish_list_out_item *p_out_item;
	ret=this->user_dining_dish.get_user_dish(RECVBUF_USERID,  &p_out_item, &(out_header.count) );
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::sysarg_db_sports_gamescore_set(DEAL_FUN_ARG)
{
	sysarg_db_sports_gamescore_set_in *p_in = PRI_IN_POS; 
		
	ret = this->sysarg_db_sports_gamescore.score_update(RECVBUF_USERID, p_in->gameid, p_in->score);
	if (ret == SYSARG_DB_SPORTS_GAMESCORE_NO_FIND_ERR) {
		ret = this->sysarg_db_sports_gamescore.score_insert(RECVBUF_USERID, p_in->gameid, p_in->score,
				p_in->user_nick);
	}
	ret = this->sysarg_db_sports_petscore.score_update(RECVBUF_USERID, p_in->petid, p_in->gameid,
			p_in->score);
	if (ret == ROOMINFO_SPORTS_PETSCORE_NO_FIND_ERR) {
		ret = this->sysarg_db_sports_petscore.score_insert(RECVBUF_USERID, p_in->petid,
				p_in->gameid, p_in->score, p_in->pet_nick);
	}
	if (ret == DB_SUCC) {
		ret = this->sysarg_db_sports_teaminfo.medal_update(p_in->teamid, p_in->medal);
	}
	STD_RETURN(ret);
}


int Croute_func::sysarg_db_sports_gamescore_get(DEAL_FUN_ARG)
{
	sysarg_db_sports_gamescore_get_in *p_in = PRI_IN_POS;
   	char out[PROTO_MAX_LEN] = { };
	sysarg_db_sports_gamescore_get_out_header*  p_out = (sysarg_db_sports_gamescore_get_out_header*)out;
	sysarg_db_sports_gamescore_get_out_item *p_all_score = NULL;
	sysarg_db_sports_petscore_get_out_item *p_pet_score = NULL;

  	uint32_t count = 0;	
	ret = this->sysarg_db_sports_gamescore.max_score_select(p_in->gameid, &count, &p_all_score);
	if (ret != SUCC) 
	{
		if (p_all_score != NULL)
		{
			free(p_all_score);
			p_all_score = NULL;
		}
		return ret;
	}
	p_out->count = count;

	count = 0;
	ret = this->sysarg_db_sports_petscore.score_get(RECVBUF_USERID, p_in->gameid, &p_pet_score, &count);
	if (ret != SUCC) 
	{
		if (p_pet_score != NULL)
		{
			free(p_pet_score);
			p_pet_score = NULL;
		}
		return ret;
	}
	
	p_out->pet_count = count;

	char *p_offset = out + sizeof(sysarg_db_sports_gamescore_get_out_header);

	memcpy(p_offset, p_all_score, sizeof(sysarg_db_sports_gamescore_get_out_item ) * p_out->count);
	p_offset += sizeof(sysarg_db_sports_gamescore_get_out_item ) * p_out->count;
	free(p_all_score);

	memcpy(p_offset, p_pet_score, sizeof(sysarg_db_sports_petscore_get_out_item) * p_out->pet_count);
	p_offset += sizeof(sysarg_db_sports_petscore_get_out_item) * p_out->pet_count;
	free(p_pet_score);

	STD_RETURN_WITH_BUF(ret, out, p_offset - out);

}

int Croute_func::roominfo_sports_meet_medal_set(DEAL_FUN_ARG)
{
	roominfo_sports_meet_medal_set_in *p_in = PRI_IN_POS; 
	
	const uint32_t MEDAL_LIMIT = 200;// 每天获得的奖牌数限制
	const uint32_t TIME_LIMIT =5;    //跟新操作时间间隔

	uint32_t db_medal_limit = 0;
	uint32_t db_time_limit = 0;
	uint32_t now_time = time(NULL); 
	ret = this->roominfo_sports_meet.top_medal_get(RECVBUF_USERID, &db_medal_limit, &db_time_limit);
	if (ret == DB_SUCC && db_medal_limit <= MEDAL_LIMIT && (now_time - db_time_limit) > TIME_LIMIT ) {
		ret = this->roominfo_sports_meet.medal_update(RECVBUF_USERID, p_in->medal);
	} else if (db_medal_limit > MEDAL_LIMIT) {
		ret = ROOMINFO_SPORTS_MEET_MEDAL_FULL_UP_ERR;
	} else if (now_time - db_time_limit <= TIME_LIMIT) {
		ret = ROOMINFO_SPORTS_MEET_TIME_LIMIT_ERR;
	}

	STD_RETURN(ret);
}

int Croute_func::roominfo_sports_pet_reward_set(DEAL_FUN_ARG)
{
	roominfo_sports_pet_reward_set_in *p_in = PRI_IN_POS; 
	ret = this->roominfo_sports_pet_info.reward_flag_insert(RECVBUF_USERID, p_in->petid);
	if (ret == DB_ERR) {
		ret = this->roominfo_sports_pet_info.reward_flag_update(RECVBUF_USERID, p_in->petid);
	}
	STD_RETURN(ret);
}

int Croute_func::roominfo_sports_user_reward_set(DEAL_FUN_ARG)
{
	ret = this->roominfo_sports_meet.reward_flag_update(RECVBUF_USERID);
	STD_RETURN(ret);
}

int Croute_func::roominfo_sports_reward_get(DEAL_FUN_ARG)
{
	roominfo_sports_reward_get_in *p_in = PRI_IN_POS; 
	roominfo_sports_reward_get_out out={};
	ret = this->roominfo_sports_meet.reward_flag_select(RECVBUF_USERID, &out);
	if (ret == DB_SUCC) {
		ret = this->roominfo_sports_pet_info.reward_flag_select(RECVBUF_USERID, 
				p_in->petid, &out.pet_reward_flag);
		if (ret == ROOMINFO_SPORTS_PET_INFO_GET_ERR) {
			out.pet_reward_flag = 0;
			ret = SUCC;
		}
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::userinfo_get_mee_fans(DEAL_FUN_ARG)
{
	userinfo_get_mee_fans_out out={};
	ret=this->user_info.get_int_value(RECVBUF_USERID,
			MEE_FANS_STR,&(out.mee_fans));
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::userinfo_set_mee_fans(DEAL_FUN_ARG)
{
	userinfo_set_mee_fans_in *p_in=PRI_IN_POS; 
	ret=this->user_info.set_int_value(RECVBUF_USERID,
			MEE_FANS_STR,p_in->mee_fans );
	STD_RETURN(ret);
}

int Croute_func::sysarg_db_sports_team_reward_get(DEAL_FUN_ARG)
{
	sysarg_db_sports_team_reward_get_in *p_in = PRI_IN_POS; 
	sysarg_db_sports_team_reward_get_out out = {};
	sysarg_db_sports_teaminfo_medal_get_out out_medal = {};
	
	ret = this->sysarg_db_sports_teaminfo.medal_get(&out_medal);
	if (ret != DB_SUCC) {
		return ret;
	}
	out.team_ranking = 3;
	out.game_reward_num = 0;
/*
	for (uint32_t i = 0; i < 3; i++) {
		if (p_in->user_teamid != (i + 1) && out_medal.medal[p_in->user_teamid - 1] >= out_medal.medal[i]) {
				--out.team_ranking;
		}
	}
*/
	uint32_t other_team_1 = (p_in->user_teamid -1 + 1) % 3;
	uint32_t other_team_2 = (p_in->user_teamid -1 + 2) % 3;

	if (out_medal.medal[p_in->user_teamid - 1] >= out_medal.medal[other_team_1]) {
		--out.team_ranking;
	}
	if (out_medal.medal[p_in->user_teamid - 1] >= out_medal.medal[other_team_2]) {
		--out.team_ranking;
	}
	
	ret = this->sysarg_db_sports_gamescore.top9_score_select(RECVBUF_USERID, &out.game_reward_num);
	if (ret == SYSARG_DB_SPORTS_GAMESCORE_NO_FIND_ERR) {
		out.game_reward_num = 0;
		ret = DB_SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_pet_pet_flag_set(DEAL_FUN_ARG)
{
	user_pet_pet_flag_set_in *p_in = PRI_IN_POS; 
	ret = this->user_pet.pet_flag_update(RECVBUF_USERID, p_in->petid, p_in->pet_flag);
	STD_RETURN(ret);
}

int Croute_func::user_diningroom_event_num_set(DEAL_FUN_ARG)
{
        user_diningroom_event_num_set_out out={};
	ret = this->user_diningroom.event_num_set(RECVBUF_USERID);
	if(ret == SUCC)
	{
		uint32_t count = 0;
		ret = this->user_diningroom.event_num_get(RECVBUF_USERID,count);
		out.num = count;
	}
        STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_sports_inc_xiaomee(DEAL_FUN_ARG)
{
	user_sports_inc_xiaomee_in *p_in = PRI_IN_POS; 
	ret=this->user.update_xiaomee_inc(RECVBUF_USERID, p_in->xiaomee);
	if (ret == SUCC)
	{
		//log_change
		change_log_item c_item;
		c_item.userid = RECVBUF_USERID;
		c_item.change_type=104;
		c_item.logtime = time(NULL);
		c_item.change_value = p_in->xiaomee;
		c_item.change_v1 = 0;
		c_item.change_v2 = 0;
		this->send_log.send(&c_item );
	}


	STD_RETURN(ret);
}

int Croute_func::user_dining_stars_get(DEAL_FUN_ARG)
{
	user_dining_stars_get_in *p_in = PRI_IN_POS; 
	user_dining_stars_get_out out = {};
	ret = this->user_dining_dish_history.dish_stars_get(RECVBUF_USERID, p_in->dish_id,
			&out.dish_count, &out.dish_stars);
	if (ret == DISH_NOFIND_ERR) {
		out.dish_count = 0;
		out.dish_stars = 0;
		ret = DB_SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::select_dish_stars(DEAL_FUN_ARG)
{
        select_dish_stars_out_header  out_header;
        select_dish_stars_out_item *p_out_item = NULL;
        ret=this->user_dining_dish_history.select_dish_star(RECVBUF_USERID, &p_out_item, &(out_header.count));
        STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::user_dining_dish_history_stars_set(DEAL_FUN_ARG)
{
	user_dining_dish_history_stars_set_in *p_in = PRI_IN_POS; 
	ret = this->user_dining_dish_history.dish_stars_set(RECVBUF_USERID, p_in->dish_id, p_in->dish_stars);
	STD_RETURN(ret);
}

int Croute_func::roominfo_reward_num_set(DEAL_FUN_ARG)
{
	/*  
	roominfo_reward_num_set_in *p_in = PRI_IN_POS; 
	uint32_t reward_num;

	if (p_in->reward_num >= 0) {
		ret = this->roominfo.reward_num_update(RECVBUF_USERID, p_in->reward_num);
	} else if (p_in->reward_num < 0) {
		ret = this->roominfo.reward_num_select(RECVBUF_USERID, &reward_num);
		if (ret == DB_SUCC && (int)reward_num + p_in->reward_num < 0) {
			ret = REWARD_FAIL_ERR;
		} else if (ret == DB_SUCC) {
			ret = this->roominfo.reward_num_update(RECVBUF_USERID, p_in->reward_num);
		}
	}
	STD_RETURN(ret);

	*/
	return 0;
}

int Croute_func::roominfo_reward_num_get(DEAL_FUN_ARG)
{
	/*
	roominfo_reward_num_get_out out = {};
	ret = this->roominfo.reward_num_select(RECVBUF_USERID, &out.reward_num);
	STD_RETURN_WITH_STRUCT(ret,out);
	*/
	return 0;
}

int Croute_func::sysarg_set_type_buf(DEAL_FUN_ARG)
{
	sysarg_set_type_buf_in *p_in=PRI_IN_POS; 
	ret=this->sysarg_type_buf.update_type_buf(p_in);
	if (ret != SUCC)
	{
		ret=this->sysarg_type_buf.insert_type_buf(p_in);
	}

	STD_RETURN(ret);
}

int Croute_func::sysarg_get_type_buf(DEAL_FUN_ARG)
{
	sysarg_get_type_buf_in *p_in=PRI_IN_POS; 
	sysarg_get_type_buf_out out={};
	ret=this->sysarg_type_buf.get_type_buf(p_in->type, &out);
	ret = SUCC;
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_dining_dec_exp(DEAL_FUN_ARG)
{
	user_dining_dec_exp_in *p_in=PRI_IN_POS;
   	uint32_t exp_db = 0;
	ret = this->user_diningroom.get_exp(RECVBUF_USERID, exp_db);
	if (exp_db < p_in->dec_exp)
	{
		return USER_DINING_EXP_NOT_ENOUGH_ERR;
	}
	ret=this->user_diningroom.update_exp_dec(RECVBUF_USERID, p_in->dec_exp);	
	if (ret == SUCC)
	{
		//log_change
		change_log_item c_item;
		c_item.userid=RECVBUF_USERID;
		c_item.change_type=10001;
		c_item.logtime=time(NULL);
		c_item.change_value=-p_in->dec_exp;
		c_item.change_v1= 103;
		c_item.change_v2=0;
		this->send_log.send(&c_item );
	}
	
	STD_RETURN(ret);
}

int Croute_func::user_noah_inc_user_info(DEAL_FUN_ARG)
{
	user_noah_inc_user_info_in *p_in=PRI_IN_POS; 
	user_noah_inc_user_info_out out={};
	user_get_noah_info_out out_noah={};
	ret=this->user.get_noah_info(RECVBUF_USERID, out_noah);
	if (ret != SUCC) return ret;
	ret = this->user.update_noah_info_inc(RECVBUF_USERID, p_in);
	if (ret != SUCC) return ret;

	out.exp = p_in->inc_exp + out_noah.exp;
	out.strong = p_in->inc_strong + out_noah.strong;
	out.iq = p_in->inc_iq + out_noah.iq;
	out.charm = p_in->inc_charm + out_noah.charm;
	out.xiaomee = p_in->inc_xiaomee + out_noah.xiaomee;

	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_new_card_get_card_info(DEAL_FUN_ARG)
{
	user_new_card_get_card_info_out out={};

	bool sl_flag = false;
	ret = this->user_ex.get_vip(RECVBUF_USERID, &sl_flag);
	out.sl_flag = sl_flag;
	uint32_t logdate = 0;
	uint32_t mole_exp = 0;
	ret=this->user.get_user_exp(RECVBUF_USERID, mole_exp);
	out.mole_exp = mole_exp;
	ret=this->user_new_card.get_new_card_info(RECVBUF_USERID, &out, logdate);
	uint32_t date = get_date(time(NULL));
	if (date != logdate)
	{
		out.day_exp = 0;
		out.day_monster = 0;
	}

	if (ret != SUCC)
	{
		ret = SUCC;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_new_card_init_card(DEAL_FUN_ARG)
{
	user_new_card_init_card_in *p_in=PRI_IN_POS; 
	ret=this->user_new_card.init_new_card(RECVBUF_USERID, p_in);
	STD_RETURN(ret);
}

int Croute_func::user_new_card_add_card(DEAL_FUN_ARG)
{
	user_new_card_add_card_in *p_in=PRI_IN_POS; 
	ret=this->user_new_card.add_new_card(RECVBUF_USERID, p_in->cardid);
	STD_RETURN(ret);
}

int Croute_func::user_new_card_add_exp(DEAL_FUN_ARG)
{
	user_new_card_add_exp_in *p_in=PRI_IN_POS; 
	uint32_t dayexp = 0;
	uint32_t logdate = 0;

	uint32_t exp = 0;
	uint32_t flag = 0;

	ret=this->user_new_card.get_exp(RECVBUF_USERID, exp, flag);
	if (exp > 1000000)
	{
		ret=this->user_new_card.set_exp(RECVBUF_USERID, 5050);
	}


	ret = this->user_new_card.update_today_date(RECVBUF_USERID);
	ret=this->user_new_card.get_dayexp_date(RECVBUF_USERID, dayexp, logdate);
	if (dayexp >= 1000)
	{
		return USER_NEW_CARD_EXP_LIMITED_ERR;
	}
	
	if (p_in->exp >= 100)
	{
		return USER_NEW_CARD_EXP_LIMITED_ERR;
	}
	
	ret=this->user_new_card.update_exp_inc(RECVBUF_USERID, p_in->exp);

	if (p_in->cardid != 0)
	{
		if ((p_in->cardid < 0) || (p_in->cardid > 59 ))
		{
			return VALUE_OUT_OF_RANGE_ERR;
		}

		ret=this->user_new_card.add_new_card(RECVBUF_USERID, p_in->cardid);
	}

	int temp = 0;	
	ret=this->user.change_xiaomee(RECVBUF_USERID, p_in->xiaomee, XIAOMEE_USE_ADD_BY_GAME,
			0, &temp);
	if (ret != SUCC) return ret;

	STD_RETURN(ret);
}

int Croute_func::user_new_card_get_exp(DEAL_FUN_ARG)
{
    user_new_card_get_exp_out out={};

	uint32_t flag = 0;
	uint32_t exp = 0;
    ret=this->user_new_card.get_exp(RECVBUF_USERID,exp,flag);
	out.exp = exp;
	out.flag = flag;
	ret = SUCC;
    STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::userinfo_set_user_enable_flag(DEAL_FUN_ARG)
{
	userinfo_set_user_enable_flag_in *p_in=PRI_IN_POS; 
	bool flag;	
	flag= p_in->enable_flag==0?true:false;

	ret=this->user_info.set_flag(RECVBUF_USERID,FLAG1_STR,
		  	USER_FLAG1_DISABLE_ACCOUNT,flag );
	STD_RETURN(ret);
}

int Croute_func::userinfo_get_user_enable_flag(DEAL_FUN_ARG)
{
	userinfo_get_user_enable_flag_out out={};
	uint32_t flag;
	ret=this->user_info.get_bit_flag(RECVBUF_USERID,FLAG1_STR,
			USER_FLAG1_DISABLE_ACCOUNT, &flag );
	if (ret!=SUCC)  return ret;
	out.enable_flag= flag==0?1:0;
	
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::hatch_dragon_egg(DEAL_FUN_ARG)
{
	uint32_t dragonid;
    hatch_dragon_egg_in *p_in=PRI_IN_POS;
    hatch_dragon_egg_out out={ };

	dragonid = this->user_dragon.get_dragon_id_by_egg(p_in->egg_id);
	if(dragonid == 0) return EGG_ID_ERR;

	uint32_t isvip = 0;
	uint32_t upgrade = 0;
	uint32_t mole_exp = 0;
	this->user_ex.get_vip(RECVBUF_USERID,(bool*)&isvip);
	this->user_ex.get_flag(RECVBUF_USERID,"event_flag",&upgrade);
	upgrade &= (1 << 14);
	ret = this->user.get_field_uint32(RECVBUF_USERID,"exp",mole_exp);
	if(ret != SUCC) return ret;

	uint32_t count = 0;
	uint32_t perm_count = this->user_dragon.get_perm_count(mole_exp,upgrade,isvip);
	//ret = this->user_dragon.get_dragon_count(RECVBUF_USERID,count);
	ret = this->user_dragon.get_dragon_count_by_isvip(RECVBUF_USERID, isvip, count);
	if(ret != SUCC) {
		count = 0;
	}

	if(perm_count < count + 1) {
		return DRAGON_COUNT_LIMIT_ERR;
	}

	uint32_t growth,state;
	ret=this->user_dragon.get_dragon_info(RECVBUF_USERID,dragonid,growth,state);
	if(ret == SUCC){
		DEBUG_LOG("eggid: %u, dragon_id: %u", p_in->egg_id, dragonid);
		return DRAGON_EXSIT_ERR;
	}

	uint32_t egg_cnt = 0;
	ret = this->user_attire.get_count(RECVBUF_USERID, p_in->egg_id, egg_cnt);
    if(ret!=SUCC) return ret;
	if(egg_cnt == 0) return NOT_HAVE_ITEM_ERR;

   	ret=this->user_dragon_egg.add(RECVBUF_USERID,p_in->egg_id);
	if(ret == SUCC) {
		out.egg_id = p_in->egg_id;
		out.time_left = this->user_dragon_egg.get_egg_time_limit(p_in->egg_id);
		//ret = this->user_attire.update_count(RECVBUF_USERID, p_in->egg_id, -1);
		user_del_attire_in del_item;
		del_item.attireid=p_in->egg_id;
		del_item.attiretype=0;
		del_item.count=1;
		del_item.maxcount=99999;
		ret = this->user_del_attire(RECVBUF_USERID, &del_item);

	} else {
		ret = DRAGON_EGG_EXSIT_ERR;
	}

    STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::get_egg_hatch_time(DEAL_FUN_ARG)
{
    get_egg_hatch_time_out out={};
        
	uint32_t eggid;
	uint32_t start;

    ret=this->user_dragon_egg.get_egg_hatch(RECVBUF_USERID,eggid,start);
	if(ret == SUCC)
	{
		uint32_t limit = this->user_dragon_egg.get_egg_time_limit(eggid);
		out.egg_id= eggid;
		if(limit + start <= time(NULL)) {
    		out.time_left = 0;
		} else {
			out.time_left = limit + start - time(NULL);
		}
	} else {
		out.egg_id= 0;
		ret = SUCC;
	}

    STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::add_dragon_egg_hatch_time(DEAL_FUN_ARG)
{
	uint32_t eggid;		
	uint32_t start;
    add_dragon_egg_hatch_time_in *p_in=PRI_IN_POS; 
    add_dragon_egg_hatch_time_out out={};

	ret = this->user_dragon_egg.get_egg_hatch(RECVBUF_USERID,eggid,start);
	if(ret != SUCC) return ret;

	uint32_t hatchtime = time(NULL) - start;
	uint32_t limit = this->user_dragon_egg.get_egg_time_limit(eggid);
	if(limit == 0xFFFFFFFF){
		return EGG_ID_ERR;
	}

	if(limit <= hatchtime) {
		return EGG_BECOME_DRAGON_ERR;
	}

	p_in->time_add = this->user_dragon_egg.get_item_growth(p_in->itemid);
	if(limit > hatchtime + p_in->time_add) {
		out.time_left = limit - hatchtime - p_in->time_add;
	} else {
		out.time_left = 0;
	}

    user_del_attire_in del_item;
	del_item.attireid=p_in->itemid;
	del_item.attiretype=0;
	del_item.count=1;
	del_item.maxcount=99999;
    ret = this->user_del_attire(RECVBUF_USERID, &del_item);

	if(ret == SUCC) {
		ret=this->user_dragon_egg.add_egg_growth(RECVBUF_USERID,0,p_in->time_add);
	}

    STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::get_dragon_hatched(DEAL_FUN_ARG)
{
	uint32_t dragonid;
	uint32_t eggid,start;
    get_dragon_hatched_out out={};
    ret=this->user_dragon_egg.get_egg_hatch(RECVBUF_USERID,eggid,start);
	if(ret == SUCC) {
		if(this->user_dragon_egg.check_egg_is_hatched(eggid,start)) {
			ret = this->user_dragon_egg.del(RECVBUF_USERID,eggid);
			dragonid = this->user_dragon.get_dragon_id_by_egg(eggid);
			ret=this->user_dragon.add(RECVBUF_USERID,dragonid);
			out.dragonid = dragonid;
			out.egg_id = eggid;
		} else {
			return HATCH_TIME_NOT_ENOUGH_ERR;
		}
	}
    STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::get_dragon_list(DEAL_FUN_ARG)
{
    get_dragon_list_out_header  out_header;
    get_dragon_list_out_item *p_out_item;
	uint32 count = 0;

    ret=this->user_dragon.get_dragons(RECVBUF_USERID,&p_out_item, &count);
	out_header.count = count;

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::add_dragon_growth(DEAL_FUN_ARG)
{
	add_dragon_growth_in *p_in=PRI_IN_POS; 
	add_dragon_growth_out out={};
	uint32_t growth = 0;
	uint32_t state = 0;

	ret = this->user_dragon.get_dragon_info(RECVBUF_USERID,p_in->dragon_id,growth,state);
	if(ret == SUCC) {
		def_dragon_info *p = this->user_dragon.get_def_dragon_info(p_in->dragon_id);
		p_in->grow_limit = p->limit;

		if(growth >= p_in->grow_limit)	{
			return DRAGON_GROWTH_MAX_ERR;
		}

		user_del_attire_in del_item;
    	del_item.attireid=p_in->itemid;
	   del_item.attiretype=0;
	   del_item.count=1;
	   del_item.maxcount=99999;
		ret=this->user_del_attire(RECVBUF_USERID ,&del_item);
		if(ret == SUCC) {	
			p_in->growth = this->user_dragon.get_item_growth(p_in->itemid);
			if(p_in->growth + growth > p_in->grow_limit) {
				out.growth = p_in->grow_limit;
				growth = p_in->grow_limit - growth;
			} else {
				out.growth = growth + p_in->growth;
				growth = p_in->growth;
			}
			out.dragon_id = p_in->dragon_id;
			ret=this->user_dragon.add_dragon_growth(RECVBUF_USERID,p_in->dragon_id,growth);
		}
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::set_dragon_state(DEAL_FUN_ARG)
{
	set_dragon_state_in *p_in=PRI_IN_POS;
	set_dragon_state_out out={};

	uint32_t state = 0;
	uint32_t growth = 0;
	uint32_t angelid = 0;
	ret = this->user_paradise_contract.update_used_count_dragon(RECVBUF_USERID, 0);
	if(NOT_DRAGON(p_in->dragon_id)) {
		ret = this->user_dragon.get_dragon_info(RECVBUF_USERID,p_in->dragon_id,growth,state);
		if(ret == SUCC){
			if(p_in->state == 1) this->user_dragon.clear_state_1(RECVBUF_USERID);
			ret = this->user_dragon.set_dragon_state(RECVBUF_USERID,p_in->dragon_id,p_in->state);
			if(p_in->state == 1){
				ret = this->user_paradise_contract.mapping_to_angel(p_in->dragon_id, &angelid);
				if(ret == SUCC){
					ret = this->user_paradise_contract.update_used_count(RECVBUF_USERID, angelid, 1);
				}
				ret = SUCC;
			}
		}//if(ret == SUCC)
			
	} else {
		ret = this->user_dragon.get_dragon_info(RECVBUF_USERID,p_in->dragon_id,growth,state);
		if(ret == SUCC) {
			if(state == 2) {
				uint32_t mole_exp = 0;
				uint32_t unlock_cnt = 0;
				uint32_t perm_count = 0;

				uint32_t isvip = 0;
				uint32_t upgrade = 0;
				this->user_ex.get_vip(RECVBUF_USERID,(bool*)&isvip);
        			this->user_ex.get_flag(RECVBUF_USERID,"event_flag",&upgrade);
        			upgrade &= (1 << 14);
				ret = this->user.get_field_uint32(RECVBUF_USERID,"exp",mole_exp);
				if(ret != SUCC) return ret;

				perm_count = this->user_dragon.get_perm_count(mole_exp,upgrade,isvip);
				this->user_dragon.get_unlock_count(RECVBUF_USERID,unlock_cnt);

				if(perm_count <= unlock_cnt) {
					return DRAGON_COUNT_LIMIT_ERR;
				}
			}

			out.growth = growth;
			if(p_in->state == 1) this->user_dragon.clear_state_1(RECVBUF_USERID);
			ret=this->user_dragon.set_dragon_state(RECVBUF_USERID,p_in->dragon_id,p_in->state);
			ret = SUCC;

		}
	}

	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::get_current_dragon(DEAL_FUN_ARG)
{
	get_current_dragon_out out={};
	ret=this->user_dragon.get_current_dragon(RECVBUF_USERID,&out);
	if(ret != SUCC) {
		ret = SUCC;
		memset(&out,0,sizeof(out));
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_set_dragon_name(DEAL_FUN_ARG)
{
	user_set_dragon_name_in *p_in=PRI_IN_POS; 
	ret=this->user_dragon.set_name(RECVBUF_USERID,p_in->dragon_id,p_in->name);
	STD_RETURN(ret);
}

int Croute_func::release_dragon(DEAL_FUN_ARG)
{
    release_dragon_in *p_in=PRI_IN_POS; 
    ret=this->user_dragon.del(RECVBUF_USERID,p_in->dragon_id);
	if(ret == SUCC) {
        change_log_item c_item;
		c_item.userid=RECVBUF_USERID;
        c_item.change_type=106;
		c_item.logtime=time(NULL);
		c_item.change_value=p_in->dragon_id;
		c_item.change_v1=0;
		c_item.change_v2=0;
		this->send_log.send(&c_item );
	}
    STD_RETURN(ret);
}

int Croute_func::user_new_card_add_cards(DEAL_FUN_ARG)
{
	user_new_card_add_cards_in_header *p_in=PRI_IN_POS;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_new_card_add_cards_in_item));
	user_new_card_add_cards_in_item * p_in_item=(user_new_card_add_cards_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
	for (uint32_t i =0; i < p_in->count; i++)
	{
		if (((p_in_item + i)->cardid < 0) || ((p_in_item + i)->cardid > 59 ))
		{
			return VALUE_OUT_OF_RANGE_ERR;
		}
		ret = this->user_new_card.add_new_card(RECVBUF_USERID, (p_in_item + i)->cardid);
	}
	
	STD_RETURN(ret);

}

int Croute_func::roominfo_get_item_sell(DEAL_FUN_ARG)
{
	roominfo_get_item_sell_in *p_in = PRI_IN_POS;
    roominfo_get_item_sell_out_header  out_header;
    roominfo_get_item_sell_out_item *p_out_item = NULL, *q = NULL;

	uint32_t count = 0;

	out_header.count = this->roominfo_item_sell.get_max_list(p_in->npcid,&p_out_item);
	ret=this->roominfo_item_sell.update_now(RECVBUF_USERID,p_in->npcid);
	if(ret == SUCC) {
        ret=this->roominfo_item_sell.get_sell_list(RECVBUF_USERID,p_in->npcid,&q, &count);
		if(ret == SUCC) {
			uint32_t i = 0,j = 0;
			
			while(i < count) {
				for(j = 0; j < out_header.count; j++) {
					if(p_out_item[j].itemid == q[i].itemid) {
						p_out_item[j].count -= q[i].count;
						break;
					}
				}

				i++;
			}
		}
		if(q) free(q);
	}
	ret = SUCC;	

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::roominfo_add_item_sell(DEAL_FUN_ARG)
{
	roominfo_add_item_sell_in *p_in=PRI_IN_POS; 
	roominfo_add_item_sell_out out={};


	uint32_t count_in_db = 0;
	
	int check = this->roominfo_item_sell.get_npc_item_count(p_in->npcid);
	if(check == 0) {
		return ROOMINFO_NO_ITEM_SELL_ERR;
	}

	uint32_t count = this->roominfo_item_sell.get_item_sell_max(p_in->npcid, p_in->itemid);
	if(p_in->count > count) {
		return ROOMINFO_NO_ITEM_SELL_ERR;
	}

	ret=this->roominfo_item_sell.get(RECVBUF_USERID,p_in->npcid,p_in->itemid,count_in_db);
	if(ret != SUCC) {
		ret = this->roominfo_item_sell.insert_add(RECVBUF_USERID,p_in->npcid,p_in->itemid,p_in->count);
		out.count = count - p_in->count;
	} else {
		if(count < count_in_db + p_in->count) {
			return ROOMINFO_NO_ITEM_SELL_ERR;
		}
		
		ret = this->roominfo_item_sell.update_add(RECVBUF_USERID,p_in->npcid,p_in->itemid,p_in->count);
		out.count = count - count_in_db - p_in->count;
	}
  
    STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_get_user_board_info(DEAL_FUN_ARG)
{
	user_get_user_board_info_out_header out={};
	user_get_user_board_info_out_item *items_on_body;

	ret=this->user.get_user_board_info(RECVBUF_USERID ,&out);
	if (ret!=SUCC){ return ret; }

	ret=this->user_ex.get_board_info(RECVBUF_USERID ,&out);
	if (ret!=SUCC)  return ret;

	uint32_t temp_time = 0;
	uint32_t plant_limit = 0;
	uint32_t breed_limit = 0;
	ret = this->user_farm.time_limit(RECVBUF_USERID, &temp_time, &plant_limit, &breed_limit, &out.plant, &out.breed);
	if (ret != SUCC && ret != USER_ID_NOFIND_ERR)
	{
		return ret;
	}

	uint32_t dining_level = 0;
	uint32_t dining_eva = 0;
	ret = this->user_diningroom.get_level_evaluate(RECVBUF_USERID, dining_level, dining_eva);
	if (ret != SUCC && ret != USER_ID_NOFIND_ERR)
	{
		return  ret;
	}
	else
	{
		if (ret == USER_ID_NOFIND_ERR) 
		{
			out.dining_flag = 0;
			ret = SUCC;
		}
		else
		{
			out.dining_flag = 1;
			out.dining_level = dining_level;
		}
	}

	if(ret == SUCC) {                                               //服饰起始id，服饰终止id
		ret=this->user_attire.get_list_by_attireid_interval(RECVBUF_USERID,12001,15999,1,&out.item_cnt,&items_on_body);
	}

	STD_RETURN_WITH_STRUCT_LIST(ret, out, items_on_body, out.item_cnt);
}

int Croute_func::user_set_fight_monster(DEAL_FUN_ARG)
{
	user_set_fight_monster_in *p_in=PRI_IN_POS;

	if (p_in->flag > 0)
	{
		ret = this->user_new_card.set_flag(RECVBUF_USERID, p_in->flag);
		ret = this->user_new_card.add_new_card(RECVBUF_USERID, 9);
		ret = this->user_new_card.add_new_card(RECVBUF_USERID, 29);
		ret = this->user_new_card.add_new_card(RECVBUF_USERID, 49);
		STD_RETURN(ret);
	}

	int temp = 0;	

	ret=this->user.change_xiaomee(RECVBUF_USERID, p_in->xiaomee,XIAOMEE_USE_NO_DEFINE,
			0, &temp);
	if (ret != SUCC) return ret;

	ret=this->user.update_exp_inc(RECVBUF_USERID, p_in->mole_exp, p_in->strong);
	if (ret == SUCC)
	{
		//log_change
		change_log_item c_item;
        c_item.userid=RECVBUF_USERID;
		c_item.change_type=10002;
		c_item.logtime=time(NULL);
		c_item.change_value=p_in->mole_exp;
		c_item.change_v1=0;
		c_item.change_v2=0;
	   this->send_log.send(&c_item );
	}
	if (p_in->cardid != 0)
	{	
		if ((p_in->cardid < 0) || (p_in->cardid > 59 ))
		{
			return VALUE_OUT_OF_RANGE_ERR;
		}

		ret=this->user_new_card.add_new_card(RECVBUF_USERID, p_in->cardid);
		if (ret != SUCC) return ret;
	}

	STD_RETURN(ret);
}

int Croute_func::user_get_lamu_diary_list(DEAL_FUN_ARG)
{
	user_get_lamu_diary_list_out_header  out_header;
	user_get_lamu_diary_list_out_item *p_out_item;
	uint32_t count = 0;

	ret=this->user_lamu_diary.get_diary_simple_list(RECVBUF_USERID,&p_out_item,&count);
	out_header.count = count;

	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
									
int Croute_func::userinfo_get_game_act_flag(DEAL_FUN_ARG)
{
	userinfo_get_game_act_flag_out out={};
	ret=this->user_info.get_int_value(RECVBUF_USERID,"game_act_flag", &(out.game_act_flag) );
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::userinfo_add_act_flag(DEAL_FUN_ARG)
{
	userinfo_add_act_flag_in *p_in=PRI_IN_POS; 
	ret=this->user_info.set_int_value_bit(RECVBUF_USERID,"game_act_flag",p_in->gameid_flag, 1  );
	STD_RETURN(ret);
}

int Croute_func::get_friend_box_items(DEAL_FUN_ARG)
{
	get_friend_box_items_out out={};

	//检查是否有友谊宝盒
	//uint32_t count = 0;
	//ret = this->user_attire.get_count(RECVBUF_USERID,1220018,count);
	//if(ret != SUCC || count == 0) return NOT_HAVE_FRIEND_BOX_ERR;

	ret=this->user_friend_box.get_item_list(RECVBUF_USERID,&out);
	if(ret != SUCC) {
		ret = SUCC;
	//	memset(&out,0,sizeof(out));
	//	this->user_friend_box.init_record(RECVBUF_USERID);
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::get_friend_box_history(DEAL_FUN_ARG)
{
	get_friend_box_history_out out={};

	//检查是否有友谊宝盒
	//uint32_t count = 0;
	//ret = this->user_attire.get_count(RECVBUF_USERID,1220018,count);
	//if(ret != SUCC || count == 0) return NOT_HAVE_FRIEND_BOX_ERR;

	ret=this->user_friend_box.get_history_list(RECVBUF_USERID,&out);
	if(ret != SUCC) {
		ret = SUCC;
	//	memset(&out,0,sizeof(out));
	//	this->user_friend_box.init_record(RECVBUF_USERID);
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::put_item_to_friend_box(DEAL_FUN_ARG)
{
	int flag = 0;
	put_item_to_friend_box_in *p_in=PRI_IN_POS; 
	get_friend_box_items_out out={};

	//检查是否有友谊宝盒
	//uint32_t count = 0;
	//ret = this->user_attire.get_count(RECVBUF_USERID,1220018,count);
	//if(ret != SUCC || count == 0) return NOT_HAVE_FRIEND_BOX_ERR;

	ret=this->user_friend_box.get_item_list(RECVBUF_USERID,&out);
	if(ret != SUCC) {
		flag = 1;
		ret = SUCC;
	//	memset(&out,0,sizeof(out));
		this->user_friend_box.init_record(RECVBUF_USERID);
	} 

	if(flag == 0) {
		uint32_t  i = 0;
		for(i = 0; i < out.count;i++) {
			if(out.items[i].attireid == p_in->attireid) {
				out.items[i].count += p_in->count;
				break;
			}
		}
		if(i == out.count) flag = 1;
	}

	if(flag == 1) {
		if(out.count == 6) return CAN_NOT_PUT_IN_BOX_ERR;
		out.items[out.count].attireid=p_in->attireid;
		out.items[out.count].count = p_in->count;
		out.count++;
	}

	user_del_attire_in del_item;
	del_item.attireid=p_in->attireid;
	del_item.attiretype=p_in->attiretype;
	del_item.count=p_in->count;
	del_item.maxcount=99999;
	ret=this->user_del_attire(RECVBUF_USERID ,&del_item);
	if(ret == SUCC) {
		this->user_friend_box.set_item_list(RECVBUF_USERID,&out);
	}

	STD_RETURN(ret);
}

int Croute_func::get_item_from_friend_box(DEAL_FUN_ARG)
{
	get_item_from_friend_box_in *p_in=PRI_IN_POS; 
	get_friend_box_items_out out={};

	//检查是否有友谊宝盒
	//uint32_t count = 0;
	//ret = this->user_attire.get_count(RECVBUF_USERID,1220018,count);
	//if(ret != SUCC || count == 0) return NOT_HAVE_FRIEND_BOX_ERR;

	ret=this->user_friend_box.get_item_list(RECVBUF_USERID,&out);
	if(ret != SUCC) {
	//	memset(&out,0,sizeof(out));
	//	this->user_friend_box.init_record(RECVBUF_USERID);
		return NO_ITEM_TO_SHARE_ERR;
	}

	uint32_t i = 0;
	for(i=0; i < out.count;i++) {
		if(out.items[i].attireid == p_in->info.attireid) break;
	}
	if(i == out.count)
		return NO_ITEM_TO_SHARE_ERR;
    if(out.items[i].count < p_in->count)
		return NOT_ENOUGH_ITEM_TO_SHARE_ERR;
	
	if(out.items[i].count > p_in->count) {
		out.items[i].count -= p_in->count;
	} else {
		out.count--;
		if(out.count > i)
			memmove((out.items + i), out.items + i + 1,sizeof(out.items[0]) * (out.count - i));
		memset(out.items + out.count,0,sizeof(out.items[0]));
	}
	
	if(p_in->info.userid != RECVBUF_USERID) {
		get_friend_box_history_out history={};
		this->user_friend_box.get_history_list(RECVBUF_USERID,&history);
		if(history.count == 20) {
			memmove(history.infos,history.infos + 1,sizeof(history.infos[0]) * 19);	
			history.count = 19;
		}
		history.infos[history.count] = p_in->info;
		history.infos[history.count].stamp=time(NULL);
		history.count++;
		this->user_friend_box.set_history_list(RECVBUF_USERID,&history);

		change_log_item c_item;
		c_item.userid=RECVBUF_USERID;
		c_item.change_type=10006;
		c_item.logtime=time(NULL);
		c_item.change_value=p_in->count;
		c_item.change_v1=p_in->info.attireid;
		c_item.change_v2=0;
		this->send_log.send(&c_item );	
	}

	ret=this->user_friend_box.set_item_list(RECVBUF_USERID,&out);
	STD_RETURN(ret);
}

int Croute_func::check_item_from_friend(DEAL_FUN_ARG)
{
	uint32_t date;
	share_src_t out={};
	check_item_from_friend_in *p_in=PRI_IN_POS;
	uint32_t exsit = 0;
	
	//检查是否有友谊宝盒
	uint32_t count = 0;
	//ret = this->user_attire.get_count(RECVBUF_USERID,1220018,count);
	//if(ret != SUCC || count == 0) return NOT_HAVE_FRIEND_BOX_ERR;

	if(RECVBUF_USERID != p_in->userid) {
		ret=this->user_ex.check_friend(RECVBUF_USERID,p_in->userid,&exsit);
		if(ret != SUCC || exsit == 0) {
			return NOT_FRIEND_ERR;
		}
	} 
	ret=this->user_friend_box.get_share_src_list(RECVBUF_USERID,date,&out);
	if(ret != SUCC){
		this->user_friend_box.init_record(RECVBUF_USERID);
	} else {
//检查今天是否拿过
		if(date != (uint32_t)get_date(time(NULL))) {
			date = get_date(time(NULL));
			memset(&out,0,sizeof(out));
			this->user_friend_box.set_share_src_list(RECVBUF_USERID,date,&out);
		} else if(out.count == 5){
			return SHARE_LIMIT_TODAY_ERR;
		} else {
			uint32_t i;
			for(i = 0; i < out.count; i++) {
				if(out.userid[i] == p_in->userid)
					return SHARED_TODAY_ERR;
			}
		}
	}

//检查武品上限
	count = 0;
	ret = this->user_attire.get_count(RECVBUF_USERID,p_in->attireid,count);
	if(ret == SUCC) {
		if(count + p_in->count > p_in->maxcount)
			return TOO_MANY_ITEM_ERR;
	} else {
		ret = SUCC;
	}

	STD_RETURN(ret);
}

int Croute_func::set_tag_item_from_friend(DEAL_FUN_ARG)
{
	uint32_t date;
	share_src_t out={};
	set_tag_item_from_friend_in *p_in=PRI_IN_POS;

	if(p_in->userid == RECVBUF_USERID) {
		STD_RETURN(SUCC);
	}

	//检查是否有友谊宝盒
	//uint32_t count = 0;
	//ret = this->user_attire.get_count(RECVBUF_USERID,1220018,count);
	//if(ret != SUCC || count == 0) return NOT_HAVE_FRIEND_BOX_ERR;

	ret=this->user_friend_box.get_share_src_list(RECVBUF_USERID,date,&out);
	if(ret != SUCC) return ret;

	if(date != (uint32_t)get_date(time(NULL))) {
		date = get_date(time(NULL));
	//	memset(&out,0,sizeof(out));
	}

	if(out.count < 5) {
		out.userid[out.count++] = p_in->userid;
	} else {
		out.userid[0] = p_in->userid;
	}

	this->user_friend_box.set_share_src_list(RECVBUF_USERID,date,&out);
	STD_RETURN(ret);
}

int Croute_func::user_checkin_black(DEAL_FUN_ARG)
{
	user_checkin_black_in *p_in = PRI_IN_POS; 
	user_checkin_black_out out = {};
	ret = this->user_ex.check_black(RECVBUF_USERID, p_in->friendid, &(out.is_existed));
	STD_RETURN_WITH_STRUCT(ret, out);
}
int Croute_func::user_pet_is_super_lamu(DEAL_FUN_ARG)
{
	user_pet_is_super_lamu_in *p_in=PRI_IN_POS; 
	user_pet_is_super_lamu_out out={};
	uint32_t count = 0;
	ret=this->user_pet.is_sulamu(RECVBUF_USERID, count);
	if(ret != SUCC) {
		ret = SUCC;
		out.is_sulamu = 0;
	}
	out.is_sulamu = count;
	if(out.is_sulamu != 0) out.is_sulamu = 1;
	DEBUG_LOG("out.is_sulamu=%d",out.is_sulamu);
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::lamu_classroom_user_create_classroom(DEAL_FUN_ARG)
{
	lamu_classroom_user_create_classroom_in *p_in = PRI_IN_POS; 
	lamu_classroom_user_create_classroom_out out = {};
	ret = this->lamu_classroom.insert(RECVBUF_USERID, p_in, out);
	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::lamu_classroom_user_set_classroom_name(DEAL_FUN_ARG)
{
	lamu_classroom_user_set_classroom_name_in *p_in = PRI_IN_POS; 
	ret = this->lamu_classroom.set_lamu_classroom_name(p_in);
	STD_RETURN(ret);
}

int Croute_func::lamu_classroom_tw_get_exp_and_name(DEAL_FUN_ARG)
{
	lamu_classroom_tw_get_exp_and_name_out out={};
	ret = this->lamu_classroom.get_lamu_classroom_exp_and_name(RECVBUF_USERID, &out);
	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::lamu_classroom_user_get_frame_classroom(DEAL_FUN_ARG)
{
	lamu_classroom_user_get_frame_classroom_in *p_in = PRI_IN_POS;
	lamu_classroom_user_get_frame_classroom_out_header out_header;
	lamu_classroom_user_get_frame_classroom_out_item *p_out_item;
	uint32_t count = 0;
	ret = this->lamu_classroom.get_lamu_classroom_count(count);
	if (ret != SUCC) {
		return ret;
	}
	if ((p_in->frame_id) * 4 < count) {
		out_header.flag = 0;
	} else {
		out_header.flag = 1;
	}
	ret = this->lamu_classroom.get_lamu_classroom_frame(p_in->frame_id, &(out_header.count), &p_out_item);
	STD_RETURN_WITH_STRUCT_LIST(ret, out_header, p_out_item, out_header.count);	
}

int Croute_func::lamu_classroom_user_get_last_frameid(DEAL_FUN_ARG)
{
	lamu_classroom_user_get_last_frameid_out out = {};
	
	uint32_t room_id = 0;
	ret = this->lamu_classroom.get_lamu_classroom_roomid(RECVBUF_USERID, room_id);
	if (ret != SUCC) {
		ret = SUCC;
	}
	if (room_id > 0) {
		out.user_frameid  = (room_id + 3) / 4;
	}
	
	out.begin_id = 1;
	
	uint32_t count = 0;
	ret = this->lamu_classroom.get_lamu_classroom_count(count);

	if (ret != SUCC) {
		return ret;
	}
	out.frame_id = (count + 3) / 4;
	if (out.frame_id == 0) {
		out.frame_id = 1;
	}

	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::lamu_classroom_get_rand_user(DEAL_FUN_ARG)
{
	lamu_classroom_get_rand_user_out out = {};
	uint32_t count;
	ret = this->lamu_classroom.get_lamu_classroom_count(count);
	uint32_t room_id = rand() % count + 1;
	uint32_t userid;
	ret = this->lamu_classroom.get_lamu_classroom_userid(room_id, userid);
	out.userid = userid;
	if (userid == RECVBUF_USERID) { //如果随机出来的用户是自己
		room_id = room_id + 1;
		room_id = room_id > count ? 1 : room_id;
		ret = lamu_classroom.get_lamu_classroom_userid(room_id, userid);
		out.userid = userid;
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * @brief 设置教室经验
 */
int Croute_func::lamu_classroom_set_teacher_exp(DEAL_FUN_ARG)
{
	lamu_classroom_set_teacher_exp_in *p_in = PRI_IN_POS; 
	ret = this->lamu_classroom.set_teacher_exp(RECVBUF_USERID, p_in->teacher_exp);
	STD_RETURN(ret);
}

/*
 * @brief 设置优秀学生数量
 */
int Croute_func::lamu_classroom_set_outstand_sum(DEAL_FUN_ARG)
{
	lamu_classroom_set_outstand_sum_in *p_in = PRI_IN_POS;
	ret = this->lamu_classroom.set_outstand_sum(RECVBUF_USERID, p_in->outstand_sum);
	STD_RETURN(ret);
}

/*
 * @brief 排名，得到好友的经验和优秀毕业数量
 */
int Croute_func::lamu_classroom_get_friend_rank(DEAL_FUN_ARG)
{
	lamu_classroom_get_friend_rank_in_header *p_in = PRI_IN_POS;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count) * sizeof(lamu_classroom_get_friend_rank_in_item));
	lamu_classroom_get_friend_rank_in_item * p_in_item = 
						(lamu_classroom_get_friend_rank_in_item*)(RCVBUF_PRIVATE_POS + sizeof(*p_in));

	lamu_classroom_get_friend_rank_out_header out_header;
	lamu_classroom_get_friend_rank_out_item *p_out_item = NULL;
	ret = this->lamu_classroom.get_friend_rank_info(p_in->count, p_in_item, &(out_header.count), &p_out_item);
	STD_RETURN_WITH_STRUCT_LIST(ret, out_header, p_out_item, out_header.count);
}

/*
 * @brief 设置教室经验和优秀学生人数
 */
int Croute_func::lamu_classroom_set_exp_and_outstand_sum(DEAL_FUN_ARG)
{
	lamu_classroom_set_exp_and_outstand_sum_in *p_in = PRI_IN_POS;	
	ret = this->lamu_classroom.set_exp_and_outstand_sum(RECVBUF_USERID, p_in->exp, p_in->outstand_sum);
	STD_RETURN(ret);
}

/* 
 * @brief 添加拉姆教室到USER表
 */
int Croute_func::user_lamu_classroom_create_classroom(DEAL_FUN_ARG)
{
	user_lamu_classroom_create_classroom_in *p_in = PRI_IN_POS; 
	ret = this->user_lamu_classroom.insert(RECVBUF_USERID, p_in);
	STD_RETURN(ret);
}

/*
 * @brief USER表修改拉姆教室名称
 */
int Croute_func::user_lamu_classroom_set_name(DEAL_FUN_ARG)
{
	user_lamu_classroom_set_name_in *p_in = PRI_IN_POS; 
	ret = this->user_lamu_classroom.set_lamu_classroom_name(RECVBUF_USERID, p_in->room_name);
	STD_RETURN(ret);
}

/*
 * @brief USER表修改拉姆教室内部装饰
 */
int Croute_func::user_lamu_classroom_set_inner_style(DEAL_FUN_ARG)
{
	user_lamu_classroom_set_inner_style_in *p_in = PRI_IN_POS; 
	ret = this->user_lamu_classroom.set_lamu_classroom_inner_style(RECVBUF_USERID, p_in->inner_style);
	STD_RETURN(ret);
}

/* 
 * @brief 拉姆教室招生，将所有学生信息添加到t_user_lamu_classroom_lamu表中
 */
int Croute_func::user_lamu_classroom_add_lamus(DEAL_FUN_ARG)
{
	user_lamu_classroom_add_lamus_in_header *p_in = PRI_IN_POS;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count) * sizeof(user_lamu_classroom_add_lamus_in_item));
	user_lamu_classroom_add_lamus_in_item * p_in_item = (user_lamu_classroom_add_lamus_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in));
	user_lamu_classroom_add_lamus_out out = {};

	uint32_t count = 0;
	ret = this->user_lamu_classroom_lamu.get_lamus_count(RECVBUF_USERID, &count);
	ret = this->user_lamu_classroom.check_class_student_cnt(RECVBUF_USERID, count + p_in->count);
	if (ret != SUCC) {
		return ret;
	}

	uint32_t difficulty = 0;
	ret = this->user_lamu_classroom.get_class_difficulty(RECVBUF_USERID, difficulty);
	
	double tmp_difficulty = (double)difficulty;
	for (uint32_t i = 0; i < p_in->count; i++) {
		ret = this->user_lamu_classroom_lamu.add_lamu(RECVBUF_USERID, (p_in_item + i), count + i + 1);
		tmp_difficulty = user_lamu_classroom.cal_class_difficulty((p_in_item + i), tmp_difficulty, count + i);
	}
	difficulty = (uint32_t)tmp_difficulty;

	if (count == 0) {	//如果教室没有学生，招生后将重新设置困难度、学期剩余课数
		ret = this->user_lamu_classroom.new_lamu_classroom(RECVBUF_USERID, difficulty);
	} else {
		ret = this->user_lamu_classroom.set_class_difficulty(RECVBUF_USERID, difficulty);
	}
	out.count = count + p_in->count;
	STD_RETURN_WITH_STRUCT(ret, out);
}

/*
 * @brief 放弃当前学生，已教授的班级数量减1
 */
int Croute_func::user_lamu_classroom_abandon_lamus(DEAL_FUN_ARG)
{
	user_lamu_classroom_abandon_lamus_out out={};
	uint32_t count = 0;
	ret = this->user_lamu_classroom_lamu.get_lamus_count(RECVBUF_USERID, &count);
	out.count = count;
	
	ret = this->user_lamu_classroom.abandon_lamu_classroom(RECVBUF_USERID);
	ret = this->user_lamu_classroom_lamu.delete_lamu(RECVBUF_USERID);
	ret = this->user_lamu_classroom_exam.delete_info(RECVBUF_USERID);
	ret = this->user_lamu_classroom_score.delete_score(RECVBUF_USERID);
	STD_RETURN_WITH_STRUCT(ret, out);
}

/*
 * @brief 进教室时拉取教室的相关信息
 */
int Croute_func::user_lamu_classroom_get_class_info(DEAL_FUN_ARG)
{
	user_lamu_classroom_get_class_info_in *p_in = PRI_IN_POS;
	char out[PROTO_MAX_LEN] = {};
	user_lamu_classroom_get_class_info_out_header *p_out = (user_lamu_classroom_get_class_info_out_header *)out;
	user_lamu_classroom_get_class_info_out_item *p_lamu_list = NULL;

	ret = this->user_lamu_classroom.get_lamu_classroom_info(RECVBUF_USERID, p_out);
	if (ret != SUCC) {
		return ret;
	}

	uint32_t count = 0;
	ret = this->user_lamu_classroom_lamu.get_lamu_info_ex(RECVBUF_USERID, &p_lamu_list, &count);
	if (ret != SUCC) {
		if (p_lamu_list != NULL) {
			free(p_lamu_list);
			p_lamu_list = NULL;
		}
		return ret;
	}
	
	if (count > 0) {//如果有学生，则更新精力、每日累计上课数
		ret = this->user_lamu_classroom.update_classroom_per_day(RECVBUF_USERID); 
	}

	if (p_out->cur_course_id == 14) {//答疑课event_cnt为学生数量*2
		p_out->event_cnt = count * 2 - p_out->event_cnt;
	} else if (p_out->cur_course_id != 0) {
		p_out->event_cnt = 1 - p_out->event_cnt;
	} else {
		p_out->event_cnt = 0;
	}

	p_out->count = count;
	char *p_offset = out + sizeof(user_lamu_classroom_get_class_info_out_header);
	memcpy(p_offset, p_lamu_list, sizeof(user_lamu_classroom_lamu_info_ex_item) * p_out->count);
	p_offset += sizeof(user_lamu_classroom_lamu_info_ex_item) * p_out->count;
	free(p_lamu_list);
	p_lamu_list = NULL;
	
	STD_RETURN_WITH_BUF(ret, out, p_offset - out);
}

/*
 * @brief 查看学生档案时，拉取学生信息
 */
int Croute_func::user_lamu_classroom_get_lamus_info(DEAL_FUN_ARG)
{
	user_lamu_classroom_get_lamus_info_out_header out_header;
	user_lamu_classroom_get_lamus_info_out_item *p_out_item = NULL;

	uint32_t exam_times = 0;
	ret = this->user_lamu_classroom.get_exam_times(RECVBUF_USERID, exam_times);
	if (ret != SUCC) {
		return ret;
	}
	out_header.userid = RECVBUF_USERID;
	out_header.exam_times = exam_times;
	ret = this->user_lamu_classroom_lamu.get_lamus_info(RECVBUF_USERID, &p_out_item, &(out_header.count));

	STD_RETURN_WITH_STRUCT_LIST(ret, out_header, p_out_item, out_header.count);
}

/*
 * @brief 查看教师档案时，拉取课程信息
 */
int Croute_func::user_lamu_classroom_get_record(DEAL_FUN_ARG)
{
	char out[PROTO_MAX_LEN] = {};
	user_lamu_classroom_get_record_out_header *p_out = (user_lamu_classroom_get_record_out_header *)out;
	user_lamu_classroom_get_record_out_item *p_out_list = NULL;
 	ret = this->user_lamu_classroom.get_lamu_classroom_record(RECVBUF_USERID, p_out);
	if (ret != SUCC) {
		return ret;
	}

	uint32_t count = 0;
 	ret = this->user_lamu_classroom_course.get_course(RECVBUF_USERID, &p_out_list, &count);
	if (ret != SUCC) {
		if (p_out_list != NULL) {
			free(p_out_list);
			p_out_list = NULL;
		}
		return ret;
	}

	p_out->count = count;
	char *p_offset = out + sizeof(*p_out);
	memcpy(p_offset, p_out_list, sizeof(user_lamu_classroom_get_record_out_item) * p_out->count);
	p_offset += sizeof(user_lamu_classroom_get_record_out_item) * p_out->count;
	free(p_out_list);
	p_out_list = NULL;
	STD_RETURN_WITH_BUF(ret, out, p_offset - out);
}

/*
 * @brief 拉取教学回忆
 */
int Croute_func::user_lamu_classroom_get_remembrance(DEAL_FUN_ARG)
{
	user_lamu_classroom_get_remembrance_out_header out_header; 
	user_lamu_classroom_get_remembrance_out_item *p_out_item = NULL;
	ret = this->user_lamu_classroom_remembrance.get_remembrances(RECVBUF_USERID, &p_out_item, &(out_header.count));
	STD_RETURN_WITH_STRUCT_LIST(ret, out_header, p_out_item, out_header.count);
}

/*
 * @brief 拉取教学方式
 */
int Croute_func::user_lamu_classroom_get_teach_plan(DEAL_FUN_ARG)
{
	user_lamu_classroom_get_teach_plan_out out = {};
	ret = this->user_lamu_classroom.get_lamu_classroom_teach_plan(RECVBUF_USERID, &out);
	STD_RETURN_WITH_STRUCT(ret, out);
}

/*
 * @brief 拉取课程教学次数
 */
int Croute_func::user_lamu_classroom_get_course_list(DEAL_FUN_ARG)
{
	user_lamu_classroom_get_course_list_out_header out_header;
	user_lamu_classroom_get_course_list_out_item *p_out_item = NULL;
	ret = this->user_lamu_classroom_course.get_course(RECVBUF_USERID, &p_out_item, &(out_header.count));
	STD_RETURN_WITH_STRUCT_LIST(ret, out_header, p_out_item, out_header.count);
}

/*
 * @brief 拉姆教室开始上课，设置当前上课状态
 */
int Croute_func::user_lamu_classroom_class_begin(DEAL_FUN_ARG)
{
	user_lamu_classroom_class_begin_in *p_in = PRI_IN_POS;
	user_lamu_classroom_class_begin_out out = {};
	
	int class_hour_limit = 0;
	class_hour_limit = this->user_lamu_classroom.check_lamu_classroom_class_begin(RECVBUF_USERID);
	if (!class_hour_limit) {
		return USER_LAMU_CLASSROOM_CLASS_HOUR_LIMIT_ERR;
	}
	
	uint32_t class_flag;
	uint32_t lamu_cnt;
	ret = this->user_lamu_classroom.get_class_flag(RECVBUF_USERID, class_flag);
	if (class_flag != 2) {	//下课状态下才能开始上课
		ret = USER_LAMU_CLASSROOM_CLASS_BEGIN_ERR;
	} else {
		uint32_t count = 0;
		ret = this->user_lamu_classroom_lamu.get_lamus_count(RECVBUF_USERID, &count);
		if (ret != SUCC || count == 0) {
			return USER_LAMU_CLASSROOM_STUDENT_NUM_ERR;
		}
		lamu_cnt = count;

		if (p_in->cur_course_type == 1) {
			class_flag = 0;
		} else if (p_in->cur_course_type== 2) {
			class_flag = 1;
		}

		count = 0;
		ret = this->user_lamu_classroom_course.find_course_id(RECVBUF_USERID, p_in->cur_course_id, count);
		if (count == 0) { //表示没有添加该课程到课程表
			ret = this->user_lamu_classroom_course.insert(RECVBUF_USERID, p_in->cur_course_id);
		}
		ret = this->user_lamu_classroom.set_class_begin(RECVBUF_USERID, p_in->cur_course_id, class_flag);
	}
	out.class_flag = class_flag;
	if (p_in->cur_course_id == 14) {
		out.event_cnt = lamu_cnt * 2;
	} else {
		out.event_cnt = 1;
	}
	STD_RETURN_WITH_STRUCT(ret, out);
}

/*
 * @brief 修改class_flag
 */
int Croute_func::user_lamu_classroom_set_teach_mode(DEAL_FUN_ARG)
{
	user_lamu_classroom_set_teach_mode_in *p_in = PRI_IN_POS;
	uint32_t class_flag;
	//先判断是否可以上课
	ret = this->user_lamu_classroom.get_class_flag(RECVBUF_USERID, class_flag);
	if (class_flag == 0 && class_flag == 1) {
		ret = USER_LAMU_CLASSROOM_CLASS_BEGIN_ERR;
	} else {
		ret = this->user_lamu_classroom.set_class_mode(RECVBUF_USERID, p_in->class_flag);
	}
	STD_RETURN(ret);
}

/*
 * 下课后修改老师以及学生的各项数值
 */
int Croute_func::user_lamu_classroom_class_end(DEAL_FUN_ARG)
{
	user_lamu_classroom_class_end_in *p_in = PRI_IN_POS;
	user_lamu_classroom_class_end_out out = {};

	ret = this->user_lamu_classroom.is_class_end_right(RECVBUF_USERID, p_in->course_id, p_in->course_time);	
	if (p_in->end_type == 0) {//正常下课
		if (ret != SUCC) {
			return ret;
		}
	} else if (p_in->end_type == 1) {//立即下课
		if (!(ret == SUCC || ret == USER_LAMU_CLASSROOM_CLASS_END_EARLY_ERR)){
			return ret;
		}
	}

	//先根据该课程的level，根据level来得到教师拿多少经验
	uint32_t level = 0;
	ret = this->user_lamu_classroom_course.get_course_level(RECVBUF_USERID, p_in->course_id, &level);
	if (ret != SUCC) {
		return ret;
	}
	
	ret = this->user_lamu_classroom_course.set_course_count(RECVBUF_USERID, p_in->course_id, p_in->course_cnt);
	
	//下课后得到教室状态、教室经验、精力、亲密度，同时得到学期总课时数和学期累计课时数及考试次数(判断是否考试)
	ret = this->user_lamu_classroom.get_class_end_info(RECVBUF_USERID, &out, p_in->course_cnt);
	if (out.exam_flag > 0) {//如果考试，class_flag设置为4
		out.class_flag = 4;
	} else {
		out.class_flag = 2;
	}

	uint32_t exam_times = 0;
	ret = this->user_lamu_classroom.get_exam_times(RECVBUF_USERID, exam_times);
	ret = this->user_lamu_classroom_lamu.update_lamus_when_class_end(RECVBUF_USERID, p_in, out.energy, out.lovely, exam_times);

	out.course_id = p_in->course_id;
	out.energy = BETWEEN_VAL(((int32_t)(out.energy) + p_in->energy), 0, 1000);
	out.lovely = BETWEEN_VAL(((int32_t)(out.lovely) + p_in->lovely), 0, 1000);
	//DEBUG_LOG("----alexhe:%d,%d,%u,%u",p_in->energy,p_in->lovely,out.energy,out.lovely);
	out.exp += p_in->level_exp[level];
	//修改经验、精力、以及上过的课程数等
	ret = this->user_lamu_classroom.update_when_class_end(RECVBUF_USERID, out, p_in->course_cnt);
	
	if (ret == SUCC) {
		change_log_item c_item;
		c_item.userid = RECVBUF_USERID;
		c_item.change_type=200;
		c_item.logtime = time(NULL);
		c_item.change_value = p_in->level_exp[level];
		c_item.change_v1 = p_in->course_id;
		c_item.change_v2 = p_in->course_cnt;
		this->send_log.send(&c_item);
	}

	STD_RETURN_WITH_STRUCT(ret, out);
}

/*
 * @brief 得到拉姆教室经验、考试次数、当前困难度、学生人数
 */
int Croute_func::user_lamu_classroom_get_exp_course(DEAL_FUN_ARG)
{
	user_lamu_classroom_get_exp_course_out out = {};
	ret = this->user_lamu_classroom.get_exp_course_cnt(RECVBUF_USERID, &out);
	if (ret == SUCC) {
		ret = this->user_lamu_classroom_lamu.get_lamus_count(RECVBUF_USERID, &(out.lamu_cnt), 0);
		ret = this->user_lamu_classroom_lamu.get_lamus_count(RECVBUF_USERID, &(out.su_lamu_cnt), 1);
	}
	STD_RETURN_WITH_STRUCT(ret, out);
}

/*
 * @brief 进教室前判断是否是在上课
 */
int Croute_func::user_lamu_classroom_is_class_time(DEAL_FUN_ARG)
{
	user_lamu_classroom_is_class_time_out out = {};
	ret = this->user_lamu_classroom.is_class_time(RECVBUF_USERID, &out);
	STD_RETURN_WITH_STRUCT(ret, out);
}

/*
 * @brief 开始考试，计算考试结果
 */
int Croute_func::user_lamu_classroom_begin_exam(DEAL_FUN_ARG)
{
	user_lamu_classroom_begin_exam_in_header *p_in = PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count) * sizeof(user_lamu_classroom_begin_exam_in_item));
	user_lamu_classroom_begin_exam_in_item * p_in_item = 
			(user_lamu_classroom_begin_exam_in_item*)(RCVBUF_PRIVATE_POS + sizeof(*p_in));
	user_lamu_classroom_begin_exam_out out = {};

	uint32_t exam_times; 
	uint32_t difficulty;
	uint32_t lovely;
	uint32_t exp;
	ret = this->user_lamu_classroom.get_about_exam_info(RECVBUF_USERID, lovely, difficulty, exam_times, exp);
	if (ret != SUCC) {
		return ret;
	}
	
	user_lamu_about_exam_list *p_list = NULL;		//学生有关考试的信息
	uint32_t lamu_count = 0;
	ret = this->user_lamu_classroom_lamu.get_class_end_or_exam_info(RECVBUF_USERID, &p_list, &lamu_count);
	if (ret != SUCC) {
		if (p_list != NULL) {
			free(p_list);
			p_list = NULL;
		}
		return ret;
	}

	user_lamu_classroom_exam_info exam_info = {0};
	for (uint32_t i = 0; i < lamu_count; ++i) {	
		user_lamu_classroom_score_info score_info = {0};
		score_info.course_list.count = p_in->count;
		ret = this->user_lamu_classroom_lamu.cal_exam_values(&score_info, (p_list +i), p_in_item, lovely, exam_times);
		if (score_info.score == 1) {
			++(exam_info.level_s);
		} else if (score_info.score == 2) {
			++(exam_info.level_a);
		} else if (score_info.score == 3) {
			++(exam_info.level_b);
		} else if (score_info.score == 4) {
			++(exam_info.level_c);
		} else if (score_info.score == 5) {
			++(exam_info.level_d);
		}
		ret = this->user_lamu_classroom_score.insert(RECVBUF_USERID, score_info);
	}
	free(p_list);
	p_list = NULL;

	//计算教学质量、考评、考试次数加1、学生评分等
	ret = this->user_lamu_classroom.cal_teacher_after_exam(exam_info, lamu_count, lovely, difficulty, exam_times);
	ret = this->user_lamu_classroom_exam.insert(RECVBUF_USERID, exam_info);
	ret = this->user_lamu_classroom_lamu.insc_lamu_level(RECVBUF_USERID, lamu_count);
	//修改教学考评、class_flag、考试次数、教师经验
	ret = this->user_lamu_classroom.set_classroom_after_exam(RECVBUF_USERID, exam_info);
	
	out.evaluate = exam_info.evaluate;
	out.exam_times = exam_times + 1;
	out.exp = exam_info.exp + exp;
	if (ret == SUCC) {
		change_log_item c_item;
		c_item.userid = RECVBUF_USERID;
		c_item.change_type=201;
		c_item.logtime = time(NULL);
		c_item.change_value = exam_info.exp;
		c_item.change_v1 = exam_times + 1;
		c_item.change_v2 = 0;
		this->send_log.send(&c_item );
	}

	STD_RETURN_WITH_STRUCT(ret, out);
}

/*
 * @brief 得到考试后的信息
 */
int Croute_func::user_lamu_classroom_get_exam_info(DEAL_FUN_ARG)
{
	char out[PROTO_MAX_LEN] = {};
	user_lamu_classroom_get_exam_info_in *p_in = PRI_IN_POS;
    user_lamu_classroom_get_exam_info_out_header *p_out_header = (user_lamu_classroom_get_exam_info_out_header *)out;
	user_lamu_classroom_get_exam_info_out_item *p_out_list = NULL;
	uint32_t exam_times = 0;
	if (p_in->exam_times == 0) {
		ret = this->user_lamu_classroom.is_exam_state(RECVBUF_USERID, exam_times);
		if (ret != SUCC) {
			return ret;
		}
	} else {
		exam_times = p_in->exam_times;
	}

	uint32_t all_exp = 0;
	ret = this->user_lamu_classroom.get_teacher_exp(RECVBUF_USERID, all_exp);
	p_out_header->all_exp = all_exp;

	ret = this->user_lamu_classroom_exam.get_exam_info(RECVBUF_USERID, exam_times, p_out_header);
	uint32_t count = 0;
	ret = this->user_lamu_classroom_score.get_exam_score(RECVBUF_USERID, exam_times, &p_out_list, &count);
	if (ret != SUCC) {
		if (p_out_list != NULL) {
			free(p_out_list);
			p_out_list = NULL;
		}
		return ret;
	}
	for (uint32_t i = 0; i < count; ++i) {
		ret = this->user_lamu_classroom_lamu.get_lamu_show_info(RECVBUF_USERID, (p_out_list + i));
	}
	
	p_out_header->lamu_count = count;
	char *p_offset = out + sizeof(*p_out_header);
	memcpy(p_offset, p_out_list, sizeof(user_lamu_classroom_get_exam_info_out_item) * count);
	p_offset += sizeof(user_lamu_classroom_get_exam_info_out_item) * count;
	
	free(p_out_list);
	p_out_list = NULL;
	STD_RETURN_WITH_BUF(ret, out, p_offset - out);
}

/*
 * @brief 判断用户是否创建了lamu教室
 */
int Croute_func::user_lamu_classroom_have_class(DEAL_FUN_ARG)
{
	user_lamu_classroom_have_class_out out = {};
	ret = this->user_lamu_classroom.is_user_have_class(RECVBUF_USERID, &(out.flag));
	out.userid = RECVBUF_USERID;
	STD_RETURN_WITH_STRUCT(ret, out);
}

/*
 * @brief 设置考试奖励
 */
int Croute_func::user_lamu_classroom_get_prize(DEAL_FUN_ARG)
{
	user_lamu_classroom_get_prize_in_header *p_in = PRI_IN_POS;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count) * sizeof(user_lamu_classroom_get_prize_in_item));
    user_lamu_classroom_get_prize_in_item * p_in_item =
	            (user_lamu_classroom_get_prize_in_item*)(RCVBUF_PRIVATE_POS + sizeof(*p_in));
	uint32_t exam_times = 0;
	ret = this->user_lamu_classroom.get_exam_times(RECVBUF_USERID, exam_times);
	ret = this->user_lamu_classroom_exam.set_exam_prize(RECVBUF_USERID, exam_times, p_in->count, p_in_item);
	STD_RETURN(ret);
}

/*
 * @brief 判断是否能够毕业
 */
int Croute_func::user_lamu_classroom_get_class_flag(DEAL_FUN_ARG)
{
	user_lamu_classroom_get_class_flag_out out = {};
	uint32_t class_flag = 0;
	ret = this->user_lamu_classroom.get_class_flag(RECVBUF_USERID, class_flag);
	out.class_flag = class_flag;
	STD_RETURN_WITH_STRUCT(ret, out);
}

/*
 * @brief 毕业
 */
int Croute_func::user_lamu_classroom_class_graduate(DEAL_FUN_ARG)
{
	char out[PROTO_MAX_LEN] = {};
	user_lamu_classroom_class_graduate_out_header *p_out_header = (user_lamu_classroom_class_graduate_out_header *)out;
	//user_lamu_classroom_class_graduate_out_item *p_out_list = NULL;
	ret = this->user_lamu_classroom.is_class_graduate_right(RECVBUF_USERID);
	if (ret != SUCC) {
		return ret;
	}

	uint32_t count;
	user_lamu_classroom_get_lamus_info_out_item *p_list = NULL;//获得毕业时拉姆的属性
	ret = this->user_lamu_classroom_lamu.get_lamus_info(RECVBUF_USERID, &p_list, &count);
	if (ret != SUCC) {
		if (p_list != NULL) {
			free(p_list);
			p_list = NULL;
		}
		return ret;
	}
	
	uint32_t remem_cnt = 0;
	user_lamu_classroom_get_remembrance_out_item *p_remem_list = NULL;//毕业回忆
	ret = this->user_lamu_classroom_remembrance.get_remembrances(RECVBUF_USERID, &p_remem_list, &remem_cnt);
	
	uint32_t score_cnt = 0;
	user_lamu_classroom_get_exam_info_out_item *p_score_list = NULL;//学生的毕业成绩
	ret = this->user_lamu_classroom_score.get_exam_score(RECVBUF_USERID, 3, &p_score_list, &score_cnt);

	uint32_t great_cnt = 0;
	user_lamu_classroom_graduate_direction_info graduate_info = {0};
	
	//计算毕业去向
	p_out_header->graduate_time = time(0);
	ret = this->user_lamu_classroom_remembrance.cal_student_graduate(RECVBUF_USERID, graduate_info, 
				p_list, count, p_remem_list, remem_cnt, p_score_list, great_cnt);

	for (uint32_t j = 0; j < graduate_info.count; ++j) {//修改毕业去向
		if (graduate_info.direct_info[j].is_new == 1){
			ret = this->user_lamu_classroom_remembrance.insert(RECVBUF_USERID, graduate_info.direct_info[j].direct_id, 
					graduate_info.direct_info[j].direct_cnt, p_out_header->graduate_time);
		} else {
			ret = this->user_lamu_classroom_remembrance.update_remem_cnt(RECVBUF_USERID, 
					graduate_info.direct_info[j].direct_id, graduate_info.direct_info[j].direct_cnt);
		}
	}
	if (p_list != NULL) {
		free(p_list);
		p_list = NULL;
	}
	if (p_remem_list != NULL) {
		free(p_remem_list);
		p_remem_list = NULL;
	}
	if (p_score_list != NULL) {
		free(p_score_list);
		p_score_list = NULL;
	}
	
	p_out_header->graduate_cnt = count;//毕业人数
	p_out_header->great_cnt = great_cnt;//优秀毕业生人数
	p_out_header->class_flag = 2;

	ret = this->user_lamu_classroom.class_graduate(RECVBUF_USERID, count, great_cnt);
	if (ret == SUCC) {
		change_log_item c_item;
		c_item.userid = RECVBUF_USERID;
		c_item.change_type=202;
		c_item.logtime = time(NULL);
		c_item.change_value = count;
		c_item.change_v1 = great_cnt;
		c_item.change_v2 = 0;
		this->send_log.send(&c_item );
	}

	//毕业后删除相应的信息
	ret = this->user_lamu_classroom_lamu.delete_lamu(RECVBUF_USERID);
	ret = this->user_lamu_classroom_exam.delete_info(RECVBUF_USERID);
	ret = this->user_lamu_classroom_score.delete_score(RECVBUF_USERID);
	ret = this->user_lamu_classroom.get_outstand_sum(RECVBUF_USERID, &(p_out_header->great_sum));
	
	p_out_header->count = graduate_info.count;
	char *p_offset = out + sizeof(*p_out_header);
	memcpy(p_offset,(char*)&(graduate_info.direct_info[0].direct_id), sizeof(user_lamu_graduate_direction) * graduate_info.count);
	p_offset += sizeof(user_lamu_graduate_direction) * graduate_info.count;
	STD_RETURN_WITH_BUF(ret, out, p_offset - out);
}

/*
 * @brief 道具增加每日课时数
 */
int Croute_func::user_lamu_classroom_add_course_cnt(DEAL_FUN_ARG)
{
	user_lamu_classroom_add_course_cnt_in *p_in = PRI_IN_POS; 
	ret = this->user_lamu_classroom.update_today_add(RECVBUF_USERID, p_in->add_cnt);
	STD_RETURN(ret);
}

/*
 * @brief 判断能否用道具增加课时数
 */
int Croute_func::user_lamu_classroom_check_add_course(DEAL_FUN_ARG)
{
	user_lamu_classroom_check_add_course_in *p_in = PRI_IN_POS; 
	ret = this->user_lamu_classroom.check_add_course(RECVBUF_USERID, p_in->add_cnt);	
	STD_RETURN(ret);
}

/*
 * @brief 恢复老师的精力或亲密度
 */
int Croute_func::user_lamu_classroom_recover_teacher_attr(DEAL_FUN_ARG)
{
	user_lamu_classroom_recover_teacher_attr_in *p_in = PRI_IN_POS;
	ret = this->user_lamu_classroom.recover_teacher_attr(RECVBUF_USERID, p_in);
	STD_RETURN(ret);
}

/*
 * @brief 修改学生心情
 */
int Croute_func::user_lamu_classroom_set_lamu_mood(DEAL_FUN_ARG)
{
	user_lamu_classroom_set_lamu_mood_in *p_in = PRI_IN_POS;
	ret = this->user_lamu_classroom_lamu.set_one_lamu_mood(RECVBUF_USERID, p_in);
	STD_RETURN(ret);
}

/*
 * @brief 修改单个学生的属性
 */
int Croute_func::user_lamu_classroom_update_lamu_attr(DEAL_FUN_ARG)
{
	user_lamu_classroom_update_lamu_attr_in *p_in = PRI_IN_POS;
	uint32_t cur_course_id = 0;
	ret = this->user_lamu_classroom.get_int_value(RECVBUF_USERID, "cur_course_id", &cur_course_id);
	ret = this->user_lamu_classroom_lamu.update_one_lamu_attr(RECVBUF_USERID, p_in, cur_course_id);
	STD_RETURN(ret);
}

/*
 * @brief 增加学生的课程掌握情况
 */
int Croute_func::user_lamu_classroom_add_course_score(DEAL_FUN_ARG)
{
	user_lamu_classroom_add_course_score_in *p_in = PRI_IN_POS;
	ret = this->user_lamu_classroom.check_class_course_id(RECVBUF_USERID, p_in->course_id);
	if (ret != SUCC) {
		return ret;
	}
	ret = this->user_lamu_classroom_lamu.add_lamu_course_score(RECVBUF_USERID, p_in);
	if (ret == SUCC) {
		ret = this->user_lamu_classroom.set_cur_course_flag(RECVBUF_USERID);
	}
	STD_RETURN(ret);
}

/*
 * @brief 得到(質量、評分、考評、獲得經驗、獲得獎勵)
 */
int Croute_func::user_lamu_classroom_tw_get_exam_result(DEAL_FUN_ARG)
{
	user_lamu_classroom_tw_get_exam_result_in *p_in = PRI_IN_POS;
	user_lamu_classroom_tw_get_exam_result_out out = {0};
	ret = this->user_lamu_classroom_exam.tw_get_exam_info(RECVBUF_USERID, p_in->exam_times, &out);
	STD_RETURN_WITH_BUF(ret, (char*)&out, sizeof(out) - sizeof(user_exam_prize_list) 
			+ out.prize_list.count * sizeof(user_exam_prize) + sizeof(out.prize_list.count));
}

int Croute_func::userinfo_get_meefan_gameflag(DEAL_FUN_ARG)
{
	userinfo_get_meefan_gameflag_out out={};
	ret = this->user_info.get_meefan_gameflag(RECVBUF_USERID,&out );
	STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * @brief 设置事件次数
 */
int Croute_func::user_lamu_classroom_set_event_cnt(DEAL_FUN_ARG)
{
	user_lamu_classroom_set_event_cnt_in *p_in = PRI_IN_POS; 
	ret = this->user_lamu_classroom.check_class_course_id(RECVBUF_USERID, p_in->course_id, 1);
	if (ret != SUCC) {
		return ret;
	}
	uint32_t lamu_cnt = 0;
	if (p_in->course_id == 14) {//答疑课时要知道学生人数
		ret = this->user_lamu_classroom_lamu.get_lamus_count(RECVBUF_USERID, &lamu_cnt);
	}
	ret = this->user_lamu_classroom.set_event_cnt(RECVBUF_USERID, p_in->course_id, lamu_cnt);
	STD_RETURN(ret);
}

/*
 * @brief 设置拉姆小导师荣誉
 */
int Croute_func::user_lamu_classroom_set_honor_flag(DEAL_FUN_ARG)
{
	user_lamu_classroom_set_honor_flag_in *p_in = PRI_IN_POS; 
	ret = this->user_lamu_classroom.set_honor_flag(RECVBUF_USERID, p_in->index);
	if (ret == SUCC) {
		ret = this->user_lamu_classroom.add_teacher_exp(RECVBUF_USERID, p_in->teach_exp);
		ret = this->user.update_xiaomee_inc(RECVBUF_USERID, p_in->xiaomee);
		if (p_in->diandiandou > 0) {
			user_add_attire_in st_attire_add;
			st_attire_add.attireid = 16012;
			st_attire_add.attiretype = 0;
			st_attire_add.count = p_in->diandiandou;
			st_attire_add.maxcount = 99999999;
			ret = this->user_add_attire(RECVBUF_USERID, &st_attire_add);
		}

		//change log
		change_log_item c_item;
		c_item.userid = RECVBUF_USERID;
		c_item.change_type=203;
		c_item.logtime = time(NULL);
		c_item.change_value = p_in->xiaomee;
		c_item.change_v1 = p_in->teach_exp;
		c_item.change_v2 = p_in->index;
		this->send_log.send(&c_item );
	} else if (ret == USER_LAMU_CLASSROOM_CHECK_HONOR_ERR) {
		ret = SUCC;
	}
	
	STD_RETURN(ret);
}

/*
 * @brief 修改学生的潜力、德智体美劳所有属性
 */
int Croute_func::user_lamu_classroom_add_lamu_attrs(DEAL_FUN_ARG)
{
	user_lamu_classroom_add_lamu_attrs_in *p_in = PRI_IN_POS;
	if(p_in->lamu_id == 0) {
		ret = this->user_lamu_classroom_lamu.add_lamu_attrs(RECVBUF_USERID, p_in);
	} else {
		ret = this->user_lamu_classroom_lamu.add_one_lamu_attrs(RECVBUF_USERID, p_in);
	}
	if (p_in->lovely != 0 && ret == SUCC) {
		user_lamu_classroom_recover_teacher_attr_in add_lovely = {2, p_in->lovely};
		ret = this->user_lamu_classroom.recover_teacher_attr(RECVBUF_USERID, &add_lovely);
	}
	STD_RETURN(ret);
}

/*
 * @brief 竞拍：开始竞拍
 */
int Croute_func::sysarg_auction_begin_auction(DEAL_FUN_ARG)
{
	sysarg_auction_begin_auction_out out = {};
	uint32_t attire_id = 0;
	uint32_t attire_cnt = 0;
	ret = this->sysarg_auction.auction_begin(attire_id, attire_cnt);
	out.attire_id = attire_id;
	out.attire_cnt = attire_cnt;
	out.end_time = 120;
	STD_RETURN_WITH_STRUCT(ret, out);
}

/*
 * @brief 竞拍：添加一条竞拍信息
 */
int Croute_func::sysarg_auction_add_one_record(DEAL_FUN_ARG)
{
	sysarg_auction_add_one_record_in *p_in = PRI_IN_POS; 
	ret = this->sysarg_auction.add_auction_record(RECVBUF_USERID, p_in->xiaomee);
	STD_RETURN(ret);
}

/*
 * @brief 竞拍：得到竞拍的物品id和结束时间
 */
int Croute_func::sysarg_auction_get_attireid_and_time(DEAL_FUN_ARG)
{
	sysarg_auction_get_attireid_and_time_out out = {};
	uint32_t item_id = 0;
	uint32_t end_time = 0;
	uint32_t item_cnt = 0;
	ret = this->sysarg_auction.get_attireid_and_time(item_id, item_cnt, end_time);
	out.attire_id = item_id;
	out.attire_cnt = item_cnt;
	out.end_time = end_time;
	STD_RETURN_WITH_STRUCT(ret, out);
}

/*
 * @brief 竞拍：结束竞拍，返回竞拍成功的用户的id和所出的价格
 */
int Croute_func::sysarg_auction_end_auction(DEAL_FUN_ARG)
{
	sysarg_auction_end_auction_out_header  out_header = {0};
	sysarg_auction_end_auction_out_item *p_out_item = NULL;

	ret = this->sysarg_auction.auction_end(&p_out_item, &out_header);
	if (ret == SUCC){
		for (uint32_t i = 0; i < out_header.count; ++i) {	//竞拍成功的用户要增加猜对的次数
			ret = this->sysarg_contribute_rank.insert((p_out_item + i)->userid, 0, 0, 1);
			if (ret == USER_ID_EXISTED_ERR) {
				ret = this->sysarg_contribute_rank.update((p_out_item + i)->userid, "guess_right_num", 1);
			}
		}
	}
	STD_RETURN_WITH_STRUCT_LIST(ret, out_header, p_out_item, out_header.count);
}

/*
 * @brief 捐款：增加捐款金额、或捐物品数量
 */
int Croute_func::sysarg_contribute_xiamee_insert(DEAL_FUN_ARG)
{
	sysarg_contribute_xiamee_insert_in *p_in = PRI_IN_POS; 
	uint32_t xiaomee = 0;
	uint32_t item_cnt = 0;
	if (p_in->attire_id == 0) {
		xiaomee = p_in->count;
	} else {
		item_cnt = p_in->count;
	}
	ret = this->sysarg_contribute_rank.insert(RECVBUF_USERID, xiaomee, item_cnt, 0);
	if (ret == SUCC) {
		sysarg_contribute_total.update(1, xiaomee / 100, item_cnt);
	} else if (ret == USER_ID_EXISTED_ERR) {
		if (p_in->attire_id == 0) {
			ret = this->sysarg_contribute_rank.update(RECVBUF_USERID, "contri_xiaomee", xiaomee);
		} else {
			ret = this->sysarg_contribute_rank.update(RECVBUF_USERID, "contri_attire", item_cnt);
		}
		sysarg_contribute_total.update(0, xiaomee / 100, item_cnt);
	}
	STD_RETURN(ret);
}

/*
 * @brief 捐款、捐物、及竞拍正确数排名
 */
int Croute_func::sysarg_contribute_get_rank(DEAL_FUN_ARG)
{
	sysarg_contribute_get_rank_in *p_in = PRI_IN_POS; 
	sysarg_contribute_get_rank_out_header out_header = {0};
	sysarg_contribute_get_rank_out_item *p_out_item = NULL;

	char filed[30] = {0};
	switch (p_in->type) {
	case 1:
		strcpy(filed, "contri_xiaomee");
		break;
	case 2:
		strcpy(filed, "contri_attire");
		break;
	case 3:
		strcpy(filed, "guess_right_num");
		break;
	default:
		break;
	}
	ret = this->sysarg_contribute_rank.get_rank(&p_out_item, filed, &(out_header.count));

	STD_RETURN_WITH_STRUCT_LIST(ret, out_header, p_out_item, out_header.count);
}

/*
 * @brief 得到捐赠的总人数，捐钱的人数，捐物的人数
 */
int Croute_func::sysarg_contribute_get_user_count(DEAL_FUN_ARG)
{
	sysarg_contribute_get_user_count_out out = {};
	ret = this->sysarg_contribute_total.get_contribute_total(&out);
	STD_RETURN_WITH_STRUCT(ret, out);
}

/*
 * @brief 得到牧场喂养的动物或家园的种植的植物
 */
int Croute_func::user_get_attireid_and_cnt(DEAL_FUN_ARG)
{
	user_get_attireid_and_cnt_in *p_in = PRI_IN_POS; 
	user_get_attireid_and_cnt_out_header out_header = {0};
	user_get_attireid_and_cnt_out_item *p_out_item = NULL;
	if (p_in->type == 1) {
		ret = this->user_jy.get_jy_attireid_and_cnt(RECVBUF_USERID, &(out_header.count), &p_out_item);
	} else if (p_in->type == 2) {
		ret = this->user_farm_animal.get_animal_attireid_and_cnt(RECVBUF_USERID, &(out_header.count), &p_out_item);
	}
	STD_RETURN_WITH_STRUCT_LIST(ret, out_header, p_out_item, out_header.count);
}

/*
 * @brief 设置联谊用户ID
 */
int Croute_func::set_class_network(DEAL_FUN_ARG)
{
	uint32_t count = 0;
    set_class_network_in *p_in = PRI_IN_POS; 
   	ret = this->user_lamu_classroom_lamu.get_lamus_count(RECVBUF_USERID, &count, 2);
	if(ret != SUCC || count == 0) {
		return USER_NO_STUDENT_ERR;
	}
	ret = this->user_lamu_classroom.set_day_networking_class(RECVBUF_USERID, p_in->userid);
	STD_RETURN(ret);
}

/*
 * @brief user_rank_buf 表中添加记录
 */
int Croute_func::user_set_user_rank_buf(DEAL_FUN_ARG)
{
	user_set_user_rank_buf_in *p_in = PRI_IN_POS;
	users_rank_buf_in p_buf = {0};
	p_buf.count = 1;
	p_buf.users[0].id = p_in->userid;
	p_buf.users[0].date = time(NULL);
	ret = this->user_rank_buf.update_rank_buf(RECVBUF_USERID, p_in->type, p_in->userid);
	if (ret == USER_ID_NOFIND_ERR) {
		ret = this->user_rank_buf.insert(RECVBUF_USERID, p_in->type, &p_buf);
	}
	STD_RETURN(ret);
}

/*
 *@brief sysarg_ranklist表中添加记录
 */
int Croute_func::sysarg_set_ranklist(DEAL_FUN_ARG)
{
	sysarg_set_ranklist_in *p_in = PRI_IN_POS;
	sysarg_get_double_count_in double_count = {p_in->type};
	sysarg_get_double_count_out double_count_out = { 0 };
	ret = this->sysarg_ranklist.get_double_count(RECVBUF_USERID, &double_count, &double_count_out);
	if( ret == USER_ID_NOFIND_ERR ) {
		ret = this->sysarg_ranklist.insert(RECVBUF_USERID, p_in->type, p_in->value);
	} else {
		uint32_t count = double_count_out.count + p_in->value;
		uint32_t dynamic_count = double_count_out.dynamic_count + p_in->value;
		uint32_t datetime = (uint32_t)time(NULL);
		ret = this->sysarg_ranklist.update(RECVBUF_USERID,p_in->type, count, dynamic_count, datetime);
		ret = this->sysarg_top_rank.update(RECVBUF_USERID, p_in->type, count, datetime);
	}

	STD_RETURN(ret);
}

/*
 * @brief 获得排名列表
 */
int Croute_func::sysarg_get_ranklist(DEAL_FUN_ARG)
{
	sysarg_get_ranklist_in *p_in = PRI_IN_POS; 
	sysarg_get_ranklist_out_header out_header = {0};
	sysarg_get_ranklist_out_item *p_out_item = NULL;
	ret = this->sysarg_top_rank.get_top_rank(p_in->type, &p_out_item, &(out_header.all_count));

	out_header.userid = RECVBUF_USERID;
	ret = SUCC;
	STD_RETURN_WITH_STRUCT_LIST(ret, out_header, p_out_item, out_header.all_count);
}


/*
 *@brief 获取苞子花获赠记录
 */
int Croute_func::user_get_recv_record(DEAL_FUN_ARG)
{
	user_get_recv_record_in *p_in = PRI_IN_POS;
	user_rank_buf_out out = {0};
	ret = this->user_rank_buf.get_rank_buf(RECVBUF_USERID , p_in->type, &out);
	ret = SUCC;
	STD_RETURN_WITH_BUF(ret, &out, 4 + sizeof(date_id) * out.count);
}

/*
 *@brief 兑换苞子花
 */
int Croute_func::exchange_flower_to_present(DEAL_FUN_ARG)
{
	exchange_flower_to_present_in *p_in = PRI_IN_POS;
	uint32_t dynamic_count_in_table = 0;
	ret = this->sysarg_ranklist.get_specify_user_dynamic_count(RECVBUF_USERID, &dynamic_count_in_table, p_in->type);
	if (ret != SUCC) {
		return ret;
	}
	if (dynamic_count_in_table < p_in->num) {
		return NUM_OF_SEND_FLOWER_NOT_ENOUGH_ERR;
	}

	ret = this->sysarg_ranklist.exchange_present(RECVBUF_USERID, p_in);
	STD_RETURN(ret);
}

/*
 *@brief 校验
 */
int Croute_func::user_check_out_buf(DEAL_FUN_ARG)                 
{
    user_check_out_buf_in *p_in = PRI_IN_POS; 
	user_rank_buf_out buf = {};
	ret = this->user_rank_buf.clear_buf(RECVBUF_USERID, p_in->type);
	ret = this->user_rank_buf.get_rank_buf(RECVBUF_USERID, p_in->type, &buf);
	if(ret != SUCC) {
		if(ret == USER_ID_NOFIND_ERR) {
			ret = SUCC;
		} else {
			return ret;
		}
	}

	if (p_in->num <= buf.count) {
		return HAS_REACHED_MAX_NUM_ERR;
	} else {
		for (uint32_t i = 0; i < buf.count; ++i) {
			if (p_in->userid == buf.users[i].id) {
				return USER_RANK_BUF_ALREADY_IN_ERR;
			}
	   }
	}
    STD_RETURN(ret);
}

/*
 * @brief 获取历史的总的数量和当前的数量
 */
int Croute_func::sysarg_get_double_count(DEAL_FUN_ARG)
{
	sysarg_get_double_count_in *p_in = PRI_IN_POS; 
	sysarg_get_double_count_out out = {0};
	ret = this->sysarg_ranklist.get_double_count(RECVBUF_USERID, p_in, &out);
	ret = SUCC;
	out.type = p_in->type;
	STD_RETURN_WITH_STRUCT(ret, out);
}

/*
 * @brief 获得当前摇奖次数,如果摇奖次数等于12，则返回1，并且次数清零，
 * 否则，返回0
 */
int Croute_func::roominfo_get_shake_rewards_times(DEAL_FUN_ARG)
{
    roominfo_get_shake_rewards_times_out out = {0};
	uint32_t times = 0;
    ret = this->roominfo_shake_rewards_times.get(RECVBUF_USERID, &times);
	if(times == 11){
		out.flag = 1;
		ret = this->roominfo_shake_rewards_times.clear_times(RECVBUF_USERID);
	}
	ret = SUCC;
    STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * @brief 更新摇奖次数
 */
int Croute_func::roominfo_change_shake_rewards_times(DEAL_FUN_ARG)
{
    ret = this->roominfo_shake_rewards_times.update(RECVBUF_USERID);
	if(ret == USER_ID_NOFIND_ERR){
		ret = this->roominfo_shake_rewards_times.insert(RECVBUF_USERID);
	}
    STD_RETURN(ret);
}

/*
 * @brief 累加米币消耗数量
 */
int Croute_func::roominfo_inc_consume_money(DEAL_FUN_ARG)
{
    roominfo_inc_consume_money_in *p_in = PRI_IN_POS;
    ret = this->roominfo_consume_money.update_inc(RECVBUF_USERID, p_in->value);
	if(ret == USER_ID_NOFIND_ERR){
		ret = this->roominfo_consume_money.insert(RECVBUF_USERID, p_in->value);
	}
    STD_RETURN(ret);
}

/*
 * @brief 由于使用米币消耗量来兑换点点豆，因此使得米币消耗量减少
 */
int Croute_func::roominfo_dec_consume_money(DEAL_FUN_ARG)
{
    roominfo_dec_consume_money_in *p_in = PRI_IN_POS;
	uint32_t value = 0;
    ret = this->roominfo_consume_money.get(RECVBUF_USERID, &value);
	if(value < p_in->value){
		return NOT_ENOUGH_MONEY_TO_EXCHANGE_ERR;
	}
	roominfo_dec_consume_money_out out = { 0 };
	out.value = value - p_in->value;
	ret = this->roominfo_consume_money.update_dec(RECVBUF_USERID, out.value);
    STD_RETURN_WITH_STRUCT(ret, out);
}

/*
 *@brief 获取米币消耗数量 
 */
int Croute_func::roominfo_get_consume_money(DEAL_FUN_ARG)
{
    roominfo_get_consume_money_out out = { 0 };
    ret = this->roominfo_consume_money.get(RECVBUF_USERID, &out.value);
	ret = SUCC;
    STD_RETURN_WITH_STRUCT(ret, out);
}

/*
 *@brief 增加圣诞用户挂的袜子数量
 */
int Croute_func::roominfo_add_christmas_sock(DEAL_FUN_ARG)
{
	roominfo_add_christmas_sock_in *p_in=PRI_IN_POS; 
	uint32_t count = 0;
	uint32_t date = 0;
	uint32_t today_date = p_in->date;

	ret=this->roominfo_sock.get(RECVBUF_USERID, count, date);
	if (ret != SUCC)
	{
		if (ret == USER_ID_NOFIND_ERR)
		{
			ret = this->roominfo_sock.insert(RECVBUF_USERID, p_in->count, today_date);
		}
		else
		{
			return ret;
		}
	}
	else
	{
		if (count >= 5)
		{
			return  ROOMINFO_SOCK_SEND_SOCK_MAX_TODAY_ERR; 
		}
		if ((date != today_date) && (count != 0))
		{
			return 	ROOMINFO_SOCK_CAN_NOT_SEND_SOCK_ERR;
		}
		ret = this->roominfo_sock.update_by_date(RECVBUF_USERID, today_date, p_in->count);
	}

	STD_RETURN(ret);
}

int Croute_func::roominfo_get_christmas_sock_info(DEAL_FUN_ARG)
{
	roominfo_get_christmas_sock_info_out out={};
	uint32_t count = 0;
	uint32_t date = 0;
	ret=this->roominfo_sock.get(RECVBUF_USERID, count, date);
	ret = SUCC;
	out.count = count;
	out.date = date;
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::roominfo_del_christmas_sock_info(DEAL_FUN_ARG)
{
	ret=this->roominfo_sock.del(RECVBUF_USERID);
	ret = SUCC;
	STD_RETURN(ret);
}

/*
 *清空bonus_used
 */
int Croute_func::user_ex_clear_bonus_used(DEAL_FUN_ARG)
{
	ret=this->user_ex.clear_bonus_used(RECVBUF_USERID);
	ret = SUCC;
     STD_RETURN(ret); 
}

/*
 * @brief 增加蛋糕积分
 */
int Croute_func::roominfo_inc_cake_score(DEAL_FUN_ARG)
{
    roominfo_inc_cake_score_in *p_in = PRI_IN_POS;
    ret = this->roominfo_cake.increase(RECVBUF_USERID, p_in->score);
	if(ret == USER_ID_NOFIND_ERR){
		ret = this->roominfo_cake.insert(RECVBUF_USERID, p_in->score);
	}
    STD_RETURN(ret);
}

/*
 * @brief 兑换物品，减少蛋糕积分
 */
int Croute_func::roominfo_dec_cake_score(DEAL_FUN_ARG)
{
    roominfo_dec_cake_score_in *p_in = PRI_IN_POS;
	uint32_t cake_score = 0;
    ret = this->roominfo_cake.query_score(RECVBUF_USERID, &cake_score);
	if(cake_score < p_in->score){
		return  NOT_ENOUGH_CAKE_SCORE_TO_EXCHANGE_ERR;
	}
	cake_score -= p_in->score;
    ret = this->roominfo_cake.update(RECVBUF_USERID, cake_score);
	ret = SUCC;
	STD_RETURN(ret);
}

/*
 * @brief 获取蛋糕积分
 */
int Croute_func::roominfo_get_cake_score(DEAL_FUN_ARG)
{
    roominfo_get_cake_score_out out = {};
    ret = this->roominfo_cake.query_score(RECVBUF_USERID, &out.score);

    STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::roominfo_query_user_cake_info(DEAL_FUN_ARG)
{
	roominfo_query_user_cake_info_in *p_in=PRI_IN_POS; 
	roominfo_query_user_cake_info_out_header  out_header = {0};
	roominfo_query_user_cake_info_out_item *p_out_item = NULL;
	uint32_t cur_date = get_date(time(NULL));
	ret=this->roominfo_user_cake.query_count_state(RECVBUF_USERID, cur_date, &out_header.cnt);
	uint32_t t_count = 0;
	ret=this->roominfo_user_cake.query_count(RECVBUF_USERID, cur_date, &t_count);
	if ((p_in->type == 2) && (t_count == 0) )
	{
		struct tm tm_tmp;
		time_t cur_time = time(NULL);
		localtime_r(&cur_time, &tm_tmp) ;
		uint32_t week_day = tm_tmp.tm_wday;
		uint32_t cakeids[14] = {1351030,1351031,1351032,1351033,1351034,1351035,1351030,
								1351031,1351032,1351033,1351034,1351035,1351030,1351031};

		ret =this->roominfo_user_cake.add_cake(RECVBUF_USERID, cur_date, cakeids[week_day*2]);
		ret =this->roominfo_user_cake.add_cake(RECVBUF_USERID, cur_date, cakeids[week_day*2+1]);
	}
	if (p_in->type == 3)
	{
		ret = this->roominfo_user_cake.get_cake_info(RECVBUF_USERID, &p_out_item, &out_header.count);
	}
	else if (p_in->type == 2)
	{
		ret=this->roominfo_user_cake.get_date_cake_info(RECVBUF_USERID, cur_date, &p_out_item, &out_header.count);
	}
	ret = SUCC;
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

int Croute_func::roominfo_user_do_cake_fin(DEAL_FUN_ARG)
{
	roominfo_user_do_cake_fin_in *p_in=PRI_IN_POS; 
	uint32_t cur_date = get_date(time(NULL));
	uint32_t state = 0;
	uint32_t level = 0;
	ret = this->roominfo_user_cake.get_state_level(RECVBUF_USERID, cur_date, p_in->cakeid, state, level);
	if (ret != SUCC)
	{
		return ret;
	}	
	if (state != 0)
	{
		return	ROOMINFO_CAKE_FIN_DO_CAKE_ERR;
	}

	ret=this->roominfo_user_cake.update_state_level(RECVBUF_USERID, cur_date, p_in->cakeid, 1, p_in->level);

	STD_RETURN(ret);
}

int Croute_func::roominfo_user_send_cake(DEAL_FUN_ARG)
{
	roominfo_user_send_cake_in *p_in=PRI_IN_POS; 
	roominfo_user_send_cake_out out; 
	uint32_t cur_date = get_date(time(NULL));
	uint32_t state = 0;
	uint32_t level = 0;
	ret = this->roominfo_user_cake.get_state_level(RECVBUF_USERID, cur_date, p_in->cakeid, state, level);
	if (ret != SUCC)
	{
		return ret;
	}	
	if (state != 1)
	{
		return	ROOMINFO_CAKE_FIN_SEND_CAKE_ERR;
	}
	uint32_t score = 1;
	if (level == 1)
	{
		score = 1;
	}
	else if (level == 2)
	{
		score = 2;
	}
	else
	{
		score = 3;
	}
	out.level = level;
	ret=this->roominfo_cake.increase(RECVBUF_USERID, score);
	if (ret == USER_ID_NOFIND_ERR)
	{
		ret = this->roominfo_cake.insert(RECVBUF_USERID, score);
	}
	ret=this->roominfo_user_cake.update_state(RECVBUF_USERID, cur_date, p_in->cakeid, 2);
    STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * @brief 增加脚印数
 */
int Croute_func::roominfo_footprint_add(DEAL_FUN_ARG)
{
    roominfo_footprint_add_in *p_in = PRI_IN_POS;
    ret = this->roominfo_footprint.update_inc(RECVBUF_USERID, p_in->count);
	if(ret == USER_ID_NOFIND_ERR){
		ret = this->roominfo_footprint.insert(RECVBUF_USERID, p_in->count);
	}
    STD_RETURN(ret);
}

/*
 * @brief 兑换物品后，减少脚印数
 */
int Croute_func::roominfo_exchange_footprint(DEAL_FUN_ARG)
{
    roominfo_exchange_footprint_in *p_in = PRI_IN_POS;
	uint32_t count = 0;
	ret = this->roominfo_footprint.get_curr_count(RECVBUF_USERID, count);
    if(count < p_in->count){
        return  NOT_ENOUGH_FOOTPRINT_COUNT_TO_EXCHANGE_ERR;
    }
	count -= p_in->count;
    ret = this->roominfo_footprint.update(RECVBUF_USERID, count);
	ret = SUCC;
    STD_RETURN(ret);
}

/*
 * @brief 获取脚印数
 */
int Croute_func::roominfo_get_footprint_count(DEAL_FUN_ARG)
{
    roominfo_get_footprint_count_out out = {};
    ret = this->roominfo_footprint.get_count(RECVBUF_USERID, out);
	ret = SUCC;
    STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * @brief 获取连续礼包登陆信息
 */
int Croute_func::roominfo_query_login_gifts(DEAL_FUN_ARG)
{
    roominfo_query_login_gifts_out out={1, 1, 1, 0, 0};
	uint32_t today  = get_date(time(NULL));
    ret = this->roominfo_login_gifts.query(RECVBUF_USERID, &out);
	if(ret != SUCC){
		if(ret == USER_ID_NOFIND_ERR){
			out.flag = 1;
			out.date = today;
			ret = this->roominfo_login_gifts.insert(RECVBUF_USERID, out.count, out.total, out.round);	
		}
	}else{
		if(out.date != today){
			ret = this->roominfo_login_gifts.update(RECVBUF_USERID, &out);
		}
	}
	ret = SUCC;
    STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::roominfo_get_train_kakunian_info(DEAL_FUN_ARG)
{
	roominfo_get_train_kakunian_info_out out={0};
	uint32_t count = 0;
	ret=this->roominfo_kakunian.get(RECVBUF_USERID, count);
	out.count = count;
	ret = SUCC;
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::roominfo_set_train_kakunian_count(DEAL_FUN_ARG)
{
	roominfo_set_train_kakunian_count_in *p_in=PRI_IN_POS; 
	if (p_in->flag > 0)
	{
		ret=this->roominfo_kakunian.del(RECVBUF_USERID);
	}
	else
	{
		ret=this->roominfo_kakunian.update(RECVBUF_USERID, 1);
		if (ret == USER_ID_NOFIND_ERR)
		{
			ret=this->roominfo_kakunian.insert(RECVBUF_USERID, 1);
		}
	}
	STD_RETURN(ret);
}

/*
 * @brief 获取星级动物列表
 */
int Croute_func::user_farm_get_fairy(DEAL_FUN_ARG)
{
	user_farm_get_fairy_out_header  out_header;
	out_header.count = 0;
	user_farm_get_fairy_out_item *p_out_item;
	ret = this->user_farm_fairy.get_fairy_list(RECVBUF_USERID, &p_out_item, &out_header.count);
	if(ret == SUCC){
		for(uint32_t i = 0; i< out_header.count; ++i){
			ret = this->user_farm_fairy_skill.get_user_animal_skill_list(RECVBUF_USERID, 
					(p_out_item + i)->id, (p_out_item + i)->spells, &((p_out_item + i)->spell_count));

		}
	}

	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);

}

/*
 * @brief 加速动物成长
 */
int Croute_func::user_farm_speed_animal_growth(DEAL_FUN_ARG)
{
    user_farm_speed_animal_growth_in *p_in=PRI_IN_POS;
	user_farm_speed_animal_growth_out out = {0};
	uint32_t date = 0;
	uint32_t eat_count = 0;
	bool if_used = true;
	ret = this->user_farm_speed_tool.get_date_count(RECVBUF_USERID, p_in->id, p_in->toolid, eat_count, date);
	if(ret == USER_ID_NOFIND_ERR){
		if_used = false; 
	}
	uint32_t now = time(0);
	if(date == ((uint32_t)get_date(now)) && eat_count >= p_in->max_count){
		return REACHED_EVERYDAY_FEED_MAX_TIMES_ERR;
	}
	uint32_t tool_count = 0;
	ret = this->user_attire.get_count(RECVBUF_USERID, p_in->toolid, tool_count);
	if(tool_count < 1 ){
		return NOT_ENOUGH_TOOL_FEED_IN_ERR;
	}
	uint32_t up_growth_value = 0;
	if(p_in->type == 1){
		up_growth_value = p_in->value ;
	}
	uint32_t output = 0;
	user_farm_speed_animal_growth_out *p_tmp = new user_farm_speed_animal_growth_out;
	if(p_tmp == 0){
		return SUCC;
	}
	ret = this->user_farm_animal.speed_cal_growth(RECVBUF_USERID, p_in->id, p_tmp,  up_growth_value, output);
	memcpy((char*)(&out), (char*)p_tmp, sizeof(user_farm_speed_animal_growth_out));
	if (output != 0)
	{
		ret = this->user_get_farm_inner(RECVBUF_USERID, p_tmp, 0, output);
		if(ret != SUCC){
			if(p_tmp != 0){
				delete p_tmp;
				p_tmp = 0;
			}
			return ret;
		}
		else{
			delete p_tmp;
		}
	}
	if(p_tmp != 0){
		delete p_tmp;
		p_tmp = 0;
	}
	//扣除道具
	//tool_count -= 1;
	//if(tool_count == 0){
		//ret = this->user_attire.remove(RECVBUF_USERID, p_in->toolid);
	//}else{
		//ret = this->user_attire.update_count(RECVBUF_USERID, p_in->toolid, -1);
	//}

	user_del_attire_in del_item;
	del_item.attireid = p_in->toolid;
	del_item.attiretype = 0;
	del_item.count = 1;
	del_item.maxcount = 99999;
	ret=this->user_del_attire(RECVBUF_USERID ,&del_item);

	//道具使用表中记录
	eat_count += 1;
	if(if_used){
		ret = this->user_farm_speed_tool.update(RECVBUF_USERID,p_in->id, p_in->toolid, eat_count, (uint32_t)get_date(now));
	}else{
		ret = this->user_farm_speed_tool.insert(RECVBUF_USERID,p_in->id, out.animal_id, p_in->toolid, 
				eat_count, (uint32_t)get_date(now));
	}
	//DEBUG_LOG("====: %u",out.animal_id);
	STD_RETURN_WITH_STRUCT(ret,out);	
}

/*
 * @brief 获取某一星级动物技能信息
 */
int Croute_func::user_fairy_skill_get_info(DEAL_FUN_ARG)
{
    user_fairy_skill_get_info_in *p_in=PRI_IN_POS;
    user_fairy_skill_get_info_out_header  out_header;
    user_fairy_skill_get_info_out_item *p_out_item;
    ret=this->user_farm_fairy_skill.get_animalid_all_skill_info(RECVBUF_USERID, p_in->id, &p_out_item, &out_header.count);
    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/*
 * @brief 更新星级动物某一技能信息
 */
int Croute_func::user_fairy_skill_update_info(DEAL_FUN_ARG)
{
    user_fairy_skill_update_info_in *p_in=PRI_IN_POS;
    user_fairy_skill_update_info_out out={0};
	uint32_t old_date = 0;
    ret=this->user_farm_fairy_skill.get_animal_one_skill_info(RECVBUF_USERID, p_in->id, 
			p_in->skillid, &out, &old_date);
    uint32_t now = (uint32_t)time(0);
    out.id = p_in->id;
    out.skillid = p_in->skillid;
    out.type = p_in->type;
    if(ret == USER_ID_NOFIND_ERR){
        uint32_t animal_id = 0;
        ret = user_farm_fairy.get_fairyid(RECVBUF_USERID,p_in->id, animal_id);
        if(ret == USER_ID_NOFIND_ERR){
            return ret;
        }
        out.used_count = 1;
        out.cold_time = 0;
        ret = user_farm_fairy_skill.insert(RECVBUF_USERID, p_in->id, animal_id, p_in->skillid, now,
                1, p_in->type, (uint32_t)get_date(now));

    }else{
        uint32_t diff_time = now - out.cold_time;
		uint32_t update_cold_time = out.cold_time;
		out.cold_time = diff_time;
        if(diff_time > p_in->cold_time){
            switch(p_in->type)
                {
                    case 1://1表示每天使用次数限制的技能类型
                        {
                            if(old_date == (uint32_t)get_date(now)){
                                if(out.used_count < p_in->max_count){
                                    out.used_count += 1;
                                    update_cold_time = now;
                                }else{
                                    return REACHED_MAX_SPELL_USED_TIMES_ERR;
							  }

                            }else{
                                out.used_count = 1;
                                update_cold_time = now;
                            }
                            break;
                        }
                    case 2://2表示终身使用次数限制的技能类型
                        {
							if(out.used_count < p_in->max_count){
								out.used_count += 1;
								update_cold_time = now;
							}else{
								return REACHED_MAX_SPELL_USED_TIMES_ERR;
							}
							break;
                        }
                    default: break;
                }

            ret = user_farm_fairy_skill.update_animal_one_skill(RECVBUF_USERID, p_in, out.used_count, 
					update_cold_time, (uint32_t)get_date(now));

        }else{
            return  NOT_REACHED_COLD_TIME_ERR;
        }
    }//else

    STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * @brief 获取星级动物的成长值
 */
int Croute_func::user_fairy_get_growth(DEAL_FUN_ARG)
{
    user_fairy_get_growth_in *p_in=PRI_IN_POS;
    user_fairy_get_growth_out out={ 0 };
	out.id = p_in->id;
    ret=this->user_farm_animal.get_growth_level(RECVBUF_USERID, p_in->id, &out);
	if(ret == RECORD_NOT_EXIST_ERR){
		out.if_mature = 1;
		uint32_t animal_id = 0;
		uint32_t level = 0;
		ret = user_farm_fairy.get_fairy(RECVBUF_USERID, p_in->id, animal_id, level);
		if(ret == SUCC){
			out.animal_id = animal_id;
			out.level = level;
		}else{
			return ret;
		}
	}
	
    STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * @brief 累加全服技能使用次数
 */
int Croute_func::sysarg_add_skill_count(DEAL_FUN_ARG)
{
	sysarg_add_skill_count_in *p_in = PRI_IN_POS; 
	sysarg_add_skill_count_out out = {0};
	ret = this->sys_arg.add_value(1100, p_in->count);
	int total = 0;
	int flag = 0;
	ret = this->sys_arg.get_value(1100, &total);
	ret = this->sys_arg.get_value(1101, &flag);
	if(ret != SUCC){
		ret = this->sys_arg.add_value(1101, 0);
	}

	int num = total/5000;	
	if (num != flag && num != 0)
	{
		if (total < 50000)
		{
			ret = this->sys_arg.set_value(1101, num);
			ret = this->sys_arg.set_value(1102, 1000);
			out.prize_flag = num;
		}
		else{
			ret = this->sys_arg.set_value(1100, total % 50000);
			ret = this->sys_arg.set_value(1101, num);
			ret = this->sys_arg.set_value(1102, 10000);
			out.prize_flag = num;
		}

	}
	out.total = total % 50000;
	STD_RETURN_WITH_STRUCT(ret, out);
}

/*
 * @brief 全服技能使用次数达到限定数量后，后送出礼物，更新玩家
 * 争抢后的礼物个数
 */
int Croute_func::sysarg_update_skill_count(DEAL_FUN_ARG)
{
	sysarg_update_skill_count_out out = { 0 };
	int present_count = 0;
	int prize_flag = 0;
	ret = this->sys_arg.get_value(1102, &present_count);
	ret = this->sys_arg.get_value(1101, &prize_flag);
	if(present_count <= 0){
		return NOT_ENOUGH_SKILL_PRESENT_COUNT_ERR;
	}
	out.prize_flag = (uint32_t)prize_flag;
	ret=this->sys_arg.set_value(1102, present_count - 1);
	STD_RETURN_WITH_STRUCT(ret, out);

}

/*
 * @brief 查询玩家极品圣光兽的个数
 */
int Croute_func::user_farm_get_super_animal_count(DEAL_FUN_ARG)
{
    user_farm_get_super_animal_count_out out={0};
	uint32_t count = 0;
    ret=this->user_farm.get_count(RECVBUF_USERID, count);
	ret = SUCC;
	out.count = count;
    STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * @brief 获得全服技能使用信息
 */
int Croute_func::sysarg_get_skill_use_info(DEAL_FUN_ARG)
{
    sysarg_get_skill_use_info_out out={0};
	int skill_count = 0;
	int prize_flag = 0;
	int prize_count = 0;
    ret= this->sys_arg.get_value(1100, &skill_count);
	ret= this->sys_arg.get_value(1101, &prize_flag);
	ret= this->sys_arg.get_value(1102, &prize_count);
	ret = SUCC;
	out.skill_count = skill_count;
	if(prize_flag < 10)
		prize_flag = 1;
	else
		prize_flag = 2;
	out.prize_flag = prize_flag;
	out.prize_count = prize_count; 
    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 进入天使乐园
 */
int Croute_func::user_get_paradise(DEAL_FUN_ARG)
{
    user_get_paradise_in *p_in=PRI_IN_POS;
	char out[PROTO_MAX_LEN]={0};
    user_get_paradise_out_header  out_header;
    user_get_paradise_out_item *p_out_item;
	paradise_item p_single ={0};
	uint32_t unsuccess_count = 0;
    uint32_t rets =this->user_paradise.get_all(RECVBUF_USERID, &p_single.nimbus, &p_single.exp, &p_single.limit_count,
			&p_single.level, &(p_single.attire_list), &unsuccess_count, &p_single.exhibit_angelid, p_in->layer);
	bool is_vip;
	ret=this->user_ex.get_vip(RECVBUF_USERID, &is_vip );
	if(ret != SUCC){
		return ret;
	}
	if(rets == USER_ID_NOFIND_ERR){
		ret = this->user_paradise.insert(RECVBUF_USERID, is_vip);
		if(ret != SUCC){
			return ret;
		}
		ret=this->user_paradise.get_all(RECVBUF_USERID, &p_single.nimbus, &p_single.exp, &p_single.limit_count,
             &p_single.level, &(p_single.attire_list), &unsuccess_count, &p_single.exhibit_angelid, p_in->layer);
	}
	
	//下面判断用户是否降星级，来确定用户种植上限
	{	
		uint32_t ret_limit = 0;
		ret = this->user_paradise.get_limit_count(RECVBUF_USERID, ret_limit);
		uint32_t config_limit = 0;
		ret = this->user_paradise.get_config_plant_limit(RECVBUF_USERID, p_single.level,
				is_vip, config_limit);
		ret = this->user_paradise.update_limit_count(RECVBUF_USERID, config_limit);
		p_single.limit_count = config_limit;
		DEBUG_LOG("limit_count :====: %u, config_count: %u", p_single.limit_count, config_limit);
	}
	ret = this->user_paradise_angel.get_all(RECVBUF_USERID, &p_out_item, &out_header.count, p_in->layer);
	if(ret != SUCC){
		free(p_out_item);
		return ret;
	}
	std::random_shuffle(p_out_item, p_out_item + out_header.count);
	uint32_t count_1 = 0, count_2 = 0;
	ret = this->user_paradise_contract.get_angelid_speci(RECVBUF_USERID, 1354134, count_1);
	ret = this->user_paradise_contract.get_angelid_speci(RECVBUF_USERID, 1354135, count_2);
	DEBUG_LOG("lcount_1 :====: %u, count_2: %u", count_1, count_2);
	for(uint32_t i = 0; i < out_header.count; ++i){
		ret = this->user_paradise_angel.cal_list(RECVBUF_USERID, p_out_item + i, &p_single.nimbus, &unsuccess_count, count_1, count_2);
		if( ret != SUCC){
			return ret;
		}
	}
	ret = this->user_paradise.update_nimbus(RECVBUF_USERID,p_single.nimbus);
	ret = this->user_paradise.update_unsuccess(RECVBUF_USERID, unsuccess_count);
	user_get_paradise_tmp *p_temp = (user_get_paradise_tmp*)out;
	char * p_offset = out;
	paradise_ret_tmp temp = {0};
	for(uint32_t i = 0; i< p_single.attire_list.count ; ++i){
		temp.used_attirelist.item[i] = p_single.attire_list.item[i].attireid;
	}
	p_temp->is_vip = (is_vip == true ? 1: 0);
	p_temp->layer = p_in->layer;
	p_temp->nimbus = p_single.nimbus;
	p_temp->exp = p_single.exp;
	p_temp->level = p_single.level;
	p_temp->limit_count = p_single.limit_count;
	p_temp->exhibit_angelid = p_single.exhibit_angelid;
	p_temp->attire_count = p_single.attire_list.count;
	p_temp->angel_count =  out_header.count;
	ret = this->user_paradise_contract.get_contract_angel_count(RECVBUF_USERID, &(p_temp->contract_count));
	ret = SUCC;
	if(p_single.attire_list.count != 0){
		memcpy(out + 40, temp.used_attirelist.item, sizeof(uint32_t) * p_single.attire_list.count);
	}
	p_offset = out + sizeof(uint32_t) * p_single.attire_list.count + 40 ;
	if(out_header.count != 0){
		memcpy(p_offset, (char *)(p_out_item), sizeof(user_get_paradise_out_item) * out_header.count);
	}
	free(p_out_item);
	p_offset += sizeof(user_get_paradise_out_item) * out_header.count;

	STD_RETURN_WITH_BUF(ret,out, p_offset - out);
}
/*
 * 更换天使乐园背景
 */
int Croute_func::user_change_paradise_backgound(DEAL_FUN_ARG)
{
    user_change_paradise_backgound_in *p_in = PRI_IN_POS;
	uint32_t count = 0;
	ret = this->user_attire.get_count(RECVBUF_USERID, p_in->background_id, count);
	if(ret != SUCC){
		return ret;
	}
	//开启事务
    STD_CLOSE_AUTOCOMMIT(ret);
    if(ret!=SUCC) return ret;

	user_del_attire_in del_item;
	del_item.attireid = p_in->background_id;
	del_item.attiretype = 0;
	del_item.count = 1;
	del_item.maxcount = 99999;
	ret=this->user_del_attire(RECVBUF_USERID ,&del_item);

	if(ret == SUCC){
		uint32_t background = 0;
		ret = this->user_paradise.update_paradise_background(RECVBUF_USERID, p_in->background_id, 
				0, &background, p_in->layer);

		if(ret == SUCC){
			//ret = this->user_attire.insert(RECVBUF_USERID, background, 0, 1);
			//if( ret != SUCC){
				//ret = this->user_attire.update_count(RECVBUF_USERID,  background, 1);
			//}
			user_add_attire_in  add_item = {0};
			add_item.attiretype = 0;
			add_item.attireid = background;
			add_item.count = 1;
			add_item.maxcount = 99999;
			ret = this->user_add_attire(RECVBUF_USERID, &add_item);
		}
	}
    if(ret==SUCC){
        //提交
        STD_COMMIT(ret);
    }else{
        //回滚
        STD_ROLLBACK();
    } 
    //关闭事务
    STD_OPEN_AUTOCOMMIT() ;	

    STD_RETURN (ret);
}
/*
 * 种植天使种子
 */
int Croute_func::user_change_angel_pos(DEAL_FUN_ARG)
{
	char ret_out[PROTO_MAX_LEN]={ };
    user_change_angel_pos_in *p_in=PRI_IN_POS;
	user_change_angel_pos_out out={ };
	const uint32_t start_pos = 0;
	uint32_t ret_limit = 0; 
	ret = this->user_paradise.get_limit_count(RECVBUF_USERID,  ret_limit);

	bool is_vip;
    ret=this->user_ex.get_vip(RECVBUF_USERID, &is_vip );
    if(ret != SUCC){
        return ret;
    }		
	uint32_t end_pos = 0;
	if(is_vip){
		end_pos = (ret_limit > 3 ? ret_limit - 3 : 0); 
		
	}
	else{
		end_pos = ret_limit;
	}
	uint32_t max_plant  = 12;
	if((p_in->position < start_pos || p_in->position >= end_pos) && (p_in->position >= max_plant + 3 || 
				p_in->position < max_plant) ){
		return NOT_CORRECT_POS_ERR;
	}
	user_angel_pos_item_list positions ={ 0};
	ret = this->user_paradise_angel.get_all_angel_pos(RECVBUF_USERID, positions.pos, &positions.count, 300);
	if(ret != SUCC){
		return ret;
	}
	uint32_t  *ps_where = std::find(positions.pos, positions.pos + positions.count, p_in->position);
	if(ps_where < positions.pos + positions.count){
		return THE_POSITON_ALREADY_HAVE_A_ANGEL_SEED_ERR;
	}	
	uint32_t angelid_count = 0;
	ret = this->user_attire.get_count(RECVBUF_USERID, p_in->angelid, angelid_count);
	if(angelid_count == 0){
		return ATTIRE_COUNT_NO_ENOUGH_ERR;
	}
	else{
		//if(angelid_count > 1){
			//uint32_t res_count = angelid_count - 1;
			////ret = this->user_attire.update_count(RECVBUF_USERID, p_in->angelid, -1 );
			//ret = this->user_attire.update(RECVBUF_USERID, p_in->angelid, 0, res_count);
		//}
		//else if (angelid_count == 1){
			//ret = this->user_attire.remove(RECVBUF_USERID, p_in->angelid);
		//}
		
		user_del_attire_in del_item;
		del_item.attireid = p_in->angelid;
		del_item.attiretype = 0;
		del_item.count = 1;
		del_item.maxcount = 99999;
		ret=this->user_del_attire(RECVBUF_USERID ,&del_item);
	}
	
    ret=this->user_paradise_angel.insert(RECVBUF_USERID, p_in->angelid, p_in->position, 300);
	if(ret != SUCC){
		return ret;
	}
	ret = this->user_paradise_angel.get_angel_by_position(RECVBUF_USERID, p_in->position, &out );
	memcpy(ret_out,(char*)(&out), sizeof(out));
	char *p_offset = ret_out + sizeof(out);

	//uint32_t first = 0;
	//ret = this->user_paradise.get_plant_first(RECVBUF_USERID, first);
	//if(first == 0){
		//id_list friendlist;
		//uint32_t  private_size;
		//ret=this->user_ex.get_idlist(RECVBUF_USERID ,FRIEND_LIST_STR, &friendlist);
		//private_size=sizeof(friendlist)-(FRIEND_COUNT_MAX -friendlist.count)*sizeof(friendlist.item[0]);
		//memcpy(p_offset,(char*)(&friendlist), private_size);
		//p_offset += private_size;
		//ret = this->user_paradise.update_plant_first(RECVBUF_USERID, 1);
	//}
	//else{
		*((uint32_t*)p_offset) = 0;
		p_offset += 4;
		//}
	
	STD_RETURN_WITH_BUF(ret,ret_out, p_offset - ret_out);
}

/*
 * 补充灵气
 */
int Croute_func::user_paradise_set_nimbus(DEAL_FUN_ARG)
{
    user_paradise_set_nimbus_in *p_in=PRI_IN_POS;
	user_paradise_set_nimbus_out out={ };
	uint32_t count = 0;
    ret=this->user_attire.get_count(RECVBUF_USERID, p_in->attireid, count);
	if(ret != SUCC){
		return ret;
	}
	if(count < p_in->count){
		return NOT_ENOUGH_ATTIRE_ERR;
	}
	//if(count == p_in->count){
		//ret = this->user_attire.remove(RECVBUF_USERID, p_in->attireid);
	//}
	//else{
		////ret = this->user_attire.update_count(RECVBUF_USERID, p_in->attireid, -p_in->count);
		//uint32_t res_count = count - p_in->count;
		//ret = this->user_attire.update(RECVBUF_USERID, p_in->attireid, 0, res_count);
	//}	
	
	user_del_attire_in del_item;
	del_item.attireid=p_in->attireid;
	del_item.attiretype=0;
	del_item.count=p_in->count;
	del_item.maxcount=99999;
	ret=this->user_del_attire(RECVBUF_USERID ,&del_item);

	uint32_t after_inc_nimbus = 0;
	ret = this->user_paradise.get_nimbus(RECVBUF_USERID, after_inc_nimbus);
	uint32_t inc_nimbus =0;
	ret = this->user_paradise.exchange_attire_to_nimbus(p_in->attireid, inc_nimbus);
	if(ret != SUCC){
		return ret;
	}
	uint32_t level = 0;
	ret = this->user_paradise.get_level(RECVBUF_USERID, level);
	if(ret != SUCC){
		return ret;
	}
	after_inc_nimbus += inc_nimbus * p_in->count;
    ret=this->user_paradise.update_nimbus(RECVBUF_USERID, after_inc_nimbus, level);
	if(ret != SUCC){
		return ret;
	}
	out.nimbus_count = after_inc_nimbus;

    STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * 签订契约
 */
int Croute_func::user_angel_sign_contract(DEAL_FUN_ARG)
{
    user_angel_sign_contract_in *p_in=PRI_IN_POS;
	user_angel_sign_contract_out out = {0}; 
	uint32_t growth = 0, angelid = 0, variate_id = 0, variate_flag = 0;
	ret = this->user_paradise_angel.get_angelid_growth_variate(RECVBUF_USERID, p_in->id, &angelid,
		   &growth, &variate_id, &variate_flag);
	if(ret != SUCC){
		return ret;
	}
	//out.angelid = p_in->id;
	bool flag_mature = this->user_paradise_angel.if_mature(angelid, growth);
	if(!flag_mature){
		return THE_ANGEL_NOT_MATURE_ERR;
	}
	out.angelid = p_in->id;
	ret = this->user_paradise_angel.free_angel(RECVBUF_USERID, p_in->id);
	if(ret != SUCC){
		return ret;
	}
	//if(variate_flag == 2 || variate_flag == 3){//2表示坐骑
	if((variate_flag & 0x02) == 0x02){//2表示坐骑
		uint32_t dragonid = 0;
		ret = this->user_paradise_contract.mapping_to_dragon(variate_id, &dragonid);
		if(ret != SUCC){
			return ret;
		}
		ret = this->user_angel_add_dragon(RECVBUF_USERID, dragonid);
		if(ret != USER_ID_EXISTED_ERR && ret != SUCC){
            return ret;
        }
	}
	ret = this->user_paradise_contract.sign_contract(RECVBUF_USERID, variate_id, 1, variate_flag);
	ret = this->user_angel_statistics.update(RECVBUF_USERID, variate_id, 1);
	if(ret == USER_ID_NOFIND_ERR){
		ret = this->user_angel_statistics.insert(RECVBUF_USERID, variate_id,variate_flag, 1);
	}
	
	ret = this->user_cal_new_paradise_honor(RECVBUF_USERID );
	//change log
		change_log_item c_item;
		c_item.userid = RECVBUF_USERID;
		c_item.change_type=204;
		c_item.logtime = time(NULL);
		c_item.change_value = p_in->id;
		c_item.change_v1 = angelid;
		c_item.change_v2 = variate_id;
		this->send_log.send(&c_item );

	//如果使用了加速道具，签约后将该天使种子在加速道具表中的记录删除掉
	ret = this->user_farm_speed_tool.del_record(RECVBUF_USERID, p_in->id);
	ret = SUCC;
	//升级
	uint32_t old_level = 0;
	ret = this->user_paradise.get_level(RECVBUF_USERID, old_level);
	uint32_t exp_inc = 0;
	ret = this->user_paradise_angel.get_increase_exp(angelid, &exp_inc);
	ret = this->user_paradise.update_level_exp(RECVBUF_USERID, exp_inc, &out.level, &out.exp, old_level);
	if(old_level < out.level){ //等级增加后，增加种植上限
		//更新种植上限
		bool is_vip;
		ret = this->user_ex.get_vip(RECVBUF_USERID, &is_vip);
		ret=this->user_paradise.update_limit_count_inc(RECVBUF_USERID, out.level, is_vip);	
		if(ret != SUCC){
			return ret;
		}
	}

  //玩家天使荣誉
	user_angel_statistic_stru *p_item = 0;
	uint32_t total_sort = 0;
	ret = this->user_angel_statistics.get_all(RECVBUF_USERID, &p_item, &total_sort);
	if(ret != SUCC){
		if(p_item != 0){
			free(p_item);
		}
	}
	else{
		uint32_t *p_out = 0;
		uint32_t honor_count = 0;
		ret = this->user_angel_honor.get_honor_ids(RECVBUF_USERID, 1, &p_out, &honor_count);
		if(ret != SUCC){
			if(p_out != 0){
				free(p_out);
			}
		}	
		this->user_cal_paradise_honor(RECVBUF_USERID, out.level, &out.honor_type, &out.honor_id,
			variate_id, 0,  p_item, total_sort, 0, p_out, honor_count);
		free(p_out);
	}
	ret = SUCC;

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 天使园荣誉2
 */
int Croute_func::user_cal_new_paradise_honor(userid_t userid )
{
	const uint32_t honor_type = 1;
	uint32_t cnt  = 0;
	ret = this->user_angel_honor.get_new_locks_cnt(userid,  &cnt);
	if(cnt < 7){
		user_angel_statistic_stru *p_item = 0;
		uint32_t total_sort = 0;
		ret = this->user_angel_statistics.get_all(userid, &p_item, &total_sort);
		if(ret != SUCC){
			if(p_item != 0){
				free(p_item);
			}
		}

		//炽天使
		uint32_t arr_1[] = {
		1353403,1353405,1354047,1354067,1354077,1354090,1354102,1354134,1354135,1354146,1354148,1354150,1354159,1354169,1354171,
		1354173,1354177,1354183,1354185,1354189,1354199,1354205,1354209,1354217
		};

		//大天使
		uint32_t arr_2[] = {
			1353401,1353414,1353416,1354033,1354158
		};

		//权天使
		uint32_t arr_3[] = {
		1353402,1353404,1353406,1353420,1353421,1353419,1353423,1353425,1353426,1353428,1353430,1353432,1354034,1354036,1354038,
		1354040,1354042,1354044,1354046,1354048,1354050,1354051,1354052,1354053,1354054,1354055,1354056,1354057,1354058,1354060,
		1354062,1354064,1354066,1354068,1354070,1354072,1354074,1354076,1354078,1354080,1354082,1354084,1354086,1354088,1354092,
		1354093,1354094,1354095,1354096,1354099,1354101,1354105,1354107,1354109,1354111,1354113,1354115,1354117,1354119,1354121,
		1354103,1354123,1354125,1354127,1354131,1354129,1354133,1354137,1354139,1354141,1354143,1354145,1354147,1354149,1354151,
		1354160,1354164,1354166,1354168,1354170,1354172,1354174,1354176,1354178,1354180,1354182,1354184,1354186,1354188,1354153,
		1354190,1354192,1354196,1354194,1354200,1354202,1354198,1354204,1354155,1354157,1354208,1354206,1354210,1354212,1354214,
		1354216
		};

		//力天使
		uint32_t arr_4[] = {
		1353407,1353408,1353409,1353410,1353411,1353412,1353413,1353415,1353418,1353422,1353424,1353417,1353427,1353429,1353431,
		1354035,1354037,1354039,1354097,1354041,1354043,1354045,1354049,1354059,1354061,1354063,1354065,1354069,1354071,1354073,
		1354075,1354079,1354081,1354083,1354085,1354087,1354089,1354091,1354098,1354100,1354104,1354106,1354108,1354110,1354112,
		1354114,1354116,1354118,1354120,1354122,1354124,1354126,1354130,1354128,1354132,1354136,1354138,1354140,1354142,1354144,
		1354161,1354163,1354165,1354167,1354175,1354179,1354181,1354187,1354191,1354195,1354193,1354201,1354197,1354203,1354152,
		1354154,1354156,1354207,1354211,1354213,1354215
		};

		uint32_t angel_cnt_1 = 0; //炽天使个数
		uint32_t angel_cnt_2 = 0; //大天使个数	
		uint32_t angel_cnt_3 = 0;//权天使个数
		uint32_t angel_cnt_4 = 0;//力天使个数
		for(uint32_t k = 0; k < total_sort; ++k){
			uint32_t *iter_1 = std::find(arr_1, arr_1+sizeof(arr_1)/sizeof(uint32_t), (p_item+k)->angelid);
			if(iter_1 != arr_1+sizeof(arr_1)/sizeof(uint32_t)){
				++angel_cnt_1; 	
				continue;
			}
			uint32_t *iter_2 = std::find(arr_2, arr_2+sizeof(arr_2)/sizeof(uint32_t), (p_item+k)->angelid);
			if(iter_2 != arr_2+sizeof(arr_2)/sizeof(uint32_t)){
				++angel_cnt_2;
				continue;
			}
			uint32_t *iter_3 = std::find(arr_3, arr_3+sizeof(arr_3)/sizeof(uint32_t), (p_item+k)->angelid);
			if(iter_3 != arr_3+sizeof(arr_3)/sizeof(uint32_t)){
				++angel_cnt_3;
				continue;
			}
			uint32_t *iter_4 = std::find(arr_4, arr_4+sizeof(arr_4)/sizeof(uint32_t), (p_item+k)->angelid);
			if(iter_4 != arr_4+sizeof(arr_4)/sizeof(uint32_t)){
				++angel_cnt_4;
			}
		}//for

		if(p_item != 0){
			free(p_item);
		}
		if(angel_cnt_1 >= 10){
			ret = this->user_angel_honor.insert(userid, honor_type, 7, 1, 0);
		}	
		if(angel_cnt_1 >= 15){
			ret = this->user_angel_honor.insert(userid, honor_type, 8, 1, 0);
		}
		if(angel_cnt_2 >= 4){
			ret = this->user_angel_honor.insert(userid, honor_type, 9, 1, 0);
		}
		if(angel_cnt_3 >= 40){
			ret = this->user_angel_honor.insert(userid, honor_type, 10, 1, 0);
		}
		if(angel_cnt_3 >= 60){
			 ret = this->user_angel_honor.insert(userid, honor_type, 11, 1, 0);
		}
		if(angel_cnt_4 >= 30){
			ret = this->user_angel_honor.insert(userid, honor_type, 12, 1, 0);
		}
		if(angel_cnt_4 >= 50){
			ret = this->user_angel_honor.insert(userid, honor_type, 13, 1, 0);
		}
	}

	return 0;
}
/*
 * 天使园荣誉
 */
int Croute_func::user_cal_paradise_honor(userid_t userid, uint32_t level, uint32_t *ret_type,
		uint32_t *honor_id, uint32_t angelid, uint32_t angel_count, user_angel_statistic_stru *p_item, 
		uint32_t total_sort, uint32_t first, uint32_t *p_list, uint32_t honor_num)
{
	const uint32_t honor_type = 1;

	//天使园达人
	if(level >= 20){
		uint32_t *it = std::find(p_list, p_list + honor_num, 1);
		if(it == p_list + honor_num){
			ret = this->user_angel_honor.insert(userid, honor_type, 1, 1, 0);
			if(*ret_type == 0){
				*ret_type = honor_type;
				*honor_id = 1;
			}
			msglog(this->msglog_file, 0x0406FAD5 + 1,time(NULL), &(userid), 4);
		}//if
	}

	//天使鉴赏家
	if(total_sort >= 60){
		uint32_t *it = std::find(p_list, p_list + honor_num, 2);
		if(it == p_list + honor_num){
			ret = this->user_angel_honor.insert(userid, honor_type, 2, 1, 0);
			if(*ret_type == 0){
				*ret_type = honor_type;
				*honor_id = 2;
			}
			msglog(this->msglog_file, 0x0406FAD5 + 2,time(NULL), &(userid), 4);
		}//if
		
	}
	//天使发烧友
	uint32_t num = 0;
	for(uint32_t i = 0; i < total_sort; ++i){
		num += (p_item + i)->count; 
	}
	if(num >= 200){
		uint32_t *it = std::find(p_list, p_list + honor_num, 3);
		if(it == p_list + honor_num){
			ret = this->user_angel_honor.insert(userid, honor_type, 3, 1, 0);
			if(*ret_type == 0){
				*ret_type = honor_type;
				*honor_id = 3;
			}
			msglog(this->msglog_file, 0x0406FAD5 + 3,time(NULL), &(userid), 4);
		}//if
	}

	//粉丝
	user_angel_statistic_stru other = {0};
	uint32_t rotate = 1;
	if(first == 1){
		rotate = total_sort;
	}
	for( uint32_t i = 0; i < rotate; ++i){
		if(first == 0){
			other.angelid = angelid; 
			user_angel_statistic_stru *iter = std::find(p_item, p_item + total_sort, other);
			if(iter != p_item + total_sort){
				other.count = iter->count;
			}
		}
		else{
			other.angelid = (p_item + i)->angelid;
			other.count = (p_item + i)->count;
		}

		if(other.count >= 10){
			switch(other.angelid){
				//豆豆果粉丝
				case 1353417:
					{
						uint32_t *it = std::find(p_list, p_list + honor_num, 4);
						if(it == p_list + honor_num){
							ret = this->user_angel_honor.insert(userid, honor_type, 4, 1, 0);
							if(*ret_type == 0){
								*ret_type = honor_type;
								*honor_id = 4;
							}
							msglog(this->msglog_file, 0x0406FAD5 + 4,time(NULL), &(userid), 4);
						}//if
						break;
					}
				//薇薇粉丝
				case 1354039:
					{
						uint32_t *it = std::find(p_list, p_list + honor_num, 5);
						if(it == p_list + honor_num){
							ret = this->user_angel_honor.insert(userid, honor_type, 5, 1, 0);
							if(*ret_type == 0){
								*ret_type = honor_type;
								*honor_id = 5;
							}
							msglog(this->msglog_file, 0x0406FAD5 + 5,time(NULL), &(userid), 4);
						}//if
						break;
					}
				//八爪粉丝
				case 1354043:
					{
						uint32_t *it = std::find(p_list, p_list + honor_num, 6);
						if(it == p_list + honor_num){
							ret = this->user_angel_honor.insert(userid, honor_type, 6, 1, 0);
							if(*ret_type == 0){
								*ret_type = honor_type;
								*honor_id = 6;
							}
							msglog(this->msglog_file, 0x0406FAD5 + 6,time(NULL), &(userid), 4);
						}//if
						break;
					}
			}//switch
		}//if---

	}//for
	free(p_item);

	return SUCC;
}

/*
 * 解除契约
 */
int Croute_func::user_terminate_contract(DEAL_FUN_ARG)
{
    user_terminate_contract_in *p_in=PRI_IN_POS;
    user_terminate_contract_out out={};
	uint32_t count = 0, total = 0;
    ret=this->user_paradise_contract.get_by_angelid_terminate(RECVBUF_USERID, p_in->angelid, &count, &total);
	if(ret != SUCC){
		return ret;
	}
	if(count < p_in->count){
		return NOT_ENOUGH_ANGEL_COUNT_IN_STORE_ERR;
	}
	uint32_t value = total - p_in->count;
	ret = this->user_paradise_contract.del_contract_angel(RECVBUF_USERID, p_in->angelid, value);
	if(ret != SUCC){
		return ret;
	}
	uint32_t type = 0;
	uint32_t used_count;
	ret = this->user_paradise_contract.get_type_used_count(RECVBUF_USERID, p_in->angelid, &type, &used_count);
	//if(p_in->count == count && (type == 2 || type ==3) && used_count == 0){//type =2 表示坐骑天使
	if(p_in->count == count && ((type & 0x02) == 0x02) && used_count == 0){//type =2 表示坐骑天使
		uint32_t dragonid = 0;
		ret = this->user_paradise_contract.mapping_to_dragon(p_in->angelid, &dragonid);
		if(ret != SUCC){
			return ret;
		}
		ret = this->user_dragon.del(RECVBUF_USERID, dragonid);
	}
	ret = this->user.update_xiaomee_inc(RECVBUF_USERID, p_in->xiaomee * p_in->count);
	out.xiaomee = p_in->xiaomee * p_in->count;
	out.angelid = p_in->angelid;
	out.count = p_in->count;
	
	//change log
		change_log_item c_item;
		c_item.userid = RECVBUF_USERID;
		c_item.change_type=205;
		c_item.logtime = time(NULL);
		c_item.change_value = p_in->angelid;
		c_item.change_v1 = p_in->count;
		c_item.change_v2 = out.xiaomee;
		this->send_log.send(&c_item );

    STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * 放生天使
 */
int Croute_func::user_angel_free(DEAL_FUN_ARG)
{
    user_angel_free_in *p_in=PRI_IN_POS;
	user_angel_free_out out = {}; 
    ret=this->user_paradise_angel.free_angel(RECVBUF_USERID, p_in->id);
	out.id = p_in->id;
	ret = this->user_paradise.update_free_count(RECVBUF_USERID, 1);

	//如果使用了加速道具，签约后将该天使种子在加速道具表中的记录删除掉
	ret = this->user_farm_speed_tool.del_record(RECVBUF_USERID, p_in->id);
	ret = SUCC;

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 获取天使乐园访客列表
 */
int Croute_func::user_paradise_get_visitlist(DEAL_FUN_ARG)
{
	user_paradise_get_visitlist_in *p_in = PRI_IN_POS;
    user_paradise_get_visitlist_out  accesslist = {0};
	ret = this->user_paradise.get_accesslist(RECVBUF_USERID, &accesslist, p_in->layer);
	if(ret!=SUCC){
		return ret;
	}	
	DEBUG_LOG("time: %u, userid: %u", accesslist.users[0].time, accesslist.users[0].userid);
    uint32_t  private_size;
    private_size=sizeof(accesslist.count)+sizeof(visit_trace) * accesslist.count  ;

    STD_RETURN_WITH_BUF(ret,(char*)&accesslist , private_size );
}
/*
 *更新天使乐园访客列表
 */
int Croute_func::user_paradise_update_visitlist(DEAL_FUN_ARG)
{
	user_paradise_update_visitlist_in *p_in=PRI_IN_POS;
	user_paradise_get_visitlist_out accesslist = { 0};	
	ret = this->user_paradise.get_accesslist(RECVBUF_USERID, &accesslist, p_in->layer);
	if(ret != SUCC){
		return ret;
	}
	visit_trace* iter = std::find(accesslist.users, accesslist.users + accesslist.count, p_in->userid);
	if(iter == accesslist.users + accesslist.count){
		if(accesslist.count >= PARADISE_ACCESS_MAX){
			uint32_t oldest = time(0);
			uint32_t pos = 0;
			for(uint32_t i =0; i< accesslist.count; ++i){
				if(accesslist.users[i].time  < oldest){
					oldest = accesslist.users[i].time;
					pos = i;
				}
			}
			accesslist.users[pos].userid = p_in->userid;
			accesslist.users[pos].time = (uint32_t)time(NULL);
			
		}else{
			accesslist.users[accesslist.count].userid = p_in->userid;
			accesslist.users[accesslist.count].time = (uint32_t)(time(NULL));
			accesslist.count += 1;
		}
	}
	else{
		iter->time = (uint32_t)time(NULL);
	}
	ret=this->user_paradise.update_paradise_accesslist(RECVBUF_USERID, accesslist,p_in->layer);

	STD_RETURN(ret);
}
/*
 * 获得天使乐园道具
 */
int Croute_func::user_get_paradise_attirelist(DEAL_FUN_ARG)
{
    user_get_paradise_attirelist_out_header  out_header;
    user_get_paradise_attirelist_out_item *p_out_item;
    ret=this->user_attire.get_paradise_noused_attirelist(RECVBUF_USERID, &p_out_item, &out_header.count);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 删除天使道具
 */
int Croute_func::user_del_attire_angel_tool(DEAL_FUN_ARG)
{
    user_del_attire_angel_tool_in *p_in=PRI_IN_POS;
    user_del_attire_angel_tool_out out={};
	out.attireid = p_in->attireid;
	out.count = p_in->count;
	uint32_t count = 0;
    ret=this->user_attire.get_count(RECVBUF_USERID, p_in->attireid, count);
	if(ret != SUCC){
		return ret;
	}
	if(count < p_in->count){
		return NOT_ENOUGH_ATTIRE_ERR;
	}
	user_del_attire_in del_item;
	del_item.attireid=p_in->attireid;
	del_item.attiretype=0;
	del_item.count=p_in->count;
	del_item.maxcount=99999;
	ret=this->user_del_attire(RECVBUF_USERID ,&del_item);

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 *   获取签订契约后的天使
 */
int Croute_func::user_get_angel_contract_all(DEAL_FUN_ARG)
{
    user_get_angel_contract_all_out_header  out_header = { 0 };
    user_get_angel_contract_all_out_item *p_out_item;
    ret = this->user_paradise_contract.get_all(RECVBUF_USERID, &p_out_item, &out_header.count);

	uint32_t *p_item = 0, num = 0;
	ret = this->user_paradise_contract.get_counts(RECVBUF_USERID,  &p_item, &num);
	if(ret != SUCC){
		if(p_item != 0){
			free(p_item);
		}
		return ret;
	}
	for(uint32_t k = 0; k < num; ++k){
		out_header.total += *(p_item + k);
	}
	free(p_item);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/*
 * 判断可否跟随
 */
int Croute_func::user_get_contract_angel_follow(DEAL_FUN_ARG)
{
    user_get_contract_angel_follow_in *p_in=PRI_IN_POS;
    user_get_contract_angel_follow_out out = { };
	
	if (p_in->outgo > 1) {
        return VALUE_OUT_OF_RANGE_ERR;
    }
    if (p_in->outgo == 1) {
        uint32_t count_in_animal = 0;
        uint32_t count_in_fairy = 0;
        uint32_t count_in_contract = 0;
		uint32_t count_in_piglet = 0;
        ret  = this->user_farm_fairy.get_state_out_count(RECVBUF_USERID, count_in_fairy);
        ret = this->user_farm_animal.get_outgo_count(RECVBUF_USERID, &count_in_animal);
        ret = this->user_paradise_contract.get_count_type2(RECVBUF_USERID, count_in_contract);
		ret = this->user_piglet.get_outgo_count(RECVBUF_USERID, &count_in_piglet);
        if (count_in_fairy > 0 || count_in_animal > 0 || count_in_contract > 0 || count_in_piglet > 0) {
            return YOU_HAVE_ANIMAL_OUTGO_ERR;
        }
    }
	uint32_t count = 0;
	uint32_t type =0;
	ret = this->user_paradise_contract.get_type(RECVBUF_USERID, p_in->angelid, &type);
	if((type & 0x02) == 0x02){
		return DRAGON_CANNOT_FOLLOW_ERR;
	}
	if(p_in->outgo == 1){
		ret=this->user_paradise_contract.get_by_angelid(RECVBUF_USERID, p_in->angelid, &count);
		if(count == 0){
			return NOT_ENOUGH_ANGEL_COUNT_IN_STORE_ERR ;
		}
		ret = this->user_paradise_contract.update_used_count(RECVBUF_USERID, p_in->angelid, 1);
	}
	else{
		ret = this->user_paradise_contract.update_used_count(RECVBUF_USERID, p_in->angelid, 0);
	}
	out.angelid = p_in->angelid;	
	out.outgo = p_in->outgo;

    STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * 获取天使园好友种植排名列表
 */
int Croute_func::sysarg_get_paradise_friend_rank(DEAL_FUN_ARG)
{
    sysarg_get_paradise_friend_rank_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(sysarg_get_paradise_friend_rank_in_item));
    sysarg_get_paradise_friend_rank_in_item * p_in_item = (sysarg_get_paradise_friend_rank_in_item*)
		(RCVBUF_PRIVATE_POS+sizeof(*p_in));
    sysarg_get_paradise_friend_rank_out_header  out_header;
    sysarg_get_paradise_friend_rank_out_item *p_out_item;

    ret=this->sysarg_paradise_rank.select(RECVBUF_USERID, p_in->count, p_in_item, &(out_header.count), &p_out_item);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 圣光兽转生
 */
int Croute_func::user_fairy_convert_angel(DEAL_FUN_ARG)
{
    user_fairy_convert_angel_in *p_in=PRI_IN_POS;
    user_fairy_convert_angel_out out={};
	uint32_t state = 0;
	uint32_t type = 0;
	uint32_t in_farm_state = 0;

    ret=this->user_farm_fairy.get_state(RECVBUF_USERID, p_in->id, &state);
	if(ret != SUCC){
		return ret;
	}
	//	uint32_t success = 0;//1 代表转生成功， 0代表转生不成功
	if(state == 20){
		uint32_t mature = 0;
		ret = this->user_farm_animal.get_table_mature(RECVBUF_USERID, p_in->id,  mature);
		if(ret != SUCC){
			return ret;
		}
		if(mature == 0){
			return THE_FOLLOWED_FAIRY_HAS_NOT_MATURE_ERR;
		}
		else{
			in_farm_state = 1;
		}
	}
	ret = this->user_farm_fairy.convert_to_angel(RECVBUF_USERID, p_in->id, &out.angelid, &out.success, &type);
	if(ret != SUCC){
		return ret;
	}
	if(out.success == 0){
		//ret = this->user_attire.update_count(RECVBUF_USERID, out.angelid, 1);
		//if(ret == USER_ID_NOFIND_ERR){
			//ret = this->user_attire.insert(RECVBUF_USERID, out.angelid,0, 1);
			//if(ret != SUCC){
				//return ret;
			//}
		//}
		user_add_attire_in  add_item = {0};
		add_item.attiretype = 0;
		add_item.attireid = out.angelid;
		add_item.count = 1;
		add_item.maxcount = 99999;
		ret = this->user_add_attire(RECVBUF_USERID, &add_item);
				
	}//
	else if(state == 36 || state == 34 || in_farm_state == 1){
		ret = this->user_paradise_contract.sign_contract(RECVBUF_USERID, out.angelid, 1, type);
		if((type & 0x02) == 0x02){
			uint32_t dragonid = 0;
			ret = this->user_paradise_contract.mapping_to_dragon(out.angelid, &dragonid);
			if(ret != SUCC){
				return ret;
			}
			ret = user_angel_add_dragon(RECVBUF_USERID, dragonid);
		  if(ret != USER_ID_EXISTED_ERR && ret != SUCC){
				return ret;
			}
		}
		ret = this->user_angel_statistics.update(RECVBUF_USERID, out.angelid, 1);
		if(ret == USER_ID_NOFIND_ERR){
		 ret = this->user_angel_statistics.insert(RECVBUF_USERID, out.angelid, type, 1);
		}          
	}
	if( state == 20){
		ret = this->user_farm_animal.del(RECVBUF_USERID, p_in->id);
	}
	ret = this->user_farm_fairy.delete_fairy_by_id(RECVBUF_USERID, p_in->id);
	
	//change log
		change_log_item c_item;
		c_item.userid = RECVBUF_USERID;
		c_item.change_type=206;
		c_item.logtime = time(NULL);
		c_item.change_value = p_in->id;
		c_item.change_v1 = out.angelid;
		c_item.change_v2 = out.success;
		this->send_log.send(&c_item);	

    STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::roominfo_get_week_count(DEAL_FUN_ARG)
{
	roominfo_get_week_count_out out={0};
	ret=this->roominfo_login_weekend.query(RECVBUF_USERID, &(out.week_count), &(out.last_week));
	ret = SUCC;
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::roominfo_update_week_count(DEAL_FUN_ARG)
{
	ret=this->roominfo_login_weekend.update_week_count(RECVBUF_USERID);
	STD_RETURN(ret);
}
/*
 * 内部函数，增加坐骑
 */
int Croute_func::user_angel_add_dragon( userid_t userid, uint32_t angelid)
{
		uint32_t count = 0;
		ret = this->user_dragon.get_angel_dragon(userid, angelid, count);
		if( ret == SUCC && count ==0){
			ret = this->user_dragon.add(userid, angelid);
		}
		return ret;
}
/*
 * 获取访客的等级和信息
 */
int Croute_func::sysarg_get_paradise_access_rank(DEAL_FUN_ARG)
{
    sysarg_get_paradise_access_rank_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(sysarg_get_paradise_access_rank_in_item));
    sysarg_get_paradise_access_rank_in_item * p_in_item = 
		(sysarg_get_paradise_access_rank_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
    sysarg_get_paradise_access_rank_out_header  out_header = {0};
    sysarg_get_paradise_access_rank_out_item *p_out_item = 0;
	if(p_in->count == 0){
		out_header.count = 0;
		ret = SUCC;
		STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
	}	
    ret = this->sysarg_paradise_rank.select(p_in->count, p_in_item, &(out_header.count), &p_out_item);
	for(uint32_t k = 0; k< p_in->count; ++k){
		for(uint32_t i = 0; i< out_header.count; ++i){
			if(p_out_item[i].userid == p_in_item[k].userid){
				p_out_item[i].time = p_in_item[k].time; 
				break;
			}
		}
	}
	ret = SUCC;

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 更新庄园中的热点
 */
int Croute_func::sysarg_update_hot_play(DEAL_FUN_ARG)
{
    sysarg_update_hot_play_in *p_in=PRI_IN_POS;
    ret = this->sysarg_hot_play.update(p_in->id, 1);
	if( ret ==  USER_ID_NOFIND_ERR){
		ret = this->sysarg_hot_play.insert(p_in->id, 1);
	}
    STD_RETURN(ret);
}

/*
 * 获取庄园热点
 */
int Croute_func::sysarg_get_hot_play(DEAL_FUN_ARG)
{
    sysarg_get_hot_play_out_header  out_header;
    sysarg_get_hot_play_out_item *p_out_item;
    ret=this->sysarg_hot_play.get_all_items(&p_out_item, &out_header.count);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 更新天使乐园排名表
 */
int Croute_func::sysarg_update_paradise_rank(DEAL_FUN_ARG)
{
    sysarg_update_paradise_rank_in *p_in=PRI_IN_POS;
    ret=this->sysarg_paradise_rank.update(RECVBUF_USERID, p_in->exp, p_in->count);
	if(ret == USER_ID_NOFIND_ERR){
		ret = this->sysarg_paradise_rank.insert(RECVBUF_USERID, p_in->exp, p_in->count);
	}
    STD_RETURN(ret);
}
/*
 * 校巴项目获取mole昵称、装扮、等级
 */
int Croute_func::user_get_mole_lev_att_nick(DEAL_FUN_ARG)
{
	char out[PROTO_MAX_LEN]={0};
	user_get_mole_lev_att_nick_out temp ={ };
	ret=this->user_ex.get_nick(RECVBUF_USERID, temp.nick);
	if(ret != SUCC){
		return ret;
	}
	uint32_t exp = 0;
	uint32_t color = 0;
	ret =this->user.get_user_exp_color(RECVBUF_USERID, exp, color);
	//temp.level= this->cal_mole_level((int)exp);
	temp.level= get_mole_level(exp);
	temp.color = color;
	memcpy(out, (char*)(&temp), sizeof(temp));
	char * p_offset = out + 24;

	uint32_t startattireid =  12001;
	uint32_t endattireid = 15999;
	uint32_t *list = 0;	
	uint32_t count = 0;
	ret=this->user_attire.get_list_by_attireid_for_bus( RECVBUF_USERID , startattireid,
			  endattireid, &count, &list );
	if(ret != SUCC && list != 0){
		free(list);
	}
	*((uint32_t *)p_offset) = count;
	memcpy(p_offset + 4, (char*)(list), sizeof(uint32_t) * count);
	p_offset = p_offset + sizeof(uint32_t) * count + 4;
	free(list);	

	STD_RETURN_WITH_BUF(ret,out, p_offset - out);
}
/*
 * 加速天使成长,增加变异率
 */
int Croute_func::user_angel_speed_up(DEAL_FUN_ARG)
{
	user_angel_speed_up_in *p_in=PRI_IN_POS;
	user_angel_speed_up_out out= {0}; 
	if(p_in->toolid != 1353102 && p_in->toolid != 1353100 && p_in->toolid != 1353101
			&& p_in->toolid != 1353103 && p_in->toolid != 1353104 && p_in->toolid != 1353105
			&& p_in->toolid != 1353109 && p_in->toolid != 1353110){
			return NOT_CORRECT_ANGEL_SPEED_TOOL_ERR;
	}
	uint32_t count = 0;
    ret=this->user_attire.get_count(RECVBUF_USERID, p_in->toolid, count);
    if(ret != SUCC){
        return ret;
    }
    if(count < 1){
        return ATTIRE_COUNT_NO_ENOUGH_ERR;
    }
  
	ret = this->user_paradise_angel.get_angel_info_by_position(RECVBUF_USERID, p_in->position, &out.item);
	if(ret != SUCC){
		return ret;
	}
	uint32_t speed_growth [] = {1353100, 1353101, 1353102};
	//uint32_t speed_variate[] = {1353103, 1353104, 1353015};
	uint32_t *iter = std::find(speed_growth, speed_growth + 3, p_in->toolid);
	if(iter != speed_growth + 3){//使用加速天使成长道具
		bool res = this->user_paradise_angel.is_mature(out.item.angelid, out.item.growth);
		if(res){
			return THE_ANGEL_ALREADY_MATURE_ERR;
		}
		uint32_t date = 0;
		uint32_t up_growth = 0;
		if(p_in->toolid != 1353102){
			ret = this->user_farm_speed_tool.get_date(RECVBUF_USERID, out.item.id,  p_in->toolid, date);
			uint32_t today = get_date(time(0));
			if(ret == USER_ID_NOFIND_ERR || (ret == SUCC && today != date)){
				if(p_in->toolid == 1353100){
					up_growth = 3600;
				}
				else if(p_in->toolid == 1353101){
					up_growth = 3*3600;
				}		
			}//if		
			else if(ret == SUCC && date == today){
				return  THE_ANGEL_SPEED_TOOL_REACHED_USED_LIMIT_ERR;
			}
		}//if
		else{// 无限次使用的道具
			up_growth = 0.5 * 3600;
		}
		uint32_t unsuccess_count = 0;
		ret = this->user_paradise.get_unsuccess(RECVBUF_USERID,  unsuccess_count);
		uint32_t count_1 = 0, count_2 = 0;
		ret = this->user_paradise_contract.get_angelid_speci(RECVBUF_USERID, 1354134, count_1);
		ret = this->user_paradise_contract.get_angelid_speci(RECVBUF_USERID, 1354135, count_2);
		ret = this->user_paradise_angel.speed_up(RECVBUF_USERID, up_growth, &out.item, &unsuccess_count, count_1, count_2);
		ret = this->user_paradise.update_unsuccess(RECVBUF_USERID,  unsuccess_count);
		if(p_in->toolid == 1353100){
			msglog(this->msglog_file, 0x405CAA3,time(NULL), &(RECVBUF_USERID), 4);
		}
		else if(p_in->toolid == 1353101){
			msglog(this->msglog_file, 0x405CAA4,time(NULL), &(RECVBUF_USERID), 4);
		}
		else if(p_in->toolid == 1353102){
			msglog(this->msglog_file, 0x405CAA5,time(NULL), &(RECVBUF_USERID), 4);
		}
	}
	else{//使用增加天使变异几率道具
		if(out.item.variate_id != 0){
			return THE_ANGEL_ALREADY_VARIATE_ERR;
		}
		if(p_in->toolid != 1353105 && p_in->toolid != 1353109 && p_in->toolid != 1353110){
			uint32_t date = 0;
			ret  = this->user_farm_speed_tool.get_date(RECVBUF_USERID, out.item.id, p_in->toolid, date);
			if(ret == USER_ID_NOFIND_ERR){
				ret = this->user_paradise_angel.speed_variate_rate(RECVBUF_USERID, out.item.id, out.item.angelid,
					p_in->toolid, &out.item.rate);
				if(ret != SUCC){
					return ret;
				}	
			}
			else{
				return THE_VARIATE_TOOL_CAN_ONLY_USE_ONE_TIMES_ERR;
			}
		}
		else{
			ret = this->user_paradise_angel.speed_variate_rate(RECVBUF_USERID, out.item.id, out.item.angelid,
				p_in->toolid, &out.item.rate);
			if(ret != SUCC){
				return ret;
			}	
		}//else
			
	}//else

    //扣除道具
	user_del_attire_in del_item = { 0 };
	del_item.attireid = p_in->toolid;
	del_item.attiretype = 0;
	del_item.count = 1;
	del_item.maxcount=99999;
	ret = this->user_del_attire(RECVBUF_USERID ,&del_item);
	////扣除物品
	//if(count == 1){
        //ret = this->user_attire.remove(RECVBUF_USERID, p_in->toolid);
    //}   
    //else{
		//uint32_t res_count = count - 1;
		//ret = this->user_attire.update(RECVBUF_USERID, p_in->toolid, 0, res_count);
    //} 
	if( ret != SUCC){
        return ATTIRE_COUNT_NO_ENOUGH_ERR;
	}
	out.item.position= p_in->position;
	out.toolid = p_in->toolid;
	
	//更新道具使用表
	ret = this->user_farm_speed_tool.update(RECVBUF_USERID, out.item.id ,p_in->toolid, 
			1, get_date(time(0)));
	if(ret == USER_ID_NOFIND_ERR){
		ret = this->user_farm_speed_tool.insert(RECVBUF_USERID, out.item.id, out.item.angelid, 
				p_in->toolid, 1, get_date(time(0)));	
	}	

	STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 获取战斗天使
 */
int Croute_func::user_get_battle_angel_info(DEAL_FUN_ARG)
{
    user_get_battle_angel_info_out_header  out_header;
    user_get_battle_angel_info_out_item *p_out_item;
    ret=this->user_paradise_contract.get_battle_angel_info(RECVBUF_USERID,  &p_out_item, &out_header.count);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 获取战斗等级、经验、获胜次数
 */
int Croute_func::user_angel_get_battle_level(DEAL_FUN_ARG)
{
    user_angel_get_battle_level_out out={0};
	ret = this->user_angel_battle.select_statistic_columns(RECVBUF_USERID, &out.victory_count,
		  	&out.exp);
	if(ret == USER_ID_NOFIND_ERR){
		out.victory_count = 0;
		out.level = 1;
		out.exp = 0;
		ret = SUCC;
	}
	else if(ret == SUCC){
		ret = this->user_angel_battle.cal_level(out.exp, &out.level);
	}
	
    STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * 获取关卡得分
 */
int Croute_func::user_angel_barrier_get_score(DEAL_FUN_ARG)
{
    user_angel_barrier_get_score_in *p_in=PRI_IN_POS;
	uint32_t out[4] = {0}; 
	out[0] = p_in->barrier_id;
    ret = this->user_angel_barrier.get_barrier_score(RECVBUF_USERID, p_in->barrier_id, &out[1]);
	
	STD_RETURN_WITH_BUF(ret,out, sizeof(out) );
}

/*
 * 天使战斗结束
 */
int Croute_func::user_angel_battle_over(DEAL_FUN_ARG)
{
    user_angel_battle_over_in *p_in=PRI_IN_POS;
	user_angel_battle_over_out out = {0};  
	out.barrier_id = p_in->barrier_id;
	out.exp_inc = p_in->exp_inc;
	out.barrier_type  = p_in->barrier_type;
	out.is_pass = p_in->is_pass;
	user_angel_battle_over_in_header *p_in_header= (user_angel_battle_over_in_header*)((char*)PRI_IN_POS 
			+ sizeof(user_angel_battle_over_in));
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in_header->count)*sizeof(user_angel_battle_over_in_item) + 4);
	user_angel_battle_over_in_item *p_in_item = (user_angel_battle_over_in_item *)((char*)p_in_header + sizeof(uint32_t));

    uint32_t day_limit_count = 60;//20;//每天玩的次数上限
	const uint32_t day_limit_exp = 100000;//46000;//每天增加的经验值上限
	const uint32_t prize_id = 1353433; //战利品id
	const uint32_t prize_limit = 600;//战利品数量上限

	if(p_in->barrier_type > 3 || p_in->barrier_type < 0){
		return EXCEED_ONE_BATTLE_TYPE_ERR;
	}
	uint32_t  pass = p_in->is_pass == 1 ? 1 : 0;//是否过关
	uint32_t day_count = 0, day_exp = 0, date = 0, day_prize = 0;
    ret = this->user_angel_battle.select_check_columns(RECVBUF_USERID, day_count, day_exp, day_prize, date);
	uint32_t day_count_0 = day_count & 0xFF;
	uint32_t day_count_1 =  day_count >> 8;
	uint32_t real_add_prize = 0;
	if(day_prize + p_in->prize > prize_limit){
		real_add_prize = 0;
	}
	else{
		real_add_prize = p_in->prize;
	}
	uint32_t exp_in_table = 0, real_add_exp = 0;
	ret = this->user_angel_battle.get_exp(RECVBUF_USERID, &exp_in_table);
	if( exp_in_table + p_in->exp_inc > 280200){
		real_add_exp = 280200 - exp_in_table;
	}
	else{
		real_add_exp = p_in->exp_inc;
	}
	if(ret == USER_ID_NOFIND_ERR){
		uint32_t day_cnt = pass;
		if(p_in->flag == 1){
			day_cnt <<= 8;
		}
		ret = this->user_angel_battle.insert(RECVBUF_USERID, real_add_exp,
				pass, day_cnt, real_add_exp, real_add_prize);
		if(real_add_prize != 0){
			user_add_attire_in  add_item = {0};
			add_item.attiretype = 0;
			add_item.attireid = prize_id;
			add_item.count = real_add_prize;
			add_item.maxcount = 99999;
			ret = this->user_add_attire(RECVBUF_USERID, &add_item);
			//ret = this->user_attire.insert(RECVBUF_USERID, prize_id, 0, real_add_prize);
		}
		if(p_in->barrier_type != 0){
			ret = this->user_angel_barrier.insert(RECVBUF_USERID, p_in->barrier_id, p_in->barrier_type,
				p_in->barrier_score, pass);
		}
	}
	else{
		uint32_t today = get_date(time(0));
		if(date == today){//首先检验玩家是否超过了一天的战斗极限
			uint32_t comp_count = 0;
			if(p_in->flag == 1){
				day_count_1 += pass;
				comp_count = day_count_1;
				day_limit_count = 10;
			}
			else{
				day_count_0 += pass;
				comp_count = day_count_0;
			}
			uint32_t comp_exp = day_exp + p_in->exp_inc;
			if(comp_count > day_limit_count ||  comp_exp > day_limit_exp){
				if(p_in->barrier_type != 0){
					this->user_record_top_barrier_score(RECVBUF_USERID, p_in->barrier_id, 
						p_in->barrier_type, p_in->barrier_score, pass);
				}

			 //玩家战斗荣誉
			 {
				uint32_t *p_list = 0;
				uint32_t battle_cnt = 0;
				ret = this->user_angel_honor.get_honor_ids(RECVBUF_USERID, 2, &p_list, &battle_cnt);
				if(ret != SUCC){
					if(p_list != 0){
						free(p_list);
					}
				}
				this->user_cal_battle_honor(RECVBUF_USERID, out.level, p_in->barrier_id, &out.honor_type,
						&out.honor_id, p_list, battle_cnt);
				free(p_list);
			  }//玩家战斗荣誉

				return PLAYER_EVERYDAY_BATTLE_LIMIT_ERR;
			}
			else{
				uint32_t tmp_count = (day_count_1 << 8) + day_count_0;
				ret = this->user_angel_battle.update_inc_info(RECVBUF_USERID, real_add_exp,
						pass, tmp_count, real_add_prize);
				if(real_add_prize != 0){
					user_add_attire_in  add_item = {0};
					add_item.attiretype = 0;
					add_item.attireid = prize_id;
					add_item.count = real_add_prize;
					add_item.maxcount = 99999;
					ret = this->user_add_attire(RECVBUF_USERID, &add_item);
					//ret = this->user_attire.update_count(RECVBUF_USERID, prize_id, real_add_prize);
					//if(ret == USER_ID_NOFIND_ERR){
						//ret = this->user_attire.insert(RECVBUF_USERID, prize_id, 0, real_add_prize);
					//}//ret==		
				}
			}//else
		}//if	
		else{
			uint32_t tmp_count = 1;
			if(p_in->flag == 1){
				tmp_count = 1 << 8;
			}
			ret = this->user_angel_battle.update_clear_day(RECVBUF_USERID, real_add_exp,
					pass, tmp_count, real_add_prize);		
			if(real_add_prize != 0){
				user_add_attire_in  add_item = {0};
				add_item.attiretype = 0;
				add_item.attireid = prize_id;
				add_item.count = real_add_prize;
				add_item.maxcount = 99999;
				ret = this->user_add_attire(RECVBUF_USERID, &add_item);
				//ret = this->user_attire.update_count(RECVBUF_USERID, prize_id, real_add_prize);
				//if(ret == USER_ID_NOFIND_ERR){
					//ret = this->user_attire.insert(RECVBUF_USERID, prize_id, 0, real_add_prize);
				//}//ret==
			}
		}
		//下面为更新关卡得分
		if(p_in->barrier_type != 0){
			this->user_record_top_barrier_score(RECVBUF_USERID, p_in->barrier_id, p_in->barrier_type,
			  	p_in->barrier_score, pass);
		}
	}//else
	
	uint32_t exp = 0;
	ret = this->user_angel_battle.get_exp(RECVBUF_USERID, &exp);
	ret = this->user_angel_battle.cal_level(exp, &out.level);

	//受伤天使要住院
	for(uint32_t k = 0; k < p_in_header->count; ++k){
		uint32_t count = 0;
		ret = this->user_paradise_contract.get_by_angelid(RECVBUF_USERID, (p_in_item + k)->angelid, &count);	
		if(count < (p_in_item + k)->count){
			return NOT_ENOUGH_ANGEL_COUNT_IN_STORE_ERR ;
		}
		ret = this->user_paradise_contract.update_hurt_count_inc(RECVBUF_USERID, (p_in_item + k)->angelid, 
				(p_in_item + k)->count);
		if(ret != SUCC){
			return ret;
		}
		for(uint32_t i = 0; i < (p_in_item + k)->count; ++i){
			ret = this->user_angel_hospital.insert(RECVBUF_USERID, (p_in_item + k)->angelid);
		}
	}

  //玩家战斗荣誉
  {
	uint32_t *p_list = 0;
	uint32_t battle_cnt = 0;
	ret = this->user_angel_honor.get_honor_ids(RECVBUF_USERID, 2, &p_list, &battle_cnt);
	if(ret != SUCC){
		if(p_list != 0){
			free(p_list);
		}
	}
	this->user_cal_battle_honor(RECVBUF_USERID, out.level, p_in->barrier_id, &out.honor_type,
			&out.honor_id, p_list, battle_cnt);
	free(p_list);
   }//玩家战斗荣誉
	ret = SUCC;

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 获取玩家战斗荣誉
 */
int Croute_func::user_cal_battle_honor(userid_t userid, uint32_t level, uint32_t barrier_id,
		uint32_t *ret_type, uint32_t *honor_id, uint32_t *p_list, uint32_t battle_cnt)
{
	const uint32_t honor_type = 2;
	
	//战斗先锋
	if(level >= 5){
		uint32_t *it = std::find(p_list, p_list + battle_cnt, 1);
		if(it == p_list + battle_cnt){
			ret = this->user_angel_honor.insert(userid, honor_type, 1, 1, 0);
			if(*ret_type == 0){
				*ret_type = honor_type;
				*honor_id = 1;
			}
		   msglog(this->msglog_file, 0x0406FB34 + 1,time(NULL), &(userid), 4);
		}//if
	}
	//战斗小将
	if(level >= 9){
		uint32_t *it = std::find(p_list, p_list + battle_cnt, 2);
		if(it == p_list + battle_cnt){
			ret = this->user_angel_honor.insert(userid, honor_type, 2, 1, 0);
			if(*ret_type == 0){
				*ret_type = honor_type;
				*honor_id = 2;
			}
		   msglog(this->msglog_file, 0x0406FB34 + 2,time(NULL), &(userid), 4);
		}//if
	}
	//战斗将军
	if(level >= 13){
		uint32_t *it = std::find(p_list, p_list + battle_cnt, 3);
		if(it == p_list + battle_cnt){
			ret = this->user_angel_honor.insert(userid, honor_type, 3, 1, 0);
			if(*ret_type == 0){
				*ret_type = honor_type;
				*honor_id = 3;
			}
		   msglog(this->msglog_file, 0x0406FB34 + 3,time(NULL), &(userid), 4);
		}//if
	}
	//战斗元帅
	if(level >= 17){
		uint32_t *it = std::find(p_list, p_list + battle_cnt, 4);
		if(it == p_list + battle_cnt){
			ret = this->user_angel_honor.insert(userid, honor_type, 4, 1, 0);
			if(*ret_type == 0){
				*ret_type = honor_type;
				*honor_id = 4;
			}
		   msglog(this->msglog_file, 0x0406FB34 + 4,time(NULL), &(userid), 4);
		}//if
	}
	
	//战胜关卡
	user_angel_barrier_stru *p_item = 0;
	uint32_t succ_count = 0;
	ret = this->user_angel_barrier.get_barrier_succss(userid, barrier_id, &p_item,
			    &succ_count);
	if(ret != SUCC){
		if(p_item != 0){
			free(p_item);
		}
	}
	if(succ_count == 3){
		uint32_t k = 0;
		for(; k < succ_count; ++k){
			if((p_item + k)->succ == 0){
				break;		
			}
		}//for
		//只有简单，中等，困难三种模式都战胜的情况下，计算荣誉
		if(k >= succ_count){
			uint32_t barriers[] ={
				2, 3, 4, 5, 6
			};
			for(uint32_t i = 0; i < sizeof(barriers)/sizeof(uint32_t); ++i){
				if(barrier_id == barriers[i]){
					uint32_t hon_id = 5 + i;
					ret = this->user_angel_honor.insert(userid, honor_type, hon_id, 1, 0);
					if(ret == SUCC){
						if(*ret_type == 0){
							*ret_type = honor_type;
							*honor_id = hon_id;
						}
						msglog(this->msglog_file, 0x0406FB34 + hon_id, time(NULL), &(userid), 4);
					}
					break;
				}
			}//for
		}
    }//if(succ)
	free(p_item);

	return SUCC;
}
/*
 * 内部函数,记录过关分数
 */
int Croute_func::user_record_top_barrier_score(uint32_t userid, uint32_t id, uint32_t type, 
		uint32_t barrier_score, uint32_t pass)
{
	uint32_t score = 0;
	ret = this->user_angel_barrier.select(userid, id, type, score);
	if(ret == USER_ID_NOFIND_ERR){
		ret = this->user_angel_barrier.insert(userid, id, type, barrier_score, pass);
	}
	else if(ret == SUCC){
		if(barrier_score > score){
			ret = this->user_angel_barrier.update(userid, id, type, barrier_score);
		}//if(p_in)
		if(pass == 1){
			ret = this->user_angel_barrier.update_succ(userid, id, type, pass);
		}
	}//else_if	

	return ret ;
}
/*
 * 净化黑暗天使
 */
int Croute_func::user_capture_angel(DEAL_FUN_ARG)
{
    user_capture_angel_in *p_in=PRI_IN_POS;
	if(p_in->angelid != 1353217 && p_in->angelid != 1353270 && p_in->angelid != 1353269){
		return NOT_CORRECT_ANGEL_CAPTURE_TOOL_OR_SEED_ERR;
	}
	if(p_in->capture_id != 190851 && p_in->capture_id != 190852 && p_in->capture_id != 190853){
		return NOT_CORRECT_ANGEL_CAPTURE_TOOL_OR_SEED_ERR;
	}
    user_capture_angel_out out={};
	memcpy((char *)(&out), (char *)p_in, sizeof(user_capture_angel_in));
	const uint32_t tool_a_id = 190851;
	const uint32_t tool_b_id = 190852;
	const uint32_t tool_c_id = 190853;

	//扣除捕获器
	uint32_t count = 0;
	ret=this->user_attire.get_count(RECVBUF_USERID, p_in->capture_id, count);	
	if(count == 0){ 
		return ATTIRE_COUNT_NO_ENOUGH_ERR;
	}
	else{

		//扣除道具
		user_del_attire_in del_item = { 0 };
		del_item.attireid = p_in->capture_id;
		del_item.attiretype = 0;
		del_item.count = 1;
		del_item.maxcount=99999;
		ret = this->user_del_attire(RECVBUF_USERID ,&del_item);
		//if(count == 1){
			//ret = this->user_attire.remove(RECVBUF_USERID, p_in->capture_id);
		//}       
		//else{   
			//uint32_t res_count = count - 1;
			//ret = this->user_attire.update(RECVBUF_USERID, p_in->capture_id, 0, res_count);
		//}
	}
	
	if(p_in->capture_id == tool_c_id){
		msglog(this->msglog_file, 0x0406BAAA,time(NULL), &(RECVBUF_USERID), 4);

	}
	              
    //下面是概率捕获            	
	uint32_t partition = 0, dinominator = 0;
	if(p_in->capture_id == tool_a_id){
		ret = this->user_capture_random_angel(RECVBUF_USERID, p_in->angelid, partition, dinominator);
		if(ret != SUCC){
			return ret;
		}
	}
	else if(p_in->capture_id == tool_b_id){
		ret = this->user_capture_random_angel(RECVBUF_USERID, p_in->angelid, partition, dinominator);
		if(ret != SUCC){
			return ret;
		}
		partition *= 3;
		dinominator *= 2;
	}
	else if(p_in->capture_id == tool_c_id){
		partition = 100;
		dinominator = 100;
	}
	uint32_t random = rand() % dinominator;
	if(random < partition){

		user_add_attire_in  add_item = {0};
		add_item.attiretype = 0;
		add_item.attireid = p_in->angelid;
		add_item.count = 1;
		add_item.maxcount = 99999;
		ret = this->user_add_attire(RECVBUF_USERID, &add_item);
		//ret = this->user_attire.update_count(RECVBUF_USERID, p_in->angelid, 1);
		//if(ret == USER_ID_NOFIND_ERR){
			//ret = this->user_attire.insert(RECVBUF_USERID, p_in->angelid,0, 1);
			//if(ret != SUCC){
				//return ret;
			//}
		//}//ret
		uint32_t date = 0;
		ret = this->user_angel_capture.select_date(RECVBUF_USERID, p_in->angelid, date);
		ret = this->user_angel_capture.update(RECVBUF_USERID, p_in->angelid, 1, date); 
		if(ret == USER_ID_NOFIND_ERR){
			uint32_t today = get_date(time(0));
			ret = this->user_angel_capture.insert(RECVBUF_USERID, p_in->angelid, 1, today);
		}
	}//random
	else{
		return CAPTURE_ANGEL_FAIL_ERR; 
	}

    STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * 净化天使，概率计算， 内部函数
 */
int Croute_func::user_capture_random_angel(uint32_t userid, uint32_t angelid, 
		uint32_t &partition, uint32_t &dinominator)
{
	uint32_t *p_list = 0, line_count = 0;
	uint32_t total = 0;
    ret=this->user_angel_capture.select_total(userid, &p_list, &line_count);
	if(ret != SUCC){
		if(p_list != 0){
			free(p_list);
		}
	}
	for(uint32_t k = 0; k < line_count; ++k){
		total += p_list[k];
	}
	free(p_list);
	const uint32_t  total_max = 50;
	const uint32_t  angel_max  = 10;
	std::map<uint32_t, uint32_t> t_map;
	t_map[1353270] = 20;
	t_map[1353217] = 40;
	t_map[1353269] = 10;
	if(total > total_max){
		return CAPTURE_ANGEL_FAIL_ERR; 
	}//if
	else{
		if(angelid == 1353269){
			uint32_t angel_count = 0, date = 0;
            ret = this->user_angel_capture.select(userid, angelid, angel_count, date);
			uint32_t today = get_date(time(0));
			if(date == today && angel_count >= angel_max){
					return CAPTURE_ANGEL_FAIL_ERR;
			}
		}
		partition = t_map[angelid];
		dinominator = 100;
	}

	return SUCC;
}

/*
 * 拉取住院天使
 */
int Croute_func::user_get_angel_in_hospital(DEAL_FUN_ARG)
{
    user_get_angel_in_hospital_out_header  out_header;
    user_get_angel_in_hospital_out_item *p_out_item;
    ret=this->user_angel_hospital.select(RECVBUF_USERID, &p_out_item, &out_header.count);
	for(uint32_t i = 0; i< out_header.count; ++i){
		if((p_out_item + i)->health_time == 0 && (p_out_item + i)->state != 1){
			ret = this->user_angel_hospital.recover(RECVBUF_USERID, (p_out_item + i)->id, (p_out_item + i)->angelid);
		}
	}
	user_get_angel_in_hospital_out_item *p_end = p_out_item + (out_header.count);
	std::sort(p_out_item, p_end);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/*
 * 使用道具，使天使康复
 */
int Croute_func::user_angel_tool_recover(DEAL_FUN_ARG)
{
    user_angel_tool_recover_in *p_in=PRI_IN_POS;
	user_angel_tool_recover_out out ={0 };
	out.id = p_in->id;
	uint32_t count = 0;
	uint32_t toolid = 190854;
    ret=this->user_attire.get_count(RECVBUF_USERID, toolid, count);
    if(ret != SUCC){
        return ret;
    }
    if(count < 1){
        return ATTIRE_COUNT_NO_ENOUGH_ERR;
    }
	uint32_t state = 0, angelid = 0;
	ret = this->user_angel_hospital.get_angelid(RECVBUF_USERID, p_in->id, angelid, state);
	if(ret == SUCC && state == 1){
		return THE_ANGEL_HAS_RECOVERED_ERR;
	}
	ret=this->user_angel_hospital.recover(RECVBUF_USERID, p_in->id, angelid);
	

    //扣除道具
	user_del_attire_in del_item = { 0 };
	del_item.attireid = toolid;
	del_item.attiretype = 0;
	del_item.count = 1;
	del_item.maxcount=99999;
	ret = this->user_del_attire(RECVBUF_USERID ,&del_item);
	////扣除物品
	//if(count == 1){
        //ret = this->user_attire.remove(RECVBUF_USERID, toolid);
    //}   
    //else{
		//uint32_t res_count = count - 1;
		//ret = this->user_attire.update(RECVBUF_USERID, toolid, 0, res_count);
		////ret = this->user_attire.update_count(RECVBUF_USERID, toolid, -1);
    //}

    STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * 天使康复，出院
 */
int Croute_func::user_angel_go_out_hospital(DEAL_FUN_ARG)
{
	user_angel_go_out_hospital_in_header *p_in = PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_angel_go_out_hospital_in_item));
	user_angel_go_out_hospital_in_item *p_in_item = (user_angel_go_out_hospital_in_item *)(RCVBUF_PRIVATE_POS + sizeof(*p_in));
	for(uint32_t i = 0; i < p_in->count; ++ i){
		uint32_t angelid = 0, state = 0;
		ret = this->user_angel_hospital.get_angelid(RECVBUF_USERID, (p_in_item + i)->id, angelid, state);
		if(state != 1){
			return  THE_ANGEL_HAS_RECOVERED_ERR; 
		}
		ret=this->user_angel_hospital.go_out_hospital(RECVBUF_USERID, (p_in_item + i)->id);
		uint32_t count = 0;
		ret = this->user_paradise_contract.get_hurt_count(RECVBUF_USERID, angelid, &count);
		if(count < 1){
			return NOT_CORRECT_ANGEL_GO_OUT_HOSPITAL_ERR;
		}
		count -= 1;
		ret = this->user_paradise_contract.update_hurt_count(RECVBUF_USERID, angelid, count);
		

		//如果是坐骑，判断是否需要插入坐骑表中	
		uint32_t type = 0;
		ret = this->user_paradise_contract.get_type(RECVBUF_USERID, angelid, &type);
		if((type & 0x02) == 0x02){//2表示坐骑,3表示可战可骑
			uint32_t dragonid = 0;
			ret = this->user_paradise_contract.mapping_to_dragon(angelid, &dragonid);
			if(ret != SUCC){
			 return ret;
			}
			uint32_t dragon_count = 0;
			ret = this->user_dragon.get_angel_dragon(RECVBUF_USERID, dragonid, dragon_count);
			ret = this->user_angel_add_dragon(RECVBUF_USERID, dragonid);
			if(ret != USER_ID_EXISTED_ERR && ret != SUCC){
				return ret;
			}
		}//if
	}

	STD_RETURN(ret);
}

/*
 * 添加天使
 */
int Croute_func::user_add_angel_contract(DEAL_FUN_ARG)
{
	char out[PROTO_MAX_LEN]={ };
    user_add_angel_contract_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_add_angel_contract_in_item));
    user_add_angel_contract_in_item * p_in_item=(user_add_angel_contract_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
	for(uint32_t i = 0; i < p_in->count; ++i){
		ret = this->user_paradise_contract.sign_contract(RECVBUF_USERID, (p_in_item + i)->angelid, 
				(p_in_item + i)->count, (p_in_item + i)->type);
	  if(((p_in_item + i)->type & 0x02) == 0x02){//2表示坐骑
			uint32_t dragonid = 0;
			ret = this->user_paradise_contract.mapping_to_dragon((p_in_item + i)->angelid, &dragonid);
			if(ret != SUCC){
				return ret;
			}
			ret = this->user_angel_add_dragon(RECVBUF_USERID, dragonid);
			if(ret != USER_ID_EXISTED_ERR && ret != SUCC){
				return ret;
			}
		}//if
		ret = this->user_angel_statistics.update(RECVBUF_USERID, (p_in_item + i)->angelid, (p_in_item + i)->count);
		if(ret == USER_ID_NOFIND_ERR){
			ret = this->user_angel_statistics.insert(RECVBUF_USERID, (p_in_item + i)->angelid, (p_in_item + i)->type,
					(p_in_item + i)->count);
		}//if

		this->user_cal_new_paradise_honor(RECVBUF_USERID);

		//计算荣誉
		uint32_t honor_type = 0, honor_id = 0, para_level = 0;
		user_angel_statistic_stru *p_item = 0;
		uint32_t total_sort = 0;
		ret = this->user_angel_statistics.get_all(RECVBUF_USERID, &p_item, &total_sort);
		if(ret != SUCC){
			if(p_item != 0){
				free(p_item);
			}
		}
		else{
			ret = this->user_paradise.get_level(RECVBUF_USERID, para_level);
			uint32_t *p_out = 0;
			uint32_t honor_count = 0;
			ret = this->user_angel_honor.get_honor_ids(RECVBUF_USERID, 1, &p_out, &honor_count);
			if(ret != SUCC){
				if(p_out != 0){
					free(p_out);
				}
			}
			this->user_cal_paradise_honor(RECVBUF_USERID, para_level, &honor_type,
					&honor_id, (p_in_item + i)->angelid, 0,  p_item, total_sort, 0, p_out, honor_count);
			free(p_out);
		}//else

	}//for

	user_add_angel_contract_out_header  *p_offset = (user_add_angel_contract_out_header*)out;
	p_offset->count = p_in->count;

    user_add_angel_contract_out_item *p_out_item = (user_add_angel_contract_out_item *)(out + 4); 
	for(uint32_t k = 0; k < p_in->count; ++k){
		(p_out_item + k)->angelid = (p_in_item + k)->angelid;
		(p_out_item + k)->count = (p_in_item + k)->count;
		
	}

	STD_RETURN_WITH_BUF(ret,out, p_in->count * sizeof(user_add_angel_contract_out_item) + 4);
}

/*
 * 拉取收藏夹天使
 */
int Croute_func::user_get_angel_favorite(DEAL_FUN_ARG)
{
	char out[PROTO_MAX_LEN]={ };
    user_get_angel_favorite_out_header  out_header = { 0 };
    user_get_angel_favorite_out_item *p_out_item = NULL;
	ret=this->user_paradise_contract.get_angel_in_favorite(RECVBUF_USERID, &p_out_item, &out_header.count);
	if(ret != SUCC && p_out_item != NULL){
		free(p_out_item);
		return ret;
	}
	memcpy(out + 4, (char*)p_out_item, sizeof(user_get_angel_favorite_out_item) * out_header.count);	

	//如果有且仅有一个，且在展示中，需要加上该展示中的天使
	user_get_angel_favorite_out_item exhibit = { 0 };
	ret = this->user_paradise.get_exhibit_angel(RECVBUF_USERID, &exhibit.angelid);
	if(exhibit.angelid != 0){
		user_get_angel_favorite_out_item *iter = std::find(p_out_item, p_out_item + out_header.count, exhibit);
		if(iter == p_out_item + out_header.count){
			char *p_offset = out + sizeof(user_get_angel_favorite_out_item) * out_header.count + 4;
			user_get_angel_favorite_out_item *p_temp = (user_get_angel_favorite_out_item *)p_offset;
			p_temp->angelid = exhibit.angelid;
			++out_header.count;
		}
	}
	*((uint32_t *)out) = out_header.count;	
	free(p_out_item);

	STD_RETURN_WITH_BUF(ret,out, 4 + out_header.count * sizeof(user_get_angel_favorite_out_item));
}

/*
 * 展示天使
 */
int Croute_func::user_exhibit_favorite_angel(DEAL_FUN_ARG)
{
    user_exhibit_favorite_angel_in *p_in=PRI_IN_POS;
    user_exhibit_favorite_angel_out out={};
	if(p_in->flag == 1){
		//要展示的天使是否为收藏天使，如果不是返回错误
		uint32_t angels[]={
			1354051, 1354053, 1354055, 1354057, 1354071, 1354075, 1354089, 1354163, 1354165, 1354167, 
			1354175, 1354179, 1354181, 1354187, 1354191, 1354195, 1354193, 1354201, 1354197, 1354203,
			1354207, 1354226, 1354231, 1354235, 1354244, 1354246
		};
		uint32_t *it = std::find(angels, angels + sizeof(angels)/ sizeof(uint32_t), p_in->angelid);
		if(it == angels + sizeof(angels)/ sizeof(uint32_t)){
			return NOT_CORRECT_EXHIBIT_ANGEL_ERR;
		}
	}
	
	out.angelid = p_in->angelid;
	uint32_t exhibit_angelid = 0;
	ret = this->user_paradise.get_exhibit_angel(RECVBUF_USERID, &exhibit_angelid);
	if(ret != SUCC){
		return ret;
	}
	else if(p_in->flag == 1 && exhibit_angelid == p_in->angelid){
		STD_RETURN_WITH_STRUCT(SUCC,out);
	}

	//开启事务
    STD_CLOSE_AUTOCOMMIT(ret);
	if(ret != SUCC) return ret;
	ret = this->show_angel(RECVBUF_USERID, p_in->angelid, exhibit_angelid, p_in->flag);
	if(ret==SUCC){
        //提交
        STD_COMMIT(ret);
    }else{
        //回滚
        STD_ROLLBACK();
    } 
    //关闭事务
    STD_OPEN_AUTOCOMMIT() ;	

    STD_RETURN_WITH_STRUCT(ret,out);
}
int  Croute_func:: show_angel(uint32_t userid, uint32_t angelid, uint32_t exhibit_angelid, uint32_t flag)
{
	if(flag == 1){//1表示展示天使
		uint32_t count = 0;
		ret = this->user_paradise_contract.get_angelid_count(userid, angelid, count);
		if(count == 0){
			return NOT_ENOUGH_EXHIBIT_ANGEL_ERR;
		}
		if(exhibit_angelid != 0 && exhibit_angelid != angelid){
			ret = this->user_paradise_contract.update_count_by_angelid(userid, exhibit_angelid, 1);
			if(ret != SUCC){
				return ret;
			}
		}
		ret = this->user_paradise_contract.update_count_by_angelid(userid, angelid, -1);	
		if(ret != SUCC){
			return ret;
		}
		ret = this->user_paradise.update_exhibit_angel(userid, angelid);
	}
	else if(flag  == 0){//表示取消展示天使
		ret = this->user_paradise_contract.update_count_by_angelid(userid, exhibit_angelid, 1);
		if(ret != SUCC){
			return ret;
		}
		ret = this->user_paradise.update_exhibit_angel(userid, 0);
	}

	return ret;
}

/*
 * 拉取已使用天使园背景
 */
int Croute_func::user_get_used_background(DEAL_FUN_ARG)
{

	char out[PROTO_MAX_LEN]={ };
   	user_get_used_background_out_header  out_header;
    user_get_used_background_out_item *p_out_item;


    ret=this->user_attire.get_paradise_noused_attirelist(RECVBUF_USERID, &p_out_item, &out_header.count);
	if( ret != SUCC){
		if(p_out_item != 0){
			free(p_out_item);
		}
		return ret;
	}	
	memcpy(out + 4, (char *)(p_out_item), sizeof(user_get_used_background_out_item) * out_header.count);
	free(p_out_item);
	paradise_attirelist att_list = {0}; 
    ret=this->user_paradise.get_bin_paradise_used_attirelist(RECVBUF_USERID, &att_list, 300);
	if(ret != SUCC){
		return ret;
	}
	char *p_offset = out +  sizeof(user_get_used_background_out_item) * out_header.count + 4;
	user_get_used_background_out_item * p_temp = (user_get_used_background_out_item *)p_offset;
	p_temp->attireid = att_list.item[0].attireid;
	p_temp->count = 1;
	out_header.count = out_header.count + 1;
	*((uint32_t *)out) = out_header.count;

	STD_RETURN_WITH_BUF(ret,out, 4 + out_header.count * sizeof(user_get_used_background_out_item));
}

/*
 * 使用十二生肖小屋交换大卫豆
 */
int Croute_func::user_exchange_davis_bean(DEAL_FUN_ARG)
{
    user_exchange_davis_bean_out out={ 0 };
	uint32_t twelve_home[] = {
		160724, 160739, 160756, 160772, 160783, 160807, 160821, 160837,
	  		160846, 160856, 160868, 160888
	};
	
	//得到数据库中已经交换大卫豆信息
	uint32_t count = 0, hometype_id = 0;
    ret = this->user_exchange_bean.select(RECVBUF_USERID, count);
	ret = this->user.get_hometypeid(RECVBUF_USERID, &hometype_id);
	stru_noused_attirelist st_list = {0} ; 
	ret = this->user.home_get_noused_attirelist(RECVBUF_USERID, &st_list);

	//查找玩家已有多少小屋	
	uint32_t ret = 0;
	for(uint32_t k = 0; k < sizeof(twelve_home) / sizeof(uint32_t); ++k){
		ret = st_list.get_attire_count(twelve_home[k]);
		if(ret != 0){
			++out.count;
			ret = 0;
		}
	}
	uint32_t len = sizeof(twelve_home)/sizeof(uint32_t);
	uint32_t *iter = std::find(twelve_home, twelve_home + len, hometype_id);
	if(iter != twelve_home + len){
		++out.count;
	}
	//开始交换大卫豆
	uint32_t tmp = out.count > count? (out.count - count): 0;
	out.count = tmp * 5;	
	out.id = 1351054; 
	if(out.count != 0){
		ret = this->user_exchange_bean.update(RECVBUF_USERID, tmp);
		if(ret == USER_ID_NOFIND_ERR){
			ret = this->user_exchange_bean.insert(RECVBUF_USERID, tmp);
		}
		//成功兑换大卫豆
		ret = this->user_temp_item.add_count(RECVBUF_USERID, out.id, out.count, 9999999);
	}//if

    STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * 获取玩家天使荣誉信息
 */
int Croute_func::user_get_angel_honors(DEAL_FUN_ARG)
{
	char out[PROTO_MAX_LEN]={ };
    user_get_angel_honors_out_header  out_header = { 0 };
    user_get_angel_honors_out_item_1 *p_out_item_1 = 0;
    user_get_angel_honors_out_item_2 *p_out_item_2 = 0;
	
	//下面为第一次拉取玩家荣誉,需要计算
	uint32_t flag = 0;
	ret = this->user_paradise.get_honor_first(RECVBUF_USERID, flag);
	if(flag == 0){
		//计算天使园荣誉	
		ret = this->user_paradise.update_honor_first(RECVBUF_USERID, 1);
		uint32_t honor_type = 0, honor_id = 0, para_level = 0;
		user_angel_statistic_stru *p_item = 0;
		uint32_t total_sort = 0;
		ret = this->user_angel_statistics.get_all(RECVBUF_USERID, &p_item, &total_sort);
		if(ret != SUCC){
			if(p_item != 0){
				free(p_item);
			}
		}
		else{
			ret = this->user_paradise.get_level(RECVBUF_USERID, para_level);
			uint32_t *p_out = 0;
			uint32_t honor_count = 0;
			ret = this->user_angel_honor.get_honor_ids(RECVBUF_USERID, 1, &p_out, &honor_count);
			if(ret != SUCC){
				if(p_out != 0){
					free(p_out);
				}
			}
			this->user_cal_paradise_honor(RECVBUF_USERID, para_level, &honor_type,
					&honor_id, 0, 0,  p_item, total_sort, 1, p_out, honor_count);
			free(p_out);

		}//else
		//计算战斗荣誉
		uint32_t battle_exp = 0, barrier_id = 9999, battle_level = 0;;
		ret = this->user_angel_battle.get_exp(RECVBUF_USERID, &battle_exp);
		ret = this->user_angel_battle.cal_level(battle_exp, &battle_level);

		uint32_t *p_list = 0;
		uint32_t battle_cnt = 0;
		ret = this->user_angel_honor.get_honor_ids(RECVBUF_USERID, 2, &p_list, &battle_cnt);
		if(ret != SUCC){
			if(p_list != 0){
				free(p_list);
			}
		}
		this->user_cal_battle_honor(RECVBUF_USERID, battle_level, barrier_id,
						&honor_type, &honor_id, p_list, battle_cnt);
		free(p_list);
	}//if 玩家第一次打开荣誉面板时

	ret = this->user_cal_new_paradise_honor(RECVBUF_USERID);
	//拉取荣誉信息
	char *p_offset = out;
	ret = this->user_angel_honor.get_all_locks(RECVBUF_USERID, 1, &p_out_item_1, &out_header.count_1);
	if(ret != SUCC){
		if(p_out_item_1 != 0){
			free(p_out_item_1);
		}
		return ret;
	}
	ret = this->user_angel_honor.get_all_locks(RECVBUF_USERID, 2, &p_out_item_2, &out_header.count_2);
	if(ret != SUCC){
		if(p_out_item_2 != 0){
			free(p_out_item_2);
		}
		return ret;
	}
	memcpy(p_offset, (char*)(&out_header), sizeof(out_header));
	p_offset = p_offset + sizeof(out_header);
	memcpy(p_offset, (char*)(p_out_item_1), sizeof(user_get_angel_honors_out_item) * out_header.count_1);
	p_offset = p_offset + sizeof(user_get_angel_honors_out_item) * out_header.count_1;
	free(p_out_item_1);
	memcpy(p_offset, (char*)(p_out_item_2), sizeof(user_get_angel_honors_out_item) * out_header.count_2);
	p_offset = p_offset + sizeof(user_get_angel_honors_out_item) * out_header.count_2;
	free(p_out_item_2);

	STD_RETURN_WITH_BUF(ret,out, p_offset - out);
}

/*
 * 玩家减锁荣誉后获取奖励
 */
int Croute_func::user_get_gift_after_unlock(DEAL_FUN_ARG)
{
    user_get_gift_after_unlock_in *p_in=PRI_IN_POS;
    user_get_gift_after_unlock_out out={};
	memcpy((char*)(&out), (char*)p_in, sizeof(user_get_gift_after_unlock_in));
	uint32_t unlock = 0, recv = 0;	
    ret=this->user_angel_honor.get_recv_lock(RECVBUF_USERID, p_in->honor_type, p_in->honor_id, &unlock,
			&recv);
	if(ret != SUCC){
		return ret;
	}
	if(unlock == 0){
		return THE_ANGEL_HONOR_LOCK_YET_ERR;
	}
	if(recv == 1){
		return THE_GIFT_OF_THE_HONOR_ALREADY_GET_ERR;
	}
	ret = this->user_angel_honor.update_recv(RECVBUF_USERID, p_in->honor_type, p_in->honor_id, 1);

    STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * 客服平台拉取签约天使
 */
int Croute_func::user_get_angel_contract_all_ex(DEAL_FUN_ARG)
{
    user_get_angel_contract_all_ex_out_header  out_header;
    user_get_angel_contract_all_ex_out_item *p_out_item;
    ret=this->user_paradise_contract.get_contract_angel_all_ex(RECVBUF_USERID, &p_out_item, &out_header.count);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/*
 * 
 *挖宝游戏开始
 */
int Croute_func::user_get_dig_treasure_begin(DEAL_FUN_ARG)
{   
	char out[PROTO_MAX_LEN]={ };
    user_get_dig_treasure_begin_in *p_in = PRI_IN_POS;
    user_get_dig_treasure_begin_out_header out_header = {0, 0, 100, 0, 0, 0, 0};	
    user_get_dig_treasure_begin_out_item *p_out_item = 0;	
    uint32_t time_last = 0, dig_counts = 0;
    ret = this->user_dig_treasure_info.get_info_game_begin(RECVBUF_USERID, &out_header.health,
		  	&out_header.experience, &time_last, &dig_counts);
    if(ret == USER_ID_NOFIND_ERR){
        ret =  this->user_dig_treasure_info.init_user(RECVBUF_USERID);
        if(ret != DB_SUCC){
            return ret;
        }   
    }//if
	else if(ret == SUCC){//更新玩家体力值
	  uint32_t now = time(0);
	  const uint32_t time_interval = 120;
	  uint32_t span = (now - time_last) / time_interval;
	  out_header.surplus = (now - time_last) % time_interval;
	  uint32_t cur_exp = 0, level = 0, hp_limit = 0;
	  ret = this->user_dig_treasure_info.get_exp(RECVBUF_USERID, cur_exp);
	  this->user_dig_treasure_info.get_level(cur_exp, level);	
	  if(level >= 10){
		  uint32_t clothes[] = {
			  13789, 13790,13791,13792
		  };
		  user_add_attire_in st_attire_add;
		  for(uint32_t i = 0; i< 4; ++i){
				st_attire_add.attireid = clothes[i];
				st_attire_add.attiretype = 0;
				st_attire_add.count = 1;
				st_attire_add.maxcount = 1;
				this->user_add_attire(RECVBUF_USERID, &st_attire_add);		
		  }//for
	  }
	  if(level >= 20){
		  uint32_t clothes[] = {
			  13797, 13798,13799, 13800
		  };
		  user_add_attire_in st_attire_add;
		  for(uint32_t i = 0; i< 4; ++i){
				st_attire_add.attireid = clothes[i];
				st_attire_add.attiretype = 0;
				st_attire_add.count = 1;
				st_attire_add.maxcount = 1;
				this->user_add_attire(RECVBUF_USERID, &st_attire_add);		
		  }//for
	  }
	  this->user_dig_treasure_info.get_hp_boundary(level, hp_limit);
	  out_header.health = (out_header.health + span * 10) > hp_limit ? hp_limit : (out_header.health + span * 10);
	  ret = this->user_dig_treasure_info.update_hp(RECVBUF_USERID, out_header.health, (now - out_header.surplus));
	  uint32_t today = get_date(now);
	  uint32_t old_day = get_date(time_last);
	  if(today != old_day){
		  ret = this->user_dig_treasure_info.update_dig_counts(RECVBUF_USERID, 0);
		  out_header.dig_counts = 0;
	  }
	  else{
		 out_header.dig_counts = dig_counts;
	  }
	}
   ret = this->user_dig_treasure.get_random_event_counts(RECVBUF_USERID, p_in->map_id, &p_out_item, &out_header.count); 
   if(ret != SUCC){
		if(p_out_item != 0){
			free(p_out_item);
			return ret;
		}
   }
   out_header.map_id = p_in->map_id;
   out_header.screen_id = p_in->screen_id;

   char *p_offset = out;
   memcpy(p_offset, (char*)(&out_header), sizeof(out_header));
   p_offset += sizeof(out_header);
   memcpy(p_offset, (char*)p_out_item, sizeof(user_get_dig_treasure_begin_out_item ) * out_header.count);
   p_offset += sizeof(user_get_dig_treasure_begin_out_item) * out_header.count;
   free(p_out_item);

   uint32_t first_login = 0;
   ret = this->user_treasure_collection.get_first_login(RECVBUF_USERID, first_login);
   if(first_login == 0){
	//id_list friendlist;
	//uint32_t  private_size;
	//ret=this->user_ex.get_idlist(RECVBUF_USERID ,FRIEND_LIST_STR, &friendlist);
	//private_size=sizeof(friendlist)-(FRIEND_COUNT_MAX -friendlist.count)*sizeof(friendlist.item[0]);
	//memcpy(p_offset,(char*)(&friendlist), private_size);
	//p_offset += private_size;
	ret = this->user_treasure_collection.update_first_login(RECVBUF_USERID, 1);
	if(ret == USER_ID_NOFIND_ERR){
		ret = this->user_treasure_collection.insert(RECVBUF_USERID, 1);
		ret = SUCC;
	}

   } 
   //else{
	*((uint32_t*)p_offset) = 0;
	p_offset += 4;
	//}

	STD_RETURN_WITH_BUF(ret, out, p_offset - out);
}   

/*
 * 
 *更新玩家信息
 */
int Croute_func::user_dig_treasure_update_player(DEAL_FUN_ARG)
{
    user_dig_treasure_update_player_in *p_in=PRI_IN_POS;
	uint32_t tim = (uint32_t)time(0) - p_in->surplus;
    uint32_t level = 0;
    this->user_dig_treasure_info.get_level(p_in->exp, level);	
	if(level == 10){
	  uint32_t clothes[] = {
		  13789, 13790,13791,13792
	  };
	  user_add_attire_in st_attire_add;
	  for(uint32_t i = 0; i< 4; ++i){
			st_attire_add.attireid = clothes[i];
			st_attire_add.attiretype = 0;
			st_attire_add.count = 1;
			st_attire_add.maxcount = 1;
			this->user_add_attire(RECVBUF_USERID, &st_attire_add);		
	  }//for
	}
   if(level == 20){
	  uint32_t clothes[] = {
		  13797, 13798,13799, 13800
	  };
	  user_add_attire_in st_attire_add;
	  for(uint32_t i = 0; i< 4; ++i){
			st_attire_add.attireid = clothes[i];
			st_attire_add.attiretype = 0;
			st_attire_add.count = 1;
			st_attire_add.maxcount = 1;
			this->user_add_attire(RECVBUF_USERID, &st_attire_add);		
	  }//for
	}
    ret=this->user_dig_treasure_info.update(RECVBUF_USERID, p_in->hp, p_in->exp, tim, p_in->dig_counts);

    STD_RETURN(ret);
}

/*
 * 挖宝游戏使用道具
 */
int Croute_func::user_dig_treasure_used_tool(DEAL_FUN_ARG)
{
    user_dig_treasure_used_tool_in *p_in=PRI_IN_POS;
    user_dig_treasure_used_tool_out out={ 0 };
	if(p_in->toolid != 1453301 && p_in->toolid != 1453302){
		return NOT_CORRECT_HP_RECOVER_TOOL_ERR;
	}
	out.toolid = p_in->toolid;
	uint32_t health = 0, cur_exp = 0, level = 0, hp_limit =0;
	ret = this->user_dig_treasure_info.get_hp(RECVBUF_USERID, health);
	ret = this->user_dig_treasure_info.get_exp(RECVBUF_USERID, cur_exp);
   	this->user_dig_treasure_info.get_level(cur_exp, level);	
   	this->user_dig_treasure_info.get_hp_boundary(level, hp_limit);
	if(health >= hp_limit){
		return THE_HEALTH_POINT_FULL_ERR;
	}
	uint32_t count = 0;
	ret=this->user_attire.get_count(RECVBUF_USERID, p_in->toolid, count);
    if(ret != SUCC){
        return ret;
    }
    if(count < 1){
        return ATTIRE_COUNT_NO_ENOUGH_ERR;
    }
	uint32_t time_last = 0;
	ret = this->user_dig_treasure_info.get_lasttime (RECVBUF_USERID, time_last);
	uint32_t now = (uint32_t)time(0);
	const uint32_t time_interval = 120;
    uint32_t span = (now - time_last) / time_interval;
	const uint32_t hp_recover_ten = 1453301;
	if(p_in->toolid == hp_recover_ten ){
		out.health = (health + 10 + span * 10) > hp_limit ? hp_limit: (health + 10 + span * 10);	
	}
	else{
		out.health = hp_limit;
	}
	
	ret=this->user_dig_treasure_info.update_hp(RECVBUF_USERID, out.health, now);
	
    //扣除道具
	user_del_attire_in del_item = { 0 };
	del_item.attireid=p_in->toolid;
	del_item.attiretype = 0;
	del_item.count = 1;
	del_item.maxcount=99999;
	ret=this->user_del_attire(RECVBUF_USERID ,&del_item);

    ////扣除道具
    //if(count == 1){
        //ret = this->user_attire.remove(RECVBUF_USERID, p_in->toolid);
    //}   
    //else{
		//uint32_t res_count = count - 1;
		//ret = this->user_attire.update(RECVBUF_USERID, p_in->toolid, 0, res_count);
    //}

    STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 *更新随机交互点、随机机关点、随机事件每日玩家见到次数
 */
int Croute_func::user_dig_treasure_update_random_count(DEAL_FUN_ARG)
{
	user_dig_treasure_update_random_count_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_dig_treasure_update_random_count_in_item ));
    user_dig_treasure_update_random_count_in_item * p_in_item=(user_dig_treasure_update_random_count_in_item *)
		(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;

	for(uint32_t k = 0; k < p_in->count; ++k){
		ret=this->user_dig_treasure.update_map_entern_count(RECVBUF_USERID, p_in->map_id, (p_in_item + k)->element_id,
				(p_in_item + k)->count);
		if(ret == USER_ID_NOFIND_ERR){
			ret = this->user_dig_treasure.add_user_dig_map(RECVBUF_USERID, p_in->map_id, (p_in_item + k)->element_id,
					(p_in_item + k)->count);
		}
	}//for
	ret = SUCC;
	STD_RETURN(ret);
}

/*
 * 挖宝玩家打开探险背包
 */
int Croute_func::user_get_expedition_bag(DEAL_FUN_ARG)
{
    user_get_expedition_bag_out_header  out_header;
    user_get_expedition_bag_out_item *p_out_item;
	// 探险背包物品起始id， 与终止id
	const uint32_t expedition_start = 1453000;
	const uint32_t expedition_end = 1552999;
    ret=this->user_attire.get_expedition_articles(RECVBUF_USERID, &p_out_item, &out_header.count,
			expedition_start, expedition_end ,0);
	
    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 拉取融合天使材料
 */
int Croute_func::user_synthesis_angel_get_material(DEAL_FUN_ARG)
{
	char out[PROTO_MAX_LEN]={ };
    user_synthesis_angel_get_material_out_header  out_header ={ 0 };
	user_synthesis_angel_get_material_out_item *p_out_item = 0;
	//获取等级
	uint32_t synthesis_level = 0;
	uint32_t synthesis_exp = 0;
	ret = this->user_paradise.get_synthesis_level(RECVBUF_USERID, synthesis_level, synthesis_exp);
	out_header.level = synthesis_level;
	out_header.exp = synthesis_exp;
	//获取材料
    user_get_expedition_bag_out_item *p_out_item_1 = (user_get_expedition_bag_out_item*) p_out_item;
	const uint32_t material_start = 1453000;
	const uint32_t material_end = 1453300;
    ret=this->user_attire.get_expedition_articles(RECVBUF_USERID, &p_out_item_1, &out_header.count_1,
			material_start, material_end, 0);
	if(ret != SUCC){
		if(p_out_item_1 != 0){
			free(p_out_item_1);
			return ret;
		}
	}
	char *p_offset = out;
	memcpy(p_offset, (char*)(&out_header), sizeof(out_header));
	p_offset += sizeof(user_synthesis_angel_get_material_out_header );
	memcpy(p_offset, p_out_item_1, sizeof(user_synthesis_angel_get_material_out_item) * out_header.count_1);
	p_offset += sizeof(user_synthesis_angel_get_material_out_item) * out_header.count_1;
	free(p_out_item_1);
	p_out_item = 0;
	user_get_angel_contract_all_out_item *p_out_item_2 = (user_get_angel_contract_all_out_item*) p_out_item;
	out_header.count_1 = 0;
	ret = this->user_paradise_contract.get_all(RECVBUF_USERID, &p_out_item_2, &out_header.count_1);
	if(ret != SUCC){
		if(p_out_item_2 != 0){
			free(p_out_item_2); 
		}
	}
	memcpy(p_offset, p_out_item_2, sizeof(user_get_angel_contract_all_out_item) * out_header.count_1);
	p_offset = p_offset + sizeof(user_get_angel_contract_all_out_item) * out_header.count_1;
	user_synthesis_angel_get_material_out_header *head= (user_synthesis_angel_get_material_out_header *)out;
	head->count_1 += out_header.count_1;
	free(p_out_item_2);	
	p_out_item = 0;

	//获取强化天使道具
	const uint32_t strengthen_tool_start = 1353106;
	const uint32_t stengthen_tool_end = 1353108;
    user_get_expedition_bag_out_item *p_out_item_3 = (user_get_expedition_bag_out_item*) p_out_item;
	ret=this->user_attire.get_expedition_articles(RECVBUF_USERID, &p_out_item_3, &out_header.count_2,
			strengthen_tool_start, stengthen_tool_end, 0);
	if(ret != SUCC){
		if(p_out_item_3 != 0){
			free(p_out_item_3);
		}
	}
	if(out_header.count_2  > 0){
		memcpy(p_offset, p_out_item_3, sizeof(user_synthesis_angel_get_material_out_item) * out_header.count_2);
		p_offset += sizeof(user_synthesis_angel_get_material_out_item) * out_header.count_2;
	}
	head->count_2 = out_header.count_2;
	free(p_out_item_3);

	STD_RETURN_WITH_BUF(ret, out , p_offset - out);
}

/*
 * 使用材料融合天使
 */
int Croute_func::user_synthesis_angel_with_material(DEAL_FUN_ARG)
{
    user_synthesis_angel_with_material_out out={ 0 };
    user_synthesis_angel_with_material_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->angel_count + p_in->material_count) * 
			sizeof(user_synthesis_angel_with_material_in_item_1));
    user_synthesis_angel_with_material_in_item_1 * p_in_item_1=(user_synthesis_angel_with_material_in_item_1*)
		(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
	//判断材料个数
	for(uint32_t i = 0; i < p_in->material_count; ++i){
		uint32_t num_in_table = 0;
		ret=this->user_attire.get_count(RECVBUF_USERID, (p_in_item_1 + i)->id, num_in_table);
		if(num_in_table < (p_in_item_1 + i)->count){
			return MATERIAL_COUNT_NOT_ENOUGH_ERR;
		}
	}
	//判断天使个数
	user_synthesis_angel_with_material_in_item_2 * p_in_item_2=(user_synthesis_angel_with_material_in_item_2*)
		       (RCVBUF_PRIVATE_POS+sizeof(*p_in) + p_in->material_count * sizeof(user_synthesis_angel_with_material_in_item_1)) ;
	for(uint32_t k = 0; k < p_in->angel_count; ++k ){
		uint32_t angel_num_in_table = 0;
		ret = this->user_paradise_contract.get_by_angelid(RECVBUF_USERID, (p_in_item_2 + k)->id, &angel_num_in_table);
		if(angel_num_in_table < (p_in_item_2 + k)->count){
			return MATERIAL_COUNT_NOT_ENOUGH_ERR;
		}

	}
	//判断合成等级是否满足	
	uint32_t synthesis_level = 0;
	uint32_t synthesis_exp = 0;
	ret = this->user_paradise.get_synthesis_level(RECVBUF_USERID, synthesis_level, synthesis_exp);
	if(synthesis_level < p_in->object_level){
		return THE_SYNTHESIS_LEVEL_LESS_THAN_OBJECT_LEVEL_ERR;
	}
	ret = this->user_paradise.update_syn_exp(RECVBUF_USERID, p_in->add_exp);
	ret = this->user_paradise.get_synthesis_level(RECVBUF_USERID, synthesis_level, synthesis_exp);
	out.level = synthesis_level; 
	ret = this->user_paradise.get_synthesis_lose_count(RECVBUF_USERID, &out.lose_count); 

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 重置装扮表中某物品的数量
 */
int Croute_func::user_set_attire_count(DEAL_FUN_ARG)
{
    user_set_attire_count_in *p_in=PRI_IN_POS;
    ret=this->user_attire.update_assign_count(RECVBUF_USERID, p_in->attireid, p_in->used_count,  p_in->count);

    STD_RETURN(ret);
}

/*
 * 重置签约天使类型
 */
int Croute_func::user_set_angel_type_ex(DEAL_FUN_ARG)
{
    user_set_angel_type_ex_in *p_in=PRI_IN_POS;
    ret=this->user_paradise_contract.set_angel_type(RECVBUF_USERID, p_in->angelid, p_in->type);
	ret= this->user_angel_statistics.set_angel_type(RECVBUF_USERID, p_in->angelid, p_in->type);
	if((p_in->type & 0x02) == 0x02){
		uint32_t dragonid = 0;
		ret = this->user_paradise_contract.mapping_to_dragon(p_in->angelid, &dragonid);
		if(ret != SUCC){
			return ret;
		}
		ret = this->user_angel_add_dragon(RECVBUF_USERID, dragonid);
	}

    STD_RETURN(ret);
}

/*
 * 天使强化历史记录
 */

int Croute_func::user_synthesis_history(DEAL_FUN_ARG)
{
    user_synthesis_history_in *p_in=PRI_IN_POS;
	if(p_in->is_success == 1){
		ret = this->user_paradise.update_synthesis_lose_count(RECVBUF_USERID, 0);
	}
	else{
		uint32_t lose_count = 0;
		ret = this->user_paradise.get_synthesis_lose_count(RECVBUF_USERID, &lose_count);
		ret = this->user_paradise.update_synthesis_lose_count(RECVBUF_USERID, lose_count + 1);
	}
	ret=this->user_synth_history.update(RECVBUF_USERID, p_in->id, p_in->is_success, 1);
	if(ret == USER_ID_NOFIND_ERR){
		ret = this->user_synth_history.insert(RECVBUF_USERID, p_in->id, p_in->is_success, 1);
	}
    STD_RETURN(ret);
}

/*
 * 拉取玩家宝藏仓库
 */
int Croute_func::user_get_treasure_warehouse(DEAL_FUN_ARG)
{
	user_get_treasure_warehouse_in *p_in = PRI_IN_POS;
    user_get_treasure_warehouse_out_header  out_header;
    user_get_treasure_warehouse_out_item *p_out_item;
	const uint32_t start_id = 1453357;
	const uint32_t end_id = 1552999;
	ret=this->user_attire.get_expedition_articles(RECVBUF_USERID, (user_get_expedition_bag_out_item **) &p_out_item,
		  	&out_header.count, start_id, end_id, p_in->flag); 

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/*
 * 玩家进入藏宝阁
 */
int Croute_func::user_get_treasure_collection(DEAL_FUN_ARG)
{
	char out[PROTO_MAX_LEN]={ };
    user_get_treasure_collection_out_header  out_header = { 0 };
    user_get_treasure_collection_out_item *p_out_item = 0;

	bool is_vip;
    ret = this->user_ex.get_vip(RECVBUF_USERID, &is_vip );
	out_header.vip = is_vip? 1:0;
    uint32_t cur_exp = 0, level = 0;
    ret = this->user_dig_treasure_info.get_exp(RECVBUF_USERID, cur_exp);
    ret = this->user_dig_treasure_info.get_level(cur_exp, level);
	out_header.level = level;
	out_header.exp = cur_exp;
    ret = this->user_treasure_collection.get_background(RECVBUF_USERID, &out_header.background);
	if(ret == USER_ID_NOFIND_ERR){
		ret = this->user_treasure_collection.insert(RECVBUF_USERID);
		ret = this->user_treasure_collection.get_background(RECVBUF_USERID, &out_header.background);
	}
	ret = this->user_treasure_show.get_all_show(RECVBUF_USERID, &p_out_item, &out_header.count);
	if(ret != SUCC){
		if(p_out_item != 0){
			free(p_out_item);
			return ret;
		}
	}
	char *p_offset = out;
	memcpy(p_offset, (char*)(&out_header), sizeof(out_header));
	p_offset += sizeof(out_header);
	memcpy(p_offset, (char *)p_out_item, sizeof(user_get_treasure_collection_out_item) * out_header.count);
	p_offset += sizeof(user_get_treasure_collection_out_item) * out_header.count;

	//第一次登陆将展示的宝藏加回到装扮表中的count字段、usedcount字段
	uint32_t first_mod = 0;
	ret = this->user_treasure_collection.get_first_mod(RECVBUF_USERID, &first_mod);
	if(first_mod == 0){
		for(uint32_t i = 0; i < out_header.count; ++i){
			ret = this->user_attire.update_usedcount_count(RECVBUF_USERID, (p_out_item + i)->id, 1, 1);
		}
		if(ret == SUCC){
			ret = this->user_treasure_collection.update_first_mod(RECVBUF_USERID, 1);
		}
	}

	free(p_out_item);
	uint32_t first_login = 0;
	ret = this->user_treasure_collection.get_first_login(RECVBUF_USERID, first_login);
	if(first_login == 0){
		id_list friendlist;
		uint32_t  private_size;
		ret=this->user_ex.get_idlist(RECVBUF_USERID ,FRIEND_LIST_STR, &friendlist);
		private_size=sizeof(friendlist)-(FRIEND_COUNT_MAX -friendlist.count)*sizeof(friendlist.item[0]);
		memcpy(p_offset,(char*)(&friendlist), private_size);
		p_offset += private_size;
		ret = this->user_treasure_collection.update_first_login(RECVBUF_USERID, 1);
		ret = SUCC;

	}
	else{
		*((uint32_t*)p_offset) = 0;
		p_offset += 4;
	}

	STD_RETURN_WITH_BUF(ret, out, p_offset - out);
}
/*
 * 玩家往格子中摆放物品 
 */
int Croute_func::user_show_treasure(DEAL_FUN_ARG)
{
    user_show_treasure_in *p_in=PRI_IN_POS;
	uint32_t cur_exp = 0, level = 0;
	ret = this->user_dig_treasure_info.get_exp(RECVBUF_USERID, cur_exp);
    ret = this->user_dig_treasure_info.get_level(cur_exp, level);
	uint32_t grid_limit = 0;
	ret = this->user_treasure_collection.get_grid_count(level, grid_limit);
	if(p_in->pos > grid_limit - 1){
		return NOT_CORRECT_TREASURE_SHOW_POSITION_ERR;
	}
	if(p_in->status > 2){
		return NOT_CORRECT_TEASURE_SHOW_STATUS_ERR;
	}
	if(p_in->itemid < 1453367 || p_in->itemid > 1552999){
		return NOT_CORRECT_TREASURE_SHOW_POSITION_ERR;
	}
    user_show_treasure_out out={};
	memcpy((char*)(&out), p_in, sizeof(user_show_treasure_in));

	uint32_t itemid = 0, status = 0;
	ret = this->user_treasure_show.get_pos_show(RECVBUF_USERID, p_in->pos, &itemid, &status);
	if(ret ==  USER_ID_NOFIND_ERR){
		if(p_in->status != 0){
			uint32_t noused_count = 0;
			ret = this->user_attire.get_nousedcount (RECVBUF_USERID, p_in->itemid, &noused_count);
			if(noused_count < 1){
				return ATTIRE_COUNT_NO_ENOUGH_ERR;
			}
			ret = this->user_treasure_show.insert(RECVBUF_USERID, p_in->itemid, p_in->pos, p_in->status);
			ret = this->user_attire.update_used_count_inc(RECVBUF_USERID, p_in->itemid, 1);
		}//内部if
	}
	else{
		if(p_in->status == 0){//将展示物品取下
			uint32_t cnt = 0;
			ret = this->user_attire.get_used_count(RECVBUF_USERID, itemid, cnt);
			if(cnt < 1){
				uint32_t show_count = 0;
				ret = this->user_treasure_show.get_show_count(RECVBUF_USERID, itemid, show_count);
				if(show_count > 0){
					ret = this->user_attire.update_usedcount_count(RECVBUF_USERID, itemid, show_count, show_count);
					cnt = cnt + show_count;
				}
				else{
					return ATTIRE_COUNT_NO_ENOUGH_ERR;
				}
			}
			ret = this->user_attire.update_used_count(RECVBUF_USERID, itemid, cnt - 1);
			ret = this->user_treasure_show.del(RECVBUF_USERID, p_in->pos);
		}
		else{
			if(itemid != p_in->itemid){
				//将原有位置物品放回去
				uint32_t count_1 = 0;
				ret=this->user_attire.get_used_count(RECVBUF_USERID, itemid, count_1);
				if(count_1 < 1){
					return ATTIRE_COUNT_NO_ENOUGH_ERR;
				}
				uint32_t count_2 = 0;
				ret=this->user_attire.get_nousedcount(RECVBUF_USERID, p_in->itemid, &count_2);
				if(count_2 < 1){
					return ATTIRE_COUNT_NO_ENOUGH_ERR;
				}
				ret = this->user_attire.update_used_count(RECVBUF_USERID, itemid, count_1 - 1);
				//将现有物品放到格子里 
				ret = this->user_treasure_show.update(RECVBUF_USERID, p_in->itemid, p_in->pos, p_in->status);	
				ret = this->user_attire.update_used_count_inc(RECVBUF_USERID, p_in->itemid, 1);
			}
		}//else
		
	}//else	

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 玩家格子中交换展示宝藏位置
 */
int Croute_func::user_exchange_treasure_show_pos(DEAL_FUN_ARG)
{
    user_exchange_treasure_show_pos_in *p_in = PRI_IN_POS;
    user_exchange_treasure_show_pos_out out={ 0 };
	memcpy((char*)(&out), p_in, sizeof(user_exchange_treasure_show_pos_in));
	uint32_t cur_exp = 0, level = 0;
    ret = this->user_dig_treasure_info.get_exp(RECVBUF_USERID, cur_exp);
    ret = this->user_dig_treasure_info.get_level(cur_exp, level);
	uint32_t grid_limit = 0;
	ret = this->user_treasure_collection.get_grid_count(level, grid_limit);
    if(p_in->pos_1 > grid_limit -1 || p_in->pos_2 > grid_limit - 1){
        return NOT_CORRECT_TREASURE_SHOW_POSITION_ERR;
    }

	if(p_in->pos_1 != p_in->pos_2){
		uint32_t itemid_1 = 0, status_1 = 0;
		uint32_t itemid_2 = 0, status_2 = 0;
		ret = this->user_treasure_show.get_pos_show(RECVBUF_USERID, p_in->pos_1, &itemid_1, &status_1);
		ret = this->user_treasure_show.get_pos_show(RECVBUF_USERID, p_in->pos_2, &itemid_2, &status_2);

		if(itemid_1 != 0 && itemid_2 != 0){
			ret = this->user_treasure_show.update(RECVBUF_USERID, itemid_2, p_in->pos_1, status_2);
			ret = this->user_treasure_show.update(RECVBUF_USERID, itemid_1, p_in->pos_2, status_1);
		}
		else if(itemid_1 != 0 && itemid_2 == 0){
			ret = this->user_treasure_show.insert(RECVBUF_USERID, itemid_1, p_in->pos_2, status_1);
			ret = this->user_treasure_show.del(RECVBUF_USERID, p_in->pos_1);
		}
		else if(itemid_1 == 0 && itemid_2 != 0){
			ret = this->user_treasure_show.insert(RECVBUF_USERID, itemid_2, p_in->pos_1, status_2);
			ret = this->user_treasure_show.del(RECVBUF_USERID, p_in->pos_2);
		}
	}

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 拉取藏宝阁访客列表
 */
int Croute_func::user_treasure_collection_get_visitlist(DEAL_FUN_ARG)
{
    user_treasure_collection_get_visitlist_out out={ 0 };
    ret = this->user_treasure_collection.get_visitlist(RECVBUF_USERID, &out);
	uint32_t visit_size = 0;
	visit_size =  sizeof(out.count) + sizeof(visit_trace) * out.count;

    STD_RETURN_WITH_BUF(ret,(char*)&out , visit_size );
}
/*
 * 更新藏宝阁访问列表
 */
int Croute_func::user_treasure_collection_update_visitlist(DEAL_FUN_ARG)
{
    user_treasure_collection_update_visitlist_in *p_in=PRI_IN_POS;
    user_treasure_collection_get_visitlist_out visitlist = { 0 };
    ret = this->user_treasure_collection.get_visitlist(RECVBUF_USERID, &visitlist);
	if(ret != SUCC){
		return ret;
	}
	visit_trace *it = std::find(visitlist.users, visitlist.users + visitlist.count, p_in->userid);
	if(it == visitlist.users + visitlist.count){
		if(visitlist.count >= TREASURE_ACCESS_MAX){
			uint32_t oldest_time = time(0);
			uint32_t index = 0;
			for(uint32_t k = 0; k < visitlist.count; ++k){
				if(visitlist.users[k].time < oldest_time){
					oldest_time = visitlist.users[k].time;
					index = k;
				}
			}//for
			visitlist.users[index].userid = p_in->userid;
			visitlist.users[index].time = (uint32_t)time(0);
		}//if
		else{
			visitlist.users[visitlist.count].userid = p_in->userid;
			visitlist.users[visitlist.count].time = (uint32_t)time(0);
			visitlist.count += 1;
		}

	}//if
	else{
		it->time = (uint32_t)time(0);
	}
	ret = this->user_treasure_collection.update_visitlist(RECVBUF_USERID, visitlist);

    STD_RETURN(ret);
}
/*
 * 改变宝藏展示状态
 */
int Croute_func::user_change_show_treasure_status(DEAL_FUN_ARG)
{
    user_change_show_treasure_status_in *p_in=PRI_IN_POS;
	user_change_show_treasure_status_out out = {0 };	
	memcpy((char*)(&out), p_in, sizeof(user_change_show_treasure_status_in ));
	if(p_in->status > 2){
		return NOT_CORRECT_TEASURE_SHOW_STATUS_ERR;
	}
    ret=this->user_treasure_show.update_show_status(RECVBUF_USERID, p_in->pos, p_in->status);

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 更新藏宝阁全局表
 */
int Croute_func::sysarg_update_treasure_collection(DEAL_FUN_ARG)
{
    sysarg_update_treasure_collection_in *p_in=PRI_IN_POS;
    ret = this->sysarg_treasure_collection.update(RECVBUF_USERID, p_in->exp);
	if(ret == USER_ID_NOFIND_ERR){
		ret = this->sysarg_treasure_collection.insert(RECVBUF_USERID, p_in->exp, 0);
	}

    STD_RETURN(ret);
}
/*
 * 从全局表中获取藏宝阁访客列表
 */
int Croute_func::sysarg_get_treasure_visit(DEAL_FUN_ARG)
{
    sysarg_get_treasure_visit_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(sysarg_get_treasure_visit_in_item));
    sysarg_get_treasure_visit_in_item * p_in_item=(sysarg_get_treasure_visit_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
    sysarg_get_treasure_visit_out_header  out_header = {0};
    sysarg_get_treasure_visit_out_item *p_out_item = 0;
	if(p_in->count == 0){
		out_header.count = 0;
		ret = SUCC;
		STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
	}	
    ret = this->sysarg_treasure_collection.select_visit(p_in->count, p_in_item, &(out_header.count), &p_out_item);
	for(uint32_t k = 0; k < p_in->count; ++k){
		for(uint32_t i = 0; i< out_header.count; ++i){
			if(p_out_item[i].userid == p_in_item[k].userid){
				p_out_item[i].time = p_in_item[k].time; 
				break;
			}
		}
	}
	ret = SUCC;

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 从全局表中获取藏宝阁好友列表
 */
int Croute_func::sysarg_get_treasure_friend(DEAL_FUN_ARG)
{
    sysarg_get_treasure_friend_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(sysarg_get_treasure_friend_in_item));
    sysarg_get_treasure_friend_in_item * p_in_item=(sysarg_get_treasure_friend_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
    sysarg_get_treasure_friend_out_header  out_header = { 0 };
    sysarg_get_treasure_friend_out_item *p_out_item = 0;
    ret=this->sysarg_treasure_collection.select_friend(RECVBUF_USERID, p_in->count, p_in_item, &(out_header.count), &p_out_item);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/*
 * 愤怒拉姆打企鹅游戏
 */
int Croute_func::roominfo_strike_pengin_game(DEAL_FUN_ARG)
{
    roominfo_strike_pengin_game_in *p_in=PRI_IN_POS;
    roominfo_strike_pengin_game_out out={ 0 };
	DEBUG_LOG("barrier: %u, cur_score: %u, is_pass: %u, base_score: %u", 
			p_in->barrier, p_in->cur_score, p_in->is_pass, p_in->base_score);
	uint32_t date = 0;
	ret = this->roominfo_strike_penguin.get_max_pass_berrier(RECVBUF_USERID, &out.max_pass_barrier);
	//out.max_pass_barrier += 1;
	if(p_in->barrier > (out.max_pass_barrier + 1) || p_in->barrier == 0){
		return THE_BARRIER_HAS_LOCKED_YET_ERR;
	}

	uint32_t award_flag = 0, pass_in_table = 0;
	if((p_in->is_pass == 1) && (p_in->cur_score >= p_in->base_score)){
		award_flag = 1;
	}

	ret = this->roominfo_strike_penguin.select(RECVBUF_USERID, p_in->barrier, &out.max_score, &date,
			&pass_in_table, &out.day_first_award);
	uint32_t today = get_date(time(0));
	if(ret == USER_ID_NOFIND_ERR){
		ret = this->roominfo_strike_penguin.insert(RECVBUF_USERID, p_in->barrier, p_in->cur_score, 
				award_flag, p_in->is_pass);
		if(award_flag == 1){
			out.day_first_award = 0;
		}
	}
	else if(ret == SUCC){
		if(award_flag == 1){
			if((date == today && out.day_first_award == 0) || date != today){
				ret = this->roominfo_strike_penguin.update_date_award(RECVBUF_USERID, p_in->barrier, today, 1);
				out.day_first_award = 0;
			}
		}
		if(p_in->is_pass == 1 && pass_in_table == 0){
			ret = this->roominfo_strike_penguin.update_ispass(RECVBUF_USERID, p_in->barrier, p_in->is_pass);	
		}
		if(p_in->cur_score > out.max_score){
			ret = this->roominfo_strike_penguin.update_score(RECVBUF_USERID, p_in->barrier, p_in->cur_score);
		}
	}//else
	if(p_in->cur_score > out.max_score){
		out.max_score = p_in->cur_score;
	}	
	out.barrier = p_in->barrier;
	out.cur_score = p_in->cur_score;
	out.is_pass = p_in->is_pass;
	DEBUG_LOG("barrier: %u, cur_score:%u, day_award: %u, max_barrier: %u, max_score: %u", 
			out.barrier, out.cur_score, out.day_first_award, out.max_pass_barrier, out.max_score);
	
    STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * 愤怒拉姆打企鹅拉取记录
 */
int Croute_func::roominfo_strike_penguin_get_info(DEAL_FUN_ARG)
{
    roominfo_strike_penguin_get_info_out_header  out_header = { 0 };
    roominfo_strike_penguin_get_info_out_item *p_out_item = 0;
    ret = this->roominfo_strike_penguin.select_history(RECVBUF_USERID, &p_out_item, &out_header.count);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/*
 * 商城连续登陆获取积分
 */
int Croute_func::user_continue_login_shop(DEAL_FUN_ARG)
{
    user_continue_login_shop_out out={ 0 };
	const uint32_t type = 0;
	ret = this->user_continue_login.cal_continue(RECVBUF_USERID, type, &out);

	if(out.get_count != 0) {
		user_add_attire_in st_attire_add;
		st_attire_add.attireid = 1351056;
		st_attire_add.attiretype = 0;//零时物品商城积分，放到了装扮表里
		st_attire_add.count = out.get_count;
		st_attire_add.maxcount = 999999999;
		this->user_add_attire(RECVBUF_USERID, &st_attire_add);
	}

    STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * 捉迷藏遊戲
 */
int Croute_func::user_hide_and_seek_get_award(DEAL_FUN_ARG)
{
    user_hide_and_seek_get_award_in *p_in=PRI_IN_POS;
    user_hide_and_seek_get_award_out out={};
	memcpy(&out, p_in, sizeof(user_hide_and_seek_get_award_in));
	uint32_t day_badge_max = 550;
	bool is_vip;
	ret = this->user_ex.get_vip(RECVBUF_USERID, &is_vip );
	if(is_vip){
		day_badge_max = 600;	
	}	
	uint32_t badge_count = 0, date = 0;
    ret=this->user_hide_and_seek.select(RECVBUF_USERID, &badge_count, &date, p_in->role);
	
	uint32_t today = get_date(time(0));
	if(date == today){
		if(badge_count + p_in->item_count > day_badge_max){
			ret = this->user_hide_and_seek.update(RECVBUF_USERID, day_badge_max, p_in->role);
			out.item_count = day_badge_max - badge_count;
		}
		else{
			ret = this->user_hide_and_seek.update(RECVBUF_USERID, badge_count + p_in->item_count, p_in->role);
		}
	}
	else{
		ret = this->user_hide_and_seek.update_date_cnt(RECVBUF_USERID, p_in->item_count, today,  p_in->role);
		if(ret == USER_ID_NOFIND_ERR){
			ret = this->user_hide_and_seek.insert(RECVBUF_USERID, p_in->item_count, p_in->role);
		}
	}
	if(out.item_count != 0){
		user_add_attire_in st_attire_add;
		st_attire_add.attireid = p_in->itemid ;
		st_attire_add.attiretype = 99;//
		st_attire_add.count = out.item_count;
		st_attire_add.maxcount = 999999999;
		this->user_add_attire(RECVBUF_USERID, &st_attire_add);
	}

    STD_RETURN_WITH_STRUCT(ret,out);
}

/* 
 * 进入蒙牛牧场 
 */
int Croute_func::user_get_mongolian_cow_pasture(DEAL_FUN_ARG)
{
	char buf[PROTO_MAX_LEN]={0};
    user_get_mongolian_cow_pasture_out_header  *out_header = (user_get_mongolian_cow_pasture_out_header*)buf;
	char *p_offset = buf;

	//拉取蒙牛牧场内容
	uint32_t day_count = 0;
	stru_grass_info grass_info ={ 0 };
	const uint32_t default_cow = 1351075;
	p_offset += sizeof(user_get_mongolian_cow_pasture_out_header);
    user_get_mongolian_cow_pasture_out_item_1 *p_out_item_1 = (user_get_mongolian_cow_pasture_out_item_1 *)p_offset;
    ret = this->user_cow_pasture.get_all(RECVBUF_USERID, &out_header->mk_storage, &out_header->background, 
			&day_count, &grass_info);
	if(ret == USER_ID_NOFIND_ERR){
		ret = this->user_cow_pasture.insert(RECVBUF_USERID);
		ret = this->user_milk_cow.insert(RECVBUF_USERID, default_cow);
		ret = this->user_cow_pasture.get_all(RECVBUF_USERID, &out_header->mk_storage, &out_header->background, 
			&day_count, &grass_info);
	}
	
	//拉取饲养的奶牛
	uint32_t today = time(0);
	user_get_mongolian_cow_pasture_out_item_2 *p_out_item_2 = 0;
	ret = this->user_milk_cow.get_all(RECVBUF_USERID, &p_out_item_2, &out_header->count_2);

	//奶牛属性计算
	for(uint32_t k = 0; k < out_header->count_2; ++k){
		ret = this->user_milk_cow.cal_cow_attribute(RECVBUF_USERID, p_out_item_2 + k, &grass_info, today);	
	}	

	//剩余牧草写入
	ret = this->user_cow_pasture.update_grass_info(RECVBUF_USERID, &grass_info);
	
	out_header->count_1 = grass_info.count;
	for(uint32_t i = 0; i< grass_info.count; ++i){
		(p_out_item_1 + i)->grassid = grass_info.grass[i].grassid;
		(p_out_item_1 + i)->index = grass_info.grass[i].index;
	}
	p_offset += grass_info.count* sizeof( user_get_mongolian_cow_pasture_out_item_1);
	memcpy(p_offset, (char*)p_out_item_2, sizeof(user_get_mongolian_cow_pasture_out_item_2) * out_header->count_2);
	p_offset += sizeof(user_get_mongolian_cow_pasture_out_item_2) * out_header->count_2;
	
	STD_RETURN_WITH_BUF(ret, buf, p_offset - buf);
}
/*
 * 玩家与奶牛互动
 */
int Croute_func::user_play_with_milk_cow(DEAL_FUN_ARG)
{
    user_play_with_milk_cow_in *p_in = PRI_IN_POS;
    user_play_with_milk_cow_out out = { };
	memset(&out, 0, sizeof(out));
	ret = this->user_milk_cow.get_milk_cow_by_id(RECVBUF_USERID, p_in->id, &out.cow_info);
	out.cow_info.id = p_in->id;
	out.oper_id = p_in->oper_id;

	stru_grass_info grass_info ={0};
	ret = this->user_cow_pasture.get_grass_info(RECVBUF_USERID, &grass_info);
	ret = this->user_cow_pasture.get_col(RECVBUF_USERID, "day_count", &out.day_count);
	ret = this->user_cow_pasture.get_col(RECVBUF_USERID, "milk_storage", &out.milk_storage);
	switch(p_in->oper_id){
		case 1://打扫卫生
			{
				uint32_t rand_1 = rand()%5 + 4;
				out.cow_info.clean = (out.cow_info.clean + rand_1) > 100 ? 100:(out.cow_info.clean + rand_1);
				ret = this->user_milk_cow.update_attribute(RECVBUF_USERID, p_in->id, "clean", out.cow_info.clean);
				break;
			}
		case 2://陪他玩耍
			{
				uint32_t rand_2 = rand()%5 + 4;
				out.cow_info.mood = (out.cow_info.mood + rand_2) > 100 ? 100:(out.cow_info.mood + rand_2); 
				ret = this->user_milk_cow.update_attribute(RECVBUF_USERID, p_in->id, "mood", out.cow_info.mood);
				break;
			}
		case 3://挤牛奶
			{
				if(out.cow_info.clean >= 40 && out.cow_info.mood >= 40 && grass_info.count != 0){
					if(out.cow_info.is_milk == 0){
						//储存牛奶，更新挤奶日期
						uint32_t add_milk = 0;
						if(out.cow_info.clean == 100 && out.cow_info.hp == 100 && out.cow_info.mood == 100){
							add_milk = 525;
						}
						else{
							add_milk = ((out.cow_info.clean + out.cow_info.hp + out.cow_info.mood - 80) * 1.0 / 220) * 525;
						}
						uint32_t today = get_date(time(0));
						out.milk_storage = (out.milk_storage + add_milk);	
						out.cow_info.is_milk = 1;
						ret = this->user_milk_cow.update_attribute(RECVBUF_USERID, p_in->id, "milk_date", today);

						//更新装满一瓶天数	
						uint32_t store_date = 0;
						ret = this->user_cow_pasture.get_col(RECVBUF_USERID, "store_date", &store_date);
						if(store_date != today){
							out.day_count += 1;
							ret = this->user_cow_pasture.update_col(RECVBUF_USERID, "day_count", out.day_count);
						}
						ret = this->user_cow_pasture.update_two_col(RECVBUF_USERID, "milk_storage", "store_date",
								out.milk_storage, today);
					}
				}//if	
				break;
			}
		default: 
			break;

	}//switch
	DEBUG_LOG("id: %u ,cowid: %u, hp:%u, mood: %u, clean: %u, is_milk: %u, eat_date:%u, storage: %u, day_count:%u",
			out.cow_info.id, out.cow_info.cowid, out.cow_info.hp, out.cow_info.mood, out.cow_info.clean, out.cow_info.is_milk,
			out.cow_info.eat_date, out.milk_storage, out.day_count);

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 种植牧草
 */
int Croute_func::user_milk_cow_pasture_plant(DEAL_FUN_ARG)
{
    user_milk_cow_pasture_plant_in *p_in=PRI_IN_POS;
	char buf[PROTO_MAX_LEN]={0};
	user_milk_cow_pasture_plant_out_header *out_header = (user_milk_cow_pasture_plant_out_header *)buf;
	stru_grass_info grass_info ={0};
    ret = this->user_cow_pasture.get_grass_info(RECVBUF_USERID, &grass_info);
	if(p_in->index > 16){
		return THE_GROUND_ALREADY_PLANT_ERR;
	}
	for(uint32_t k = 0; k < grass_info.count; ++k){
		if(grass_info.grass[k].index == p_in->index){
			return THE_GROUND_ALREADY_PLANT_ERR;
		}
	}
	grass_info.grass[grass_info.count].grassid = p_in->grassid;
	grass_info.grass[grass_info.count].index = p_in->index;
	grass_info.count += 1;
	ret = this->user_cow_pasture.update_grass_info(RECVBUF_USERID, &grass_info);
	out_header->count = grass_info.count;
	char *p_offset = buf + sizeof(user_milk_cow_pasture_plant_out_header);
	memcpy(p_offset, (char *)grass_info.grass, sizeof( user_milk_cow_pasture_plant_out_item) * grass_info.count);
	p_offset += sizeof( user_milk_cow_pasture_plant_out_item) * grass_info.count;
	
	STD_RETURN_WITH_BUF(ret, buf, p_offset - buf);
}
/*
 * 妙妙收购牛奶
 */
int Croute_func::user_set_pasture_milk_storage(DEAL_FUN_ARG)
{
	user_set_pasture_milk_storage_out out={0};
	ret = this->user_cow_pasture.get_two_col(RECVBUF_USERID, "milk_storage", "day_count", &out.milk_storage, &out.day_count);
	if(out.milk_storage < 1000){
		return NOT_ENOUGH_MILK_TO_PURCHASE_ERR;
	}
	out.milk_storage -= 1000;
	uint32_t day = 0;	
	if(out.milk_storage != 0){
			day = 1;
	}
    ret = this->user_cow_pasture.update_two_col(RECVBUF_USERID, "milk_storage", "day_count", out.milk_storage, 1);

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 删除邮件列表
 */
 int Croute_func::emailsys_del_list(DEAL_FUN_ARG)
{
    emailsys_del_list_in_header *p_in = PRI_IN_POS;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(emailsys_del_list_in_item));
    emailsys_del_list_in_item * p_in_item=(emailsys_del_list_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
    ret = this->user_email.remove_email_list(RECVBUF_USERID, p_in->count, p_in_item);
	ret = SUCC;
	STD_RETURN(ret);
}
/*
 * 获取随机摇奖次数
 */
 int Croute_func::roominfo_get_random_gain_times(DEAL_FUN_ARG)
{
    roominfo_get_random_gain_times_in *p_in=PRI_IN_POS;
    roominfo_get_random_gain_times_out out={0};
    ret=this->roominfo_random_gain_gift.get_times(RECVBUF_USERID, p_in->type, &out.times);
	ret = SUCC;

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 更新随机摇奖次数
 */
int Croute_func::roominfo_change_random_gain_times(DEAL_FUN_ARG)
{
    roominfo_change_random_gain_times_in *p_in=PRI_IN_POS;
	DEBUG_LOG("type: %u, flag: %u", p_in->type, p_in->is_clear);
	if(p_in->is_clear == 1){
		ret=this->roominfo_random_gain_gift.update_times(RECVBUF_USERID, p_in->type, 0);
	}
	else{
		ret = this->roominfo_random_gain_gift.add_times(RECVBUF_USERID, p_in->type, 1);
	}

    STD_RETURN(ret); 
}
//2011暑期版本战斗部分
/*
 * 拉取角色属性
 */
int Croute_func::user_get_battle_character_bag(DEAL_FUN_ARG)
{
	char buf[PROTO_MAX_LEN]={0};
	//基本角色属性
    user_get_battle_character_bag_out_header  *out_header = (user_get_battle_character_bag_out_header*)buf;
	
	uint32_t if_first = 0;
	ret = this->user_battle_character_attribute.get_character(RECVBUF_USERID, &out_header->person, &if_first);
	//如果玩家第一次参与战斗，增加一默认主动技能
	if(if_first == 1){
		const uint32_t default_skill = 1563000;
		const uint32_t default_card = 1553000;
		ret = this->user_battle_skill_equip.insert(RECVBUF_USERID, default_skill, 0, 1, 1);
		uint32_t is_first = 0;
		ret = this->user_battle_card_booklet.add_card(RECVBUF_USERID, default_card, 1, 1, 1, &is_first);

		//统计等级人数
		struct lvl_player_t{
			uint32_t userid;
			uint32_t level;
		};	
		lvl_player_t package_send = { RECVBUF_USERID, 1};
		msglog(this->msglog_file, 0x0409BBC7, time(NULL), &package_send, sizeof(package_send));

	}
	uint32_t today = get_date(time(0));
	uint32_t date = 0;
	ret = this->user_battle_character_attribute.get_one_column(RECVBUF_USERID, "date", &date);
	if(date != today){
		out_header->day_first_login = 1;
		ret = this->user_battle_character_attribute.update_three_columns(RECVBUF_USERID, "day_energy", "day_vigour", "date",
				0, 0, today);
		this->user_battle_friend_event.clear_fight_count(RECVBUF_USERID);
		ret = this->user_battle_day_task.clear_old_task(RECVBUF_USERID);
		this->user_battle_master.clear_train_info(RECVBUF_USERID);
		this->user_battle_prentice.clear(RECVBUF_USERID, today);
	}
	uint32_t bat_date = 0;	
	ret = this->user_battle_challenge_note.get_two_col(RECVBUF_USERID, 2, "date", "pvp_cnt", &bat_date, &out_header->day_pvp_cnt);
	if(bat_date != today){
		ret = this->user_battle_challenge_note.clear_challenge_cnt(RECVBUF_USERID, 2, today);
		out_header->day_pvp_cnt = 0;
	}
	//this->user_battle_character_attribute.cal_level(out_header->person.exp, &out_header->person.level);
	uint32_t recover_time = 0;
	ret = this->user_battle_character_attribute.get_one_column(RECVBUF_USERID, "recover_time", &recover_time);
	char *p_offset = buf + sizeof(user_get_battle_character_bag_out_header);
	ret = this->user_battle_character_attribute.cal_person_attribute(RECVBUF_USERID, &out_header->person, recover_time);
	
	//道具使用信息	
	user_get_battle_character_bag_out_item_1 *p_out_item_1 = 0;
	ret = this->user_battle_props_info.get_all(RECVBUF_USERID, &p_out_item_1, &out_header->count_1);
	memcpy(p_offset, p_out_item_1, sizeof(user_get_battle_character_bag_out_item_1) * out_header->count_1);
	p_offset = p_offset + sizeof(user_get_battle_character_bag_out_item_1) * out_header->count_1;
	free(p_out_item_1);
	
	//已经装备的主动技能
	user_get_battle_character_bag_out_item_2 *p_out_item_2 = 0;
	ret = this->user_battle_skill_equip.get_used_ini_skill(RECVBUF_USERID,  &p_out_item_2, &out_header->count_2, 0, 1);
	memcpy(p_offset, p_out_item_2, sizeof(user_get_battle_character_bag_out_item_2) * out_header->count_2);
	p_offset += sizeof(user_get_battle_character_bag_out_item_2) * out_header->count_2;
	free(p_out_item_2);

	//往师徒表中添加数据
	uint32_t tmp_value;
	ret = this->user_battle_prentice.get_int_value(RECVBUF_USERID, "merit", &tmp_value);
	if (ret != SUCC) {
		ret = this->user_battle_prentice.insert(RECVBUF_USERID, 0, 0);
	}

	//装扮
	ret = this->user_battle_skill_equip.get_used_equip_attire(RECVBUF_USERID, &out_header->equip_id);
	ret = SUCC;
	DEBUG_LOG("lenth-------------: %u", (uint32_t)(p_offset - buf));
	STD_RETURN_WITH_BUF(ret, buf, p_offset - buf);
}
/*
 * 拉取技能
 */
int Croute_func::user_get_battle_skill(DEAL_FUN_ARG)
{
	char buf[PROTO_MAX_LEN]={0};

    user_get_battle_skill_out_header *out_header = (user_get_battle_skill_out_header*)buf;
	char* p_offset = buf + sizeof(user_get_battle_skill_out_header);
	//技能
    user_get_battle_skill_out_item *p_out_item = 0;
	ret = this->user_battle_skill_equip.get_skill_equip(RECVBUF_USERID, &p_out_item, &out_header->count);
	memcpy(p_offset, p_out_item, sizeof(user_get_battle_skill_out_item) * out_header->count);
	p_offset += sizeof(user_get_battle_skill_out_item) * out_header->count;
	free(p_out_item);

	STD_RETURN_WITH_BUF(ret, buf, p_offset - buf);
}
/*
 * 拉取玩家战斗背包
 */
int Croute_func::user_get_battle_bag(DEAL_FUN_ARG)
{
	char buf[PROTO_MAX_LEN]={0};
    user_get_battle_bag_out_header  *out_header = (user_get_battle_bag_out_header*)buf;
	char *p_offset = buf + sizeof(user_get_battle_bag_out_header);
	//卡片
    user_get_battle_bag_out_item_1 *p_out_item_1 = 0;
	const uint32_t card_start = 1553000;
	const uint32_t card_end = 1562999;
	ret = this->user_battle_articles.get_items_range(RECVBUF_USERID, card_start, card_end, 0,
			&out_header->count_1, &p_out_item_1);
	memcpy(p_offset, p_out_item_1, out_header->count_1 * sizeof(user_get_battle_bag_out_item_1));
	p_offset += out_header->count_1 * sizeof(user_get_battle_bag_out_item_1);
	free(p_out_item_1);
	//道具
    user_get_battle_bag_out_item_2 *p_out_item_2 = 0;
	const uint32_t props_start = 1301001;
	const uint32_t props_end = 1301999;
	ret = this->user_battle_articles.get_items_range(RECVBUF_USERID, props_start, props_end, 0,  
			&out_header->count_2, &p_out_item_2);
	memcpy(p_offset, p_out_item_2, out_header->count_2 * sizeof(user_get_battle_bag_out_item_2));
	p_offset += out_header->count_2 * sizeof(user_get_battle_bag_out_item_2);
	free(p_out_item_2);
	//装扮
	user_get_battle_bag_out_item_3 *p_out_item_3 = 0;
	ret = this->user_battle_skill_equip.get_equip_attire(RECVBUF_USERID, &out_header->count_3, &p_out_item_3);
	memcpy(p_offset, p_out_item_3, sizeof(user_get_battle_bag_out_item_3) * out_header->count_3);
	p_offset += sizeof(user_get_battle_bag_out_item_3) * out_header->count_3;
	free(p_out_item_3);

	STD_RETURN_WITH_BUF(ret, buf, p_offset - buf);
}
/*
 * 使用道具
 */
int Croute_func::user_battle_use_props(DEAL_FUN_ARG)
{
    user_battle_use_props_in *p_in=PRI_IN_POS;
    user_battle_use_props_out out={0};
	uint32_t cnt = 0;
	ret = this->user_battle_articles.get_noused_count(RECVBUF_USERID, p_in->props_id, cnt);
	if(cnt == 0){
		return ATTIRE_COUNT_NO_ENOUGH_ERR;
	}
	DEBUG_LOG("add_cnt: %u, flag: %u, props_id: %u, props_level: %u, type: %u", p_in->add_cnt, p_in->flag, 
			p_in->props_id, p_in->props_level, p_in->type);
	out.state = 1;
	switch(p_in->type){
		case 1://恢复类道具
			{
				ret = this->user_battle_character_attribute.use_recover_props(RECVBUF_USERID, p_in->flag, 
						p_in->props_level, p_in->add_cnt, &out.state, &out.day_add_point);
				break;
			}
		case 2://增益类道具
			{
				ret = this->user_battle_props_info.update_inc(RECVBUF_USERID, p_in->type, p_in->flag, p_in->round);
				if(ret == USER_ID_NOFIND_ERR){
					ret = this->user_battle_props_info.insert(RECVBUF_USERID, p_in->type, p_in->flag, p_in->round);
				}
				DEBUG_LOG("^^^^^^^^^^^^^^^^^^^^^^^^^^p_in->flag: %u, p_in->round: %u", p_in->flag, p_in->round);
				break;
			}
		case 4: //礼包类道具
			{
				break;
			}
		case 3: //其他类道具
			{
				break;
			}
	}
	if(out.state != 2 && p_in->type != 3 && p_in->type!= 4){
		ret = this->user_battle_articles.sub_count(RECVBUF_USERID, p_in->props_id, 1);

		if(ret == SUCC){
		//change log
        change_log_item c_item;
        c_item.userid = RECVBUF_USERID;
        c_item.change_type = 207;
        c_item.logtime = time(NULL);
        c_item.change_value = p_in->props_id;
        c_item.change_v1 = p_in->add_cnt;
        c_item.change_v2 = out.state;
        this->send_log.send(&c_item);
		}
	}
    
    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 使用卡片 == 解封
 */
int Croute_func::user_battle_use_card(DEAL_FUN_ARG)
{
    user_battle_use_card_in *p_in=PRI_IN_POS;
    user_battle_use_card_out out={0};
	enum skill_type{
		ini_skill = 0,//主动技能
		non_ini_skill,//被动技能
		battle_attire,//装扮
	};
	enum skill_used_info_t{
		no_used = 0,//未装备
		used = 1,//已经装备，被动技能默认装备
	};
	DEBUG_LOG("add_cnt: %u, attribute_value: %u, cardid: %u, flag: %u, max_cnt: %u, itemid: %u, type: %u", 
			p_in->add_cnt, p_in->attribute_value, p_in->cardid, p_in->flag, p_in->max_cnt, p_in->to_itemid, p_in->type);
	uint32_t card_cnt_bk = 0;
	ret = this->user_battle_card_booklet.get_count(RECVBUF_USERID, p_in->cardid, card_cnt_bk);

	switch(p_in->type){
		case 1://天使卡 == 主动技能
			{
				uint32_t old_variety = 0;
				ret = this->user_battle_card_booklet.get_variety_count(RECVBUF_USERID, p_in->type, old_variety);

				ret = this->user_battle_card_booklet.add_card(RECVBUF_USERID, p_in->cardid, p_in->type, 1, 1, &out.cnt);
				if(out.cnt != 0){
					ret = this->user_battle_skill_equip.insert(RECVBUF_USERID, p_in->to_itemid, ini_skill, 1, no_used);
					if(old_variety + 1 == 5){//天使使者
						out.achieve_card = 1553039;
					}
					if(old_variety + 1 == 10){//天使信使
						out.achieve_card = 1553040;
					}
					if(out.achieve_card != 0){
						//this->user_battle_articles.add_count(RECVBUF_USERID, out.achieve_card, 1, 99);	
						user_add_attire_in  add_item = {0};
						add_item.attiretype = 32;
						add_item.attireid =  out.achieve_card;
						add_item.count = 1;
						add_item.maxcount = 999999;
						ret = this->user_add_attire(RECVBUF_USERID, &add_item);
					}
				}
				
				break;
			}
		case 3://角色被动技能卡
			{
				uint32_t variety = 0;
				ret = this->user_battle_card_booklet.get_variety_count(RECVBUF_USERID, p_in->type, variety);
				ret = this->user_battle_card_booklet.add_card(RECVBUF_USERID, p_in->cardid, p_in->type, 1, 1, &out.cnt);
				if(out.cnt != 0){
					ret = this->user_battle_skill_equip.insert(RECVBUF_USERID, p_in->to_itemid, non_ini_skill, 1, used);
					ret = this->user_battle_character_attribute.update_base_attribute(RECVBUF_USERID, &p_in->base_attr);
					
					if(variety + 1 == 5){
						out.achieve_card = 1553041;
					}
					if(variety + 1 == 10){
						out.achieve_card = 1553042;
					}
					if(out.achieve_card != 0){
						//this->user_battle_articles.add_count(RECVBUF_USERID, out.achieve_card, 1, 99);	
						user_add_attire_in  add_item = {0};
						add_item.attiretype = 32;
						add_item.attireid =  out.achieve_card;
						add_item.count = 1;
						add_item.maxcount = 999999;
						ret = this->user_add_attire(RECVBUF_USERID, &add_item);
					}
				}
				break;
			}
		case 2://成就卡
			{
				uint32_t limit = p_in->max_cnt / p_in->add_cnt;
				ret = this->user_battle_card_booklet.add_card(RECVBUF_USERID, p_in->cardid, p_in->type, 1, limit, &out.cnt); 
				if( out.cnt == 0){
					ret = this->user_battle_articles.sub_count(RECVBUF_USERID, p_in->cardid, 1);
				}
				break;
			}
		case 4://地图卡
		case 5://怪物卡
			{
				uint32_t limit = p_in->max_cnt / p_in->add_cnt;
				ret = this->user_battle_card_booklet.add_card(RECVBUF_USERID, p_in->cardid, p_in->type, 1, limit, &out.cnt); 
				break;
			}
		case 6://装扮卡
			{
				ret = this->user_battle_skill_equip.insert(RECVBUF_USERID, p_in->to_itemid, battle_attire, 1, no_used);
				if(ret != USER_ID_EXISTED_ERR && ret != DB_ERR){
					out.cnt = 1;
				}
				else{
					out.cnt = 0;
				}
			}
	}//switch
	if(out.cnt != 0){
		if(p_in->type != 6 && card_cnt_bk == 0){//首次解封,有属性加成
			ret = this->user_battle_character_attribute.update_base_attribute(RECVBUF_USERID, p_in->flag,
					p_in->attribute_value);
		}
		if(p_in->type != 6){
			uint32_t old_collect_point = 0;
			ret = this->user_battle_character_attribute.get_one_column(RECVBUF_USERID, "collect_points", &old_collect_point);
			ret = this->user_battle_character_attribute.update_inc(RECVBUF_USERID, "collect_points", p_in->add_cnt);
			//添加收集点数后，属性加成
			ret = this->user_battle_character_attribute.update_strong_attribute(RECVBUF_USERID, old_collect_point, p_in->add_cnt);
		}
		ret = this->user_battle_articles.sub_count(RECVBUF_USERID, p_in->cardid, 1);
		if(ret != SUCC){
			return ret;
	  	}
	
    //change log
        change_log_item c_item;
        c_item.userid = RECVBUF_USERID;
        c_item.change_type = 208;
        c_item.logtime = time(NULL);
        c_item.change_value = p_in->cardid;
        c_item.change_v1 = p_in->to_itemid;
        c_item.change_v2 = out.cnt;
        this->send_log.send(&c_item);

	}
	ret = SUCC;

    STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * 拉取卡册
 */
int Croute_func::user_battle_get_card_booklet(DEAL_FUN_ARG)
{
    user_battle_get_card_booklet_out_header  out_header = {0};
    user_battle_get_card_booklet_out_item *p_out_item = 0;
	ret=this->user_battle_card_booklet.get_all(RECVBUF_USERID, &out_header.count, &p_out_item);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * gameserver 拉取玩家进入战斗信息
 */
int Croute_func::user_gameserv_battle_get_info(DEAL_FUN_ARG)
{
	//user_gameserv_battle_get_info_in *p_in = PRI_IN_POS;
	char buf[PROTO_MAX_LEN]={ 0 };
    user_gameserv_battle_get_info_out_header  *out_header = (user_gameserv_battle_get_info_out_header*)buf;
	//拉取摩尔昵称和颜色	
	uint32_t color = 0;
	ret=this->user.get_mole_color(RECVBUF_USERID, color);
	out_header->color = color;
	ret=this->user_ex.get_nick(RECVBUF_USERID, out_header->nick);

	//基本属性
	uint32_t if_first = 0;
	ret = this->user_battle_character_attribute.get_character(RECVBUF_USERID, &out_header->person, &if_first);
    uint32_t recover_time = 0;
    ret = this->user_battle_character_attribute.get_one_column(RECVBUF_USERID, "recover_time", &recover_time);
    char *p_offset = buf + sizeof(user_gameserv_battle_get_info_out_header);
    ret = this->user_battle_character_attribute.cal_person_attribute(RECVBUF_USERID, &out_header->person, recover_time);
	
	//技能	
    user_gameserv_battle_get_info_out_item_1 *p_out_item_1 = 0;
	ret = this->user_battle_skill_equip.get_equiped_skill(RECVBUF_USERID, &p_out_item_1, &out_header->count_1);
	memcpy(p_offset, p_out_item_1, sizeof( user_gameserv_battle_get_info_out_item_1) * out_header->count_1);
	p_offset += sizeof( user_gameserv_battle_get_info_out_item_1) * out_header->count_1;
	free(p_out_item_1);
	//增益型道具
	user_gameserv_battle_get_info_out_item_2 *p_out_item_2 = (user_gameserv_battle_get_info_out_item_2*) p_offset;
	ret = this->user_battle_props_info.get_flag(RECVBUF_USERID, &p_out_item_2, &out_header->count_2);
	p_offset += sizeof(user_gameserv_battle_get_info_out_item_2) * out_header->count_2;
	
	uint32_t equip_id = 0;
	//装扮
	ret = this->user_battle_skill_equip.get_used_equip_attire(RECVBUF_USERID, &equip_id);
	if(equip_id == 0){
		out_header->equip_id = -1;
	}
	else{
		out_header->equip_id = equip_id;
	}

	//参与战斗人次统计
	msglog(this->msglog_file, 0x0409B7DD, time(NULL), &(RECVBUF_USERID), 4);

	ret = SUCC;
	DEBUG_LOG("exp: %u, level: %u, energy: %u, flexibility: %u, power: %u, vigour: %u, wisdom: %u",out_header->person.exp, 
			out_header->person.level, out_header->person.energy, out_header->person.flexibility,
			out_header->person.power, out_header->person.vigour, out_header->person.wisdom);	
	STD_RETURN_WITH_BUF(ret, buf, p_offset - buf);
}
/*
 * 技能升级
 */
int Croute_func::user_battle_upgrade_skill(DEAL_FUN_ARG)
{
    user_battle_upgrade_skill_in *p_in=PRI_IN_POS;
    user_battle_upgrade_skill_out out={0};
	DEBUG_LOG("skillid: %u, type: %u, level_inc: %u, cardid: %u ,card_cnt: %u, level_limit: %u, money_cnt: %u, rate: %u",
		  	p_in->skillid, p_in->type, p_in->object_level, p_in->cardid, p_in->card_cnt, p_in->level_limit, p_in->money_cnt,
		  	p_in->rate);
	uint32_t old_level = 0;
	ret = this->user_battle_skill_equip.get_one_column(RECVBUF_USERID, p_in->skillid, "level", &old_level);
	if((p_in->object_level - old_level) != 1){
		return THE_LEVEL_NOT_REACHED_UP_LIMIT_ERR;
	}
	//判断卡牌数
	uint32_t card_cnt_table = 0;
	ret = this->user_battle_articles.get_noused_count(RECVBUF_USERID, p_in->cardid, card_cnt_table);
	if(card_cnt_table < p_in->card_cnt){
		return NOT_ENOGH_CARD_MONEY_TO_SKILL_UPGRADE_ERR;
	}
	//判断摩尔豆
	uint32_t money = 0;
	ret = this->user.get_xiaomee(RECVBUF_USERID, &money);	
	if(money < p_in->money_cnt){
		return NOT_ENOGH_CARD_MONEY_TO_SKILL_UPGRADE_ERR;
	}

	if(p_in->type == 0){//主动技能
		uint32_t battle_lvl = 0; 
		ret = this->user_battle_character_attribute.cal_battle_level(RECVBUF_USERID,&battle_lvl);
		if(battle_lvl < p_in->level_limit){
			return THE_LEVEL_NOT_REACHED_UP_LIMIT_ERR;
		}
		if(ret == SUCC){
			uint32_t random = rand()%100;
			if(random < p_in->rate){
					uint32_t new_skill_level = p_in->object_level > 10 ? 10 : p_in->object_level;
					ret = this->user_battle_skill_equip.update(RECVBUF_USERID, p_in->skillid, "level", new_skill_level);
					DEBUG_LOG("random: %u, rate: %u, new_skill_level: %u, old_level : %u", random, 
							p_in->rate, new_skill_level, old_level);
					if(ret == SUCC){
						out.is_succ = 1;
					}
			}//if
		}//(ret==SUCC)
	}
	else{//被动技能
		uint32_t ran = rand()%100;
		if(ran < p_in->rate){
			//需要属性增加数值
			ret = this->user_battle_character_attribute.update_base_attribute(RECVBUF_USERID, &p_in->base_attr);
			uint32_t new_skill_level = 0;
			new_skill_level = p_in->object_level > 10 ? 10 : p_in->object_level;
			ret = this->user_battle_skill_equip.update(RECVBUF_USERID, p_in->skillid, "level", new_skill_level);
			if(ret == SUCC){
				out.is_succ = 1;
			}
			//uint32_t cardid = 0;	
			if(new_skill_level >= 5 && old_level < 5){
				uint32_t cnt = 0;
				this->user_battle_skill_equip.get_more_level_non_ini_skill(RECVBUF_USERID, 5, &cnt);
				if(cnt == 5){//天赋小强
					out.achieve_card = 1553043;
				}
				else if(cnt == 8){//天赋高人
					out.achieve_card = 1553045;
				}
				else if(cnt == 12){//天赋大师
					out.achieve_card = 1553047;
				}
			}
			if(new_skill_level >= 10 && old_level < 10){
				uint32_t cnt = 0;
				this->user_battle_skill_equip.get_more_level_non_ini_skill(RECVBUF_USERID, 10, &cnt);
				if(cnt == 5){//天赋大强
					out.achieve_card = 1553044;
				}
				if(cnt == 8){//天赋牛人
					out.achieve_card = 1553046;
				}
				if(cnt == 12){//天赋宗师
					out.achieve_card = 1553048;
				}
			}
			if(out.achieve_card != 0){
				//this->user_battle_articles.add_count(RECVBUF_USERID, out.achieve_card, 1, 99999);
				user_add_attire_in  add_item = {0};
				add_item.attiretype = 32;
				add_item.attireid =  out.achieve_card;
				add_item.count = 1;
				add_item.maxcount = 999999;
				ret = this->user_add_attire(RECVBUF_USERID, &add_item);
			}
		}//if	
	}//else
	//扣除卡牌，摩尔豆
	ret = this->user_battle_articles.sub_count(RECVBUF_USERID, p_in->cardid, p_in->card_cnt);
	ret = this->user.change_xiaomee(RECVBUF_USERID, -p_in->money_cnt, XIAOMEE_USE_DEL_ANGEL_BATTLE, p_in->cardid,(int*)&money);
	
    //change log
	if(out.is_succ == 1){
		change_log_item c_item;
        c_item.userid = RECVBUF_USERID;
        c_item.change_type = 209;
        c_item.logtime = time(NULL);
        c_item.change_value = p_in->cardid;
        c_item.change_v1 = p_in->card_cnt;
        c_item.change_v2 = p_in->money_cnt;
        this->send_log.send(&c_item);
	}
        
    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 装备主动技能，或装扮
 */
int Croute_func::user_equip_skill_attire(DEAL_FUN_ARG)
{
    user_equip_skill_attire_in *p_in=PRI_IN_POS;
	user_equip_skill_attire_out out = {0};
	out.type = p_in->state;
	if(p_in->type == 2){
		ret = this->user_battle_skill_equip.put_off(RECVBUF_USERID);
	}
	else if(p_in->type == 0){
		uint32_t ini_count = 0;
		ret = this->user_battle_skill_equip.get_equip_ini_skill_count(RECVBUF_USERID, &ini_count);
		if(ini_count >= 5){
			return ALREADY_EQUIP_ENOUGHT_INI_SKILL_ERR;
		}
	}

	ret = this->user_battle_skill_equip.update(RECVBUF_USERID, p_in->equip_id, "is_used", p_in->state);

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 拉取戰鬥收集品
 */
int Croute_func::user_get_battle_colletion(DEAL_FUN_ARG)
{
    user_get_battle_colletion_out_header  out_header = {0};
    user_get_battle_colletion_out_item *p_out_item = 0;
	const uint32_t start_id = 0;
	const uint32_t end_id = 0;
    ret=this->user_battle_articles.get_items_range(RECVBUF_USERID, start_id, end_id, 0, &out_header.count, &p_out_item);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/*
 * 战斗后所过关卡统计
 */
int Croute_func::user_battle_get_pass_achievement(userid_t userid, uint32_t barrier_id, uint32_t comp_degree,
		user_battle_over_info_out_header *p_out, user_battle_over_info_out_item_1* &p_offset)
{
	uint32_t count = 0;
	ret = this->user_battle_pass_barrier.get(userid, barrier_id, &count);
	//更新地图关卡完成度
	ret = this->user_battle_pass_barrier.update_inc(userid, barrier_id, comp_degree);
	if(ret == USER_ID_NOFIND_ERR){
		ret = this->user_battle_pass_barrier.insert(userid, barrier_id, comp_degree);
	}
	ret = this->user_battle_articles.get_pass_boss_achivement_card(userid, count, comp_degree, barrier_id, 
				&p_out->count_1, p_offset);
	return ret;
}
/*
 * 战斗结束后计算
 */
int Croute_func::user_battle_game_over_caculate(DEAL_FUN_ARG)
{
	enum LEVEL_TYPE{
		LT_NORMAL	= 0,
		LT_BOSS,
		LT_BOSS_TIME,
		LT_BOSS_VIP,
		LT_BOSS_COST,
		LT_FRIEND,
		LT_GET_APPRENTICE,		//收徒弟
		LT_GRAB_APPRENTICE,		//抢徒弟
		LT_PK_MASTER,			//挑战师傅
		LT_PK_APPRENTICE,		//挑战徒弟
		LT_TRAIN,               //切磋武艺
		LT_PK,  //PVP战斗
	};

    user_battle_game_over_caculate_in *p_in=PRI_IN_POS;
	DEBUG_LOG("nownow==exp: %u=========barrier_id: %u, rival_id: %u, comp_degree: %u, friend_id: %u, is_succ: %u =============",
			p_in->exp_inc, p_in->barrierid, p_in->rival_id, p_in->comp_degree, p_in->rival_id, p_in->is_sucess);

	//周末默默怪作战经验翻倍
	if(p_in->level_type != LT_TRAIN && p_in->level_type != LT_GET_APPRENTICE && p_in->level_type != LT_GRAB_APPRENTICE){
		uint32_t now = time(0);
		uint32_t week_day = get_week_day(now);
		uint32_t hour = get_hour_time(now);
		if(week_day == 0 || week_day == 6 || week_day == 5){	
		//uint32_t today = get_date(now);
		//if(today >= 20111021 && today <= 20111023){
			if(hour >= 14 && hour < 16){
				p_in->exp_inc = p_in->exp_inc * 4;//4倍经验
			}
			else{
				//p_in->exp_inc *= 2;//2倍经验
				p_in->exp_inc = p_in->exp_inc * 2;//2倍经验
			}
		}
	}

	//与好友对战,记录对战信息
	if(p_in->is_energy != 1){
		if(p_in->level_type != LT_GET_APPRENTICE && p_in->level_type != LT_GRAB_APPRENTICE){
			uint32_t msg_type = 0;
			if(p_in->level_type == LT_PK){
				msg_type = 1;
				//如果pvp次数大于10，消息记录的经验置为0
				uint32_t day_pk_cnt = 0;
				ret = this->user_battle_challenge_note.get_int_value(RECVBUF_USERID,"pvp_cnt", &day_pk_cnt);
				if(day_pk_cnt + 1 > 10){
					p_in->exp_inc = 0;
				}
			}
			user_battle_gefight_over_info_out_item temp = {msg_type, p_in->rival_id, p_in->is_can_flip, p_in->is_sucess, 
																p_in->exp_inc, (uint32_t)time(0)};
			ret = this->user_battle_fight_record.update_records(RECVBUF_USERID, &temp);
		}
	}

	if(p_in->level_type == LT_PK && p_in->is_sucess == 1){
		uint32_t pvp_win = 0;
		ret = this->user_battle_accident.get_int_value(RECVBUF_USERID, "pvp_win", &pvp_win);
		ret = this->user_battle_accident.set_int_value(RECVBUF_USERID, "pvp_win", pvp_win + 1);
	}
	
	ret = this->user_battle_flip_card_info.remove(RECVBUF_USERID);	
	ret = this->user_battle_flip_card_info.insert(RECVBUF_USERID, p_in);
	//保存翻拍信息		
	if(p_in->is_can_flip){
		if(p_in->barrierid == 0){
			//更新挑战好友每日次数
			if(p_in->rival_id != 0){
				if(p_in->level_type != LT_GET_APPRENTICE  && p_in->level_type != LT_GRAB_APPRENTICE && 
						p_in->level_type != LT_PK && p_in->level_type != LT_TRAIN){
					ret = this->user_battle_friend_event.update_fight_count_inc(RECVBUF_USERID, p_in->rival_id, 1);
					if(ret == USER_ID_NOFIND_ERR){
						ret = this->user_battle_friend_event.insert(RECVBUF_USERID, p_in->rival_id);
					}
				}
				//统计好友战斗次数
			  msglog(this->msglog_file, 0x0409B7DC, time(NULL), &(RECVBUF_USERID), 4);
				
			}
		}	
		else{//进入关卡，与怪物对战， 统计关卡参与人数
			  if(p_in->barrierid <= 24){
				  uint32_t buf_barr[2]={ RECVBUF_USERID, 1};
				  uint32_t type_id = 0x0409B7E0 + (p_in->barrierid - 1)*2;
				  msglog(this->msglog_file, type_id , time(NULL), buf_barr, 8);

				  if(p_in->is_sucess == 1){
					  uint32_t succ_type = 0x0409B7E1 + (p_in->barrierid - 1)*2;
					  msglog(this->msglog_file, succ_type , time(NULL), buf_barr, 8);
				  }//if
			  }
			  else if(p_in->barrierid > 24 && p_in->barrierid <= 34){
				  uint32_t buf_barr[2]={ RECVBUF_USERID, 1};
				  uint32_t type_id = 0x0409B41E + (p_in->barrierid - 25);
				  msglog(this->msglog_file, type_id , time(NULL), buf_barr, 8);
			  }
			  else if(p_in->barrierid >= 35 && p_in->barrierid <= 42){
				  uint32_t buf_barr[2]={ RECVBUF_USERID, 1};
				  uint32_t type_id = 0x0409B810 + (p_in->barrierid - 35) * 2;
				  msglog(this->msglog_file, type_id , time(NULL), buf_barr, 8);
				  
				  if(p_in->is_sucess == 1){
					  uint32_t succ_type = 0x0409B811 + (p_in->barrierid - 35)*2;
					  msglog(this->msglog_file, succ_type , time(NULL), buf_barr, 8);
				  }
			  }
		}//else
		//先增加经验，通知前端升级和送成就卡放到与online的最后一条协议
		//ret = this->user_battle_character_attribute.update_inc(RECVBUF_USERID, "exp", p_in->exp_inc);
	}
	else{
		if(p_in->level_type != LT_GET_APPRENTICE && p_in->level_type != LT_GRAB_APPRENTICE 
				&& p_in->level_type != LT_TRAIN){
			//扣除增益型道具
			props_info_t *p_temp_item = 0;	
			uint32_t count_1 = 0;
			ret = this->user_battle_props_info.get_all(RECVBUF_USERID, &p_temp_item, &count_1);
			for(uint32_t k = 0; k < count_1; ++k){
				if((p_temp_item + k)->flag != 5){
					ret = this->user_battle_props_info.sub_count(RECVBUF_USERID, (p_temp_item + k)->flag, 1);
				}
			}
			free(p_temp_item);
		}
		if(p_in->exp_inc != 0){
			//增加好友经验
			user_battle_over_info_out_header p_temp = {0};
			user_battle_over_info_out_item_1  it_temp = {0}; 
			user_battle_over_info_out_item_1 *p_offset = &it_temp;
			uint32_t is_upgrade = 0;
			user_battle_add_exp_handle_event(RECVBUF_USERID, p_in->exp_inc,  &is_upgrade, &(p_temp.count_1), p_offset);
		}
	}
	//翻牌
	//this->user_battle_articles.user_battle_fip_card(RECVBUF_USERID, p_in->count_1, p_in_item_1, p_in->count_2,
	//p_in_item_2,  out_header);
	STD_RETURN(ret);
}
/*
 * 增加经验后，等级升级，送成就卡片
 */
int Croute_func::user_battle_add_exp_handle_event(userid_t userid, uint32_t exp_inc, uint32_t *is_upgrade, 
		uint32_t *count, user_battle_over_info_out_item_1* p_offset)
{
	//升级
	uint32_t new_level = 0, exp = 0, old_level = 0;
	//用等级和卡牌来判断是否给成就卡
	ret = this->user_battle_character_attribute.get_one_column(userid, "exp", &exp);
	this->user_battle_character_attribute.cal_level(exp, &old_level);
	this->user_battle_character_attribute.cal_level(exp + exp_inc, &new_level);
	if(new_level > old_level){
		*is_upgrade = 1;
		user_battle_character_attribute.update_secondary_attribute(userid, new_level);
		uint32_t energy_limit = 0, vigour_limit = 0;
		ret = this->user_battle_character_attribute.get_two_columns(userid, "energy_limit", "vigour_limit",
					&energy_limit, &vigour_limit);
		energy_limit += 50;
		vigour_limit += 50;
		user_battle_character_attribute.update_two_columns(userid, "energy", "vigour", energy_limit, vigour_limit);
		//加卡成就牌
		this->user_battle_articles.add_achievement_level(userid, new_level, old_level, count, p_offset);

		//统计等级人数
		struct lvl_friend_t{
			uint32_t userid;
			uint32_t level;
		};
		lvl_friend_t package_send = { userid, new_level};
		msglog(this->msglog_file, 0x0409BBC7, time(NULL), &package_send, sizeof(package_send));
	}
	ret = this->user_battle_character_attribute.update_inc(userid, "exp", exp_inc);
	return SUCC;
}


/*
 * 拉取好友战斗经验
 */
int Croute_func::angel_battle_get_friends_exp(DEAL_FUN_ARG)
{
    angel_battle_get_friends_exp_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(angel_battle_get_friends_exp_in_item));
    angel_battle_get_friends_exp_in_item * p_in_item=(angel_battle_get_friends_exp_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
    angel_battle_get_friends_exp_out_header  out_header = {0} ;
    angel_battle_get_friends_exp_out_item *p_out_item = 0;
    ret=this->angel_battle.select_friend_exp(RECVBUF_USERID, p_in->count, p_in_item, &(out_header.count), &p_out_item);
	uint32_t now = time(0);
	uint32_t today = get_date(now);
	uint32_t datetime = 0;
	ret = this->angel_battle.get_last_login_time(RECVBUF_USERID, &datetime);
	if((now - datetime)/(3600*24) >= 10){
		bat_arg_event_t ev;
		memset(&ev, 0, sizeof(ev));
		ret = this->angel_battle.get_event(RECVBUF_USERID, &ev);
		if(ret == USER_ID_NOFIND_ERR){
			ev.events[1] = 1;
			ret = this->angel_battle.insert(RECVBUF_USERID, 0, &ev);
		}
		else{
			ev.events[1] =  (ev.events[1] + 1)%255;
			ret = this->angel_battle.update_events(RECVBUF_USERID, &ev);
		}
	}

	uint32_t date = get_date(datetime);
	if(date != today){
		ret = this->angel_battle.set_last_login_time(RECVBUF_USERID, now);
	}
	ret = SUCC;

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 更新全局表中的战斗经验
 */
int Croute_func::angel_battle_update_exp(DEAL_FUN_ARG)
{
    angel_battle_update_exp_in *p_in=PRI_IN_POS;
    ret=this->angel_battle.add_exp(RECVBUF_USERID, p_in->exp);

    STD_RETURN(ret);
}
/*
 * 拉取每日与各个好友的对战信息
 */
int Croute_func::user_battle_get_friend_fight_list(DEAL_FUN_ARG)
{
    user_battle_get_friend_fight_list_out_header  out_header = {0};
    user_battle_get_friend_fight_list_out_item *p_out_item = 0;
    ret=this->user_battle_friend_event.get_friend_fight_list(RECVBUF_USERID, &p_out_item, &out_header.count);
	ret = SUCC;

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 拉取地图完成度
 */
int Croute_func::user_battle_map_info(DEAL_FUN_ARG)
{
    user_battle_map_info_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_battle_map_info_in_item));
    user_battle_map_info_in_item * p_in_item=(user_battle_map_info_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
    user_battle_map_info_out_header  out_header = { 0 };
    user_battle_map_info_out_item *p_out_item = 0;
	ret = this->user_battle_pass_barrier.get_barrier_list(RECVBUF_USERID,  p_in_item, p_in->count, &p_out_item, &out_header.count);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/*
 * 拉取一个技能等级
 */
int Croute_func::user_battle_get_one_skill(DEAL_FUN_ARG)
{
	user_battle_get_one_skill_in *p_in = PRI_IN_POS;
	user_battle_get_one_skill_out out = {p_in->skill_id, 0};
	ret = this->user_battle_skill_equip.get_one_column(RECVBUF_USERID, p_in->skill_id, "level", &(out.skill_lvl));
	STD_RETURN_WITH_STRUCT(SUCC, out);
}
/*
 * gameserver 更新消耗能量、活力點數
 */
int Croute_func::user_battle_gameserv_consume(DEAL_FUN_ARG)
{
	enum LEVEL_TYPE{
		LT_NORMAL	= 0,
		LT_BOSS,
		LT_BOSS_TIME,
		LT_BOSS_VIP,
		LT_BOSS_COST,
		LT_FRIEND,
		LT_GET_APPRENTICE,		//收徒弟
		LT_GRAB_APPRENTICE,		//抢徒弟
		LT_PK_MASTER,			//挑战师傅
		LT_PK_APPRENTICE,		//挑战徒弟
		LT_TRAIN,               //切磋武艺
		LT_PK,
		LT_BOSS_ACTIVE,			//活动BOSS
	};
    user_battle_gameserv_consume_in *p_in=PRI_IN_POS;
    user_battle_gameserv_consume_out out={0};
	if(p_in->level_type == LT_GET_APPRENTICE || p_in->level_type == LT_GRAB_APPRENTICE){
		uint32_t rv_cnt = 0;
		ret = this->user_battle_prentice.get_int_value(RECVBUF_USERID, "recv_cnt", &rv_cnt);
		if(rv_cnt >= 3){
			  out.barrier_comp_flag= 0;
		}
		else{
			out.barrier_comp_flag= 1;
		}
	}
	else if(p_in->level_type == LT_TRAIN){
		uint32_t train = 0;
		ret = this->user_battle_master.get_train(RECVBUF_USERID, (uint32_t)p_in->rival_id, &train);
		const uint32_t train_id = 1;//切磋武艺
		uint32_t mask = 1 << (train_id - 1);
		uint32_t value = (mask & train) >>(train_id - 1);
		if(value == 1){
			 out.barrier_comp_flag= 0;
		}
		else{
			out.barrier_comp_flag= 1;
		}
	}
	else if(p_in->level_type == LT_PK_MASTER){
		uint32_t master = 0;
		ret = this->user_battle_prentice.get_int_value(RECVBUF_USERID, "master", &master);	
		if(master != (uint32_t)p_in->rival_id){
			out.barrier_comp_flag= 0;
		}
		else{
			uint32_t fight_count = 0;   
            ret = this->user_battle_friend_event.get_friend_fight_count(RECVBUF_USERID,(uint32_t)p_in->rival_id, &fight_count);
            if(fight_count >= 1){       
                out.barrier_comp_flag= 0;//0表示挑战好友，不能挑战
            }                           
            else{                       
                //is_update_flag = 1;   
                out.barrier_comp_flag = 1;
            }                           
		}
	}
	else if(p_in->level_type == LT_PK_APPRENTICE){
		uint32_t initial_level = 0;
		ret = this->user_battle_master.get_one_col(RECVBUF_USERID, (uint32_t)p_in->rival_id, "initial_level", &initial_level);		
		if( ret == USER_ID_NOFIND_ERR){
			out.barrier_comp_flag= 0;
		}
		else{
			uint32_t fight_count = 0;
			ret = this->user_battle_friend_event.get_friend_fight_count(RECVBUF_USERID,(uint32_t)p_in->rival_id, &fight_count);
			if(fight_count >= 1){
				out.barrier_comp_flag= 0;//0表示挑战好友，不能挑战
			}
			else{
				//is_update_flag = 1;
				out.barrier_comp_flag = 1;
			}
		}
	}
	else if(p_in->level_type == LT_BOSS){
		ret = this->user_battle_challenge_note.check_challenge_boss(RECVBUF_USERID, LT_BOSS, &out.barrier_comp_flag);
	}
	else if(p_in->level_type == LT_BOSS_COST){
		//去掉门卡功能
		uint32_t  key_cnt = 0;
		//ret = this->user_battle_articles.get_count(RECVBUF_USERID, p_in->card_id, card_cnt);
		ret = this->user_battle_articles.get_count(RECVBUF_USERID, p_in->key_id, key_cnt);
		if(key_cnt == 0){
			out.barrier_comp_flag= 0;
		}
		else{
			out.barrier_comp_flag= 1;
		}
	}
	else if(p_in->level_type == LT_BOSS_VIP){
		bool is_vip;
		ret = this->user_ex.get_vip(RECVBUF_USERID, &is_vip );
		if(is_vip){
			ret = this->user_battle_challenge_note.check_challenge_boss(RECVBUF_USERID, LT_BOSS_VIP, &out.barrier_comp_flag);
		}
		else{
			out.barrier_comp_flag= 0;
		}
	}
	else if(p_in->level_type == LT_BOSS_TIME){
		ret = this->user_battle_challenge_note.check_challenge_boss(RECVBUF_USERID, LT_BOSS_TIME, &out.barrier_comp_flag);
	}
	else if(p_in->level_type == LT_BOSS_ACTIVE){
		ret = this->user_battle_challenge_note.check_challenge_boss(RECVBUF_USERID, LT_BOSS_ACTIVE, &out.barrier_comp_flag);
	}
	else if(p_in->level_type == LT_FRIEND){
		id_list friendlist;
		ret=this->user_ex.get_idlist(RECVBUF_USERID ,FRIEND_LIST_STR, &friendlist);
		uint32_t k = 0;
		for( ;k < friendlist.count; ++ k){
			if(friendlist.item[k] == (uint32_t)p_in->rival_id)
				break;
		}
		if(k < friendlist.count){
			uint32_t fight_count = 0;
			ret = this->user_battle_friend_event.get_friend_fight_count(RECVBUF_USERID,(uint32_t)p_in->rival_id, &fight_count);
			if(fight_count >= 1){
				out.barrier_comp_flag= 0;//0表示挑战好友，不能挑战
			}
			else{
				//is_update_flag = 1;
				out.barrier_comp_flag = 1;
			}
		}
		else{//删除好友后，判断好友是否在战斗消息列表,如果在，依然可以战斗
			uint32_t *rival_list = 0;
			uint32_t n_cnt = 0;
			ret = this->user_battle_fight_record.get_rival(RECVBUF_USERID, &rival_list, &n_cnt);
			uint32_t j = 0;
			for(; j < n_cnt; ++j){
				if(*(rival_list + j) == (uint32_t)p_in->rival_id){
					break;
				}
			}
			if(j < n_cnt){
				out.barrier_comp_flag= 1;
			}
			else{
				out.barrier_comp_flag = 0;
			}
		}//else
	}
	
	ret = SUCC;

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 战斗结束后online拉取翻牌信息
 */
int Croute_func::user_battle_get_flip_info(DEAL_FUN_ARG)
{
	enum LEVEL_TYPE{
		LT_NORMAL   = 0,
        LT_BOSS,
        LT_BOSS_TIME,
        LT_BOSS_VIP,
        LT_BOSS_COST,
        LT_FRIEND,
        LT_GET_APPRENTICE,      //收徒弟
        LT_GRAB_APPRENTICE,     //抢徒弟
        LT_PK_MASTER,           //挑战师傅
        LT_PK_APPRENTICE,       //挑战徒弟
        LT_TRAIN,               //切磋武艺
		LT_PK,
		LT_BOSS_ACTIVE,			//活动BOSS
	};
    user_battle_get_flip_info_out_header out_header={0};
	user_battle_get_flip_info_out_item *p_out_item = 0;
	out_header.able_flip = 1;

	flip_cd_bin_t arr_info;
	memset(&arr_info, 0, sizeof(flip_cd_bin_t));
    ret = this->user_battle_flip_card_info.get_info(RECVBUF_USERID, &out_header, &arr_info);
	if(ret != SUCC){
		return ret;
	}

	//如果是pvp，则10次之后不能翻牌
	if(out_header.fight_type == LT_PK){
			ret = this->user_battle_challenge_note.update_challenge_times(RECVBUF_USERID, out_header.fight_type);
			ret = this->user_battle_challenge_note.check_challenge_boss(RECVBUF_USERID, LT_PK, &out_header.able_flip);
			if(out_header.able_flip == 0){
				out_header.exp_inc = 0;
			}
	}
	////如果PVP，每天大于10次后不可以翻牌
	//if(out_header.fight_type == LT_PK){
		//ret = this->user_battle_challenge_note.check_challenge_boss(RECVBUF_USERID, LT_PK, &out_header.able_flip);
	//}	
	ret = this->user_battle_master.get_all_prentices(RECVBUF_USERID, (uint32_t**)&p_out_item, &out_header.apprentice_cnt);
	DEBUG_LOG("cnt: %u,  vs_master_id: %u, vs_userid: %u, fight_type: %u", out_header.apprentice_cnt, 
			out_header.vs_master_id, out_header.vs_userid, out_header.fight_type);	
	//如果是收徒，收徒次数加1
	if(out_header.fight_type == LT_GET_APPRENTICE || out_header.fight_type == LT_GRAB_APPRENTICE){
		uint32_t recv_cnt = 0, date = 0;	
		ret = this->user_battle_prentice.get_two_col(RECVBUF_USERID, "recv_cnt", "date", &recv_cnt, &date);
		uint32_t today = get_date(time(0));
		if(date == today){
			ret = this->user_battle_prentice.set_int_value(RECVBUF_USERID, "recv_cnt", recv_cnt + 1);
		}
		else{
			ret = this->user_battle_prentice.update_two_col(RECVBUF_USERID, "recv_cnt", "respect", 1, 0);
			ret = this->user_battle_prentice.set_int_value(RECVBUF_USERID, "date", today);
		}
		if(out_header.is_win == 0){
			this->user_battle_flip_card_info.remove(RECVBUF_USERID);
		}
	}	

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.apprentice_cnt);
}
/*
 * 小白作战游戏结束
 */
int Croute_func::user_battle_over_info(DEAL_FUN_ARG)
{
	enum LEVEL_TYPE{
        LT_NORMAL   = 0,
        LT_BOSS,
        LT_BOSS_TIME,
        LT_BOSS_VIP,
        LT_BOSS_COST,
        LT_FRIEND,
		LT_GET_APPRENTICE,		//收徒弟
		LT_GRAB_APPRENTICE,		//抢徒弟
		LT_PK_MASTER,			//挑战师傅
		LT_PK_APPRENTICE,		//挑战徒弟
		LT_TRAIN,               //切磋武艺
		LT_PK,
		LT_BOSS_ACTIVE,			//活动BOSS
    };	
	char buf[PROTO_MAX_LEN]={ 0 };
	user_battle_over_info_in *p_in=PRI_IN_POS;

	user_battle_over_info_out_header  *out_header = (user_battle_over_info_out_header*)buf;
	user_battle_over_info_out_item_1 *p_out_item_1 = (user_battle_over_info_out_item_1 *)(buf + 
			sizeof(user_battle_over_info_out_header));
	char* p_offset = buf + sizeof(user_battle_over_info_out_header);	

	//uint32_t able_get_bonus = 1; //是否可以加经验，领奖励， 默认可以
	game_over_cal_info_t p_tmp = {0};
	flip_cd_bin_t arr_info; 
	memset(&arr_info, 0, sizeof(flip_cd_bin_t));
	ret=this->user_battle_flip_card_info.get_battle_over_info(RECVBUF_USERID, &p_tmp, &arr_info);
	if(ret != SUCC){
		return ret;
	}
	
	DEBUG_LOG("id: %u, comp_degree: %u, exp_inc: %u, is_win: %u", p_tmp.barrier_id, p_tmp.comp_degree, p_tmp.exp_inc, p_tmp.is_win);
	if(p_tmp.level_type != LT_GET_APPRENTICE && p_tmp.level_type != LT_GRAB_APPRENTICE){
		//删除去牌卡
		DEBUG_LOG("p_in->re_count: %u, p_in->remove_cardid: %u", p_in->re_count, p_in->remove_cardid);
		if(p_in->re_count != 0){
			ret = this->user_battle_articles.sub_count(RECVBUF_USERID, p_in->remove_cardid, p_in->re_count);
			if(ret != SUCC){
				return ret;
			}
		}
			//添加抽中的卡牌
		if(p_in->cardid != 0){
			//ret = this->user_battle_articles.add_count(RECVBUF_USERID, p_in->cardid, p_in->count, 9999999);
			user_add_attire_in  add_item = {0};
			add_item.attiretype = 32;
			add_item.attireid =  p_in->cardid;
			add_item.count = p_in->count;
			add_item.maxcount = 999999;
			ret = this->user_add_attire(RECVBUF_USERID, &add_item);
		}	
		else{
			int xiaomee = 0;
			ret=this->user.change_xiaomee(RECVBUF_USERID,p_in->count, XIAOMEE_USE_ADD_ANGEL_BATTLE, 0, &xiaomee);
		}

		if(p_tmp.level_type != LT_TRAIN){
			//扣除增益型道具
			props_info_t *p_temp_item = 0;	
			uint32_t count_1 = 0;
			ret = this->user_battle_props_info.get_all(RECVBUF_USERID, &p_temp_item, &count_1);
			for(uint32_t k = 0; k < count_1; ++k){
				if((p_temp_item + k)->flag != 6){
					ret = this->user_battle_props_info.sub_count(RECVBUF_USERID, (p_temp_item + k)->flag, 1);
				}
			}
			free(p_temp_item);

			if(p_tmp.level_type != LT_PK){
				//扣除能量、活力
				if(arr_info.remainder[0] == 1){ //扣除能量
					uint32_t energy = 0;
					ret = this->user_battle_character_attribute.get_one_column(RECVBUF_USERID, "energy", &energy);
					energy = energy > arr_info.remainder[1] ? (energy - arr_info.remainder[1]):0;
					ret = this->user_battle_character_attribute.update(RECVBUF_USERID, "energy", energy);
				}
				else{//活力
					uint32_t vigour = 0;
					ret = this->user_battle_character_attribute.get_one_column(RECVBUF_USERID, "vigour", &vigour);
					vigour = vigour > arr_info.remainder[1] ? (vigour - arr_info.remainder[1]):0;
					ret = this->user_battle_character_attribute.update(RECVBUF_USERID, "vigour", vigour);
				}
			}
			
		}
		//师徒切磋武艺
		if(p_tmp.level_type == LT_TRAIN){
			ret = this->user_battle_master.update_train_by_id(RECVBUF_USERID, arr_info.remainder[4], 1);
			if(ret == SUCC){
				ret = this->user_battle_prentice.update_merit_inc(RECVBUF_USERID, 2);

				user_battle_add_mp_msg_in msg = {
					(uint32_t)time(0), RECVBUF_USERID, arr_info.remainder[4], 1, p_tmp.exp_inc, 2 
				};
				ret = this->user_battle_master_prentice_msg.update_record(RECVBUF_USERID, &msg);
			}
		}
				
		//如果挑战BOSS_COST,要扣除掉钥匙
		if(p_tmp.level_type == LT_BOSS_COST){
			//去掉门卡功能
			//uint32_t door_card_cnt = 0;
			//ret = this->user_battle_articles.get_count(RECVBUF_USERID, arr_info.remainder[2], door_card_cnt);
			//if(door_card_cnt == 0){
			ret = this->user_battle_articles.sub_count(RECVBUF_USERID, arr_info.remainder[3], 1);
			//}
		}

		//置BOSS每日挑战次数
		if(p_tmp.level_type == LT_BOSS || p_tmp.level_type == LT_BOSS_TIME || p_tmp.level_type == LT_BOSS_VIP ||
				 p_tmp.level_type == LT_BOSS_ACTIVE){
			ret = this->user_battle_challenge_note.update_challenge_times(RECVBUF_USERID, p_tmp.level_type);
		}	

		//用等级和卡牌来判断是否给成就卡
		user_battle_add_exp_handle_event(RECVBUF_USERID, p_tmp.exp_inc, &out_header->is_upgrade, &out_header->count_1,
			p_out_item_1);
		if(p_tmp.is_win == 1){
			if(p_tmp.barrier_id != 0 && p_tmp.level_type == LT_NORMAL){
				//计算战斗后过关成就 ,更新地图关卡完成度
				this->user_battle_get_pass_achievement(RECVBUF_USERID, p_tmp.barrier_id, p_tmp.comp_degree, out_header,
						p_out_item_1);
			}

			//战斗每日任务
			uint32_t level_type = 0;
			uint32_t object_id = p_tmp.barrier_id;
			if(p_tmp.level_type == LT_NORMAL){
				level_type = 2;
			}
			else if(p_tmp.level_type == LT_FRIEND){
				level_type = 3;
				object_id = 0;
			}
			else if(p_tmp.level_type == LT_BOSS || p_tmp.level_type == LT_BOSS_TIME || p_tmp.level_type == LT_BOSS_VIP
					 || p_tmp.level_type == LT_BOSS_COST){
				level_type = 4;
			}
			if(level_type != 0){
				battle_task_id_t *p_list = 0;
				uint32_t count = 0;
				ret = this->user_battle_day_task.get_taskid_by_object_type(RECVBUF_USERID, level_type, object_id, 
						&p_list, &count);	
				for(uint32_t i = 0; i < count; ++i){
					ret = this->user_battle_day_task.update_day_task(RECVBUF_USERID, (p_list + i)->taskid);
				}
				if(p_list != 0){
					free(p_list);
				}
			}

			//统计连胜次数
			uint32_t winning_streak = 0;
			ret = this->user_battle_character_attribute.get_one_column(RECVBUF_USERID, "win_streak", &winning_streak);
			p_out_item_1->cardid = 0;
			//节节高升
			if(winning_streak + 1 == 20){
				p_out_item_1->cardid = 1553049 ;
			}
			//造诣深厚
			if(winning_streak + 1 == 30){
				p_out_item_1->cardid = 1553050;;
			}
			//仁者无敌
			if(winning_streak + 1 == 40){
				p_out_item_1->cardid = 1553051;
			}
			//常胜将军
			if(winning_streak + 1 == 50){
				p_out_item_1->cardid = 1553052;
			}
			if(p_out_item_1->cardid != 0){
				uint32_t cnt_1 = 0, cnt_2 = 0;
				ret = this->user_battle_articles.get_count(RECVBUF_USERID, p_out_item_1->cardid, cnt_1);
				ret = this->user_battle_card_booklet.get_count(RECVBUF_USERID, p_out_item_1->cardid, cnt_2);
				if(cnt_1 == 0 && cnt_2 == 0){
					//ret = this->user_battle_articles.add_count(RECVBUF_USERID, p_out_item_1->cardid, 1, 99);
					user_add_attire_in  add_item = {0};
					add_item.attiretype = 32;
					add_item.attireid =  p_out_item_1->cardid;
					add_item.count = 1;
					add_item.maxcount = 999999;
					ret = this->user_add_attire(RECVBUF_USERID, &add_item);

					++out_header->count_1;
					++p_out_item_1;
				}
			}
			this->user_battle_character_attribute.update(RECVBUF_USERID, "win_streak", winning_streak + 1);

			//战胜boss后获得成就卡
			std::map<uint32_t, uint32_t> t_map;
			for(uint32_t i = 0; i < 10; ++i){
				if( i <= 3){
					t_map[25 + i] = 1553112 + i; 
				}
				else if( i >3 && i <= 6){
					t_map[25 + i] = 1553116;
				}
				else {
					t_map[25 + i] = 1553117;
				}
			}
			//胜萨尔冥王
			t_map[43] = 1553141;
			if(p_tmp.level_type == LT_BOSS || p_tmp.level_type == LT_BOSS_TIME || p_tmp.level_type == LT_BOSS_VIP
					||  p_tmp.level_type == LT_BOSS_COST){
				uint32_t bs_cnt_1 = 0, bs_cnt_2 = 0;
				ret = this->user_battle_articles.get_count(RECVBUF_USERID, t_map[p_tmp.barrier_id], bs_cnt_1);
				ret = this->user_battle_card_booklet.get_count(RECVBUF_USERID, t_map[p_tmp.barrier_id], bs_cnt_2);
				if(bs_cnt_1 == 0 && bs_cnt_2 == 0){
					//this->user_battle_articles.add_count(RECVBUF_USERID, t_map[p_tmp.barrier_id], 1, 9999);
					user_add_attire_in  add_item = {0};
					add_item.attiretype = 32;
					add_item.attireid =  t_map[p_tmp.barrier_id];
					add_item.count = 1;
					add_item.maxcount = 999999;
					ret = this->user_add_attire(RECVBUF_USERID, &add_item);
					++out_header->count_1;
					p_out_item_1->cardid = t_map[p_tmp.barrier_id];
					++p_out_item_1;
				}
			}//if
				
		}
		else if(p_tmp.is_win == 0){
			this->user_battle_character_attribute.update(RECVBUF_USERID, "win_streak", 0);
		}

		//与好友对战后获得成就卡, 还要判断是否给成就卡
		uint32_t rival_cnt = 0;
		uint32_t achieve_friend_card[] = {0, 1553032, 1553033, 1553034};
		ret = this->user_battle_friend_event.get_rival_count(RECVBUF_USERID,  &rival_cnt);
		uint32_t index = 0;
		for(uint32_t n = 1; n < 4; ++n){
			if(rival_cnt >= n*10){
				index = n;
			}
			if(index != 0){
				uint32_t cou_1 = 0, cou_2 = 0;
				ret = this->user_battle_articles.get_count(RECVBUF_USERID, achieve_friend_card[index], cou_1);
				ret = this->user_battle_card_booklet.get_count(RECVBUF_USERID, achieve_friend_card[index], cou_2);
				if(cou_1 == 0 && cou_2 == 0){
					//this->user_battle_articles.add_count(RECVBUF_USERID, achieve_friend_card[index], 1, 9999);
					user_add_attire_in  add_item = {0};
					add_item.attiretype = 32;
					add_item.attireid =  achieve_friend_card[index];
					add_item.count = 1;
					add_item.maxcount = 999999;
					ret = this->user_add_attire(RECVBUF_USERID, &add_item);

					++out_header->count_1;
					p_out_item_1->cardid = achieve_friend_card[index];
					++p_out_item_1;
	
				}
				index = 0;
			}

		}//for

		/*
		//PK特殊boss，送蓝色炸弹
		{
			if(p_tmp.barrier_id == 45 || p_tmp.barrier_id == 46 ){
				user_add_attire_in st_attire_add; 
				st_attire_add.attireid = 190876;
				st_attire_add.attiretype = 0;//
				st_attire_add.count = 5;
				st_attire_add.maxcount = 999999999;
				this->user_add_attire(RECVBUF_USERID, &st_attire_add);
				p_out_item_1->cardid = 190876;
				++p_out_item_1;
				++out_header->count_1;
			}
		}
		//摩摩怪作战结束后送光明勋章、黑森林记忆石
		{
			uint32_t attires[] = { 190880, 190882 };
			user_add_attire_in st_attire_add; 
			for(uint32_t k = 0; k < sizeof(attires)/sizeof(uint32_t); ++k){
				st_attire_add.attireid = attires[k];
				st_attire_add.attiretype = 0;//
				st_attire_add.count = 1;
				st_attire_add.maxcount = 999999999;
				this->user_add_attire(RECVBUF_USERID, &st_attire_add);
				p_out_item_1->cardid = attires[k];
				++p_out_item_1;
				++out_header->count_1;
			}
		}
		*/

		p_offset = p_offset + sizeof(user_battle_over_info_out_item_1) * out_header->count_1;	
		user_battle_over_info_out_item_2 *p_out_item_2 = (user_battle_over_info_out_item_2*)p_offset;

		//战斗结束，激活与好友交互事件2,3
		uint32_t fail_cnt = 0, fight_cnt = 0;
		ret = this->user_battle_accident.get_cnts(RECVBUF_USERID, &fail_cnt, &fight_cnt);
		if(ret == USER_ID_NOFIND_ERR){
			ret = this->user_battle_accident.insert(RECVBUF_USERID, 0, p_tmp.is_win, 1,0,0);
		}
		else{
			if(fail_cnt == 1 && p_tmp.is_win == 0){
				++out_header->count_2;
				p_out_item_2->event_id = 2;
				++p_out_item_2;
				ret = this->user_battle_accident.set_int_value(RECVBUF_USERID, "fail_cnt", 0);
			}
			else if(fail_cnt == 0 && p_tmp.is_win == 0){
				ret = this->user_battle_accident.set_int_value(RECVBUF_USERID, "fail_cnt", 1);
			}
			if(fight_cnt == 9){
				++out_header->count_2;
				p_out_item_2->event_id = 3;
				ret = this->user_battle_accident.set_int_value(RECVBUF_USERID, "fight_cnt", 0);
			}
			else if(fight_cnt < 9){
				ret = this->user_battle_accident.set_int_value(RECVBUF_USERID, "fight_cnt", fight_cnt + 1);
			}
		}
		p_offset += out_header->count_2 * sizeof(user_battle_over_info_out_item_2);
		
	}//如果是收徒战斗，什么都不扣，什么都不给

	ret = this->user_battle_flip_card_info.remove(RECVBUF_USERID);	
	ret = SUCC;
	STD_RETURN_WITH_BUF(ret, buf, p_offset- buf);
}
/*
 * 许愿时，拉取全局表祝福情况
 */
int Croute_func::user_diningroom_get_wish(DEAL_FUN_ARG)
{
	user_diningroom_get_wish_out out = {0};
    ret=this->angel_battle.get_wish_count(RECVBUF_USERID, &out.can_wish);
	ret = SUCC;

    STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * 玩家是否有许愿心道具
 */
int Croute_func::user_battle_able_to_wish(DEAL_FUN_ARG)
{
	user_battle_able_to_wish_in *p_in = PRI_IN_POS;
	user_battle_able_to_wish_out out = {0};
	uint32_t wish_item = 0;
	uint32_t date = 0, day_wish_cnt = 0;
	ret = this->user_battle_accident.get_three_column(RECVBUF_USERID, &wish_item, &date, &day_wish_cnt);
	uint32_t today = get_date(time(0));
	if( date == today && day_wish_cnt >= 2){
		out.can_wish = 2;//每天许愿2次
	}
	else{
		if(wish_item == 0){
			const uint32_t itemid = 1301024;//许愿心id
			ret=this->user_battle_articles.sub_count(RECVBUF_USERID, itemid, 1);
			if(ret == SUCC){
				out.can_wish = 1;
				ret = this->user_battle_accident.add_wish_item(RECVBUF_USERID, p_in->wish_id, day_wish_cnt, 
						today, date);		

				//许愿每日任务
				battle_task_id_t *p_temp = 0;
				uint32_t count = 0;
				ret = this->user_battle_day_task.get_taskid_by_object_type(RECVBUF_USERID, 6, 1, &p_temp, &count);	
				for(uint32_t i = 0; i < count; ++i){
					ret = this->user_battle_day_task.update_day_task(RECVBUF_USERID, (p_temp + i)->taskid);
				}
				if(p_temp != 0){
					free(p_temp);
				}

			}
		}//if
	}//else
	
    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 许愿成功
 */
int Croute_func::user_battle_wish_succ(DEAL_FUN_ARG)
{
	user_battle_wish_succ_in *p_in = PRI_IN_POS;

	bat_arg_event_t ev;
	memset(&ev, 0, sizeof(bat_arg_event_t));

	ret = this->angel_battle.get_event(RECVBUF_USERID, &ev);
	if(ret == USER_ID_NOFIND_ERR){
		ev.events[0] = 1;
		ret = this->angel_battle.insert(RECVBUF_USERID, 0, &ev);
	}
	else{
		ev.events[0] = (ev.events[0] + 1) % 255;
		ret = this->angel_battle.update_events(RECVBUF_USERID, &ev);
	}
	ret = this->angel_battle.set_wish_count(RECVBUF_USERID, p_in->wish_count);
	ret = SUCC;	
	STD_RETURN(ret);
}
/*
 * 拉取全局表中好友事件信息
 */
int Croute_func::user_battle_get_friend_event_info(DEAL_FUN_ARG)
{
    user_battle_get_friend_event_info_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_battle_get_friend_event_info_in_item));
    user_battle_get_friend_event_info_in_item * p_in_item=(user_battle_get_friend_event_info_in_item*)(RCVBUF_PRIVATE_POS + 
			sizeof(*p_in)) ;
    user_battle_get_friend_event_info_out_header  out_header = {0};
    user_battle_get_friend_event_info_out_item *p_out_item = 0;
    ret=this->angel_battle.get_variety_events(RECVBUF_USERID, p_in_item, p_in->count, &p_out_item, &out_header.count);
	ret = SUCC;
    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 拉取玩家本地事件信息
 */
int Croute_func::user_get_self_events_info(DEAL_FUN_ARG)
{
    user_get_self_events_info_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_get_self_events_info_in_item));
    user_get_self_events_info_in_item * p_in_item=(user_get_self_events_info_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
    user_get_self_events_info_out_header  out_header = {0} ;
    user_get_self_events_info_out_item *p_out_item = 0;
    ret = this->user_battle_friend_event.get_friend_local_events(RECVBUF_USERID, p_in_item, p_in->count, &p_out_item, 
			&out_header.count);
	ret = SUCC;	
    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 玩家祝福好友时，拉取好友的全局表中的祝福信息
 */
int Croute_func::user_diningroom_bless_get_wish_info(DEAL_FUN_ARG)
{
    user_diningroom_bless_get_wish_info_in *p_in=PRI_IN_POS;
    user_diningroom_bless_get_wish_info_out out={0};
	out.friend_id = p_in->friend_id;
    ret = this->angel_battle.get_wish_count(p_in->friend_id, &out.wish_count);
	bat_arg_event_t ev;
	memset(&ev, 0, sizeof(ev));
	ret = this->angel_battle.get_event(p_in->friend_id, &ev);
	out.raise_cnt = ev.events[0];
	ret = SUCC;
    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 玩家祝福好友
 */
int Croute_func::user_battle_bless_friend_info(DEAL_FUN_ARG)
{
	user_battle_bless_friend_info_in *p_in = PRI_IN_POS;
    user_battle_bless_friend_info_out out={0};
	out.friend_id = p_in->friend_id;
	bat_arg_event_t ev;
	memset(&ev, 0, sizeof(ev));
	ret = this->user_battle_friend_event.get_friend_event(RECVBUF_USERID, p_in->friend_id, &ev);
	if(ret == USER_ID_NOFIND_ERR){
		ev.events[0] = p_in->raise_cnt;
		out.can_bless = 1;
		ret = this->user_battle_friend_event.insert(RECVBUF_USERID, p_in->friend_id, &ev);
	}
	else{
		if(ev.events[0] != p_in->raise_cnt){
			out.can_bless = 1;
			ev.events[0] = p_in->raise_cnt;
			ret = this->user_battle_friend_event.update(RECVBUF_USERID, p_in->friend_id, &ev);
		}
	}
	if(out.can_bless == 1){
		out.item_id = 0;
		out.item_cnt = 20;
		int xiaomee = 0;
		ret=this->user.change_xiaomee(RECVBUF_USERID,out.item_cnt, XIAOMEE_USE_ADD_ANGEL_BATTLE, 0, &xiaomee);

		//交互每日任务
		battle_task_id_t *p_temp = 0;
		uint32_t count = 0;
		ret = this->user_battle_day_task.get_taskid_by_object_type(RECVBUF_USERID, 1, 1, &p_temp, &count);	
		for(uint32_t i = 0; i < count; ++i){
			ret = this->user_battle_day_task.update_day_task(RECVBUF_USERID, (p_temp + i)->taskid);
		}
		if(p_temp != 0){
			free(p_temp);
		}
	}
	ret = SUCC;
    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 好友祝福成功后，重置需要好友祝福次数
 */
int Croute_func::user_diningroom_set_wish_cnt(DEAL_FUN_ARG)
{
	uint32_t wish_count = 0;
	ret = this->angel_battle.get_wish_count(RECVBUF_USERID, &wish_count);
	if(wish_count > 0){
		--wish_count;
	}
	else{
		wish_count = 0;
	}
	ret=this->angel_battle.set_wish_count(RECVBUF_USERID, wish_count);
	ret = SUCC;
    STD_RETURN(ret);
}
/*
 * 全局表,获取好友普通事件
 */
int Croute_func::user_dining_room_get_c_event_info(DEAL_FUN_ARG)
{
    user_dining_room_get_c_event_info_in *p_in=PRI_IN_POS;
    user_dining_room_get_c_event_info_out out = {p_in->friend_id, 1,  p_in->event_id, 0};
	if(p_in->event_id - 1 == 1){
		uint32_t datetime = 0;
		ret = this->angel_battle.get_last_login_time(p_in->friend_id, &datetime);
		uint32_t now = time(0);
		if( (now - datetime)/(24*3600) < 10){
			out.is_handle = 0;
			STD_RETURN_WITH_STRUCT(ret,out);
		}
	}
    bat_arg_event_t ev;
	memset(&ev, 0, sizeof(ev));
	ret = this->angel_battle.get_event(p_in->friend_id, &ev);

	out.event_cnt = ev.events[p_in->event_id - 1];
	ret = SUCC;

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 全局表，置普通事件
 */
int Croute_func::user_diningroom_set_com_event(DEAL_FUN_ARG)
{
    user_diningroom_set_com_event_in *p_in=PRI_IN_POS;
	bat_arg_event_t ev;
	memset(&ev, 0, sizeof(ev));
    ret = this->angel_battle.get_event(RECVBUF_USERID, &ev);
	if(ret == USER_ID_NOFIND_ERR){
		ev.events[p_in->event_id] = 1;
		ret = this->angel_battle.insert(RECVBUF_USERID, 0, &ev);
	}
	else{
		ev.events[p_in->event_id] =  (ev.events[p_in->event_id] + 1)%255;
		ret = this->angel_battle.update_events(RECVBUF_USERID, &ev);
	}
	ret = SUCC;
    STD_RETURN(ret);
}
/*
 * 玩家处理普通好友事件
 */
int Croute_func::user_battle_handle_common_event(DEAL_FUN_ARG)
{

	char buf[PROTO_MAX_LEN]={ 0 };
    user_battle_handle_common_event_in *p_in=PRI_IN_POS;
    user_battle_handle_common_event_out_header *out_header = (user_battle_handle_common_event_out_header *)buf;
	user_battle_handle_common_event_out_item *p_out_item = (user_battle_handle_common_event_out_item *)(buf + 
			sizeof(user_battle_handle_common_event_out_header));
	bat_arg_event_t ev; 
	memset(&ev, 0, sizeof(ev));
    ret = this->user_battle_friend_event.get_friend_event(RECVBUF_USERID, p_in->friend_id, &ev);
	uint32_t exp_inc = 0;
	if(p_in->event_id == 2){
		exp_inc = 5;
		out_header->itemid = 13;
		out_header->cnt = exp_inc;
	}
	else if(p_in->event_id == 4){
		exp_inc = 2;
		out_header->itemid = 13;
		out_header->cnt = exp_inc;
	}
	else if(p_in->event_id ==3){
		out_header->itemid = 0;
		out_header->cnt = 20;
	}
	else if(p_in->event_id == 5){//为好友加油
		;
	}
	if(ret == USER_ID_NOFIND_ERR){
		out_header->is_succ = 1;
		ev.events[p_in->event_id - 1] = p_in->event_cnt;
		ret = this->user_battle_friend_event.insert(RECVBUF_USERID, p_in->friend_id, &ev);
	}
	else{
		if(ev.events[p_in->event_id - 1] != p_in->event_cnt){
			out_header->is_succ = 1;
			ev.events[p_in->event_id -1] = p_in->event_cnt;
			ret = this->user_battle_friend_event.update(RECVBUF_USERID, p_in->friend_id, &ev);
		}
	}
	if(out_header->is_succ == 1){
		if(p_in->event_id == 2 || p_in->event_id == 4){
			user_battle_add_exp_handle_event(RECVBUF_USERID, exp_inc, &out_header->is_upgrade, &out_header->count, p_out_item);
		}	
	  	else if (p_in->event_id == 3) {
			int xiaomee = 0;
			ret=this->user.change_xiaomee(RECVBUF_USERID,out_header->cnt, XIAOMEE_USE_ADD_ANGEL_BATTLE, 0, &xiaomee);
	  	}

		//普通每日任务
		battle_task_id_t *p_temp = 0;
		uint32_t count = 0;
		ret = this->user_battle_day_task.get_taskid_by_object_type(RECVBUF_USERID, 1, p_in->event_id, &p_temp, &count);	
		for(uint32_t i = 0; i < count; ++i){
			ret = this->user_battle_day_task.update_day_task(RECVBUF_USERID, (p_temp + i)->taskid);
		}
		if(p_temp != 0){
			free(p_temp);
		}
	}
	else{
		out_header->itemid = 0;
		out_header->cnt = 0;
	}
	
	uint32_t length = sizeof(user_battle_handle_common_event_out_header) + out_header->count* 
		sizeof(user_battle_handle_common_event_out_item);
	ret = SUCC;	

	STD_RETURN_WITH_BUF(ret, buf, length);
}
/*
 * 拉取玩家许愿时的物品
 */
int Croute_func::user_get_wish_item_id(DEAL_FUN_ARG)
{
    user_get_wish_item_id_out out={0};
    ret = this->user_battle_accident.get_int_value(RECVBUF_USERID, "itemid", &out.wish_itemid);
	if (ret != SUCC) {
		out.wish_itemid = 0;
	}
    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 拉取战斗结束时，玩家战斗信息
 */
int Croute_func::user_battle_gefight_over_info(DEAL_FUN_ARG)
{
    user_battle_gefight_over_info_out_header out_header={0};
	user_battle_gefight_over_info_out_item *p_out_item = 0; 

	ret = this->user_battle_fight_record.get_all_info(RECVBUF_USERID, &p_out_item, &out_header.count);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 本轮许愿玩家实现后，送给玩家许愿物品
 */
int Croute_func::user_battle_give_wish_article(DEAL_FUN_ARG)
{
    user_battle_give_wish_article_out out={0};
	uint32_t item_id = 0;
    ret=this->user_battle_accident.get_int_value(RECVBUF_USERID, "itemid", &item_id);
	if(item_id != 0){
		out.is_give = item_id;		
		//ret = this->user_battle_articles.add_count(RECVBUF_USERID, item_id, 1, 99999);
		user_add_attire_in  add_item = {0};
		add_item.attiretype = 32;
		add_item.attireid =  item_id;
		add_item.count = 1;
		add_item.maxcount = 999999;
		ret = this->user_add_attire(RECVBUF_USERID, &add_item);

		ret = this->user_battle_accident.set_int_value(RECVBUF_USERID, "itemid", 0);
	}
	ret = SUCC;
    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 拉取战斗每日任务
 */
int Croute_func::user_battle_get_day_tasklist(DEAL_FUN_ARG)
{
    user_battle_get_day_tasklist_out_header  out_header = {0};
    user_battle_get_day_tasklist_out_item *p_out_item = 0;
	uint32_t date = 0;
	ret = this->user_battle_character_attribute.get_two_columns(RECVBUF_USERID, "task_date", "day_refresh", &date, 
			&out_header.refresh_cnt);
	uint32_t today = get_date(time(0));
	if(date == today){
		ret = this->user_battle_day_task.get_day_task(RECVBUF_USERID, &p_out_item , &out_header.count);
		out_header.state = 1;
	}
	else{
		out_header.refresh_cnt = 0;
	}

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 新的一天，新的战斗任务
 */
int Croute_func::user_battle_new_day_task(DEAL_FUN_ARG)
{
    user_battle_new_day_task_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_battle_new_day_task_in_item));
    user_battle_new_day_task_in_item * p_in_item=(user_battle_new_day_task_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
	ret = this->user_battle_day_task.clear_old_task(RECVBUF_USERID);
	//1:任务已接， 2：任务可完成， 3： 任务已完成
	for(uint32_t k = 0; k < p_in->count; ++k){
		ret = this->user_battle_day_task.insert(RECVBUF_USERID, (p_in_item + k)->taskid, (p_in_item + k)->type, 
				(p_in_item + k)->maxcount, (p_in_item + k)->object_id);
	}
	ret = this->user_battle_character_attribute.update_two_columns(RECVBUF_USERID, "task_date", "day_refresh",
			(uint32_t)get_date(time(0)), 0);

    STD_RETURN(ret);
}

/*
 *使用刷新任务道具 
 */
int Croute_func::user_battle_refresh_day_task(DEAL_FUN_ARG)
{
    user_battle_refresh_day_task_in *p_in = PRI_IN_POS;
    user_battle_refresh_day_task_out out;
	memset(&out, 0, sizeof(user_battle_refresh_day_task_out));
	uint32_t day_refresh = 0;
	ret = this->user_battle_character_attribute.get_one_column(RECVBUF_USERID, "day_refresh", &day_refresh);
	if(day_refresh >= 6){
		return HANDLE_BATTLE_TASK_ERR;
	}
	
	battle_task_id_t* p_temp_item = 0;
	uint32_t cnt = 0;
	ret = this->user_battle_day_task.get_taskid(RECVBUF_USERID, &p_temp_item, &cnt);
	if (cnt != 3 && ret != SUCC) {
		return HANDLE_BATTLE_TASK_ERR;
	}

	for(uint32_t k = 0, idx = 0; k < cnt; ++k){
		if((p_temp_item + k)->taskid != p_in->taskid){
			if (idx == 2) {
				return HANDLE_BATTLE_TASK_ERR;
			}
			out.taskid[idx++]= (p_temp_item + k)->taskid;
		}
	}
	if(p_temp_item != NULL){
		free(p_temp_item);
	}
	uint32_t count = 0;
	ret = this->user_battle_articles.get_noused_count(RECVBUF_USERID, p_in->itemid, count);
	if(count == 0){
		return ATTIRE_COUNT_NO_ENOUGH_ERR;
	}

    STD_RETURN_WITH_STRUCT(ret, out);
}
/*
 *增加新任务 
 */
int Croute_func::user_battle_new_a_task(DEAL_FUN_ARG)
{
    user_battle_new_a_task_in *p_in=PRI_IN_POS;
    ret=this->user_battle_day_task.update_one_task(RECVBUF_USERID, p_in->taskid, p_in->type, p_in->maxcount, 
			p_in->object_id, p_in->old_id);
	if(ret == SUCC){
		ret = this->user_battle_character_attribute.update_inc(RECVBUF_USERID, "day_refresh", 1);
		const uint32_t toolid = 1301025;
		ret = this->user_battle_articles.sub_count(RECVBUF_USERID, toolid, 1);
	}

    STD_RETURN(ret);
}
/*
 *完成任务
 */
int Croute_func::user_battle_terminate_day_task(DEAL_FUN_ARG)
{
    user_battle_terminate_day_task_in *p_in=PRI_IN_POS;
	user_battle_terminate_day_task_out out = { 0 };
	
	ret = this->user_battle_day_task.get_one_column(RECVBUF_USERID, p_in->taskid, "state", &(out.state));

	if (ret == SUCC && p_in->itemid != 0 && out.state != 3){
		ret = this->user_battle_articles.sub_count(RECVBUF_USERID, p_in->itemid, 1);
		if (ret == SUCC) {
			out.state = 2;
		} else {
			out.state = 0;
		}
	}
	if (out.state == 2) {
		ret = this->user_battle_day_task.update(RECVBUF_USERID, p_in->taskid, "state", 3);
	}

    STD_RETURN_WITH_STRUCT(ret, out);
}

/*
 * 增加玩家战斗经验
 */
int Croute_func::user_battle_add_exp(DEAL_FUN_ARG)
{
    user_battle_add_exp_in *p_in=PRI_IN_POS;
	char buf[1024] = { 0 };
    user_battle_add_exp_out_header *out_header = (user_battle_add_exp_out_header*)buf;
    user_battle_add_exp_out_item *p_out_item = (user_battle_add_exp_out_item *)(buf + sizeof(user_battle_add_exp_out_header));
	user_battle_add_exp_handle_event(RECVBUF_USERID, p_in->exp_inc, &out_header->is_upgrade, &out_header->count, p_out_item);
	uint32_t length = sizeof(user_battle_add_exp_out_header) + out_header->count* sizeof(user_battle_add_exp_out_item);

	STD_RETURN_WITH_BUF(ret, buf, length);
}

/*
 * 拉取挑战boss次数
 */
int Croute_func::user_battle_get_challenge_times(DEAL_FUN_ARG)
{
    user_battle_get_challenge_times_out out = { };
	uint32_t date = 0;
    ret=this->user_battle_challenge_note.get_challenge_cnt(RECVBUF_USERID, 2, &out.normal_cnt, &out.vip_cnt, &out.time_cnt,
			&out.active_cnt, &date);
	uint32_t today = get_date(time(0));
	if(date != today){
		memset((char*)&out, 0, sizeof(user_battle_get_challenge_times_out));	
	}
	ret = SUCC;

    STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * 拉取徒弟市场,第一步,拉取玩家的师傅及徒弟
 */
int Croute_func::user_battle_get_prentice_market_filter(DEAL_FUN_ARG)
{
	char buf[PROTO_MAX_LEN] = { 0 };
    user_battle_get_prentice_market_filter_out_header  *out_header = (user_battle_get_prentice_market_filter_out_header*)buf;
    user_battle_get_prentice_market_filter_out_item *p_out_item = (user_battle_get_prentice_market_filter_out_item *)(buf + 
			sizeof(user_battle_get_prentice_market_filter_out_header));

	uint32_t *p_temp_item = 0;
    ret = this->user_battle_master.get_all_prentices(RECVBUF_USERID, &p_temp_item, &out_header->count);
	if(out_header->count != 0){
		memcpy(p_out_item, (char*)p_temp_item, out_header->count * sizeof(user_battle_get_prentice_market_filter_out_item));
	}
	char* p_offset = buf + sizeof(*out_header) + out_header->count * sizeof(user_battle_get_prentice_market_filter_out_item);
	ret = this->user_battle_prentice.get_int_value(RECVBUF_USERID, "master", (uint32_t *)p_offset);
	if(*(uint32_t*)p_offset != 0){
		++out_header->count;
		p_offset += sizeof(uint32_t);
	}

	uint32_t buf_barr[2]={ RECVBUF_USERID, 1 };
	msglog(this->msglog_file, 0x0409B436 , time(NULL), buf_barr, 8);

	STD_RETURN_WITH_BUF(SUCC, buf, p_offset - buf);
}
/*
 * 拉取徒弟市场，第二步
 */
int Croute_func::user_battle_get_prentice_market(DEAL_FUN_ARG)
{
    user_battle_get_prentice_market_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_battle_get_prentice_market_in_item));
    user_battle_get_prentice_market_in_item * p_in_item=(user_battle_get_prentice_market_in_item*)(RCVBUF_PRIVATE_POS+
			sizeof(*p_in));
    user_battle_get_prentice_market_out_header  out_header = { 0};
    user_battle_get_prentice_market_out_item *p_out_item = 0;
    ret = this->angel_battle.get_prentice_level_and_master(RECVBUF_USERID, p_in_item, p_in->count, &p_out_item, 
			&out_header.count);
	if (out_header.count != 0) {
		ret = this->angel_battle.get_master_level(p_out_item, out_header.count);
	}

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 拉取玩家本人的师徒关系
 */
int Croute_func::user_battle_get_self_mp_relatrion(DEAL_FUN_ARG)
{
    user_battle_get_self_mp_relatrion_out_header  out_header = {0};
    user_battle_get_self_mp_relatrion_out_item *p_out_item = NULL;
    ret = this->user_battle_prentice.get_self_relation(RECVBUF_USERID, &out_header);
	ret = this->user_battle_master.get_all_prentices_info(RECVBUF_USERID, &p_out_item, &out_header.prentice_cnt);

    STD_RETURN_WITH_STRUCT_LIST(SUCC, out_header, p_out_item, out_header.prentice_cnt);
}
/*
 * 拉取师傅信息
 */
int Croute_func::user_battle_get_master_info(DEAL_FUN_ARG)
{
    user_battle_get_master_info_out out={0};
    ret=this->user_battle_master.get_prentice_count(RECVBUF_USERID, &out.prentice_cnt);
	ret = this->user_battle_character_attribute.cal_battle_level(RECVBUF_USERID, &out.master_level);
	//ret = this->user_battle_prentice.get_int_value(RECVBUF_USERID, "merit", &out.master_merit);
	ret = this->user_battle_prentice.get_two_col(RECVBUF_USERID, "merit", "succ_master", &(out.master_merit), 
			&(out.master_out_cnt));
    STD_RETURN_WITH_STRUCT(SUCC, out);
}

/*
 * 校验是否可以收徒
 */
int Croute_func::user_battle_check_teach_prentice(DEAL_FUN_ARG)
{
    user_battle_check_teach_prentice_out out={0};
	uint32_t day_rev_cnt = 0;
    ret = this->user_battle_prentice.get_int_value(RECVBUF_USERID, "recv_cnt", &day_rev_cnt);
	if(day_rev_cnt >= 3){
		out.state = 2;
	}
	else{
		uint32_t level = 0;
		ret = this->user_battle_character_attribute.cal_battle_level(RECVBUF_USERID, &level);
		uint32_t prentice_cnt = 0;
		ret = this->user_battle_master.get_prentice_count(RECVBUF_USERID, &prentice_cnt);
		if(prentice_cnt == 3){
			out.state = 4;
		}
		if(level < 1 || (level >= 1 && level < 10 && prentice_cnt == 1) || (level >= 10 && level < 20 && 
					prentice_cnt == 2)){
			out.state = 3;

		}
		else{
			out.state = 1;
		}
	}

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 检查徒弟是否可拜师
 */
int Croute_func::user_battle_check_prentice(DEAL_FUN_ARG)
{
	user_battle_check_prentice_out out={};
	uint32_t today = get_date(time(0));
	uint32_t date = 0, ini_level = 0;
	out.state = 1;
	uint32_t new_level = 0, master = 0;
	ret = this->user_battle_character_attribute.get_level(RECVBUF_USERID, &new_level);
	//ret = this->user_battle_prentice.get_two_col(RECVBUF_USERID, "escape_date", "initial_level", &date, &ini_level);
	ret = this->user_battle_prentice.get_three_col(RECVBUF_USERID, "escape_date", "initial_level", "master",
			        &date, &ini_level, &master);
	//还要判断是不是可以出师，要去师傅的表中校验等级
	if (ret != SUCC) {
		ret = this->user_battle_prentice.insert(RECVBUF_USERID, 0, 0);
	}
	if(ret == SUCC){
		if(date == today || (master != 0 && (new_level - ini_level) >= 5)) {
			out.state = 5;
		}
	}
	
	STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 拉取训练信息
 */
int Croute_func::user_battle_get_train_info(DEAL_FUN_ARG)
{
    user_battle_get_train_info_in *p_in=PRI_IN_POS;
	char buf[256] = { 0 };
    user_battle_get_train_info_out_header  *out_header = (user_battle_get_train_info_out_header*)buf;
    user_battle_get_train_info_out_item *p_out_item = (user_battle_get_train_info_out_item *)(buf + 
			sizeof(user_battle_get_train_info_out_header));
    ret = this->user_battle_master.get_train_info(RECVBUF_USERID, p_in->prentice, p_out_item, &out_header->count);

    STD_RETURN_WITH_BUF(ret,buf, sizeof(user_battle_get_train_info_out_item)* out_header->count + sizeof(*out_header));
}
/*
 * 训练徒弟
 */
int Croute_func::user_battle_train_prentice(DEAL_FUN_ARG)
{
    user_battle_train_prentice_in *p_in=PRI_IN_POS;
	user_battle_train_prentice_out out ={ 0 };	
	uint32_t merit = 0;
	ret = this->user_battle_prentice.get_int_value(RECVBUF_USERID, "merit", &merit);
	if((merit < 50 && p_in->train_id >= 3) || (merit < 100 && p_in->train_id >= 4) || (merit < 500 && 
				p_in->train_id >= 5) || (merit < 1000 && p_in->train_id >= 6)){
		return USER_RESPECT_MASTER_ERR;
	}
    ret = this->user_battle_master.update_train_by_id(RECVBUF_USERID, p_in->prentice, p_in->train_id);
	if(ret == SUCC){
		ret = this->user_battle_prentice.update_merit_inc(RECVBUF_USERID, 2);
		this->user_battle_master.get_one_col(RECVBUF_USERID, p_in->prentice, "initial_level", &out.ini_level);
		
		user_battle_add_mp_msg_in msg = {
			(uint32_t)time(0), RECVBUF_USERID, p_in->prentice, p_in->train_id, 0, 2 
		};
		ret = this->user_battle_master_prentice_msg.update_record(RECVBUF_USERID, &msg);

	}

	STD_RETURN_WITH_STRUCT(ret,out);
	//STD_RETURN(ret);
}
/*
 * 解除师徒关系, 第一步 
 */
int Croute_func::user_battle_evict_prentice(DEAL_FUN_ARG)
{
    user_battle_evict_prentice_in *p_in=PRI_IN_POS;
    user_battle_evict_prentice_out out={p_in->prentice_id};
    ret = this->user_battle_master.remove_prentice(RECVBUF_USERID, p_in->prentice_id);
	if( ret == SUCC && p_in->type == 1){//主动
		uint32_t merit = 0;
		ret = this->user_battle_prentice.get_int_value(RECVBUF_USERID, "merit", &merit);
		merit = merit >  10 ? merit - 10: 0;
		ret = this->user_battle_prentice.set_int_value(RECVBUF_USERID, "merit", merit);

		user_battle_add_mp_msg_in msg = {
			(uint32_t)time(0), RECVBUF_USERID, p_in->prentice_id, 101, 0, 10 
		};
		ret = this->user_battle_master_prentice_msg.update_record(RECVBUF_USERID, &msg);
	}

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 解除师徒关系, 第二步
 */ 
int Croute_func::user_battle_evict_prentice_another(DEAL_FUN_ARG)
{
	user_battle_evict_prentice_another_in *p_in=PRI_IN_POS; 
    user_battle_evict_prentice_another_out out={0};

    ret = this->user_battle_prentice.get_int_value(RECVBUF_USERID, "master", &out.master_id);
	if(out.master_id != 0){
		//ret = this->user_battle_prentice.set_int_value(RECVBUF_USERID, "master", 0);
		ret = this->user_battle_prentice.update_two_col(RECVBUF_USERID, "master", "initial_level", 0, 0);
		if(p_in->type == 1){//主动
			uint32_t today = get_date(time(0));
			ret = this->user_battle_prentice.set_int_value(RECVBUF_USERID, "escape_date", today);
			user_battle_add_mp_msg_in msg = {
				(uint32_t)time(0), out.master_id, RECVBUF_USERID, 102, 0, 0 
			};
			ret = this->user_battle_master_prentice_msg.update_record(RECVBUF_USERID, &msg);
		}
	}

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 解除师徒关系，第三步， 置全局表
 */
int Croute_func::user_dininingroom_evict_prentice_another(DEAL_FUN_ARG)
{
	user_dininingroom_evict_prentice_another_in *p_in=PRI_IN_POS; 
    user_dininingroom_evict_prentice_another_out out={0};
    ret = this->angel_battle.get_one_colum(RECVBUF_USERID, "master", &out.master);
	ret = this->angel_battle.update_one_column(RECVBUF_USERID, "master", p_in->new_master);

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 徒弟孝敬师傅
 */
int Croute_func::user_battle_respect_master(DEAL_FUN_ARG)
{
	user_battle_respect_master_out out={1,0};
	uint32_t master = 0;
	ret = this->user_battle_prentice.get_int_value(RECVBUF_USERID, "master", &master);
	if(master == 0){
		return USER_RESPECT_MASTER_ERR;
	}
	uint32_t is_resp = 0, date = 0;
	ret = this->user_battle_prentice.get_two_col(RECVBUF_USERID, "respect", "date", &is_resp, &date);
	uint32_t today = get_date(time(0));
	if(date == today && is_resp != 0){
		return USER_RESPECT_MASTER_ERR;
	}
	else if(is_resp == 0){
		if(date != today){
			ret = this->user_battle_prentice.update_two_col(RECVBUF_USERID, "respect", "date", 1, today);
			ret = this->user_battle_prentice.set_int_value(RECVBUF_USERID, "recv_cnt", 0);
		}
		else{
			ret = this->user_battle_prentice.set_int_value(RECVBUF_USERID, "respect", 1);
		}
		ret = this->user_battle_prentice.update_merit_inc(RECVBUF_USERID, 1);
		out.state = 0;
	}
	ret = this->user_battle_prentice.get_int_value(RECVBUF_USERID, "master", &out.master);

	STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 徒弟孝敬师傅,置师傅表中相应字段
 */
int Croute_func::user_battle_respect_set_in_master(DEAL_FUN_ARG)
{
	user_battle_respect_set_in_master_in *p_in = PRI_IN_POS; 
    ret=this->user_battle_master.update_one_col(RECVBUF_USERID, p_in->prentice, "thank_flag", 1);

	STD_RETURN(ret);
}
/*
 * 师傅领取感谢金
 */
int Croute_func::user_battle_master_receive_respect(DEAL_FUN_ARG)
{
    user_battle_master_receive_respect_in *p_in=PRI_IN_POS;
    user_battle_master_receive_respect_out out={0};
	uint32_t resp  = 0;
	ret = this->user_battle_master.get_one_col(RECVBUF_USERID, p_in->prentice, "thank_flag", &resp);
	if(resp != 0){
		ret = this->user_battle_master.recive_prentice_res(RECVBUF_USERID, p_in->prentice);
		ret = this->user_battle_prentice.update_merit_inc(RECVBUF_USERID, 1);
		//int xiaomee = 0;
		//ret=this->user.change_xiaomee(RECVBUF_USERID,200, XIAOMEE_USE_ADD_ANGEL_BATTLE, 0, &xiaomee);
		ret = this->user.update_xiaomee_inc(RECVBUF_USERID, 200);
		out.state = 1;
	}
	else{
		out.state = 0;
	}

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * @brief 天使对战：判断徒弟是否可以出师
 */
int Croute_func::user_check_finish_apprentice(DEAL_FUN_ARG)
{
	user_check_finish_apprentice_in *p_in  = PRI_IN_POS;
	
	user_check_finish_apprentice_out out = {0};
	uint32_t master = 0;
	ret = this->user_battle_prentice.get_int_value(RECVBUF_USERID, "master", &master);
	if(ret != SUCC || master != p_in->master){
		return USER_RESPECT_MASTER_ERR;
	}
	ret = this->user_battle_character_attribute.get_level(RECVBUF_USERID, &(out.apprentice_level));
	STD_RETURN_WITH_STRUCT(ret, out);
}

/*
 * @brief 天使对战：师傅让徒弟出师
 */
int Croute_func::user_master_finish_apprentice(DEAL_FUN_ARG)
{
	user_master_finish_apprentice_in *p_in = PRI_IN_POS; 
	char buf[1024] = { 0 };
	user_master_finish_apprentice_out_header *out_header = (user_master_finish_apprentice_out_header*)buf;
	user_master_finish_apprentice_out_item *p_out_item = (user_master_finish_apprentice_out_item*)(buf+
			sizeof(user_master_finish_apprentice_out_header));
	
	uint32_t ini_level = 0;
	 this->user_battle_master.get_one_col(RECVBUF_USERID, p_in->apprentice_id, "initial_level", &ini_level);
	 if(p_in->apprentice_level >= ini_level + 5){
		 out_header->state = 0;
		ret = this->user_battle_master.remove_prentice(RECVBUF_USERID, p_in->apprentice_id);
		ret = this->user_battle_prentice.update_merit_inc(RECVBUF_USERID, 10);

		ret = this->user_battle_prentice.get_int_value(RECVBUF_USERID, "succ_master", &out_header->apprentice_cnt);
		out_header->apprentice_cnt++;
		ret = this->user_battle_prentice.set_int_value(RECVBUF_USERID, "succ_master", out_header->apprentice_cnt);

		//统计	
	    uint32_t buf_barr[2]={ RECVBUF_USERID, 1};
	    uint32_t type_id =  0;
		if(out_header->apprentice_cnt == 1){
			type_id = 0x0409B437;	
		}
		else if(out_header->apprentice_cnt == 4){
			type_id = 0x0409B438;
		}
		else if(out_header->apprentice_cnt == 10){
			type_id = 0x0409B439;
		}
		else if(out_header->apprentice_cnt == 20){
			type_id = 0x0409B43A;
		}
		if(type_id != 0){
			msglog(this->msglog_file, type_id , time(NULL), buf_barr, 8);
		}

		user_battle_add_mp_msg_in msg = {
			(uint32_t)time(0), RECVBUF_USERID, p_in->apprentice_id, 103, 0, 10 
		};
		ret = this->user_battle_master_prentice_msg.update_record(RECVBUF_USERID, &msg);
		//出师礼包
		uint32_t merit_inc = 0;
		if(out_header->apprentice_cnt >= 1 && out_header->apprentice_cnt <= 2){
			
			merit_inc = 10;
			p_out_item->item_id = 1301028;;
			
		}
		else if( out_header->apprentice_cnt == 3){
		
			merit_inc = 10;
			p_out_item->item_id = 1301029;

		}
		else if(out_header->apprentice_cnt >= 4 && out_header->apprentice_cnt <= 9){
			merit_inc = 30;
			p_out_item->item_id = 1301030;
		}
		else if(out_header->apprentice_cnt >= 10 && out_header->apprentice_cnt <= 19){
			merit_inc = 50;
			p_out_item->item_id = 1301031;
			
		}
		else if(out_header->apprentice_cnt >= 20){
			merit_inc = 50;
			p_out_item->item_id = 1301032;
		}

		if(merit_inc != 0){
			ret = this->user_battle_prentice.update_merit_inc(RECVBUF_USERID, merit_inc);
			//this->user_battle_articles.add_count(RECVBUF_USERID, p_out_item->item_id, 1, 9999);
			user_add_attire_in  add_item = {0};
			add_item.attiretype = 32;
			add_item.attireid = p_out_item->item_id;
			add_item.count = 1;
			add_item.maxcount = 999999;
			ret = this->user_add_attire(RECVBUF_USERID, &add_item);

			p_out_item->item_cnt = 1;
			++out_header->count;
			++p_out_item;
		}
		
		//出师成就卡
		uint32_t achieve_card = 0;
		switch(out_header->apprentice_cnt){
			case 1:
				{
				  achieve_card = 1553142;
				  break;
				}
			case 2:
				{
				  achieve_card = 1553143;
				  break;
				}
			case 3:
				{
				  achieve_card = 1553144;
				  break;
				}
			case 10:
				{
				  achieve_card = 1553145;
				  break;
				}
			case 20:
				{
				  achieve_card = 1553146;
				  break;
				}
		}
		if(achieve_card != 0){
			++out_header->count;
			p_out_item->item_cnt = 1;
			p_out_item->item_id = achieve_card;
			++p_out_item;
			//this->user_battle_articles.add_count(RECVBUF_USERID, achieve_card, (uint32_t)1, 99);
			user_add_attire_in  add_item = {0};
			add_item.attiretype = 32;
			add_item.attireid =  achieve_card;
			add_item.count = 1;
			add_item.maxcount = 999999;
			ret = this->user_add_attire(RECVBUF_USERID, &add_item);
		}
	 }
	 else{
		 out_header->state = 1;
	 }

	 ret = SUCC;
	STD_RETURN_WITH_BUF(ret, buf, (char*)p_out_item - buf);
}
/*
 * 出师，徒弟
 */
int Croute_func::user_battle_prentice_finish_master(DEAL_FUN_ARG)
{
	char buf[120] = { 0 };
    user_battle_prentice_finish_master_out_header  *out_header = (user_battle_prentice_finish_master_out_header*)buf;
    user_battle_prentice_finish_master_out_item *p_out_item = (user_battle_prentice_finish_master_out_item*)(buf +
			sizeof(user_battle_prentice_finish_master_out_header));
	uint32_t master = 0;
	this->user_battle_prentice.get_int_value(RECVBUF_USERID, "master", &master);
	if(master != 0){
		user_battle_add_mp_msg_in msg = {
			(uint32_t)time(0), master, RECVBUF_USERID, 103, 0, 5 
		};
		ret = this->user_battle_master_prentice_msg.update_record(RECVBUF_USERID, &msg);
	}
	ret = this->user_battle_prentice.update_two_col(RECVBUF_USERID, "master", "initial_level", 0, 0);
	//ret = this->user_battle_prentice.set_int_value(RECVBUF_USERID, "master", 0);
	ret = this->user_battle_prentice.update_merit_inc(RECVBUF_USERID, 5);
	uint32_t cnt = 0;
	ret = this->user_battle_prentice.get_int_value(RECVBUF_USERID, "succ_prentice", &cnt);
	if(ret == SUCC && cnt == 0){
		ret = this->user_battle_prentice.set_int_value(RECVBUF_USERID, "succ_prentice", 1);
		//巧虎种子
		const uint32_t itemid = 1353279;
		user_add_attire_in st_attire_add;
        st_attire_add.attireid = itemid ;
        st_attire_add.attiretype = 0;//
        st_attire_add.count = 1;
        st_attire_add.maxcount = 999999999;
        this->user_add_attire(RECVBUF_USERID, &st_attire_add);
		++out_header->count;
		p_out_item->item_cnt = 1;
		p_out_item->item_id = itemid;
		++p_out_item;
	}
	ret = SUCC;
	STD_RETURN_WITH_BUF(ret, buf, (char*)p_out_item - buf);
}
/*
 * 拉取师徒消息
 */
int Croute_func::user_battle_get_master_prentice_info(DEAL_FUN_ARG)
{
    user_battle_get_master_prentice_info_out_header  out_header = {0};
    user_battle_get_master_prentice_info_out_item *p_out_item = 0;
    ret = this->user_battle_master_prentice_msg.get_all(RECVBUF_USERID, &p_out_item, &out_header.count);
	ret = SUCC;
    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/*
 * 拉取玩家战斗等级
 */
int Croute_func::user_battle_get_level(DEAL_FUN_ARG)
{
    user_battle_get_level_out out={0};
    ret=this->user_battle_character_attribute.get_level(RECVBUF_USERID, &out.level);
	ret = SUCC;
    STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * 战斗胜利,收徒
 */
int Croute_func::user_battle_add_prentice(DEAL_FUN_ARG)
{
    user_battle_add_prentice_in *p_in = PRI_IN_POS;
	user_battle_add_prentice_out out = { 0 };
	uint32_t prentice_cnt = 0;
	ret = this->user_battle_master.get_prentice_count(RECVBUF_USERID, &prentice_cnt);
	if(prentice_cnt >= 3){
		out.state = 1;		
	}
	else{
		DEBUG_LOG("!!!!!!!!!prentice: %u, master: %u, level: %u",p_in->prentice, p_in->master, p_in->prentice_level);
		ret = this->user_battle_master.insert(RECVBUF_USERID, p_in->prentice, p_in->prentice_level, 0);
		user_battle_add_mp_msg_in msg = {
			(uint32_t)time(0), RECVBUF_USERID, p_in->prentice, 100, 0, 0 
		};
		ret = this->user_battle_master_prentice_msg.update_record(RECVBUF_USERID, &msg);
	}
	ret = this->user_battle_flip_card_info.remove(RECVBUF_USERID);

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 收徒，置新师傅
 */
int Croute_func::user_battle_set_new_master(DEAL_FUN_ARG)
{
	user_battle_set_new_master_in *p_in = PRI_IN_POS;
	ret = this->user_battle_prentice.update_two_col(RECVBUF_USERID, "master", "initial_level",
		   	p_in->new_master, p_in->ini_level);
	if(ret == USER_ID_NOFIND_ERR){
		ret = this->user_battle_prentice.insert(RECVBUF_USERID, p_in->new_master, 0);	
	}

    STD_RETURN(ret);
}
/*
 * 增加师徒消息
 */
int Croute_func::user_battle_add_mp_msg(DEAL_FUN_ARG)
{
    user_battle_add_mp_msg_in *p_in = PRI_IN_POS;
	p_in->datetime = (uint32_t)time(0);
	ret = this->user_battle_master_prentice_msg.update_record(RECVBUF_USERID, p_in);

    STD_RETURN(ret);
}
/*
 * 时间囊
 */
int Croute_func::user_send_time_mail(DEAL_FUN_ARG)
{

   user_send_time_mail_in_header *p_in = PRI_IN_POS;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER_EX(p_in->msglen, THROUGH_TIME_MAIL_LEN);

	uint32_t *p_mail_list = 0;
	uint32_t mail_cnt = 0;
	uint32_t today = get_date(time(0));
	ret = this->user_through_time_mail.get_mails_sendtime(RECVBUF_USERID, &p_mail_list, &mail_cnt);
	uint32_t k = 0;
	for(; k < mail_cnt; ++k){
		uint32_t date = get_date(*(p_mail_list + k));
		if(date == today) break;	
	}
	if(k < mail_cnt){
		return THROUGH_TIME_SPACE_MAIL_ERR;
	}

	const uint32_t time_bag = 1351107;
	ret = this->user_temp_item.sub_count(RECVBUF_USERID, time_bag, 1);
	if(ret != SUCC){
		return ret;
	}

	ret = this->user_through_time_mail.insert(RECVBUF_USERID, (roominfo_thr_tim_sp_t*)p_in);

	STD_RETURN(ret);

}
/*
 * 时间囊
 */
int Croute_func::user_get_time_mail(DEAL_FUN_ARG)
{
 
	char buf[1024] = { 0 };
    user_get_time_mail_out *out= (user_get_time_mail_out*)buf;
	ret = this->user_through_time_mail.get_random_mail(RECVBUF_USERID, out);
	if(ret == USER_ID_NOFIND_ERR){
		return NONE_TIME_SPACE_MAIL_ERR;
	}
	STD_RETURN_WITH_BUF(ret, buf, sizeof(user_get_time_mail_out)+out->msg_len );
}
/*
 * 时间囊
 */
int Croute_func::user_send_time_item(DEAL_FUN_ARG)
{

    user_send_time_item_in *p_in=PRI_IN_POS;
    user_send_time_item_out out={0};
	const uint32_t time_bag = 1351107;
	uint32_t count_1 = 0, count_2 = 0;
	ret = this->user_temp_item.get_count(RECVBUF_USERID, time_bag, count_1);
	ret = this->user_temp_item.get_count(RECVBUF_USERID, p_in->itemid, count_2);
	if(count_1 == 0 || count_2 == 0){
		return ATTIRE_COUNT_NO_ENOUGH_ERR;
	}
	ret = this->user_temp_item.sub_count(RECVBUF_USERID, time_bag, 1);
	ret = this->user_temp_item.sub_count(RECVBUF_USERID, p_in->itemid, 1);

	ret = this->user_through_time_item.insert(RECVBUF_USERID, p_in->itemid);

    STD_RETURN_WITH_STRUCT(ret,out);

}
/*
 * 时间囊
 */
int Croute_func::user_get_time_item(DEAL_FUN_ARG)
{

	user_get_time_item_out out={0};
	roominfo_thr_tim_item_t *items = 0;
	std::map<uint32_t, uint32_t> t_map;	
	for(uint32_t k = 0; k < 11; ++k){
		if(k < 6){
			t_map[1351110+k] = 13881 + k;
		}
		else if( k < 9){
			t_map[1351110+k] = 160926 + k - 6;
		}
		else{
			t_map[1351110+k] = 160930 + k - 9;
		}
	}
	uint32_t count = 0;
    ret = this->user_through_time_item.get_items(RECVBUF_USERID, &items, &count);
	if(ret == USER_ID_NOFIND_ERR){
		return NONE_TIME_SPACE_ITEM_ERR;
	}
	if(count != 0){
		uint32_t index = rand()%count;
		out.itemid = t_map[(items + index)->itemid];
		ret = this->user_through_time_item.remove(RECVBUF_USERID, (items+index)->time);
	}
	if(count - 1 != 0){
		out.flag = 1;
	}
	if(items != 0){
		free(items);
	}

    STD_RETURN_WITH_STRUCT(ret,out);

}
/*
 * 时间囊
 */
int Croute_func::user_get_non_dig_time_article(DEAL_FUN_ARG)
{

    user_get_non_dig_time_article_out out={ 0 };
    ret=this->user_through_time_mail.get_non_dig_cnt(RECVBUF_USERID, &out.mail_cnt);
    ret=this->user_through_time_item.get_non_dig_icnt(RECVBUF_USERID, &out.item_cnt);
	ret = SUCC;
    STD_RETURN_WITH_STRUCT(ret,out);

}
/*
 * 客服查询玩家所拥有摩摩怪的数量和等级
 */
int Croute_func::user_battle_get_ini_skill_level_ex(DEAL_FUN_ARG)
{
    user_battle_get_ini_skill_level_ex_out_header  out_header;
    user_battle_get_ini_skill_level_ex_out_item *p_out_item;
    ret=this->user_battle_skill_equip.get_want_skill(RECVBUF_USERID, &p_out_item, &out_header.count, 0);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 客服查询天使园战斗等级
 */
int Croute_func::user_get_angel_battle_level_ex(DEAL_FUN_ARG)
{
    user_get_angel_battle_level_ex_out out={0};

	uint32_t battle_exp = 0;
	ret = this->user_angel_battle.get_exp(RECVBUF_USERID, &battle_exp);
	ret = this->user_angel_battle.cal_level(battle_exp, &out.level);

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 竞技场面板
 */
int Croute_func::user_battle_get_pvp_info(DEAL_FUN_ARG)
{
	user_battle_get_pvp_info_out out={};
	memset(&out, 0, sizeof(user_battle_get_pvp_info_out));
    ret = this->user_battle_challenge_note.get_int_value(RECVBUF_USERID, "pvp_cnt", &out.day_pvp_cnt);

	ret = this->user_battle_accident.get_double_col(RECVBUF_USERID, "pvp_win", "pvp_rev", &out.win_pvp_cnt, &out.is_illume);
	ret = SUCC;
    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 *竞技场领取成就卡
 */
int Croute_func::user_battle_recveive_pvp_card(DEAL_FUN_ARG)
{
	char buf[1024] = { 0 };
    user_battle_recveive_pvp_card_in *p_in=PRI_IN_POS;
	user_battle_recveive_pvp_card_out_header *out_header = (user_battle_recveive_pvp_card_out_header*)buf;	
	user_battle_recveive_pvp_card_out_item *p_out_item = (user_battle_recveive_pvp_card_out_item *)(buf + sizeof(
				user_battle_recveive_pvp_card_out_header)); 
	int pos = -1;
	if(p_in->recv_index == 10){
		pos = 0;
	}
	else if(p_in->recv_index == 50){
		pos = 1; 
	}
	else if(p_in->recv_index == 100){
		pos = 2;
	}
	else if(p_in->recv_index == 200){
		pos = 3;
	}
	else if(p_in->recv_index == 500){
		pos = 4;
	}	
	else if(p_in->recv_index == 1000){
		pos = 5;
	}
	uint32_t flag = 0, pvp_win = 0;
	ret = this->user_battle_accident.get_double_col(RECVBUF_USERID, "pvp_rev", "pvp_win", &flag, &pvp_win);
	if(pos != -1 && pvp_win >= p_in->recv_index){
		uint32_t bit = flag & (1<< pos);
		if(bit == 0){
			uint32_t achieve_card[] = {1553151, 1553152, 1553153, 1553154, 1553155, 1553156}; 	
			//ret = this->user_battle_articles.add_count(RECVBUF_USERID, achieve_card[pos], 1, 1);
			user_add_attire_in  add_item = {0};
			add_item.attiretype = 32;
			add_item.attireid =  achieve_card[pos];
			add_item.count = 1;
			add_item.maxcount = 999999;
			ret = this->user_add_attire(RECVBUF_USERID, &add_item);

			if(ret == SUCC){
				ret = this->user_battle_accident.set_int_value(RECVBUF_USERID,"pvp_rev", flag | (1<<pos));	
				p_out_item ->itemid  = achieve_card[pos];
				p_out_item ->cnt  = 1;
				out_header->state = 1;
				out_header->count = 1;
				++p_out_item;
			}		
		}
		
	}
	ret = SUCC;

	STD_RETURN_WITH_BUF(ret, buf, (char*)p_out_item - buf);
}
//2011暑期战斗部分结束

int Croute_func::user_eat_moon_cake(DEAL_FUN_ARG)
{
	user_eat_moon_cake_in *p_in = PRI_IN_POS;
	user_eat_moon_cake_out out = {p_in->eat_cnt, 0, 0};
	uint32_t mooncake_type = 0;
    ret = this->user_ex.get_int_value(RECVBUF_USERID, "mooncake_type", &mooncake_type);
	if (mooncake_type == 0) {
		mooncake_type = rand() % 3 + 1;
		ret = this->user_ex.set_int_value(RECVBUF_USERID, "mooncake_type", mooncake_type);
	}
	
	uint32_t itemid = p_in->item_id;
	uint32_t limit_cnt = (itemid == 190886) ? 30 : 100;
	if (itemid != 190886) {
		itemid = 190883 + mooncake_type - 1;
	}
	out.item_id = itemid;
	if (p_in->eat_cnt < limit_cnt) {
		user_add_attire_in  add_item = {0};
		add_item.attiretype = 0;
		add_item.attireid = itemid;
		add_item.count = 1;
		add_item.maxcount = 99999;
		ret = this->user_add_attire(RECVBUF_USERID, &add_item);
		out.left_cnt += 1;
		out.count = add_item.count;

		if (ret == SUCC) {
			change_log_item c_item;
			c_item.userid = RECVBUF_USERID;
			c_item.change_type = 10004;
			c_item.logtime = time(NULL);
			c_item.change_value = add_item.count;
			c_item.change_v1 = add_item.attireid;
			c_item.change_v2 = 0;
			this->send_log.send(&c_item );
		}
	}
	
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::user_get_moon_cake(DEAL_FUN_ARG)
{
	user_get_moon_cake_out out = {0};
	ret = this->user_ex.get_int_value(RECVBUF_USERID, "mooncake_type", &(out.mooncake_type));
	if (ret != SUCC) {
		return ret;
	}
	if (out.mooncake_type == 0) {
		STD_RETURN_WITH_STRUCT(ret,out);
	}
	out.item_id = 190883 + out.mooncake_type - 1;
	ret = this->user_attire.get_nousedcount(RECVBUF_USERID, out.item_id, &(out.count));
	ret = SUCC;
	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::user_get_exp_and_vip_level(DEAL_FUN_ARG)
{
	user_get_exp_and_vip_level_out out={0};
	ret = this->user.get_int_value(RECVBUF_USERID, "exp", &(out.exp));
	if (ret != SUCC) {
		ret = this->user_ex.get_int_value(RECVBUF_USERID, "vip_pet_level", &(out.exp));
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::get_user_task_ex_idlist(DEAL_FUN_ARG)
{
	get_user_task_ex_idlist_out_header out_header = {0};
	get_user_task_ex_idlist_out_item *p_out_item = NULL;
	ret = this->user_task_ex.get_task_id_list(RECVBUF_USERID, &p_out_item, &(out_header.count));
	STD_RETURN_WITH_STRUCT_LIST(ret, out_header, p_out_item, out_header.count);
}

/*
 * 玩家进入猪倌
 */
int Croute_func::user_get_piglet_house(DEAL_FUN_ARG)
{
	enum{
		FRESH_MAN = 1,//新手	
	};
	char buf[PROTO_MAX_LEN];
	memset(buf, 0, PROTO_MAX_LEN);

	user_get_piglet_house_in *p_in = PRI_IN_POS	; 
    user_get_piglet_house_out_header* out_header = (user_get_piglet_house_out_header*)buf;
    user_get_piglet_house_out_item *p_out_item = (user_get_piglet_house_out_item*)(buf + 
			sizeof(user_get_piglet_house_out_header));
	//拉取猪倌信息
	uint32_t logintime = 0;
	uint32_t now = time(0);
	int ret = this->user_piglet_house.get_piglet_house(RECVBUF_USERID, out_header, &logintime); 
	DEBUG_LOG("bath_time: %u, back_ground: %u", out_header->bath_time, out_header->background);
	if(ret != SUCC && RECVBUF_USERID == p_in->uid){
		ret = this->user_piglet_house.insert(RECVBUF_USERID, now);	
		out_header->state = FRESH_MAN;
		ret = this->user_piglet.birth(RECVBUF_USERID, 1593010, (char*)"福仔", (char*)" ", (char*)" ", 5, 
				0, 150, 0, 0, (uint32_t)time(0), 3, 0x02, 30*24*3600, 0, 1, 50);
		ret = this->user_piglet.birth(RECVBUF_USERID, 1593013, (char*)"憨憨", (char*)" ", (char*)" ", 6, 
				1, 350, 0, 0, (uint32_t)time(0) - 2*24*3600, 2, 0x02, 32*24*3600, 0, 1, 80, 1);
		this->user_piglet_handbook.add(RECVBUF_USERID, 5);
		this->user_piglet_handbook.add(RECVBUF_USERID, 6);
		ret = this->user_piglet_attire.add_count(RECVBUF_USERID, 1613100, 10, 99999);
		ret = this->user_piglet_attire.add_count(RECVBUF_USERID, 1593028, 1, 99999);
		ret = this->user.update_xiaomee_inc(RECVBUF_USERID, 2000);

		ret = this->user_piglet_house.get_piglet_house(RECVBUF_USERID, out_header, &logintime);
		
	}
	else if( ret != SUCC && RECVBUF_USERID != p_in->uid){
		  STD_RETURN(USER_ID_NOFIND_ERR);
	}
	uint32_t back_cnt = 0;
	ret = this->user_piglet_attire.get_count(RECVBUF_USERID, 1613116, back_cnt);
	if(ret != SUCC){
		ret = this->user_piglet_attire.add_count(RECVBUF_USERID, 1613116, 1, 1);
		ret = this->user_piglet_attire.put_on(RECVBUF_USERID, 1613116);
	}
	
	 //清理昨日记录
	if(get_date(now) != get_date(logintime)){
		ret = this->user_piglet.clear(RECVBUF_USERID);	
		ret = this->user_piglet_house.clear(RECVBUF_USERID, now);
		ret = this->user_piglet_task.clear_task(RECVBUF_USERID);
	}
	
	//buff 道具
	buff_tool_t *p_tool_item = 0;
	uint32_t tool_cnt = 0;
	ret = this->user_piglet_effect_tool.get_buff_tools(RECVBUF_USERID, &tool_cnt, &p_tool_item);
	//恶魔卡道具更改状态
	for(uint32_t k = 0; k < tool_cnt; ++k){
		if((p_tool_item +k)->itemid == 1613129 && (p_tool_item + k)->state == 1){
			this->user_piglet_effect_tool.update_state(RECVBUF_USERID, (p_tool_item +k)->itemid, 1);
			break;
		}
	}
	if(ret != SUCC){
		if(p_tool_item != 0){
			free(p_tool_item);
			p_tool_item = 0;
		}
	}
	
	//拉取猪倌中所有猪仔
	std::vector<birth_info_t> vec;
	std::set<uint32_t> sets;
	uint32_t feed_type = 0;
	ret = this->user_piglet_house.get_int_value(RECVBUF_USERID, "feed_type", &feed_type);
	ret = this->user_piglet.get_piglets(RECVBUF_USERID, p_out_item, &out_header->count, vec,
		   	sets, feed_type, tool_cnt, p_tool_item);

	if(p_tool_item != 0){
		free(p_tool_item);
	}		

	if(sets.size() != 0){
		//小小猪任务
		{
			ret = this->user_piglet_task.change_task_state(RECVBUF_USERID, 9);
		}
	}
	//产仔公告
	user_get_all_msg_out_item msg; 
	for(uint32_t k = 0; k < vec.size(); ++k){
		memset(&msg, 0, sizeof(user_get_all_msg_out_item));
		msg.datetime = vec[k].birth_time;
		msg.type = 3;
		msg.other_id = RECVBUF_USERID;
		msg.itemid = 0;
		msg.value = vec[k].cnt;
		this->user_piglet.get_nick(RECVBUF_USERID, vec[k].index, msg.nick);
		ret = this->user_piglet_msg.update_records(RECVBUF_USERID, &msg);
	}
		
	//产出的猪仔加入图鉴		
	user_piglet_get_handbook_out_item *p_temp_item = 0;
	uint32_t temp_count = 0;
	ret = this->user_piglet_handbook.get_all(RECVBUF_USERID, &p_temp_item, &temp_count);
	for(std::set<uint32_t>::iterator it = sets.begin(); it != sets.end(); ++it)
	{
		user_piglet_get_handbook_out_item *iter = std::find(p_temp_item, p_temp_item + temp_count, *it); 
		if(iter == p_temp_item + temp_count){
			this->user_piglet_handbook.add(RECVBUF_USERID, *it);
		}
	}
	if(p_temp_item != 0){
		free( p_temp_item);
	}

	uint32_t length = sizeof(user_get_piglet_house_out_header) + 
		sizeof(user_get_piglet_house_out_item)*out_header->count;
	
	STD_RETURN_WITH_BUF(SUCC, buf, length);
}
/*
 * 拉取单只猪仔信息
 */
int Croute_func::user_get_single_piglet_info(DEAL_FUN_ARG)
{
    user_get_single_piglet_info_in *p_in = PRI_IN_POS;
    user_get_single_piglet_info_out out={ 0 };
	uint32_t feed_type = 0, level = 0;
	ret = this->user_piglet_house.get_double_col(RECVBUF_USERID, "feed_type", "level", &feed_type, &level);

	const uint32_t angel_card = 1613128; 
	uint32_t effect_time = 0, lasttime = 0;
	ret = this->user_piglet_effect_tool.select(RECVBUF_USERID, angel_card, &effect_time, &lasttime);

    ret = this->user_piglet.get_one_piglet(RECVBUF_USERID, p_in->index, feed_type, &out, effect_time, lasttime);

	//返回可再出生小猪上限	
	uint32_t all_piglet_count = 0; 
	ret = this->user_piglet.get_all_counts(RECVBUF_USERID, &all_piglet_count);
	uint32_t limit = this->user_piglet.get_level_piglet_limit(RECVBUF_USERID, level);
	if(all_piglet_count >= limit+6){
		out.inc_limit = 0;
	}	
	else{
		out.inc_limit = (limit + 6) - all_piglet_count; 
	}

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 喂食猪仔
 */
int Croute_func::user_get_piglet_hungry(DEAL_FUN_ARG)
{
	user_get_piglet_hungry_in* p_in = PRI_IN_POS;
    user_get_piglet_hungry_out out={ 0 };
	
	//饲料id
	const uint32_t common_id = 1613100;//上等玉米,普通
	const uint32_t advanced_id = 1613101;//麦片，高级
	const uint32_t nutrition = 1613102;//营养液，普通
	const uint32_t protein = 1613104;//高级蛋白，高级
	if(p_in->itemid != common_id && p_in->itemid != advanced_id && p_in->itemid != nutrition 
			&& p_in->itemid != protein){
		return PIGLET_FEDD_ITEM_ERR;
	}
	uint32_t feed_type = 0;
	ret = this->user_piglet_house.get_int_value(RECVBUF_USERID, "feed_type", &feed_type);
	uint32_t hungry_degree = 0;
	ret = this->user_piglet.get_piglet_sum_hungry(RECVBUF_USERID, &hungry_degree, feed_type);
	uint32_t charm_inc = 0, strong_inc = 0;
	uint32_t survive_cnt = 0;
	ret = this->user_piglet.get_piglet_survive(RECVBUF_USERID, &survive_cnt);
		
	if((hungry_degree !=0 && p_in->count*100 >= hungry_degree && p_in->itemid != nutrition
			   	&& p_in->itemid != protein) || ((p_in->itemid == nutrition || 
				p_in->itemid == protein) && survive_cnt != 0 && survive_cnt <=  p_in->count)){

		uint32_t feed_cnt = 0;
		ret = this->user_piglet_house.get_int_value(RECVBUF_USERID, "feed_cnt", &feed_cnt);
		uint32_t nor_cnt = feed_cnt >> 16;
		uint32_t adv_cnt = feed_cnt & 0xFFFF;

		//不同饲料，增加的属性和方式不同
		if(nor_cnt < 4 ){
			out.weight_inc = 1*10;
		}
		if(p_in->itemid == advanced_id){
			out.weight_inc = out.weight_inc + 10*10;				
		}
			
		if(p_in->itemid == protein){
			out.weight_inc = out.weight_inc + 20*10;
		}
		//营养液每天5次限制
		if(p_in->itemid == nutrition){
			if(adv_cnt < 5){
				out.weight_inc = out.weight_inc + 3*10;
				adv_cnt = adv_cnt + 1;
			}
			else{
				out.state = 3;//达到每日营养液限制
			}
		}
		if(out.state != 3){
			//每天喂养次数加1
			nor_cnt = nor_cnt + 1;
			if(p_in->itemid != nutrition && p_in->itemid != protein){
				const uint32_t angel_card = 1613128; 
				uint32_t effect_time = 0, lasttime = 0;

				ret = this->user_piglet_effect_tool.select(RECVBUF_USERID, angel_card, &effect_time, &lasttime);

				uint32_t now = time(0);
				this->user_piglet.change_attribute_value(RECVBUF_USERID, out.weight_inc, charm_inc, 
						strong_inc, feed_type, effect_time, lasttime, now);
				if(ret == SUCC){
					if(effect_time == 0 || lasttime == 0){

						 this->user_piglet_effect_tool.drop(RECVBUF_USERID, angel_card);
					}
					else{
						if(now >= (effect_time + lasttime)){
							 this->user_piglet_effect_tool.drop(RECVBUF_USERID, angel_card);
						}
						else{
							 lasttime = effect_time + lasttime - now; 
							 effect_time = now;
							 this->user_piglet_effect_tool.update_two_time(RECVBUF_USERID, effect_time, lasttime, angel_card);
						}
					}
				}//ret==SUCC
			}
			else{
				this->user_piglet.add_nutrition_value(RECVBUF_USERID, out.weight_inc, charm_inc, strong_inc);
			}
			out.weight_inc = out.weight_inc / 10;
			out.feed_cnt = (nor_cnt << 16) | adv_cnt;
			this->user_piglet_house.set_int_value(RECVBUF_USERID, "feed_cnt", out.feed_cnt);
			
			out.consume = hungry_degree / 100 ;
			if(hungry_degree % 100 != 0){
				out.consume += 1;
			}
			if( p_in->itemid == nutrition || p_in->itemid == protein){
				out.consume = survive_cnt;
			}
			//取消恶魔卡已发生状态
			{
				const uint32_t devil_card = 1613129; 
				ret = this->user_piglet_effect_tool.update_state(RECVBUF_USERID,  devil_card, 0);
			}
			//喂食公告
			{
				user_get_all_msg_out_item msg; 
				memset(&msg, 0, sizeof(user_get_all_msg_out_item));
				msg.datetime = (uint32_t)time(0);
				msg.type = 4;
				msg.other_id = p_in->feed_user_id;
				msg.itemid = p_in->itemid;
				msg.value = out.consume;
				ret = this->user_piglet_msg.update_records(RECVBUF_USERID, &msg);
			}
		}//out.state = 3
	}
	else if( hungry_degree == 0  && p_in->itemid != nutrition && p_in->itemid != protein){
		out.state = 2;//饥饿度为0
	}
	else if((p_in->count*100 < hungry_degree && p_in->itemid != nutrition && p_in->itemid != protein) ||
			((p_in->itemid == nutrition || p_in->itemid == protein) && survive_cnt >  p_in->count)){
		out.state = 1;//饲料不够
	}
	else{
		out.state = 4;//其他非正常状态
	}
	DEBUG_LOG("==== userid: %u, out.state: %u ====",RECVBUF_USERID, out.state);

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 *饲养购买回的小猪仔
 */
int Croute_func::user_feed_fancy_piglet(DEAL_FUN_ARG)
{
    user_feed_fancy_piglet_in *p_in=PRI_IN_POS;
    user_feed_fancy_piglet_out out = { 0 };
   	uint32_t count = 0; 
	ret = this->user_piglet.get_piglet_counts(RECVBUF_USERID, &count);
	uint32_t level = 0;
	ret = this->user_piglet_house.get_int_value(RECVBUF_USERID, "level", &level);
	uint32_t limit = user_piglet.get_level_piglet_limit(RECVBUF_USERID, level);

	//猪仔总数包含未出生
	uint32_t all_count = 0;
	ret = this->user_piglet.get_all_counts(RECVBUF_USERID, &all_count);
	if(count < limit && all_count < limit + 6){
		uint32_t count = 0;
		ret = this->user_piglet_attire.get_noused_count(RECVBUF_USERID, p_in->piglet_id, count);
		if(count > 0){
			uint32_t max_index = 0;
			ret = this->user_piglet.get_max_index(RECVBUF_USERID, &max_index);	
			char nick[4] = { 0 };
			sprintf(nick, "%03u", (max_index+1) % 1000);
			memcpy(out.self_nick, p_in->self_nick, NICK_LEN);
			strcat(out.self_nick, nick);

			ret = this->user_piglet.birth(RECVBUF_USERID, p_in->piglet_id, out.self_nick, (char*)" ", (char*)" ", p_in->breed, 
					p_in->sex, p_in->weight, p_in->charm, p_in->strong, (uint32_t)time(0), p_in->growth, 0x02, 
					p_in->lifetime, 0, 1, p_in->price);
			//肥肥馆收集荣誉
			{
				uint32_t res = 0;
				this->user_piglet_honor.add_honor(RECVBUF_USERID, p_in->breed, &res);	
			}
			uint32_t feed_type = 0;
			ret = this->user_piglet_house.get_int_value(RECVBUF_USERID, "feed_type", &feed_type);
			char* p_offset = (char*)(&out);
			ret = this->user_piglet.get_newest_piglet(RECVBUF_USERID, feed_type, (user_get_piglet_house_out_item*)(p_offset + 4)); 

			DEBUG_LOG("[breed: %u, condition: %u, degree: %u, index: %u, piglet_id: %u, sex: %u, state: %u, transform: %u]", 
					out.breed, out.condition, out.hungry_degree, out.index, out.piglet_id, out.sex, out.state, out.transform);

			out.condition = 1;
			//加入图鉴
			this->user_piglet_handbook.add(RECVBUF_USERID, p_in->breed);
			ret = this->user_piglet_attire.sub_count(RECVBUF_USERID, p_in->piglet_id, 1);
		}
	}
	else{
		out.condition = 0;
	}
	ret = SUCC;
		
    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 *训练猪仔 
 */
int Croute_func::user_train_piglet(DEAL_FUN_ARG)
{
    user_train_piglet_in *p_in=PRI_IN_POS;
    user_train_piglet_out out={0};
	uint32_t train_point = 0;
	ret = this->user_piglet.train_piglet(RECVBUF_USERID, p_in->index, p_in->type, &train_point, &out);
	if(out.state == 1){
		uint32_t exp_train_inc = 0;
		if(train_point >= 0 && train_point < 21){
			exp_train_inc = 4;
		}
		else if(train_point >= 21 && train_point < 41){
			exp_train_inc = 8;
		}
		else{
			exp_train_inc = 12;
		}
		ret = this->user_piglet_house.get_int_value(RECVBUF_USERID, "exp", &out.exp); 
		ret = this->user_piglet_house.set_int_value(RECVBUF_USERID, "exp", out.exp + exp_train_inc);
		out.exp = exp_train_inc;

		//训练任务
		if(p_in->type == 1){
			ret = this->user_piglet_task.change_task_state(RECVBUF_USERID, 5);
		}
		else{
			ret = this->user_piglet_task.change_task_state(RECVBUF_USERID, 6);
		}
	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 *逗乐乐猪仔 
 */
int Croute_func::user_amuse_piglet(DEAL_FUN_ARG)
{
    user_amuse_piglet_in *p_in=PRI_IN_POS;
    user_amuse_piglet_out out={0};
	out.index = p_in->index;
	uint32_t amuse_cnt = 0, breed = 0;
    ret = this->user_piglet.select_two_cols(RECVBUF_USERID, p_in->index, "amuse_cnt", "breed", &amuse_cnt, &breed);
	int32_t msg_item = 0;
	if(amuse_cnt < 3){
		char *col = (char*)"";
		if(breed >= 0 && breed < 10000){
			col = (char*)"weight";
			msg_item = -2;
		}
		else if(breed >= 10000 && breed < 20000){
			col = (char*)"weight";
			msg_item = -3;
		}
		else{
			col = (char*)"weight";
			msg_item = -4;
		}

		uint32_t random = rand()%3;	
		uint32_t v_inc = 0;
		if(random == 0){
			v_inc = 1 * 10;
		}
		else if(random == 1){
			v_inc = 2 * 10;
		}
		else{
			v_inc = 3 * 10;
		}
		
		out.weight = v_inc/10;

		uint32_t value = 0;
		ret = this->user_piglet.select(RECVBUF_USERID, p_in->index, col, &value);
		uint32_t real_val = value;
		if(value  < 150000){
			if(value + v_inc > 150000){
				real_val = 150000;
			}
			else{
				real_val = value + v_inc;
			}
		}

		ret = this->user_piglet.update_two_cols(RECVBUF_USERID, p_in->index, col, "amuse_cnt", real_val, amuse_cnt+1);
		if(ret == SUCC){
			out.state = 1;
			//逗乐任务
			{
				//引导任务
				ret = this->user_piglet_task.change_task_state(RECVBUF_USERID, 3);
				//每日任务
				this->user_piglet_task.change_task_state(RECVBUF_USERID, 13);
			}
			//逗乐公告
			{
				user_get_all_msg_out_item msg;
				memset(&msg, 0, sizeof(user_get_all_msg_out_item));
				msg.datetime = (uint32_t)time(0);
				msg.type = 1;
				msg.other_id = RECVBUF_USERID;
				msg.itemid = msg_item; 
				//if( msg_item == -2){
				msg.value = v_inc/10;
				//}
				this->user_piglet.get_nick(RECVBUF_USERID, p_in->index, msg.nick);
				ret = this->user_piglet_msg.update_records(RECVBUF_USERID, &msg);
			}
		}
	}
    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 玩家给猪仔洗澡
 */
int Croute_func::user_bath_piglet(DEAL_FUN_ARG)
{
	user_bath_piglet_in *p_in = PRI_IN_POS;
    user_bath_piglet_out out={ 0 };
	uint32_t bath_time = 0;
	ret = this->user_piglet_house.get_int_value(RECVBUF_USERID, "bath_time", &bath_time);
	uint32_t now = time(0);
	if(now >= bath_time+ 6*3600){
		out.state = 1;
		ret = this->user_piglet_house.set_int_value(RECVBUF_USERID, "bath_time", now);
		//洗澡任务
		//{
			//ret = this->user_piglet_task.change_task_state(RECVBUF_USERID, 2, 1);
		//}
		//洗澡公告
		{
			user_get_all_msg_out_item msg;
			memset(&msg, 0, sizeof(user_get_all_msg_out_item));
			msg.datetime = (uint32_t)time(0);
			msg.type = 2;
			msg.other_id = p_in->user_id;
			msg.itemid = 0;
			msg.value = 0;
			ret = this->user_piglet_msg.update_records(RECVBUF_USERID, &msg);
		}
		out.left_time = 6*3600;
	}
	else{
		out.left_time = (6*3600 - (now - bath_time));
	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 更改猪仔名字
 */
int Croute_func::user_change_piglet_nick(DEAL_FUN_ARG)
{
    user_change_piglet_nick_out out ={ 0 };
    user_change_piglet_nick_in *p_in=PRI_IN_POS;
	const uint32_t rename_card = 1613114;
	
	uint32_t count = 0;
	ret = this->user_piglet_attire.get_noused_count(RECVBUF_USERID, rename_card, count);	
	if(count > 0){
		ret = this->user_piglet.change_piglet_nick(RECVBUF_USERID, p_in->index, p_in->nick);
		if(ret == SUCC){
			ret = this->user_piglet_attire.sub_count(RECVBUF_USERID, rename_card, 1);
			out.state = 1;
			//我的猪仔，我做主任务
			{
				ret = this->user_piglet_task.change_task_state(RECVBUF_USERID, 4);
			}
		}//if
	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}

/*
 *设置猪仔排列队形 
 */
int Croute_func::user_change_piglet_formation(DEAL_FUN_ARG)
{
    user_change_piglet_formation_out out = { 0 };
    user_change_piglet_formation_in *p_in=PRI_IN_POS;
	ret = this->user_piglet_house.change_formation(RECVBUF_USERID, p_in);
	if(ret == SUCC){
		out.state = 1;
	}
    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 *校验公猪仔是否可以配对 
 */
int Croute_func::user_check_mail_piglet(DEAL_FUN_ARG)
{
    user_check_mail_piglet_in *p_in=PRI_IN_POS;
    user_check_mail_piglet_out out = { 0 };
	ret = this->user_piglet.check_mail_piglet_make_pair(RECVBUF_USERID, p_in->index, &out.state);
	if(out.state == 1){
		ret = this->user.update_xiaomee_inc(RECVBUF_USERID, p_in->money);
	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 母猪仔怀孕
 */
int Croute_func::user_femail_piglet_pregnant(DEAL_FUN_ARG)
{
	enum CP_MATE_RET {
		CMR_OK					= 0,
		CMR_NOT_ENOUGH_MONEY,
		CMR_INVALID_PIG_ID,
		CMR_TAR_CAN_NOT_MATE,
		CMR_CAN_NOT_MATE,
		CMR_INVALID_USER,
		CMR_DB
	};

    user_femail_piglet_pregnant_in_header *p_in=PRI_IN_POS;
    user_femail_piglet_pregnant_out out = { CMR_DB };
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_femail_piglet_pregnant_in_item));
    user_femail_piglet_pregnant_in_item * p_in_item=(user_femail_piglet_pregnant_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
	uint32_t pregnent_time = time(0);
    ret = this->user_piglet.update_female_pregnent(RECVBUF_USERID, p_in->index, pregnent_time);
	if(ret == SUCC){
		uint32_t k = 0;
		for(;k < p_in->count; ++k){
			uint32_t max_index = 0;
			ret = this->user_piglet.get_max_index(RECVBUF_USERID, &max_index);

			char appendex[4] = { 0 };
			char nick[NICK_LEN] = { 0 };	
			sprintf(appendex, "%03u", (max_index+1) % 1000);
			memcpy(nick, (p_in_item+k)->self_nick, NICK_LEN);
			strcat(nick, appendex);

			ret = this->user_piglet.birth(RECVBUF_USERID, (p_in_item + k)->piglet_id, nick, 
					(p_in_item +k)->mother_nick, (p_in_item +k)->father_nick, (p_in_item + k)->breed, (p_in_item+k)->sex, 
					(p_in_item+k)->weight, (p_in_item + k)->charm, (p_in_item +k)->strong, pregnent_time + 24*3600,
					 (p_in_item + k)->growth, 0x01, (p_in_item+k)->lifetime, p_in->index, (p_in_item+k)->generate, 
					 (p_in_item + k)->price);
			if(ret != SUCC){
				break;
			}
			else{
				//肥肥馆收集荣誉
				uint32_t res = 0;
				this->user_piglet_honor.add_honor(RECVBUF_USERID, (p_in_item + k)->breed, &res);	

				//50猪仔荣誉
				uint32_t re = 0;
				user_set_piglet_honor_in para = {38, 0};
				this->user_piglet_honor.set_honor(RECVBUF_USERID, &para, &re);
				if(re == 1){
					user_add_attire_in  add_item = {0};
					add_item.attireid = 1351280;
					add_item.attiretype = 99;
					add_item.count = 99;
					add_item.maxcount = 99;
					this->user_add_attire(RECVBUF_USERID, &add_item);
				}
				ret = SUCC;
			}
		}
		if(k >= p_in->count && ret == SUCC){
			int money = 0;
			ret = this->user.change_xiaomee(RECVBUF_USERID, -p_in->money, XIAOMEE_USE_DEL_PIGLET, 0, &money);
			out.state = 0;
			//猪爸猪妈
			{
				ret = this->user_piglet_task.change_task_state(RECVBUF_USERID, 8);
			}
		}
	}
	DEBUG_LOG("state: %u", out.state);
	
    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 拉取猪倌物品
 */
int Croute_func::user_get_piglet_articles(DEAL_FUN_ARG)
{
    user_get_piglet_articles_out_header  out_header;
    user_get_piglet_articles_out_item *p_out_item;
	const uint32_t start_id = 1593000;
	const uint32_t end_id = 1622999;
    ret = this->user_piglet_attire.get_items_range(RECVBUF_USERID, start_id, end_id, 0, &out_header.count, &p_out_item);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 卖掉猪仔
 */
int Croute_func::user_sale_piglet(DEAL_FUN_ARG)
{
    user_sale_piglet_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_sale_piglet_in_item));
	user_sale_piglet_in_item *p_in_item = (user_sale_piglet_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in));

    user_sale_piglet_out out={ 0 };

	uint32_t  day_sale_cnt = 0;
	ret = this->user_piglet_house.get_int_value(RECVBUF_USERID, "sale_cnt", &day_sale_cnt);
	if( p_in->count > 30 || (p_in->count + day_sale_cnt) > 30){
			out.state = 1;//不成功
			out.left_cnt = 30 - day_sale_cnt;
	}
	else{
		user_piglet_dress clothes;
		for(uint32_t k = 0; k < p_in->count; ++k){
			memset(&clothes, 0, sizeof(user_piglet_dress));

			const uint32_t angel_card = 1613128; 
			uint32_t effect_time = 0, lasttime = 0;
			ret = this->user_piglet_effect_tool.select(RECVBUF_USERID, angel_card, &effect_time, &lasttime);
			uint32_t weight = 0, price = 0, sex = 0, piglet_id = 0;
			ret = this->user_piglet.get_piglet_dress(RECVBUF_USERID, (p_in_item + k)->index, &price, &weight, 
					&sex,  &piglet_id, &clothes, effect_time, lasttime);
			if(ret == SUCC){
				for(uint32_t i = 0; i < clothes.count; ++i){
					this->user_piglet_attire.take_off(RECVBUF_USERID, clothes.itemid[i]);
				}
				//换算规则
				{
					out.money = out.money + (weight*price)/100;	
				}
				//查看该猪仔是否是female，如果是，查看其是否怀孕,删除其未出生的猪仔
				if(sex == 1){
					uint32_t* p_item = 0;
					uint32_t cnt = 0;
					ret = this->user_piglet.get_no_born_child(RECVBUF_USERID, (p_in_item + k)->index, &p_item, &cnt);
					for(uint32_t j = 0; j < cnt; ++j){
						ret = this->user_piglet.remove(RECVBUF_USERID, *(p_item+j));
					}	
					free(p_item);
				}//sex==1
				ret = this->user_piglet.remove(RECVBUF_USERID, (p_in_item + k)->index);
				
				//change log
				{
					change_log_item c_item;
					c_item.userid = RECVBUF_USERID;
					c_item.change_type = 210;//卖出猪仔
					c_item.logtime = time(NULL);
					c_item.change_value = (p_in_item + k)->index;
					c_item.change_v1 = piglet_id;
					c_item.change_v2 = (weight*price)/100;
					this->send_log.send(&c_item);
				}	
			}//if
			
		}//for
		ret = this->user.update_xiaomee_inc(RECVBUF_USERID, out.money);
		if(out.money != 0)
		//拜拜猪仔任务
		{
			ret = this->user_piglet_task.change_task_state(RECVBUF_USERID, 7);
		}
		this->user_piglet_house.set_int_value(RECVBUF_USERID, "sale_cnt", (p_in->count + day_sale_cnt));
		out.left_cnt = 15 - (p_in->count + day_sale_cnt);
		out.state = 0;
	}
	
	
    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 获取用户可以配对的所有公猪
 */
int Croute_func::user_get_able_make_pair_mail_piglet(DEAL_FUN_ARG)
{
	// 0 代表公猪， 1代表母猪
    user_get_able_make_pair_mail_piglet_out_header  out_header = { 0 };
    user_get_able_make_pair_mail_piglet_out_item *p_out_item = 0;
    ret = this->user_piglet.get_all_able_make_pair_mail_pig(RECVBUF_USERID, &p_out_item, &out_header.count);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 更新全局表中猪倌等级
 */
int Croute_func::sysarg_alter_piglet_house_level(DEAL_FUN_ARG)
{
    sysarg_alter_piglet_house_level_in *p_in=PRI_IN_POS;
    ret = this->sysarg_treasure_collection.update_piglet_level(RECVBUF_USERID, p_in->level);
	if(ret == USER_ID_NOFIND_ERR){
		ret = this->sysarg_treasure_collection.insert(RECVBUF_USERID, 0, p_in->level);
	}
    STD_RETURN(ret);
}
/*
 * 玩家猪倌升级
 */
int Croute_func::user_upgrade_piglet_house(DEAL_FUN_ARG)
{
    user_upgrade_piglet_house_in *p_in=PRI_IN_POS;
    ret = this->user_piglet_house.set_int_value(RECVBUF_USERID, "level", p_in->level);
	//猪倌升级公告
	{
		user_get_all_msg_out_item msg;
		memset(&msg, 0, sizeof(user_get_all_msg_out_item));
		msg.datetime = (uint32_t)time(0);
		msg.type = 12;
		msg.other_id = RECVBUF_USERID;
		msg.itemid = -1;//等级
		msg.value = p_in->level;
		ret = this->user_piglet_msg.update_records(RECVBUF_USERID, &msg);
	}
    STD_RETURN(ret);
}
/*
 *拉取全局表中好友猪倌等级
 */
int Croute_func::user_get_friend_piglet_house(DEAL_FUN_ARG)
{
    user_get_friend_piglet_house_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_get_friend_piglet_house_in_item));
    user_get_friend_piglet_house_in_item * p_in_item=(user_get_friend_piglet_house_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
    user_get_friend_piglet_house_out_header  out_header = { 0 };
    user_get_friend_piglet_house_out_item *p_out_item = 0;
    ret = this->sysarg_treasure_collection.select_piglet_house_friend(RECVBUF_USERID, p_in->count, p_in_item,
                &out_header.count, &p_out_item);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 拉取引导任务
 */
int Croute_func::user_get_piglet_day_task(DEAL_FUN_ARG)
{
	char buf[PROTO_MAX_LEN] = { 0 };
    user_get_piglet_day_task_out_header  *out_header = (user_get_piglet_day_task_out_header*)buf;
    user_get_piglet_day_task_out_item *p_out_item = 0;
	ret = this->user_piglet_task.get_all_task(RECVBUF_USERID, &p_out_item, &out_header->count);
	char *p_offset = buf + sizeof(user_get_piglet_day_task_out_header);
	memcpy(p_offset, p_out_item, out_header->count* sizeof(user_get_piglet_day_task_out_item));
	if(p_out_item != 0){
		free(p_out_item);
	}	
	p_offset += out_header->count * sizeof(user_get_piglet_day_task_out_item);
	//如果所有引导任务完成，检测是否可以开启每日任务
	{
		uint32_t count = 0;
		ret = this->user_piglet_task.get_guide_task_count(RECVBUF_USERID, &count);
		//引导任务总共十个，任务id: 1,2,3,4,5,6,7,8,9,10
		//uint32_t cnt = 0;
		//ret = this->user_piglet_task.get_day_task_count(RECVBUF_USERID, &cnt);
		if(count >= 10){
				user_get_piglet_day_task_out_item* pointer = ( user_get_piglet_day_task_out_item*)p_offset;
				uint32_t type[] = { 10010, 10000, 10002, 10011};
				uint32_t max_count[]={ 6, 3, 6, 3};
				for(uint32_t k = 1; k <= 4; ++k){
					ret = this->user_piglet_task.insert(RECVBUF_USERID, 10+k, type[k-1], max_count[k-1]);
					if(ret == SUCC){
						++out_header->count;
						pointer->taskid = k+10;
						pointer->state = 1;
						pointer->count = 0;
						++pointer;
					}
				}
				p_offset = (char*)pointer;
			}
	}	

	STD_RETURN_WITH_BUF(SUCC, buf, p_offset - buf);
}
/*
 * 生成新的引导任务
 */
int Croute_func::user_new_piglet_task(DEAL_FUN_ARG)
{
    user_new_piglet_task_in *p_in=PRI_IN_POS;
	user_new_piglet_task_out out= { 0 };	
    ret = this->user_piglet_task.insert(RECVBUF_USERID, p_in->taskid, p_in->type, p_in->maxcount);
	if(ret == SUCC){
		out.state = 1;
	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 完成任务
 */
int Croute_func::user_finish_piglet_task(DEAL_FUN_ARG)
{
	//1 表示已接， 2表示可完成， 3表示已完成
    user_finish_piglet_task_in *p_in=PRI_IN_POS;
	user_finish_piglet_task_out out = { 0 };	
	uint32_t state = 0, maxcount = 0;
	ret = this->user_piglet_task.get_two_col(RECVBUF_USERID, p_in->taskid, "state", "maxcount", &state, &maxcount);
	if(ret == SUCC && state == 2){
		if(p_in->taskid > 10){
			uint32_t low = maxcount & 0xFFFF;
			uint32_t high = maxcount >> 16;

			if(high  < 5){
				if(p_in->taskid != 14){
					state = 1;
					maxcount = ((high + 1) << 16)|low;
					ret = this->user_piglet_task.update_state_count(RECVBUF_USERID, p_in->taskid, state, 0, maxcount);
				}
				else{
					state = 3;
					ret = this->user_piglet_task.update_two_col(RECVBUF_USERID, p_in->taskid, "state", 
							"maxcount", state, maxcount);
				}
			}
			else if(high == 5){
				state = 3;
				ret = this->user_piglet_task.update_two_col(RECVBUF_USERID, p_in->taskid, "state", 
						"maxcount", state, maxcount);
			}
		}
		else{
			ret = this->user_piglet_task.update(RECVBUF_USERID, p_in->taskid, "state", 3);
		}
		if(ret == SUCC){
			out.state = 1;
			if(p_in->taskid > 10){
				uint32_t buf_barr[2]={ RECVBUF_USERID, 1};
				uint32_t statics_id = 0x0409BD94 + (p_in->taskid - 11);
				msglog(this->msglog_file, statics_id, time(NULL), buf_barr, 8);
				//每日任务统计
			}//p_in->taskid > 10
			
		}//ret == succ
	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 加工工厂
 */
int Croute_func::user_piglet_factory_process(DEAL_FUN_ARG)
{
	enum{
		SUCCESS              = 0, //成功
		REACHED_DAY_LIMIT    = 1,//达到每日加工上限
		NOT_ENOUGHT_MATERIAL ,//材料不够
		PIGLET_NOT_SATISFY_CON,//要加工的猪仔不满足条件
		NOT_SATISFY_FACTORY_LEVEL,//不满足加工厂等级
	};
    user_piglet_factory_process_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_piglet_factory_process_in_item));
    user_piglet_factory_process_in_item * p_in_item=(user_piglet_factory_process_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
	user_piglet_factory_process_out out = { 0 };
	
	uint32_t process_cnt = 0, factory_level = 0;
    ret=this->user_piglet_house.get_double_col(RECVBUF_USERID, "process_cnt", "factory_level", &process_cnt, &factory_level);
	DEBUG_LOG("process_cnt: %u, in_factor: %u, factory_level: %u",  process_cnt, p_in->factory_level, factory_level);

	if(process_cnt < 20 && p_in->factory_level <= factory_level){
		uint32_t k = 0;
		for(; k < p_in->count; ++k){
			uint32_t count = 0;
			ret = this->user_piglet_attire.get_noused_count(RECVBUF_USERID, (p_in_item + k)->itemid, count);
			if(count < (p_in_item + k)->count){
				break;
			}
		}
		if(k >= p_in->count){
			//检查是否可以加工
			uint32_t state = 0;
			ret = this->user_piglet.check_satisfy_process(RECVBUF_USERID, p_in->index, p_in->sort, &state);			
			DEBUG_LOG("state: %u", state);
			if(state == 1){
				for(uint32_t i = 0; i < p_in->count; ++i){
					ret = this->user_piglet_attire.sub_count(RECVBUF_USERID, (p_in_item + i)->itemid, (p_in_item + i)->count);
				}	
				user_piglet_dress dress;
				memset(&dress, 0, sizeof(user_piglet_dress));

				const uint32_t angel_card = 1613128; 
				uint32_t effect_time = 0, lasttime = 0;
				ret = this->user_piglet_effect_tool.select(RECVBUF_USERID, angel_card, &effect_time, &lasttime);

				//uint32_t now = time(0);
				//if(now >= (effect_time + lasttime)){
					//ret = this->user_piglet_effect_tool.drop(RECVBUF_USERID, angel_card);
					//effect_time = 0;
					//lasttime = 0;
				//}
				uint32_t weight = 0, sex = 0;
				ret = this->user_piglet.get_weight_sex_dress(RECVBUF_USERID, p_in->index, &weight, &sex, 
						&out.itemid, &dress, effect_time, lasttime);
				//脱掉装扮
				for(uint32_t j = 0; j < dress.count; ++j){
					this->user_piglet_attire.take_off(RECVBUF_USERID, dress.itemid[j]);
				}
				ret = this->user_piglet.remove(RECVBUF_USERID, p_in->index);
				if(sex == 1){//如果是母肥肥猪，需要删掉她未出生的孩子
					uint32_t *p_item = 0;
					uint32_t  cnt = 0;
					ret = this->user_piglet.get_no_born_child(RECVBUF_USERID, p_in->index, &p_item, &cnt);
					for(uint32_t i = 0; i < cnt; ++i){
						this->user_piglet.remove(RECVBUF_USERID, *(p_item + i));
					}
					free(p_item);
				}
				out.money = p_in->price * (weight/10);
				ret = this->user.update_xiaomee_inc(RECVBUF_USERID, out.money);
				ret = this->user_piglet_house.update_inc_col(RECVBUF_USERID, "process_cnt", 1);
				out.state = SUCCESS;
				//加工任务
				{
					ret = this->user_piglet_task.change_task_state(RECVBUF_USERID, 10);
				}
				//加工公告
				{
					user_get_all_msg_out_item msg;
					memset(&msg, 0, sizeof(user_get_all_msg_out_item));
					msg.datetime = (uint32_t)time(0);
					msg.type = 5;
					msg.other_id = RECVBUF_USERID;
					msg.itemid = 0;
					msg.value = out.money;
					ret = this->user_piglet_msg.update_records(RECVBUF_USERID, &msg);
				}
				//change log
				{
					change_log_item c_item;
					c_item.userid = RECVBUF_USERID;
					c_item.change_type = 211;//加工
					c_item.logtime = time(NULL);
					c_item.change_value = p_in->index;
					c_item.change_v1 = out.itemid;
					c_item.change_v2 = out.money;
					this->send_log.send(&c_item);
				}
			}
			else{
				//要加工的猪不满足条件
				out.state = PIGLET_NOT_SATISFY_CON;
			}
		}
		else{
			//材料不够用
			out.state = NOT_ENOUGHT_MATERIAL;
		}
	}
	else{
		if(process_cnt >= 20){
			//超过每日上限
			out.state = REACHED_DAY_LIMIT;
		}
		if(p_in->factory_level > factory_level){
			out.state = NOT_SATISFY_FACTORY_LEVEL;
		}	
	}
	DEBUG_LOG("out,state: %u", out.state);	
    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 猪倌公告板
 */
int Croute_func::user_get_all_msg(DEAL_FUN_ARG)
{
    user_get_all_msg_out_header  out_header = {0};
    user_get_all_msg_out_item *p_out_item = 0;
    ret = this->user_piglet_msg.get_all(RECVBUF_USERID, &p_out_item, &out_header.count);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);

}
/*
 * 猪倌随即好运
 */
int Croute_func::user_piglet_rand_fortune(DEAL_FUN_ARG)
{
    user_piglet_rand_fortune_out out={ 0 };
	uint32_t random = rand()%100;
	if(random < 30){//经验
		out.item_id = 14;
		out.item_cnt = 20;
		ret = this->user_piglet_house.update_inc_col(RECVBUF_USERID, "exp", out.item_cnt);
	}
	else if(random < 65){
		out.item_id = 0;
		out.item_cnt = 500;
		ret = this->user.update_xiaomee_inc(RECVBUF_USERID, out.item_cnt);
	}
	//else if(random < 65){
		//out.item_id = 1353201;
		//out.item_cnt = 1;
		//ret = this->user_piglet_attire.add_count(RECVBUF_USERID, out.item_id, out.item_cnt, 999999);
	//}
	else if(random < 95){
		out.item_id = 1613100;
		out.item_cnt = 20;
		ret = this->user_piglet_attire.add_count(RECVBUF_USERID, out.item_id, out.item_cnt, 999999);
	}
	else{
		uint32_t ran = rand()%2;
		if(ran == 1){
			out.item_id = 1593000;
		}
		else{
			out.item_id = 1593001;
		}
		out.item_cnt = 1;
		ret = this->user_piglet_attire.add_count(RECVBUF_USERID, out.item_id, out.item_cnt, 999999);
	}
	out.result = 1;	
	//随机好运公告
	{
		user_get_all_msg_out_item msg;
		memset(&msg, 0, sizeof(user_get_all_msg_out_item));
		msg.datetime = (uint32_t)time(0);
		msg.type = 6;
		msg.other_id = RECVBUF_USERID;
		msg.itemid = out.item_id;
		msg.value = out.item_cnt;
		ret = this->user_piglet_msg.update_records(RECVBUF_USERID, &msg);
	}
	
    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 猪倌图鉴
 */
int Croute_func::user_piglet_get_handbook(DEAL_FUN_ARG)
{
    user_piglet_get_handbook_out_header  out_header = { 0 };
    user_piglet_get_handbook_out_item *p_out_item = 0;
    ret = this->user_piglet_handbook.get_all(RECVBUF_USERID, &p_out_item, &out_header.count);


    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 建筑物升级
 */
int Croute_func::user_piglet_upgrade_building(DEAL_FUN_ARG)
{
	enum {
		SUCCESS  = 0, //成功
		NOT_SATISFY_LEVEL = 1,//等级不满足
		NOT_ENOUGH_MONEY = 2,//摩尔豆不足
		NOT_CORRECT_BUILD = 3, //不正确的建筑物
	};
    user_piglet_upgrade_building_in *p_in=PRI_IN_POS;
    user_piglet_upgrade_building_out out={ 0 };

	///建筑物升级需要的摩尔豆数
	uint32_t upgrade_cost[][4]= {
		{20000, 50000, 80000, 300000},
		{50000, 100000, 80000, 300000},
		{20000, 50000, 80000, 300000},
	};

	uint32_t money = 0;	
	ret = this->user.get_xiaomee(RECVBUF_USERID, &money);	
	if(p_in->build_id != 1 && p_in->build_id != 2 && p_in->build_id != 3){
		out.state = 3;
	}
	else{
		switch(p_in->build_id){
			case 1://加工工厂
				{
					uint32_t build_level = 0, real_level = 0;
					this->user_piglet_house.cal_factory_level(RECVBUF_USERID, &build_level);
					ret = this->user_piglet_house.get_int_value(RECVBUF_USERID, "factory_level", &real_level);
					
					if(real_level >0 && real_level < 4 && (real_level + 1) <= build_level && 
							money >= upgrade_cost[p_in->build_id - 1][real_level-1]){
						this->user_piglet_house.set_int_value(RECVBUF_USERID, "factory_level", real_level+1);	
						out.state = SUCCESS;
						out.money = upgrade_cost[p_in->build_id-1][real_level-1];
						ret = this->user.change_xiaomee(RECVBUF_USERID, -upgrade_cost[p_in->build_id-1][real_level-1],
								XIAOMEE_USE_DEL_PIGLET, 0, (int*)&money);

					}
					else if(real_level == 0 ||real_level >= 5 || (real_level + 1) > build_level){
						out.state = NOT_SATISFY_LEVEL; 
					}
					else{
						out.state = NOT_ENOUGH_MONEY;
					}
					break;

				}
			case 2://美美展台
				{
					uint32_t level  = 0, beauty_level = 0;
					ret = this->user_piglet_house.get_double_col(RECVBUF_USERID, "level", "beauty_level", &level, &beauty_level);
					if((((level >= 10 && level <  20) && beauty_level == 1) || (level >= 20 && (beauty_level == 2 ||
						beauty_level == 1))) && money >= upgrade_cost[p_in->build_id - 1][beauty_level-1]){
						ret = this->user_piglet_house.update_inc_col(RECVBUF_USERID, "beauty_level", 1);
						out.state = SUCCESS;
						ret = this->user.change_xiaomee(RECVBUF_USERID, -upgrade_cost[p_in->build_id-1][beauty_level-1],
									XIAOMEE_USE_DEL_PIGLET, 0, (int*)&money);
						out.money = upgrade_cost[p_in->build_id-1][beauty_level-1];
					}
					else if(level < 10 || beauty_level >= 3){
						 out.state= NOT_SATISFY_LEVEL;
					}
					else{
						 out.state= NOT_ENOUGH_MONEY;
					}
					break;
				}
			case 3://机械工厂升级
				{
					uint32_t machine_level = 0, warehouse_lvl = 0;	
					ret = this->user_piglet_house.get_double_col(RECVBUF_USERID, "machine_level",
							"warehouse_level", &machine_level, &warehouse_lvl);
					if(machine_level >= 3){
						out.state= NOT_SATISFY_LEVEL;
					}
					else{
						ret = this->user_piglet_house.update_double_col(RECVBUF_USERID, "machine_level", 
								"warehouse_level", machine_level+1, warehouse_lvl+1); 		
						work_piglets_t piglets;
						memset(&piglets, 0, sizeof(work_piglets_t));
						uint32_t index = 1;
						const uint32_t stove_id = 0;
						const uint32_t m_tool_id = 0;
						if(machine_level == 1){
							index = 2;
						}
						else if(machine_level == 2){
							index = 3;
						}
						ret = this->user_piglet_work.add(RECVBUF_USERID, 1, index, stove_id, 0, &piglets, 0, 0);
						ret = this->user_piglet_work.add(RECVBUF_USERID, 2, index, m_tool_id, 0, &piglets, 0, 0);
					}
					break;
				}
		}
	}
	
    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 内部函数
 */
int Croute_func::user_piglet_speed_birth(uint32_t userid, uint32_t index,uint32_t pregnant_time, 
		uint32_t sex, uint32_t *state, uint32_t *flag)
{
	enum {
		NO_SUCCESS = 0,		//失败
		SUCCESS = 1,		//成功
		NEED_REFRESH = 2,	//刷新 
	};

	if(sex == 1 && pregnant_time != 0){

		//丘比特祝福卡	
		uint32_t now = time(0);
		const uint32_t wish_card = 1613130; 
		uint32_t effect_time = 0, lasttime = 0;
		ret = this->user_piglet_effect_tool.select(userid, wish_card, &effect_time, &lasttime);

		no_born_piglet_st *p_item = 0; 
		uint32_t count = 0;
		ret = this->user_piglet.get_no_born_state_child(userid, index, &p_item, &count);
		if(ret != SUCC){
			if(p_item != 0){
				free(p_item);
			}
		}
		else{
			for(uint32_t k = 0; k < count; ++k){
				ret = this->user_piglet.update_fancy_born_state(userid, (p_item+k)->index);
				if(effect_time + lasttime > now){
					ret = this->user_piglet.update_inc_col(userid, (p_item+k)->index, "weight", 1000);
				}
				 //修正图鉴breed
				 {
					 uint32_t type = 0;
					 ret = this->user_piglet.get_piglet_real_breed((p_item+k)->pigletid, type);
					 if(ret == 0 && (p_item+k)->breed != type){
						 (p_item+k)->breed = type;
					 }
				 } 
				//加入图鉴
				this->user_piglet_handbook.add(userid, (p_item+k)->breed);
			}
			ret = this->user_piglet.change_pregnant_state(userid, index);
			free(p_item);
			*flag = 1;
			//小小猪任务
			{
				ret = this->user_piglet_task.change_task_state(userid, 9);
			}
			(*state) |= NEED_REFRESH; 
		}//else
	}//sex==1

	return 0;
}
/*
 * 道具使用
 */
int Croute_func::user_piglet_use_tool(DEAL_FUN_ARG)
{
	enum {
		NO_SUCCESS = 0,		//失败
		SUCCESS = 1,		//成功
		NEED_REFRESH = 2,	//刷新 
	};
    user_piglet_use_tool_in *p_in=PRI_IN_POS;
    user_piglet_use_tool_out out={ 0 };
    
	uint32_t sex = 0, breed = 0;					
	ret = this->user_piglet.select_two_cols(RECVBUF_USERID, p_in->index, "sex", "breed", &sex, &breed);
	uint32_t cnt = 0;
	ret = this->user_piglet_attire.get_noused_count(RECVBUF_USERID, p_in->itemid, cnt);
	if(ret == SUCC && cnt >= 1){
		uint32_t flag = 0;	
		switch(p_in->itemid){
			case 1613108://延寿药剂
				{
					ret = this->user_piglet.give_new_life(RECVBUF_USERID, p_in->index);
					if(ret == SUCC){
						flag = 1;
					}
					break;
				}
			case 1613109://闪电成长药剂
				{
					ret = this->user_piglet.lengthen_lifetime(RECVBUF_USERID, p_in->index, breed);
					if(ret == 0){
						flag = 1;
					}
					break;
				}
			case 1613110://基因变异药剂
				{
					if(sex == 1){
						uint32_t growth_stage = 0;
						ret = this->user_piglet.select(RECVBUF_USERID, p_in->index, "growth_stage", &growth_stage);
						if((growth_stage & 0x10) == 0){
							ret = this->user_piglet.update(RECVBUF_USERID, p_in->index, "growth_stage", growth_stage|0x10);
							if(ret == SUCC){
								flag = 1;
							}
						}
					}//sex==1
					break;
				}
			case 1613111://催产针
				{
					uint32_t pregnant_time = 0, growth_stage = 0;
					ret = this->user_piglet.select_two_cols(RECVBUF_USERID, p_in->index, "pregnant_time",
						   "growth_stage", &pregnant_time, &growth_stage);
					uint32_t now = time(0);
					if(sex == 1 && pregnant_time != 0 && (growth_stage & 0x20) == 0){
						if(now - pregnant_time < 12*3600){
							ret = this->user_piglet.update_two_cols(RECVBUF_USERID, p_in->index, "pregnant_time",
							   "growth_stage", pregnant_time - 12*3600, growth_stage|0x20);
							if(ret == SUCC){

								uint32_t *p_item = 0;
								uint32_t cnt = 0;
								ret = this->user_piglet.get_no_born_child(RECVBUF_USERID, p_in->index, &p_item, &cnt);	
								if(ret != SUCC){
									if(p_item != 0){
										free(p_item);
									}
								}
								else{
									for(uint32_t k = 0; k < cnt; ++k){
										uint32_t birthday = 0;
										ret = this->user_piglet.select(RECVBUF_USERID, *(p_item +k), "birthday", &birthday);
										ret = this->user_piglet.update(RECVBUF_USERID, *(p_item+k), "birthday",  
												birthday - 12*3600);
									}
									free(p_item);
									flag = 1;
								}

							}
								//}sex==1
						}
						else{//立即生出小猪仔
							this->user_piglet_speed_birth(RECVBUF_USERID, p_in->index, pregnant_time, sex,
									&out.state, &flag);
						}

					}//sex==1
					break;
				}
			case 1613112://给力催产针
				{
					uint32_t pregnant_time = 0;
					ret = this->user_piglet.select(RECVBUF_USERID, p_in->index, "pregnant_time", &pregnant_time);

					this->user_piglet_speed_birth(RECVBUF_USERID, p_in->index, pregnant_time, sex,
							&out.state, &flag);
					break;
				}
			case 1613113://多仔药剂
				{
					uint32_t growth_stage = 0, state = 0;
					ret = this->user_piglet.check_use_more_child_tool(RECVBUF_USERID, p_in->index, &state, &growth_stage);
					if(sex == 1 && (growth_stage & 0x08) == 0 && state == 2){
						ret = this->user_piglet.update(RECVBUF_USERID, p_in->index, "growth_stage", growth_stage|0x08);
						if(ret == SUCC){
							flag = 1;
						}
					}//sex
					break;
				}
			case 1613103://疯狂药水 
				{
					const uint32_t val_inc = 35*10;
					ret = this->user_piglet.update_inc_col(RECVBUF_USERID, p_in->index, "weight", val_inc);
					if(ret == SUCC){
						flag = 1;
					}
					break;
				}
		}//switch
		if(flag == 1){
			out.state |= SUCCESS;
			this->user_piglet_attire.sub_count(RECVBUF_USERID, p_in->itemid, 1);
			//change log
			{
				change_log_item c_item;
				c_item.userid = RECVBUF_USERID;
				c_item.change_type = 212;//使用道具
				c_item.logtime = time(NULL);
				c_item.change_value = p_in->index;
				c_item.change_v1 = p_in->itemid;
				c_item.change_v2 = breed;
				this->send_log.send(&c_item);
			}
		}
	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}

int Croute_func::user_get_lucky_ticket(DEAL_FUN_ARG)
{
	user_get_lucky_ticket_in *p_in = PRI_IN_POS;

	ret = this->user_lucky_ticket.insert(RECVBUF_USERID, p_in->date, p_in->ticket, p_in->prize_level);
	STD_RETURN(ret);
}

int Croute_func::user_check_get_ticket(DEAL_FUN_ARG)
{
	user_check_get_ticket_in *p_in=PRI_IN_POS; 
	user_check_get_ticket_out out={0};
	ret = this->user_lucky_ticket.get_date_ticket(RECVBUF_USERID, p_in->date, &out);
	ret = SUCC;
	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::user_swap_ticket_prize(DEAL_FUN_ARG)
{
	user_swap_ticket_prize_in *p_in = PRI_IN_POS; 
	user_swap_ticket_prize_out out = {0};
	ret = this->user_lucky_ticket.get_swap_prize_info(RECVBUF_USERID,p_in->date, &(out.is_get), &(out.prize_level));
	if (ret == SUCC && out.is_get == 0) {
		ret = this->user_lucky_ticket.set_prize_is_get(RECVBUF_USERID, p_in->date, 1);
	}
	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::user_get_history_ticket_info(DEAL_FUN_ARG)
{
	user_get_history_ticket_info_out_header  out_header = {0};
	user_get_history_ticket_info_out_item *p_out_item = NULL;
	ret = this->user_lucky_ticket.get_history_ticket_info(RECVBUF_USERID, &p_out_item, &(out_header.count));
	STD_RETURN_WITH_STRUCT_LIST(ret, out_header, p_out_item, out_header.count);
}

int Croute_func::user_get_national_day_login(DEAL_FUN_ARG)
{
	user_get_national_day_login_out out = {0};
	ret = this->user_continue_login.get_national_day_info(RECVBUF_USERID, 2, &(out.login_val));
	STD_RETURN_WITH_STRUCT(ret, out);
}

int Croute_func::user_set_national_day_gift(DEAL_FUN_ARG)
{
	user_set_national_day_gift_in *p_in = PRI_IN_POS; 
	user_set_national_day_gift_out out = {0};
	ret = this->user_continue_login.set_national_day(RECVBUF_USERID, 2, p_in->gift_val, &(out.state));
	STD_RETURN_WITH_STRUCT(ret, out);
}
/*
 * 更改猪倌任务状态
 */
int Croute_func::user_piglet_task_change(DEAL_FUN_ARG)
{
    user_piglet_task_change_in *p_in=PRI_IN_POS;
	switch(p_in->eventid)
	{
		case 0://喂食猪仔
			{
				ret = this->user_piglet_task.change_task_state(RECVBUF_USERID, 1);
				this->user_piglet_task.change_task_state(RECVBUF_USERID, 12);
				break;

			}
		case 1://给猪仔洗澡
			{
				ret = this->user_piglet_task.change_task_state(RECVBUF_USERID, 2);
				break;

			}
		case 2://开宝箱
			{
				ret = this->user_piglet_task.change_task_state(RECVBUF_USERID, 11);
				//肥肥馆收集荣誉
				{
					uint32_t res = 0;
					user_set_piglet_honor_in para = {36, 0};
					this->user_piglet_honor.set_honor(RECVBUF_USERID, &para, &res);	
					if(res == 1){
						user_add_attire_in  add_item = {0};
						add_item.attireid = 1351278;
						add_item.attiretype = 99;
						add_item.count = 99;
						add_item.maxcount = 99;
						ret = this->user_add_attire(RECVBUF_USERID, &add_item);
					}
					
				}
				break;

			}
	}

    STD_RETURN(ret);
}
/*
 *领取猪票 
 */
int Croute_func::user_piglet_receive_ticket(DEAL_FUN_ARG)
{
	enum R_TICKET_S{
		OK = 0, //可以领取
		ALREADY_GET = 1,//已经领取了
		DB_ER  //DB出错
	};
    user_piglet_receive_ticket_in *p_in = PRI_IN_POS;
    user_piglet_receive_ticket_out out={0};
	//字段is_ticket 使用了原来的currency  字段，由于原来currency字段初始值为1000，
	//所以现在用1000表示is_ticket 当天猪票没有领取， 1001表示猪票领取过
	uint32_t is_ticket = 1000;	
    ret = this->user_piglet_house.get_int_value(RECVBUF_USERID, "is_ticket", &is_ticket);
	if(ret == SUCC ){
		if(is_ticket == 1000){
			ret = this->user_piglet_attire.add_count(RECVBUF_USERID, p_in->ticket_id, 1, 99999);
			ret = this->user_piglet_house.set_int_value(RECVBUF_USERID, "is_ticket", 1001);
			out.state = OK;
		}
		else{
			out.state = ALREADY_GET;
		}
	}
	else{
		out.state = DB_ER;
	}
		
    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 拉取猪倌BUFF道具
 */
int Croute_func::user_piglet_get_effect_tools(DEAL_FUN_ARG)
{
    user_piglet_get_effect_tools_out_header  out_header;
    user_piglet_get_effect_tools_out_item *p_out_item;
    ret = this->user_piglet_effect_tool.get_all(RECVBUF_USERID, &p_out_item, &out_header.count);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 使用猪倌BUFF 道具
 */
int Croute_func::user_piglet_use_effect_tool(DEAL_FUN_ARG)
{
	enum CP_USE_CARD_RESULT
	{
		CUCR_OK		= 0,
		CUCR_NOT_ENOUGH_CARD,
		CUCR_INVALID_CARD,
		CUCR_CAN_NOT_USE_TO_SELF,
		CUCR_NO_EFFECT,
	};
    user_piglet_use_effect_tool_in *p_in=PRI_IN_POS;
	user_piglet_use_effect_tool_out out = {  0 };	
	DEBUG_LOG("itemid: %u, uid: %u", p_in->itemid, p_in->uid);
   
	switch(p_in->itemid)
	{
		case 1613128://天使卡
		case 1613129://恶魔卡
		case 1613130://丘比特祝福卡
			{
				ret = this->user_piglet_effect_tool.add(RECVBUF_USERID, p_in->itemid, p_in->uid);	
				out.state = CUCR_OK;
				break;
			}
		case 1613131://恶魔拜拜卡
			{
				uint32_t effect_time  = 0, lasttime = 0;
				ret = this->user_piglet_effect_tool.select(RECVBUF_USERID, 1613129, &effect_time, &lasttime); 
				if(ret != SUCC){
					out.state = CUCR_NO_EFFECT;
				}
				else{
					ret = this->user_piglet_effect_tool.drop(RECVBUF_USERID,1613129);
					out.state = CUCR_OK;
				}
				break;
			}
	}	
	if(out.state == CUCR_OK){
		//使用buff道具公告
		user_get_all_msg_out_item msg; 
		memset(&msg, 0, sizeof(user_get_all_msg_out_item));
		msg.datetime = time(0);
		msg.type = 13;
		msg.other_id = p_in->uid;
		msg.itemid = p_in->itemid;
		msg.value = 1;
		ret = this->user_piglet_msg.update_records(RECVBUF_USERID, &msg);
	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}

/*
 * 给肥肥猪投票
 */
int Croute_func::user_piglet_poll(DEAL_FUN_ARG)
{
    user_piglet_poll_in *p_in=PRI_IN_POS;
    ret = this->user_piglet_house.set_poll(RECVBUF_USERID, p_in->index);

    STD_RETURN(SUCC);
}
/*
 * 获取投票记录
 */
int Croute_func::user_get_piglet_poll(DEAL_FUN_ARG)
{
    user_get_piglet_poll_out out={ 0 };
    ret = this->user_piglet_house.get_int_value(RECVBUF_USERID, "poll", &out.poll);

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 投票类型
 */
int Croute_func::sysarg_get_questionnaire_subtype(DEAL_FUN_ARG)
{
	sysarg_get_questionnaire_subtype_in *p_in = PRI_IN_POS;
	sysarg_get_questionnaire_subtype_out out = {0};
	ret = this->questionnaire.get_subtype_with_max_value(p_in->type, p_in->main_type, &(out.sub_type));
	STD_RETURN_WITH_STRUCT(ret, out);
}
/*
 * 申请对方好友时，先加入待响应表
 */
int Croute_func::user_check_response_friend(DEAL_FUN_ARG)
{
    user_check_response_friend_in *p_in=PRI_IN_POS;
	user_check_response_friend_out out= { 0 };	
	ret=this->user_response_friend.add(RECVBUF_USERID, p_in->uid);
	if(ret == SUCC){
		out.state = 1;
	}

	STD_RETURN_WITH_STRUCT(SUCC, out);
}
/*
 * 收到对方加好友响应后，检测好友是否在表中
 */
int Croute_func::user_check_exist_friend(DEAL_FUN_ARG)
{
    user_check_exist_friend_in *p_in=PRI_IN_POS;
    user_check_exist_friend_out out={ 0 };
	uint32_t datetime = 0;
    ret = this->user_response_friend.select(RECVBUF_USERID, p_in->uid, &datetime);
	if(ret == SUCC){
		ret = this->user_response_friend.drop(RECVBUF_USERID, p_in->uid);
		out.state = 1;
	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 删掉银行存款
 */
int Croute_func::user_delete_bank_money(DEAL_FUN_ARG)
{
    user_delete_bank_money_in *p_in=PRI_IN_POS;
	uint32_t total_money = 0;
	this->user_bank.get_total_money_in_bank(RECVBUF_USERID, &total_money);
	
	uint32_t xiaomee = 0;
	if(p_in->money > 30000){
		xiaomee = p_in->money - 30000;
	}
	else{
		xiaomee = 0;
	}
	user_bank_add_out *p_list = 0;
	uint32_t count = 0;
	ret = this->user_bank.get_all_record(RECVBUF_USERID, &p_list, &count);
	if(total_money >= xiaomee && xiaomee != 0){
		for(uint32_t k = 0; k < count; ++count){
			if(xiaomee != 0){
				if((p_list+k)->xiaomee == xiaomee){
					this->user_bank.delete_bank_money(RECVBUF_USERID, (p_list+k)->time);
					break;
				}
				else if((p_list+k)->xiaomee < xiaomee ){
					 this->user_bank.delete_bank_money(RECVBUF_USERID, (p_list+k)->time);
					 xiaomee = xiaomee - (p_list+k)->xiaomee;
				}
				else{
					uint32_t surplus = (p_list+k)->xiaomee -  xiaomee;
					this->user_bank.update_value(RECVBUF_USERID, (p_list+k)->time, surplus);
					break;
				}
			}
		}//for
	}//if
	if(p_list !=0){
		free(p_list);
	}

    STD_RETURN(ret);
}
/*
 * 领取糖果
 */
int Croute_func::user_swap_halloween_candy(DEAL_FUN_ARG)
{
    user_swap_halloween_candy_in *p_in=PRI_IN_POS;
    user_swap_halloween_candy_out out={ 0 };
	//判断是否是好友
	id_list friendlist;
	ret=this->user_ex.get_idlist(RECVBUF_USERID ,FRIEND_LIST_STR, &friendlist);
	uint32_t k = 0;
	for(; k < friendlist.count; ++ k){
		if(friendlist.item[k] == p_in->friend_id)
			break;
	}
	if(k >=  friendlist.count){
		return NOT_CORRECT_FRIEND_ERR;
	}
	//领取糖果
	uint32_t candy_count = 0;
	const uint32_t candy = 1351123;	
	ret = this->user_temp_item.get_count(RECVBUF_USERID, candy, candy_count);
	if(candy_count == 0){
		return ATTIRE_COUNT_NO_ENOUGH_ERR;
	}

	uint32_t random = rand()%70;
	if(random < 30){
		out.count = 1;	
	}
	else if(random < 35){
		out.count = 5;
	}
	else if(random < 40){
		out.count = 4;
	}
	else if(random < 50){
		out.count = 3;
	}
	else if(random < 60){
		out.count = 2;
	}
	else{
		out.count = 0;
	}
	DEBUG_LOG("count: %u, candy_count: %u", out.count, candy_count);
	if(out.count > candy_count){
		out.count = candy_count;
	}
	out.candy = candy;

	uint32_t datetime = 0, times = 0; 
	swap_candy_t swap_history;
	memset(&swap_history, 0, sizeof(swap_candy_t));
	ret = this->user_halloween_candy.get_friends_times(RECVBUF_USERID, &datetime, &times, &swap_history);
	if(ret == SUCC){
		uint32_t today = get_date(time(0));
		if(datetime == today){
			//判断今天是否领取过
			uint32_t i = 0;
			for(; i < swap_history.count; ++i){
				if(swap_history.friends[i] == p_in->friend_id){
					break;
				}
			}//for		
			if( i < swap_history.count){
				return ALREADY_SWAP_CANDY_ERR;
			}
		}
		else{
			memset(&swap_history, 0, sizeof(swap_candy_t));
		}

		swap_history.friends[swap_history.count] = p_in->friend_id;
		++swap_history.count;
		ret = this->user_halloween_candy.update_friends_times(RECVBUF_USERID, today, times+1, &swap_history);
	}
	else{
		swap_history.friends[0] = p_in->friend_id;
		swap_history.count = 1;
		ret = this->user_halloween_candy.insert(RECVBUF_USERID, &swap_history);
	}
	if(out.count != 0){
		ret = this->user_temp_item.sub_count(RECVBUF_USERID, candy, out.count);	
	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 查看好友领取糖果历史记录
 */
int Croute_func::user_get_swap_halloween_history(DEAL_FUN_ARG)
{
    user_get_swap_halloween_history_out out={0};
    ret = this->user_halloween_candy.get_int_value(RECVBUF_USERID, "times", &out.times);

    STD_RETURN_WITH_STRUCT(SUCC,out);

}
/*
 * 使用好友领取次数交换物品
 */
int Croute_func::user_swap_halloween_item(DEAL_FUN_ARG)
{

	uint32_t times = 0;
	ret = this->user_halloween_candy.get_int_value(RECVBUF_USERID, "times", &times);
	if(times < 5){
		return NOT_ENOUGH_SWAP_TIMES_ERR;
	}
	else{
		ret = this->user_halloween_candy.set_int_value(RECVBUF_USERID, "times", times-5);
	}

    STD_RETURN(ret);
}
/*
 * 客服查看猪倌所有猪仔信息
 */
int Croute_func::su_user_get_all_piglets(DEAL_FUN_ARG)
{
    su_user_get_all_piglets_out_header  out_header = { 0 };
    su_user_get_all_piglets_out_item *p_out_item = 0;
	ret = this->user_piglet_house.get_int_value(RECVBUF_USERID, "level", &out_header.level);
    ret = this->user_piglet.su_get_all(RECVBUF_USERID, &p_out_item, &out_header.count);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 客服查看猪倌物品信息
 */
int Croute_func::su_user_get_pilget_attire(DEAL_FUN_ARG)
{
    su_user_get_pilget_attire_out_header  out_header = { 0 };
    su_user_get_pilget_attire_out_item *p_out_item = 0;
	const uint32_t start = 1593000;
	const uint32_t end = 1622999;
	ret = this->user_piglet_house.get_int_value(RECVBUF_USERID, "level", &out_header.level);
    ret = this->user_piglet_attire.get_items_range(RECVBUF_USERID, start, end, 2, &out_header.count, &p_out_item);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 交互小花仙1
 */
int Croute_func::user_get_xhx_task_state(DEAL_FUN_ARG)
{
    user_get_xhx_task_state_in *p_in = PRI_IN_POS;
	user_get_xhx_task_state_out out = {0};
	ret = this->user_continue_login.get_xhx_task_state(RECVBUF_USERID, p_in->type, 10000, &(out.state));
    STD_RETURN_WITH_STRUCT(SUCC, out);
}
/*
 * 与小花仙交互2
 */
int Croute_func::user_set_continue_login_value(DEAL_FUN_ARG)
{
	user_set_continue_login_value_in *p_in = PRI_IN_POS;
	ret = this->user_continue_login.update_count(RECVBUF_USERID, p_in->type, p_in->count);
	STD_RETURN(SUCC);
}
/*
 * 拉取所有已经保存套装
 */
int Croute_func::user_get_profiles(DEAL_FUN_ARG)
{
	char buf[PROTO_MAX_LEN] = { 0 };
    user_get_profiles_out_header  *out_header = (user_get_profiles_out_header*)buf;
	char* p_offset = buf + sizeof( *out_header);
	user_get_profiles_out_item *p_out_item = (user_get_profiles_out_item*)(p_offset);
	
	std::vector<uint32_t> vec;
	uint32_t real_cnt = 0;

    user_get_profiles_out_item *p_temp_item = 0;
    ret = this->user_profile_dress.get_profiles(RECVBUF_USERID, &p_temp_item, &out_header->count);
	uint32_t count = 0;
	attire_count *p_item = 0;
	ret = this->user_attire.get_list_by_attireid_interval(RECVBUF_USERID, 12001, 15999 + 1, 2, &count, &p_item);
	
	for(uint32_t k = 0; k < out_header->count; ++k){
		for(uint32_t i = 0; i < (p_temp_item + k)->dress.count; ++i){
			attire_count other = { (p_temp_item +k)->dress.profiles[i], 0};
			attire_count *iter = std::find(p_item, p_item+count, other);		
			if(iter !=  p_item+count && iter->count != 0){
				p_out_item->dress.profiles[p_out_item->dress.count] = (p_temp_item + k)->dress.profiles[i];
				++(p_out_item)->dress.count;
			}
		}	
		if((p_out_item)->dress.count != 0){
			p_out_item->index = (p_temp_item + k)->index; 
			p_offset  = p_offset + (p_out_item)->dress.count * sizeof(uint32_t) + 2*sizeof(uint32_t);
			p_out_item = (user_get_profiles_out_item *)p_offset;
			++real_cnt;
		}
		else{
			vec.push_back((p_temp_item + k)->index);
		}
	}
	out_header->count = real_cnt;

	if(p_temp_item !=0 ){
		free(p_temp_item);
	}
	if(p_item != 0){
		free(p_item);
	}
	for(std::vector<uint32_t>::iterator iter = vec.begin(); iter != vec.end(); ++iter){
		this->user_profile_dress.remove(RECVBUF_USERID, *iter);
	}

	STD_RETURN_WITH_BUF(SUCC, buf, (char*)p_out_item - buf);
}
/*
 *保存形象套装 
 */
int Croute_func::user_add_profile_dress(DEAL_FUN_ARG)
{
	enum SAVE_AVATAR_RET
	{
		SAR_OK		= 0,
		SAR_FULL,
		SAR_EMPTY,
	};

    user_add_profile_dress_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_add_profile_dress_in_item));
    user_add_profile_dress_in_item * p_in_item=(user_add_profile_dress_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
	user_add_profile_dress_out out = {0};
	if(p_in->count > 12){
		out.state = SAR_FULL;
	}
	else{
		uint32_t count = 0;
		ret = this->user_profile_dress.get_count(RECVBUF_USERID, &count);
		bool is_vip;
		ret = this->user_ex.get_vip(RECVBUF_USERID, &is_vip );
		if(!is_vip){
			if(count >= 2){
				out.state = SAR_FULL;
			}
		}
		else{
			uint32_t vip_pet_level = 0;
			ret = this->user_ex.get_int_value(RECVBUF_USERID, "vip_pet_level", &vip_pet_level);
			if(vip_pet_level >= 1 && vip_pet_level <= 4){
				if(count >= 5){
					out.state = SAR_FULL;
				}
			}
			else if(vip_pet_level >= 5 && vip_pet_level <= 8){
				if(count >= 8){
					out.state = SAR_FULL;
				}
			}
			else if(vip_pet_level >= 9){
				if(count >= 10){
					 out.state = SAR_FULL;
				}
			}
		}
		if(out.state == SAR_OK){
			profile_dress_t profile;
			memset(&profile, 0, sizeof(profile_dress_t));
			profile.count = p_in->count;
			memcpy((char*)(&profile)+4, (char*)p_in_item, sizeof(user_add_profile_dress_in_item)*p_in->count);
			ret = this->user_profile_dress.insert(RECVBUF_USERID, &profile);
		}
	}
	
    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 删除形象套装
 */
int Croute_func::user_remove_profile_dress(DEAL_FUN_ARG)
{
	enum REMOVE_AVATAR_RET
	{
		RAR_OK		= 0,
		RAR_INVALID_ID,
	};	
    user_remove_profile_dress_in *p_in=PRI_IN_POS;
    user_remove_profile_dress_out out={ 0 };
    ret=this->user_profile_dress.remove(RECVBUF_USERID, p_in->index);
	if(ret != SUCC){
		out.state = RAR_INVALID_ID;
	}
	else{
		out.state = RAR_OK;
	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 交换猪倌背景
 */
int Croute_func::user_swap_piglet_house_back(DEAL_FUN_ARG)
{
	enum{
		RET_OK 				= 0,
		NO_BACKGROUND_ID,
		DB_WRONG,

	};
    user_swap_piglet_house_back_in *p_in=PRI_IN_POS;
    user_swap_piglet_house_back_out out={ 0 };
	uint32_t count = 0;
    ret = this->user_piglet_attire.get_noused_count(RECVBUF_USERID, p_in->background, count);
	if(count == 0){
		out.state =  NO_BACKGROUND_ID; 
	}
	else{
		uint32_t old_back = 0;
		ret = this->user_piglet_house.get_int_value(RECVBUF_USERID, "background", &old_back);
		ret = this->user_piglet_attire.take_off(RECVBUF_USERID, old_back);

		ret = this->user_piglet_house.set_int_value(RECVBUF_USERID, "background", p_in->background);
		ret = this->user_piglet_attire.put_on(RECVBUF_USERID, p_in->background);
	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 拉取系列任务
 */
int Croute_func::user_get_task_list(DEAL_FUN_ARG)
{
    user_get_task_list_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_get_task_list_in_item));
    user_get_task_list_in_item * p_in_item=(user_get_task_list_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
    user_get_task_list_out_header  out_header = { 0 };
    user_get_task_list_out_item *p_out_item = 0;
    ret = this->user_task_ex.get_specify_list(RECVBUF_USERID, p_in->count, p_in_item, &p_out_item, &out_header.count);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/*
 * 超级蘑菇向导, 客服查看超级向导举报记录
 */
int Croute_func::su_get_usermsg_mushroom_guide(DEAL_FUN_ARG)
{
    su_get_usermsg_mushroom_guide_in *p_in=PRI_IN_POS;
    su_get_usermsg_mushroom_guide_out_header  out_header = { 0 };
    su_get_usermsg_mushroom_guide_out_item *p_out_item;
	
	ret = this->usermsg.get_count1(p_in, &out_header.record_cnt);
    ret = this->usermsg.get_tip_offs_by_date(p_in, &p_out_item, &out_header.count);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/*
 * 超级蘑菇向导，领取成就奖励
 */
int Croute_func::user_mushroom_guider_receive_award(DEAL_FUN_ARG)
{
	enum{
		OK_SUCC         = 0,//成功
		ERR_ACHIEVEMENT = 1,//不满足领取成就等级
		ALREDAY_GET     = 2,//已经领取过
	};
    user_mushroom_guider_receive_award_in *p_in=PRI_IN_POS;
	user_mushroom_guider_receive_award_out out = { 0 };	

	uint32_t history = 0;
	ret = this->user.get_int_value(RECVBUF_USERID, "medal", &history);

	const uint32_t medal_id = 1351131;
	uint32_t guide_medals = 0;
	ret = this->user_temp_item.get_count(RECVBUF_USERID, medal_id, guide_medals);
	uint32_t accomplishment = 0;
	if(guide_medals >= 1 && guide_medals <= 10){
		accomplishment = 1;
	}
	else if(guide_medals >= 11 && guide_medals <= 50){
		accomplishment = 2;
	}
	else if(guide_medals >= 51 && guide_medals <= 100){
		accomplishment = 3;
	}
	else if(guide_medals >= 101 && guide_medals <= 150){
		accomplishment = 4;
	}
	else {
		accomplishment =  5;
	}

	if(p_in->index == 0 || accomplishment < p_in->index || p_in->index > 5){
		out.state = ERR_ACHIEVEMENT;
	}

	if((history & (1<<(p_in->index-1))) != 0){
		out.state = ALREDAY_GET;
	}
	if(out.state == OK_SUCC){
		ret = this->user.set_int_value(RECVBUF_USERID, "medal", history|(1 << (p_in->index-1)));
		user_add_attire_in  add_item = {0};
		switch(p_in->index){
			case 1:
				{
					add_item.attireid = 160037;
					add_item.attiretype = 1;
					add_item.maxcount = 99;
					break;
				}
			case 2:
				{
					add_item.attireid = 160043;
					add_item.attiretype = 1;
					add_item.maxcount = 99;
					break;
				}
			case 3:
				{
					add_item.attireid = 1270011;
					add_item.attiretype = 0;
					add_item.maxcount = 99999;
					break;
				}
			case 4:
				{
					add_item.attireid = 1270029;
					add_item.attiretype = 0;
					add_item.maxcount = 99999;
					break;
				}
			case 5:
				{
					add_item.attireid = 190681;
					add_item.attiretype = 0;
					add_item.maxcount = 99999;
					break;
				}
		}

		add_item.count = 1;
		ret = this->user_add_attire(RECVBUF_USERID, &add_item);
	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 超级蘑菇向导，查看领取奖励
 */
int Croute_func::user_guid_mushroom_get_awards(DEAL_FUN_ARG)
{
    user_guid_mushroom_get_awards_out out={0};
    ret = this->user.get_int_value(RECVBUF_USERID, "medal", &out.history);

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 超级蘑菇向导，删除客服处理过后的举报记录
 */

int Croute_func::usermsg_mushroom_guide_del(DEAL_FUN_ARG)
{
	usermsg_mushroom_guide_del_in *p_in=PRI_IN_POS;
	usermsg_mushroom_guide_del_out out = { 0 };
	ret = this->usermsg.get_del_count(p_in, &out.count);
	ret = this->usermsg.remove(p_in);

    STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * 猪倌中猪仔携带
 */
int Croute_func::user_piglet_carry_piglet(DEAL_FUN_ARG)
{
	
    user_piglet_carry_piglet_in *p_in=PRI_IN_POS;
    user_piglet_carry_piglet_out out={ 0 };
	out.index = p_in->piglet_index;
	if (p_in->outgo > 1) {
        return VALUE_OUT_OF_RANGE_ERR;
    }
	if (p_in->outgo == 1) {
        uint32_t count_in_animal = 0;
        uint32_t count_in_fairy = 0;
        uint32_t count_in_contract = 0;
		uint32_t count_in_piglet = 0;
        ret  = this->user_farm_fairy.get_state_out_count(RECVBUF_USERID, count_in_fairy);
        ret = this->user_farm_animal.get_outgo_count(RECVBUF_USERID, &count_in_animal);
        ret = this->user_paradise_contract.get_count_type2(RECVBUF_USERID, count_in_contract);
		ret = this->user_piglet.get_outgo_count(RECVBUF_USERID, &count_in_piglet);
        if (count_in_fairy > 0 || count_in_animal > 0 || count_in_contract > 0 || count_in_piglet > 0) {
            return YOU_HAVE_ANIMAL_OUTGO_ERR;
        }
		ret = this->user_piglet.check_able_carry_piglet(RECVBUF_USERID, p_in->piglet_index, &out);
		if(ret == SUCC && out.state == 1){
			this->user_piglet.update(RECVBUF_USERID, p_in->piglet_index, "carry_flag", p_in->outgo);
		}	
    }
	else if(p_in->outgo == 0){
		ret = this->user_piglet.update(RECVBUF_USERID, p_in->piglet_index, "carry_flag", p_in->outgo);
		out.state = 1;

	}
	
	if(out.state == 1){
		out.state = p_in->outgo;
	}
	else{
		out.state = 2;
	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 美美猪展台表演
 */
int Croute_func::user_check_piglet_performance(DEAL_FUN_ARG)
{
	enum CP_SHOW_RET{
		CSR_OK				= 0,
		CSR_LIMIT, //超过每日表演次数
		CSR_INVALID_DATA,//其他无效数据
	};
    user_check_piglet_performance_in *p_in=PRI_IN_POS;
	user_check_piglet_performance_out out = { 0 };	
	if(p_in->is_initialtive == 1){
		uint32_t beauty_level = 0;
		ret = this->user_piglet_house.get_int_value(RECVBUF_USERID, "beauty_level", &beauty_level);
		uint32_t pig_count = 0;
		for(uint32_t i = 0; i < sizeof(p_in->pig_index)/sizeof(uint32_t); ++i){
			if(p_in->pig_index[i] != 0){
				++pig_count;
			}
		}
		if(pig_count > beauty_level){
			out.state = CSR_INVALID_DATA;
			STD_RETURN_WITH_STRUCT(ret,out);
		}
	}

	ret = this->user_piglet_house.get_double_col(RECVBUF_USERID, "exp", "level", &out.exp, &out.level);
	//道具id及顺序
	uint32_t perf_tool[] = { 1613250, 1613251, 1613252, 1613253, 1613270, 1613271, 1613272, 1613273};	
	attire_count *p_temp_item = 0;
	uint32_t temp_cnt = 0;
	ret = this->user_piglet_attire.get_interval_item(RECVBUF_USERID, perf_tool, sizeof(perf_tool)/sizeof(uint32_t),
        	&p_temp_item, &temp_cnt);
	
	uint32_t k = 0;
	uint32_t enough_tool_flag = 0;
	for(; k < sizeof(perf_tool)/sizeof(uint32_t); ++k){
		if(*(p_in->item_cnt + k) != 0){
			attire_count other = { *(perf_tool + k), 0 };
			attire_count *iter = std::find(p_temp_item, p_temp_item+temp_cnt, other);
			if(iter != p_temp_item + temp_cnt){
				//DEBUG_LOG("iter->count: %u, p_in->item_cnt: %u, itemid: %u", iter->count,  p_in->item_cnt[k], perf_tool[k]);
				if( iter->count < p_in->item_cnt[k]){
					break;	
				}
			}
			else{
				break;
			}
		}//if
	}//for
	if( k < sizeof(perf_tool)/sizeof(uint32_t)){
		enough_tool_flag = 0;
	}
	else{
		enough_tool_flag = 1;
	}
	
	uint32_t condition = 0;
	ret = this->user_piglet.check_performance_by_hungry(RECVBUF_USERID, p_in->pig_index, &condition);
	if(condition == 1 && enough_tool_flag == 1){
		out.state = CSR_OK;
	}
	else{
		out.state = CSR_INVALID_DATA;
	}

	if(out.state == CSR_OK){
		uint32_t perform_cnt = 0;
		ret = this->user_piglet_house.get_int_value(RECVBUF_USERID, "perform_cnt", &perform_cnt);
		uint32_t active = perform_cnt & 0xFFFF;
		uint32_t pk = perform_cnt >> 16;
		if(p_in->is_initialtive != 2){
			if((p_in->target_user == 0 && active >= 5) || (p_in->target_user !=0 && pk >= 5 && 
						p_in->is_initialtive == 1)){
				out.state = CSR_LIMIT; 
			}
		}
		
		//扣除道具
		for(uint32_t k = 0; k < sizeof(p_in->item_cnt)/sizeof(uint32_t); ++k){
			if(*(p_in->item_cnt + k) != 0 ){
				this->user_piglet_attire.sub_count(RECVBUF_USERID, perf_tool[k], *(p_in->item_cnt + k));
			}
		}//for	
		if(p_in->is_initialtive != 2){
			if(p_in->target_user == 0){
				if(active < 5){
					ret = this->user_piglet_house.set_int_value(RECVBUF_USERID, "perform_cnt", (pk << 16)|(active+1));
				}
			}
			else{
				if(pk < 5){
					ret = this->user_piglet_house.set_int_value(RECVBUF_USERID, "perform_cnt", ((pk+1) << 16)|active);
				}
			}
		}//不是与NPC斗斗秀
		
		//}
		for(uint32_t k = 0; k < sizeof(p_in->pig_index)/sizeof(uint32_t);++k){
			uint32_t charm = 0;
			if(p_in->pig_index[k] != 0){
				this->user_piglet.select(RECVBUF_USERID, p_in->pig_index[k], "weight", &charm);
				out.charm += charm;
			}
		}
		this->user_piglet_task.change_task_state(RECVBUF_USERID, 14);
	}

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 拉取猪仔分馆
 */
int Croute_func::user_get_another_pighouse(DEAL_FUN_ARG)
{
    user_get_another_pighouse_out_header  out_header;
    user_get_another_pighouse_out_item *p_out_item;
    ret = this->user_piglet.get_another_piglets(RECVBUF_USERID, &p_out_item, &out_header.count);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 将猪仔放入分馆或放入主馆或机械工厂
 */
int Croute_func::user_transfer_piglet(DEAL_FUN_ARG)
{
	enum{
		PUT_IN_SECONDARY = 0,//从主馆放入分館
		PUT_IN_PRIMARY = 1,//从分馆放入主館
		PUT_IN_MACHINE = 2,//从主馆放入机械工厂
		PUT_IN_PRIM_FROM_M = 3,//从主馆放入机械工厂
	};
	enum{
		RET_DEFEAT = 0,//放入失败
		RET_SUCC   = 1,//放入成功
		RET_INJECT_DEAFEAT = 2,//放入成功，灌注能量失败
	};
    user_transfer_piglet_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_transfer_piglet_in_item));
    user_transfer_piglet_in_item * p_in_item=(user_transfer_piglet_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
	user_transfer_piglet_out out = { 0 };	
	DEBUG_LOG("count: %u, in_out: %u",p_in->count, p_in->in_out);

	bool is_vip;
	ret = this->user_ex.get_vip(RECVBUF_USERID, &is_vip );

	if(is_vip){
		uint32_t buf_barr[4]={ RECVBUF_USERID, 1, 0, 0};
		msglog(this->msglog_file, 0x0409BF10, time(NULL), buf_barr, 16);
	}
	else{
		uint32_t buf_barr[4]={ 0, 0, RECVBUF_USERID, 1};
		msglog(this->msglog_file, 0x0409BF10, time(NULL), buf_barr, 16);

	}

	if(p_in->in_out == PUT_IN_SECONDARY || p_in->in_out == PUT_IN_MACHINE){
		uint32_t cnt_in_secondary = 0;
		uint32_t capacity = 0, orient = 0;
		if(p_in->in_out == PUT_IN_SECONDARY){//放入分馆
			this->user_piglet.get_secondary_piglet_cnt(RECVBUF_USERID, &cnt_in_secondary, 1);
			if(is_vip){
				uint32_t vip_pet_level = 0;
				ret = this->user_ex.get_int_value(RECVBUF_USERID, "vip_pet_level", &vip_pet_level);
				if(vip_pet_level >= 1 && vip_pet_level <= 3){
					capacity = 40;
				}
				else if(vip_pet_level >= 4 && vip_pet_level <= 5){
					capacity = 80;
				}
				else{
					 capacity = 100;
				}
			}
			else{
				capacity = 20;
			}
			orient = 1;
		}
		else{//放入机械工厂
			this->user_piglet.get_secondary_piglet_cnt(RECVBUF_USERID, &cnt_in_secondary, 2);
			uint32_t machine_level = 0;
			this->user_piglet_house.get_int_value(RECVBUF_USERID, "machine_level", &machine_level);
			if(machine_level == 1){
				capacity = 5;
			}
			else if(machine_level == 2){
				capacity = 10;
			}
			else{
				capacity = 15;
			}
			orient = 2;
		}
		
		DEBUG_LOG("secondary: %u, capacity: %u, p_in->count: %u", cnt_in_secondary, capacity,  p_in->count);
		if( p_in->count == 0 || (cnt_in_secondary + p_in->count > capacity)){
			out.state = 0;
			DEBUG_LOG("!!!secondary: %u, capacity: %u, p_in->count: %u", cnt_in_secondary, capacity,  p_in->count);
		}
		else{

			pregnant_piglet_t *p_item = 0;
			uint32_t item_cnt = 0;
		    ret = this->user_piglet.get_pregnant_piglet(RECVBUF_USERID, p_in_item, p_in->count, &p_item, &item_cnt);	

			const uint32_t angel_card = 1613128; 
			uint32_t effect_time = 0, lasttime = 0;
			ret =this->user_piglet_effect_tool.select(RECVBUF_USERID, angel_card, &effect_time, &lasttime);
			uint32_t inject_state = 3;
			uint32_t k = 0;
			for(; k < item_cnt; ++k){
				uint32_t survive = this->user_piglet.check_piglet_dead((p_item+k)->feedtime, 12, 
						(p_item+k)->birthday, (p_item+k)->lifetime);
				DEBUG_LOG("survive: %u", survive);
				if(survive != 0 || ((p_item+k)->sex == 1 && (p_item+k)->pregnant_time != 0)){
					out.state = 0;
					break;
				}//sex==1
				if(p_in->in_out == PUT_IN_MACHINE){//如果是放入机械厂，需要判断是否成年
					uint32_t status = this->user_piglet.get_piglet_growth_state((p_item+k)->birthday, (p_item+k)->lifetime, 
							(p_item+k)->breed, (uint32_t)time(0));	
					DEBUG_LOG("[status: %u]", status);
					if(status != 2){
						out.state = 0;
						break;
					}
					ret = this->user_piglet.inject_energy(RECVBUF_USERID, (p_item + k)->index, &inject_state);
					if(inject_state == 0){
						DEBUG_LOG("inject_state: %u", inject_state);
						break;
					}
				}
				ret = this->user_piglet.transfer_piglet(RECVBUF_USERID, (p_item + k)->index, effect_time, lasttime, orient);
			}
			if(k >= item_cnt){
				out.state = 1;
			}
			else{
				if(inject_state == 0){
					DEBUG_LOG("---inject_state: %u", inject_state);
					out.state = RET_INJECT_DEAFEAT; 
				}
			}
			if(p_item != 0){
				free(p_item);
			}
		}

	}
	else if(p_in->in_out == PUT_IN_PRIMARY || p_in->in_out == PUT_IN_PRIM_FROM_M){
		uint32_t all_piglet_count = 0; 
		ret = this->user_piglet.get_all_counts(RECVBUF_USERID, &all_piglet_count);
		uint32_t level = 0;
		ret = this->user_piglet_house.get_int_value(RECVBUF_USERID, "level", &level);

		uint32_t limit = this->user_piglet.get_level_piglet_limit(RECVBUF_USERID, level);
		if(p_in->count == 0 || (p_in->count + all_piglet_count > limit)){
			out.state = 0;
		}
		else{
			uint32_t flag = 0;
			if(p_in->in_out == PUT_IN_PRIMARY){
				flag = 1;
			}
			else{
			    flag = 2;
			}
			for(uint32_t k = 0; k < p_in->count; ++k){
				ret = this->user_piglet.put_in_primary(RECVBUF_USERID, (p_in_item+k)->index, flag);
			}
			out.state = 1;
		}//else
	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 交换分馆和主馆的肥肥猪
 */
int Croute_func::user_exchange_piglet_house(DEAL_FUN_ARG)
{

    user_exchange_piglet_house_in *p_in=PRI_IN_POS;
	user_exchange_piglet_house_out out = { 0 };
	pregnant_piglet_t *p_item = 0;
	uint32_t item_cnt = 0;
	user_transfer_piglet_in_item in_item = {  p_in->index_1 };	
	ret = this->user_piglet.get_pregnant_piglet(RECVBUF_USERID, &in_item, 1, &p_item, &item_cnt);	

	const uint32_t angel_card = 1613128; 
	uint32_t effect_time = 0, lasttime = 0;
	this->user_piglet_effect_tool.select(RECVBUF_USERID, angel_card, &effect_time, &lasttime);
	uint32_t k = 0;
	for(; k < item_cnt; ++k){
		uint32_t survive = this->user_piglet.check_piglet_dead((p_item+k)->feedtime, 12, 
							(p_item+k)->birthday, (p_item+k)->lifetime);
		if(survive != 0 || ((p_item+k)->sex == 1 && (p_item+k)->pregnant_time != 0)){
			out.state = 0;
			break;
		}//sex==1
		ret = this->user_piglet.transfer_piglet(RECVBUF_USERID, (p_item + k)->index, effect_time, lasttime, 1);

	}
	if(item_cnt > 0 && k > 0){
		//开启事务
		STD_CLOSE_AUTOCOMMIT(ret);
		if(ret != SUCC)  {
			out.state = 0;
			STD_RETURN_WITH_STRUCT(SUCC,out);
		}
		ret = this->user_piglet.put_in_primary(RECVBUF_USERID, p_in->index_2, 1);
		if(ret==SUCC){
			//提交
			out.state = 1;
			STD_COMMIT(ret);
		}else{
			//回滚
			out.state = 0;
			STD_ROLLBACK();
		} 
		//关闭事务
		STD_OPEN_AUTOCOMMIT() ;	

	}	
	
    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 美美豬展台使用道具
 */
int Croute_func::user_piglet_add_beaty_tool(DEAL_FUN_ARG)
{
    user_piglet_add_beaty_tool_in *p_in=PRI_IN_POS;
	user_piglet_add_beaty_tool_out out = { 0 };	
	uint32_t count = 0;
	ret = this->user_piglet_attire.get_noused_count(RECVBUF_USERID, p_in->itemid, count);
	if(count > 0){
		DEBUG_LOG("itemid: %u, lasttime: %u", p_in->itemid, p_in->lasttime);
		ret = this->user_piglet_effect_tool.n_insert(RECVBUF_USERID, p_in->itemid, RECVBUF_USERID, p_in->lasttime);
		if(ret == SUCC){
			out.state = 1;
			
		}
	}
    
	if(out.state == 1){
		ret = this->user_piglet_attire.sub_count(RECVBUF_USERID, p_in->itemid, 1);
		ret = this->user_piglet_honor.insert(RECVBUF_USERID, 1, 37, 1, 0, 1, 1, 0);
		if(ret == SUCC){
			user_add_attire_in  add_item = {0};
			add_item.attireid = 1351279;
			add_item.attiretype = 99;
			add_item.count = 99;
			add_item.maxcount = 99;
			this->user_add_attire(RECVBUF_USERID, &add_item);
		}

	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 拉取美美豬展台
 */
int Croute_func::user_get_beauty_piglet_tool(DEAL_FUN_ARG)
{
	char buf[PROTO_MAX_LEN] = { 0 };
    user_get_beauty_piglet_tool_out_header *out_header = (user_get_beauty_piglet_tool_out_header *)buf;
    user_get_beauty_piglet_tool_out_item *p_out_item = (user_get_beauty_piglet_tool_out_item*)(buf+sizeof(*out_header));

	this->user_piglet_house.get_double_col(RECVBUF_USERID, "perform_cnt", "beauty_level", 
			&out_header->perform_cnt, &out_header->beauty_level);
	beauty_piglet_effect_t *p_item = 0;	
	uint32_t cnt = 0;
	uint32_t now = time(0);
    ret = this->user_piglet_effect_tool.get_beauty_effect_tools(RECVBUF_USERID, &p_item, &cnt);
	out_header->count = cnt;
	for(uint32_t k = 0; k < cnt; ++k){
		if((p_item+k)->start_time + (p_item+k)->lasttime <= now){
			this->user_piglet_effect_tool.drop(RECVBUF_USERID, (p_item+k)->itemid);
			--out_header->count;
		}
		else{
			p_out_item->itemid = (p_item+k)->itemid;
			p_out_item->lasttime = (p_item+k)->lasttime;
			++p_out_item;
		}
	}
	if(p_item != 0){
		free(p_item);
	}

	STD_RETURN_WITH_BUF(SUCC, buf, (char*)p_out_item - buf);
}
/*
 * 超级蘑菇向导，客服逐条删除记录
 */
int Croute_func::su_user_drop_super_mushroom_record(DEAL_FUN_ARG)
{
    su_user_drop_super_mushroom_record_in *p_in=PRI_IN_POS;
    ret = this->usermsg.drop_one_record(p_in);
	
    STD_RETURN(ret);
}
/*
 * 给美美猪穿衣或脱掉衣服
 */
int Croute_func::user_put_on_piglet_clothes(DEAL_FUN_ARG)
{
    user_put_on_piglet_clothes_in *p_in=PRI_IN_POS;
    user_put_on_piglet_clothes_out out={0};

	user_piglet_dress dress;
	memset(&dress, 0, sizeof(user_piglet_dress));
	uint32_t breed = 0;
    ret = this->user_piglet.get_breed_dress(RECVBUF_USERID, p_in->index, &breed, &dress);
	if(ret != SUCC || (breed < 10000 || breed >= 20000)){
		out.state = 0;
	}
	else{
		DEBUG_LOG("p_in->type: %u", p_in->type);
		if(p_in->type == 0){//代表穿衣
			uint32_t *iter = std::find(dress.itemid, dress.itemid + dress.count, p_in->itemid);
			if(iter == dress.itemid + dress.count){
				ret = this->user_piglet_attire.put_on(RECVBUF_USERID, p_in->itemid);
				if(ret != SUCC){
					out.state = 0;
				}
				else{
					for(uint32_t i = 0; i < dress.count; ++i){
						if(i < 1){
							this->user_piglet_attire.take_off(RECVBUF_USERID, dress.itemid[i]);
						}
					}
					memset(&dress, 0, sizeof(user_piglet_dress));
					dress.itemid[dress.count] = p_in->itemid;
					dress.count = 1;
					ret = this->user_piglet.put_on(RECVBUF_USERID, p_in->index, &dress);
					out.state = 3;
				}
			}
			else{
				out.state = 3;
			}

		}
		else{//表示脱衣服
			for(uint32_t i = 0; i < dress.count; ++i){
				this->user_piglet_attire.take_off(RECVBUF_USERID, dress.itemid[i]);
			} 
			memset(&dress, 0 ,sizeof(user_piglet_dress));
			ret = this->user_piglet.put_on(RECVBUF_USERID, p_in->index, &dress);
			out.state = 3;
		}
	}

    STD_RETURN_WITH_STRUCT(ret,out);

}
/*
 * 增加猪仔属性
 */
int Croute_func::user_change_beauty_piglet(DEAL_FUN_ARG)
{
    user_change_beauty_piglet_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_change_beauty_piglet_in_item));
    user_change_beauty_piglet_in_item * p_in_item=(user_change_beauty_piglet_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
	for(uint32_t k = 0; k < p_in->count; ++k){
		uint32_t value = 0, real_value = 0;	
		this->user_piglet.select(RECVBUF_USERID, (p_in_item+k)->index, "weight", &value);
		if(value < 150000){
			if(value + (p_in_item+k)->inc_value > 150000){
				real_value = 150000;
			}
			else{
				real_value = value + (p_in_item+k)->inc_value;
			}
			this->user_piglet.update(RECVBUF_USERID, (p_in_item+k)->index, "weight", real_value);
		}
	}

    STD_RETURN(SUCC);
}
/*
 * 美美斗秀赛参与
 */
int Croute_func::sysarg_join_beauty_contend(DEAL_FUN_ARG)
{
    sysarg_join_beauty_contend_in *p_in=PRI_IN_POS;
	sysarg_join_beauty_contend_out out = { 0 };	
	ret = this->sysarg_beauty_contend.add(p_in);
	ret = this->sysarg_beauty_contend.get_total(&out.total);
	if(out.total != 0 && out.total % 10000 == 0){
		uint32_t now = time(0);
		this->sysarg_beauty_contend.update_two_cols((char*)"cnt", (char*)"datetime", out.total / 10000, now);
	}

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 查看美美斗秀参与人数
 */
int Croute_func::sysarg_get_beauty_contend(DEAL_FUN_ARG)
{
    sysarg_get_beauty_contend_out out={0};
    ret = this->sysarg_beauty_contend.get_all(&out.value_1, &out.value_2, &out.value_3, &out.total);

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 *检查是否给好友喂食 
 */
int Croute_func::user_check_feed_piglet(DEAL_FUN_ARG)
{
    user_check_feed_piglet_in *p_in=PRI_IN_POS;
    user_check_feed_piglet_out out = { 0 };
	
	if(p_in->person != RECVBUF_USERID){
		//判断是否是好友
		id_list friendlist;
		ret=this->user_ex.get_idlist(RECVBUF_USERID ,FRIEND_LIST_STR, &friendlist);
		uint32_t k = 0;
		for(; k < friendlist.count; ++ k){
			if(friendlist.item[k] == p_in->person)
				break;
		}
		if(k >=  friendlist.count){
			out.state  = 0;//给陌生人猪仔喂食
		}
		else{
			out.state = 1;//表示给好友或自己
		}
	}
	else{
		out.state = 1;
	}
	uint32_t cnt = 0;
	ret = this->user_piglet_attire.get_noused_count(RECVBUF_USERID, p_in->itemid, cnt);	
	out.count = cnt;
	
    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 查看美美斗斗秀达到发奖次数和时间
 */
int Croute_func::user_get_beauty_contend_cnt(DEAL_FUN_ARG)
{
	/*
	 * 第一次美美斗秀赛数据  
	+---------+---------+---------+--------+-----+------------+
	| value_1 | value_2 | value_3 | total  | cnt | datetime   |
	+---------+---------+---------+--------+-----+------------+
	|  104472 |   89135 |   60744 | 254351 |  25 | 1322396710 | 
	+---------+---------+---------+--------+-----+------------+
	*/
    user_get_beauty_contend_cnt_out out={0};
    ret = this->sysarg_beauty_contend.get_two_cols((char*)"cnt", (char*)"datetime", &out.cnt, &out.datetime);
	uint32_t now = time(0);
	out.datetime = now - out.datetime;

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * AS通用任务添加
 */
int Croute_func::user_as_common_add(DEAL_FUN_ARG)
{
    user_as_common_add_in *p_in=PRI_IN_POS;
    ret = this->user_as_common.add(RECVBUF_USERID, p_in->type, p_in->data);
    STD_RETURN(ret);
}


/*
 * AS通用查询一任务
 */
int Croute_func::user_as_common_query(DEAL_FUN_ARG)
{
    user_as_common_query_in *p_in=PRI_IN_POS;
    user_as_common_query_out out={0};
	out.type = p_in->type;
    ret = this->user_as_common.get_one(RECVBUF_USERID, p_in->type, &out.data);

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 美美大比拼第三期，置连续次数
 */
int Croute_func::roominfo_set_beauty_continuation(DEAL_FUN_ARG)
{
    roominfo_set_beauty_continuation_in *p_in=PRI_IN_POS;
	//roominfo_set_beauty_continuation_out out = { 0 };	
	DEBUG_LOG("value: %u", p_in->value);
	ret = this->roominfo_beauty_piglet.set_attributes(RECVBUF_USERID, p_in->value);

    STD_RETURN(ret);
	//STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 美美大比拼第三期，领奖
 */
int Croute_func::roominfo_get_award_beauty(DEAL_FUN_ARG)
{
    roominfo_get_award_beauty_in *p_in=PRI_IN_POS;
	roominfo_get_award_beauty_out out = { 0 };	
    ret = this->roominfo_beauty_piglet.set_award(RECVBUF_USERID, p_in->type, &out.state);

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 美美斗秀赛第三期，查看领奖记录
 */
int Croute_func::roominfo_get_award_history(DEAL_FUN_ARG)
{
    roominfo_get_award_history_out out;
	memset(&out, 0, sizeof(roominfo_get_award_history_out));
    ret = this->roominfo_beauty_piglet.get_award_history_whole(RECVBUF_USERID, &out.history, &out.continuation);

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 给好友圣诞树挂袜子
 */
int Croute_func::user_put_on_christmas_socks(DEAL_FUN_ARG)
{
    user_put_on_christmas_socks_in *p_in=PRI_IN_POS;
	
	if(p_in->type == 2){
		user_add_attire_in  add_item = {0};
		add_item.attireid = 1351176; 
		add_item.attiretype = 99;
		add_item.count = 1;
		add_item.maxcount = 999999;
		ret = this->user_add_attire(RECVBUF_USERID, &add_item);
	}
	else{
		user_del_attire_in del_item = { 0 };
		del_item.attireid =  1351175;
		del_item.attiretype = 99;
		del_item.count = 1;
		del_item.maxcount=99999;
		ret=this->user_del_attire(RECVBUF_USERID ,&del_item);
	}
	if(ret == SUCC){
		ret = this->user_christmas_socks.add(RECVBUF_USERID, p_in->friendid, p_in->type, 1);
	}

    STD_RETURN(SUCC);
}

/*
 * @brief 金豆购买时校验小屋数据是否到达上限
 */
int Croute_func::user_get_home_attire_count(DEAL_FUN_ARG)
{
	user_get_home_attire_count_out out={0};
	bool is_vip;
	ret = this->user_ex.get_vip(RECVBUF_USERID, &is_vip);
	ret = this->user.get_home_attire_count(RECVBUF_USERID, is_vip, &out);
	STD_RETURN_WITH_STRUCT(ret, out);
}

/*
 * 查看给自己圣诞树挂袜子的好友
 */
int Croute_func::user_query_christmas_socks(DEAL_FUN_ARG)
{
    user_query_christmas_socks_in *p_in = PRI_IN_POS;
    user_query_christmas_socks_out_header  out_header = { 0 };
    user_query_christmas_socks_out_item *p_out_item = 0;
	out_header.cur_page = p_in->page;
	ret = this->user_christmas_socks.select_page_count(RECVBUF_USERID, &out_header.all_page, p_in->type);	
	ret = this->user_christmas_socks.select_socks_info(RECVBUF_USERID, p_in->type, p_in->page, &p_out_item, &out_header.count);

	ret = SUCC;
    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 *查看某一好友给我挂袜子数量 
 */
int Croute_func::user_check_christmas_socks(DEAL_FUN_ARG)
{
    user_check_christmas_socks_in *p_in=PRI_IN_POS;
    user_check_christmas_socks_out out={0};

	ret = this->user_ex.check_friend(RECVBUF_USERID, p_in->friendid, &(out.is_friend));
	if (out.is_friend == 1) {
		ret = this->user_christmas_socks.query_some_friend(RECVBUF_USERID, p_in->friendid, 2, &out.self_sock_cnt);
		ret = this->user_christmas_socks.query_toal(RECVBUF_USERID, 2, &out.all_cnt);
	}

	ret = SUCC;
    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 *查看圣诞树上袜子最多的玩家， top10 
 */
int Croute_func::user_sysarg_get_christmas_top10(DEAL_FUN_ARG)
{
    user_sysarg_get_christmas_top10_in *p_in = PRI_IN_POS;
	user_sysarg_get_christmas_top10_out_header  out_header = { 0 };
    user_sysarg_get_christmas_top10_out_item *p_out_item = 0;
    ret = this->sysarg_christmas_socks.get_all(&p_out_item, &out_header.count, p_in->type);

	ret = SUCC;
    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 圣诞树挂袜子，全局表置投票top10
 *
 */
int Croute_func::user_sysarg_set_christmas_top10(DEAL_FUN_ARG)
{
    user_sysarg_set_christmas_top10_in *p_in=PRI_IN_POS;
    ret = this->sysarg_christmas_socks.renew(p_in->userid, p_in->count);

    STD_RETURN(SUCC);


}
/*
 * 肥肥馆check 收藏兑换都是一组美美猪,领取猪仔
 */
int Croute_func::user_check_piglet_handbook(DEAL_FUN_ARG)
{
	enum{
		RET_BAD = 0,
		RET_OK  = 1,
	};

    user_check_piglet_handbook_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_check_piglet_handbook_in_item));
    user_check_piglet_handbook_in_item * p_in_item=(user_check_piglet_handbook_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
    user_check_piglet_handbook_out out={ 0 };

	user_piglet_get_handbook_out_item *p_tmp = 0;
	for(uint32_t i = 0; i < p_in->count; ++i){
		DEBUG_LOG("breed: %u", (p_in_item+i)->breed);
	}	
	uint32_t cnt = 0;
    ret = this->user_piglet_handbook.get_all(RECVBUF_USERID, &p_tmp, &cnt);
	for(uint32_t k = 0; k < p_in->count; ++k){
		uint32_t i = 0;
		for(; i < cnt; ++i){
			if((p_in_item+k)->breed  == (p_tmp+i)->breed){
				break;
			}
		}
		if(i >= cnt){
			if(p_tmp != 0){
				free(p_tmp);
			}
		    out.state = RET_BAD;
			STD_RETURN_WITH_STRUCT(ret,out);
		}
	}
	out.state = RET_OK; 
	if(p_tmp != 0){
		free(p_tmp);
	}
	DEBUG_LOG("state------------: %u ", out.state);

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 查看圣诞挂袜子领取奖励情况
 */
int Croute_func::user_check_christmas_sock_gift(DEAL_FUN_ARG)
{
    user_check_christmas_sock_gift_in *p_in=PRI_IN_POS;
    user_check_christmas_sock_gift_out out={0};

    ret=this->user_christmas_socks.check_socks_gift(RECVBUF_USERID, p_in->friendid, &out.count, &out.is_get);

	ret = SUCC;
    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 圣诞树挂袜子，置领取奖励
 */
int Croute_func::user_set_christmas_sock_gift(DEAL_FUN_ARG)
{
    user_set_christmas_sock_gift_in *p_in=PRI_IN_POS;
    ret = this->user_christmas_socks.set_flag(RECVBUF_USERID, p_in->friendid);

    STD_RETURN(ret);
}
/*
 *拉取 超拉天使兑换祥云九尾信息 
 */
int Croute_func::user_get_vip_angel_info(DEAL_FUN_ARG)
{
	user_get_vip_angel_info_in *p_in = PRI_IN_POS; 
    user_get_vip_angel_info_out out={0};
	//兑换九尾祥云
	uint32_t vip_angel[] = {1354075, 1354102, 1354146, 1354159, 1354189, 1354199, 1354205, 1354209};
	//兑换九尾憨福
	uint32_t vip_another[] = {1354076, 1354103, 1354147, 1354160, 1354190, 1354200, 1354206, 1354210};
	uint32_t *pointer = 0;
	if(p_in->type != 0 && p_in->type != 1){
		STD_RETURN_WITH_STRUCT(SUCC,out);
	}

	uint32_t exchange_cnt = 0;	
	ret = this->user_paradise.get_int_value(RECVBUF_USERID, "exchange", &exchange_cnt);
	if(p_in->type == 0){
		pointer = vip_angel;
		exchange_cnt = exchange_cnt & 0xFFFF;
	}
	else{
		pointer = vip_another;
		exchange_cnt = (exchange_cnt >> 16);
	}
	vip_angel_t *p_tmp = 0;
	uint32_t cnt = 0;
    ret = this->user_angel_statistics.get_vip_angel(RECVBUF_USERID, pointer, sizeof(vip_angel)/sizeof(uint32_t),
			&p_tmp, &cnt);

	
	for(uint32_t k = 0; k < cnt; ++k){
		if((p_tmp+k)->count > exchange_cnt){
			uint32_t i = 0;
			for(; i < sizeof(vip_angel)/sizeof(uint32_t); ++i){
				if(pointer[i] == (p_tmp+k)->angelid){
					out.flag |= (1 << i);
					break;
				}	
			}//for
		}//if
	}
	if(p_tmp != 0){
		free(p_tmp);
	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 满足超拉天使兑换条件，兑换祥云九尾
 */
int Croute_func::user_exchange_vip_angel_info(DEAL_FUN_ARG)
{
	user_exchange_vip_angel_info_in *p_in = PRI_IN_POS;  
    user_exchange_vip_angel_info_out out={0};

	uint32_t vip_angel[] = {1354075, 1354102, 1354146, 1354159, 1354189, 1354199, 1354205, 1354209};
	uint32_t vip_another[] = {1354076, 1354103, 1354147, 1354160, 1354190, 1354200, 1354206, 1354210};

	uint32_t *pointer = 0;
	if(p_in->type != 0  && p_in->type  != 1){
		STD_RETURN_WITH_STRUCT(SUCC,out);
	}

	uint32_t exchange_cnt = 0;	
	ret = this->user_paradise.get_int_value(RECVBUF_USERID, "exchange", &exchange_cnt);
	uint32_t low_cnt = exchange_cnt & 0xFFFF;
	uint32_t high_cnt = (exchange_cnt >> 16);
	if(p_in->type  == 0){
		pointer = vip_angel;
		exchange_cnt = low_cnt;
	}
	else{
		pointer = vip_another;
		exchange_cnt = high_cnt;
	}
    vip_angel_t *p_tmp = 0;
    uint32_t cnt = 0;
    ret = this->user_angel_statistics.get_vip_angel(RECVBUF_USERID, pointer, sizeof(vip_angel)/sizeof(uint32_t),
            &p_tmp, &cnt);

	if(cnt < sizeof(vip_angel)/sizeof(uint32_t)){
		out.state = 0;
	}
	else{
		uint32_t k = 0;
		for(;k < cnt; ++k){
			if((p_tmp+k)->count <= exchange_cnt){
				break;
			}//if
		}
		if(k < cnt){
			out.state = 0;
		}
		else{
			out.state = 1;
			user_add_attire_in  add_item = {0};
			if(p_in->type == 0){
				add_item.attireid = 1353308; //祥云九尾
				add_item.attiretype = 0;
				++low_cnt;
			}
			else{
				add_item.attireid = 1593069; //九尾憨福
				add_item.attiretype = 36;
				++high_cnt;
			}
			add_item.count = 1;
			add_item.maxcount = 999999;
			ret = this->user_add_attire(RECVBUF_USERID, &add_item);
			ret = this->user_paradise.set_int_value(RECVBUF_USERID, "exchange", (high_cnt << 16)|low_cnt);
		}
	}
	if(p_tmp != 0){
		free(p_tmp);
	}

    STD_RETURN_WITH_STRUCT(SUCC, out);
}
/*
 * 龙族大冒险，全局表检查加入游戏人数
 */
int Croute_func::user_sysarg_check_player_num(DEAL_FUN_ARG)
{
	enum{
		CANNOT_PART_IN  = 0,//人数大于1000，不能加入状态
		PART_IN        = 1
	};

    user_sysarg_check_player_num_out out={0};
	int num = 0;
    ret= this->sys_arg.get_value(1103, &num);
	if(num >= 10000){
		out.state = CANNOT_PART_IN;
	}
	else{
		ret = this->sys_arg.set_value(1103, num+1);
		out.state = PART_IN;
	}

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 *龙族大冒险，全局表拼接宝藏地图 
 */
int Croute_func::user_sysarg_matching_map(DEAL_FUN_ARG)
{
	enum{
        NON_REPETITION = 0,//没有重复拼接
        REPETITION =   1 //地图已有，重复拼接
    };
    user_sysarg_matching_map_in *p_in=PRI_IN_POS;
    user_sysarg_matching_map_out out={0};
    int flag = 0;
    ret = this->sys_arg.get_value(1105, &flag);
	uint32_t record_count = 0;
    if(flag == 0){

        ret = this->sysarg_dragon_explore.insert(p_in->itemid, 1);
        if(ret != SUCC){
            out.flag = REPETITION;
        }
        else{
			this->sysarg_dragon_explore.get_count(&record_count);
			if(record_count == 60){
				this->sys_arg.set_value(1105, 1);
			}
        }
        if(record_count == 60 && flag == 0){
            out.count = 1;
			//this->sys_arg.set_value(1105, (int)(time(0)));

        }
        else{
            out.count = 0;
        }

    }
    else{
        out.flag = REPETITION;
        out.count = 0;

    }

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 拼接地图成功，开启冒险，删除地图碎片记录
 */
int Croute_func::user_sysarg_drop_map(DEAL_FUN_ARG)
{
    ret = this->sysarg_dragon_explore.drop();
	ret = this->sys_arg.set_value(1105,0);

    STD_RETURN(ret);
}
/*
 * 龙族大冒险，查询地图碎片
 */
int Croute_func::user_sysarg_get_map(DEAL_FUN_ARG)
{
    user_sysarg_get_map_out_header  out_header ={ 0 };
    user_sysarg_get_map_out_item *p_out_item = 0;
    ret = this->sysarg_dragon_explore.get_all(&p_out_item, &out_header.count);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 龙族大冒险，开启冒险, 置状态
 */
int Croute_func::user_explore_get_key(DEAL_FUN_ARG)
{

	enum{
		NEED_GET_INIT     = 0x00, //初始状态
		NEED_GET_FIRST_KEY = 0x01, //需要获取第一把钥匙
		NEED_GET_SECOND_KEY = 0x02,//需要获取第二把钥匙
		NEED_GET_THIRD_KEY = 0x04,//需要获取第三把钥匙
		NEED_GET_ULTIMAT = 0x08,//最终状态
	};
	user_explore_get_key_out out = { 0 };
	uint32_t key_id[] = {190898, 190899, 190900};	

	user_del_attire_in del_item = { 0 };
	del_item.attireid =  1351242;
	del_item.attiretype = 99;
	del_item.count = 100;
	del_item.maxcount=99999;
	ret=this->user_del_attire(RECVBUF_USERID ,&del_item);
	if(ret != SUCC){
		return ret;
	}

	uint32_t count = 0;
	attire_count *p_tmp = 0;
	ret = this->user_attire.get_list_by_attireid_interval(RECVBUF_USERID, key_id[0], key_id[2]+1, 2, &count, &p_tmp);
	uint32_t contribute = 0;
    ret = this->user_dragon_explore.query(RECVBUF_USERID, &contribute, &out.state);
	if(ret != SUCC){
		ret = this->user_dragon_explore.insert(RECVBUF_USERID, 0, 0);
	}
	DEBUG_LOG("userid: %u, count: %u", RECVBUF_USERID, count);
	if(out.state == NEED_GET_INIT)
	{
		if(count == 0){
			out.state = 0x01;
		}
		else{
			for(uint32_t k = 0; k < count; ++k){
				for(uint32_t i = 0; i < sizeof(key_id)/sizeof(uint32_t); ++i){
					if((p_tmp+k)->attireid == key_id[i]){
						if((p_tmp+k)->attireid != key_id[2]){
							out.state &= ~(1<<i);
							out.state |= (1 << (i+1));
						}
						else{
							out.state &= ~(1<<i);
						}
					}//if
				}//for	
			}
		}//else
		
		DEBUG_LOG("userid: %u, state: %u", RECVBUF_USERID, out.state);
		this->user_dragon_explore.update(RECVBUF_USERID, "state", out.state);
	}
	if(p_tmp != 0){
		free(p_tmp);
	}

	STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * 龙族大冒险，清状态
 */
int Croute_func::user_explore_clear_state(DEAL_FUN_ARG)
{
	enum{
		NEED_GET_INIT     = 0x00, //初始状态
		NEED_GET_FIRST_KEY = 0x01, //需要获取第一把钥匙
		NEED_GET_SECOND_KEY = 0x02,//需要获取第二把钥匙
		NEED_GET_THIRD_KEY = 0x04,//需要获取第三把钥匙
		NEED_GET_ULTIMAT = 0x08,//最终状态
	};
    user_explore_clear_state_out out = { 0 };

	//uint32_t key_id[] = {190898, 190899, 190900};	
	uint32_t state = 0, contribute = 0;
	//uint32_t count = 0;
    ret = this->user_dragon_explore.query(RECVBUF_USERID, &contribute, &state);

	user_add_attire_in  add_item = {0};
	if(state == NEED_GET_FIRST_KEY){
		add_item.attireid = 190898; 
	}
	else if(state == NEED_GET_SECOND_KEY){
		add_item.attireid = 190899;
	}
	else if(state == NEED_GET_THIRD_KEY){
		add_item.attireid = 190900;
	}
	if(add_item.attireid != 0){
		add_item.attiretype = 0;
		add_item.count = 1;
		add_item.maxcount = 999999;
		ret = this->user_add_attire(RECVBUF_USERID, &add_item);
		if(ret == SUCC){
			if(state == 4){
				state = NEED_GET_ULTIMAT;
			}
			else{
				state = NEED_GET_INIT;
			}
			this->user_dragon_explore.update(RECVBUF_USERID, "state", state);

		}
	}

	STD_RETURN_WITH_STRUCT(ret,out);

}
/*
 * 龙族大冒险，每轮结束清除人数
 */
int Croute_func::user_sysarg_clear_explore_num(DEAL_FUN_ARG)
{
    ret=this->sys_arg.set_value(1103, 0);

    STD_RETURN(ret);
}

/*
 * 龙族大冒险，查询状态
 */
int Croute_func::user_get_explore_state(DEAL_FUN_ARG)
{
	enum{
		NEED_GET_FIRST_KEY = 0x01, //需要获取第一把钥匙
		NEED_GET_SECOND_KEY = 0x02,//需要获取第二把钥匙
		NEED_GET_THIRD_KEY = 0x04,//需要获取第三把钥匙
	};
    user_get_explore_state_out out={0};
	uint32_t contribute = 0;
    ret = this->user_dragon_explore.query(RECVBUF_USERID, &contribute, &out.state);
	if(ret != SUCC){
		ret = this->user_dragon_explore.insert(RECVBUF_USERID, 0, 0);
	}

    STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * @brief 爱心天使慈善派对：捐赠物品
 */
int Croute_func::sysarg_add_contribute_item(DEAL_FUN_ARG)
{
	sysarg_add_contribute_item_in *p_in = PRI_IN_POS;
	ret = this->sysarg_love_contribute.add_contribute_item(RECVBUF_USERID, p_in);
    //sysarg_christmas_socks做成统一的前十名排行榜的表
	ret = this->sysarg_christmas_socks.renew(RECVBUF_USERID, p_in->modal_cnt, 1);
	STD_RETURN(ret);
}

/*
 * @brief 爱心天使慈善派对：开始竞拍
 */
int Croute_func::sysarg_begin_love_auction(DEAL_FUN_ARG)
{
	sysarg_begin_love_auction_out_header out_header = {0};
	sysarg_begin_love_auction_out_item	*p_out_item = NULL;

	uint32_t start_time = 0;
	ret = this->sysarg_love_auction.get_auction_list(&(out_header.count), &p_out_item, 0, &start_time);
	//out_header.left_time = time(0) - start_time;

	uint32_t count = 0;
	contribute_info p_list[16];	//最多找出16个小摩尔捐的东西
	memset(p_list, 0, sizeof(p_list));
	ret = this->sysarg_love_contribute.renew_contribute_list(&count, p_list);
	DEBUG_LOG("begin auction: count[%u]", count);

	ret = this->sysarg_love_auction.renew_auction_list(count, p_list);
	
	STD_RETURN_WITH_STRUCT_LIST(ret, out_header, p_out_item, out_header.count);
}

/*
 * @brief 爱心天使慈善派对：查询竞拍的物品列表
 */
int Croute_func::sysarg_get_auction_list(DEAL_FUN_ARG)
{
	sysarg_get_auction_list_in*	p_in = PRI_IN_POS;
	sysarg_get_auction_list_out_header  out_header = {0};
	sysarg_get_auction_list_out_item *p_out_item = NULL;
	uint32_t start_time = 0;
	ret = this->sysarg_love_auction.get_auction_list(&(out_header.count), &p_out_item, p_in->old_flag - 1, &start_time);
	out_header.left_time = (uint32_t)time(0) - start_time;
	
//	DEBUG_LOG("sysarg_get_auction_list: left[%u] start[%u]", out_header.left_time, start_time);

	STD_RETURN_WITH_STRUCT_LIST(ret, out_header, p_out_item, out_header.count);
}

/*
 * @brief 爱心天使慈善派对：竞拍物品
 */
int Croute_func::sysarg_auction_item(DEAL_FUN_ARG)
{
	sysarg_auction_item_in *p_in = PRI_IN_POS; 
	sysarg_auction_item_out out = {0};

	auction_list_info item_info = {0};
	ret = this->sysarg_love_auction.get_auction_item(p_in->auction_itemid, &item_info);
	if (ret == USER_ID_NOFIND_ERR) {
		out.ret_state = 1;		//没有这个物品
		ret = SUCC;
	} else {
		if (item_info.auction_money >= p_in->auction_money) {
			out.ret_state = 2;	//钱少了
		} else if (RECVBUF_USERID == item_info.auction_userid) {
			out.ret_state = 3;
		} else {
			ret = this->sysarg_love_auction.set_auction_item(p_in->auction_itemid, RECVBUF_USERID, 
					p_in->auction_money, p_in->auction_nick);
			out.old_auction_userid = item_info.auction_userid;
			out.old_auction_money = item_info.auction_money;
		}
	}
	
	STD_RETURN_WITH_STRUCT(ret, out);
}

/*
 * 拉取肥肥猪倌荣誉
 */
int Croute_func::user_get_piglet_honor(DEAL_FUN_ARG)
{

	char buf[PROTO_MAX_LEN] = { 0 };
    user_get_piglet_honor_out_header *out_header = (user_get_piglet_honor_out_header*)buf;
    user_get_piglet_honor_out_item *p_out_item = (user_get_piglet_honor_out_item*)(buf+sizeof(*out_header));
	//修正加工bug
	{
		uint32_t lit = 0, cur_times = 0, max_times = 0, mul_values = 0;
		ret = this->user_piglet_honor.get_honor_by_id(RECVBUF_USERID, 1, 29, &lit,
					&cur_times, &max_times, &mul_values);
		if(ret == SUCC){
			uint32_t count = 0;
			ret = this->user_temp_item.get_count(RECVBUF_USERID, 1351271, count);
			if(ret != SUCC){
				user_add_attire_in  add_item = {0};
				add_item.attireid = 1351271;
				add_item.attiretype = 99;
				add_item.count = 99;
				add_item.maxcount = 99;
				ret = this->user_add_attire(RECVBUF_USERID, &add_item);
			}
		}
	}
	//修正培育成年猪猪50只
	{
		uint32_t count = 0;	
		ret = this->user_temp_item.get_count(RECVBUF_USERID, 1351280, count);
		uint32_t lit = 0, cur_times = 0, max_times = 0, mul_values = 0;
		ret = this->user_piglet_honor.get_honor_by_id(RECVBUF_USERID, 1, 38, &lit,
					&cur_times, &max_times, &mul_values);
		if(lit == 0 && count > 0){
			ret = this->user_piglet_honor.update_two_cols(RECVBUF_USERID, 1, 38, "light", "cur_times",
				   	1, max_times);
		}
		else if(lit == 1 && count == 0){
			user_add_attire_in  add_item = {0};
			add_item.attireid = 1351280;
			add_item.attiretype = 99;
			add_item.count = 99;
			add_item.maxcount = 99;
			this->user_add_attire(RECVBUF_USERID, &add_item);
		}
		
	}

	//pk连胜改为5次
	{
		uint32_t lit = 0, cur_times = 0, max_times = 0, mul_values = 0;
		ret = this->user_piglet_honor.get_honor_by_id(RECVBUF_USERID, 1, 31, &lit,
					&cur_times, &max_times, &mul_values);
		if(lit == 0) {
			if(cur_times >= 5){
				ret = this->user_piglet_honor.update_two_cols(RECVBUF_USERID, 1, 31, "light", "max_times",
						1, cur_times);
				if(ret == SUCC){
					user_add_attire_in  add_item = {0};
					add_item.attireid = 1351273;
					add_item.attiretype = 99;
					add_item.count = 99;
					add_item.maxcount = 99;
					ret = this->user_add_attire(RECVBUF_USERID, &add_item);

				}
			}//if
			else if(cur_times > 0){
				ret = this->user_piglet_honor.update(RECVBUF_USERID, 1, 31, "max_times", 5);
			}

		}
		else{
			uint32_t count = 0;
			ret = this->user_temp_item.get_count(RECVBUF_USERID, 1351273, count);
			if(ret != SUCC){
				user_add_attire_in  add_item = {0};
				add_item.attireid = 1351273;
				add_item.attiretype = 99;
				add_item.count = 99;
				add_item.maxcount = 99;
				ret = this->user_add_attire(RECVBUF_USERID, &add_item);
			}
		}

	}

	//完成臭臭任务、分馆收藏20只 这两个荣誉特殊，故在此单独处理
	uint32_t guide_task_count = 0;
	ret = this->user_piglet_task.get_guide_task_count(RECVBUF_USERID, &guide_task_count);	
	if(guide_task_count == 10){
		ret = this->user_piglet_honor.insert(RECVBUF_USERID, 1, 28, 1, 0, 10, 10, 0);
		if(ret == SUCC){
			user_add_attire_in  add_item = {0};
			add_item.attireid = 1351270;
			add_item.attiretype = 99;
			add_item.count = 99;
			add_item.maxcount = 99;
			this->user_add_attire(RECVBUF_USERID, &add_item);
		}
	}
	
	uint32_t cnt_in_secondary = 0;
	this->user_piglet.get_secondary_piglet_cnt(RECVBUF_USERID, &cnt_in_secondary,1);
	if(cnt_in_secondary >= 20){
		ret = this->user_piglet_honor.insert(RECVBUF_USERID, 1, 25, 1, 0, 20, 20, 0);
		if(ret == SUCC){
			user_add_attire_in  add_item = {0};
			add_item.attireid = 1351267;
			add_item.attiretype = 99;
			add_item.count = 99;
			add_item.maxcount = 99;
			this->user_add_attire(RECVBUF_USERID, &add_item);
		}
	}
	user_piglet_honor_t *p_tmp = 0;
	uint32_t cnt = 0;
    ret = this->user_piglet_honor.get_all(RECVBUF_USERID, &p_tmp, &cnt);

	uint32_t now = time(0);
	for(uint32_t k = 0; k < cnt; ++k){
		if((p_tmp+k)->type == 0 && (p_tmp+k)->light == 0){
			if(now - (p_tmp+k)->timestamp >= 12*3600){
				(p_tmp+k)->light = 1;
				(p_tmp+k)->cur_times = 1;
				this->user_piglet_honor.update_two_cols(RECVBUF_USERID, (p_tmp+k)->type, 
						(p_tmp+k)->honorid, "light", "cur_times", 1, 1);
				user_add_attire_in  add_item = {0};
				add_item.attireid = ((p_tmp+k)->honorid - 1)+1351243;
				add_item.attiretype = 99;
				add_item.count = 99;
				add_item.maxcount = 99;
				this->user_add_attire(RECVBUF_USERID, &add_item);
			}	
		}	
		if((p_tmp+k)->cur_times != 0){
			(p_out_item)->honorid = (p_tmp+k)->honorid;
			(p_out_item)->light = (p_tmp+k)->light;
			(p_out_item)->cur_times = (p_tmp+k)->cur_times;
			(p_out_item)->max_times = (p_tmp+k)->max_times;	
			++p_out_item;
			++(out_header->count);
		}
	}
	if(p_tmp != 0){
		free(p_tmp);
	}
	STD_RETURN_WITH_BUF(SUCC, buf, (char*)p_out_item - buf);
}
/*
 * 置肥肥馆挑战荣誉
 */
int Croute_func::user_set_piglet_honor(DEAL_FUN_ARG)
{
    user_set_piglet_honor_in *p_in=PRI_IN_POS;

	uint32_t light_flag = 0;
    ret = this->user_piglet_honor.set_honor(RECVBUF_USERID, p_in, &light_flag);
	if(p_in->honorid >= 26 && p_in->honorid <= 40){
		if(light_flag == 1){
			user_add_attire_in  add_item = {0};
			add_item.attireid = 1351268 + (p_in->honorid - 26);
			add_item.attiretype = 99;
			add_item.count = 99;
			add_item.maxcount = 99;
			ret = this->user_add_attire(RECVBUF_USERID, &add_item);

		}

	}
	
    STD_RETURN(ret);
}
/* 
 *许愿墙，置全局表 
 */
int Croute_func::user_sysarg_set_wish_wall(DEAL_FUN_ARG)
{
	user_sysarg_set_wish_wall_in *p_in = PRI_IN_POS;
    ret = this->sysarg_wish_wall.add(p_in->userid, p_in->nick);

    STD_RETURN(ret);
}
/*
 * 许愿墙，查看若干玩家
 */
int Croute_func::user_sysarg_get_wish_wall(DEAL_FUN_ARG)
{
    user_sysarg_get_wish_wall_in *p_in=PRI_IN_POS;
    user_sysarg_get_wish_wall_out_header  out_header = { 0 };
    user_sysarg_get_wish_wall_out_item *p_out_item = 0;
    ret = this->sysarg_wish_wall.get_some_userid(RECVBUF_USERID, p_in, &p_out_item, &out_header.count);
	ret = this->sysarg_wish_wall.get_total_page(&out_header.page_total);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 许愿墙，玩家写对联，许愿
 */
int Croute_func::user_write_spring_couplet(DEAL_FUN_ARG)
{
	enum{
		WRITE_SUCC = 0,//提交成功
		FIRST_SUCC = 1,//第一次提交成功
		REACH_LIMIT = 2,//到达上限
	};
    user_write_spring_couplet_in *p_in=PRI_IN_POS;
	user_write_spring_couplet_out out = { 0 };
	uint32_t count = 0; 
	ret = this->user_wish_wall.get_count(RECVBUF_USERID, &count);
	if(count >= 30){
		out.state = REACH_LIMIT;
	}
	else{
		ret = this->user_wish_wall.insert(RECVBUF_USERID, p_in->spcp_1, p_in->spcp_2, p_in->spcp_3);
		if(ret == SUCC){
			if(count == 0){
				out.state = FIRST_SUCC;
			}
			else{
				out.state = WRITE_SUCC;
			}
		}
	}

	STD_RETURN_WITH_STRUCT(SUCC, out);
}

/*
 * 查看对联
 */
int Croute_func::user_get_wish_wall(DEAL_FUN_ARG)
{
    user_get_wish_wall_out_header out_header;
	memset(&out_header, 0 ,sizeof(out_header));
	user_get_wish_wall_out_item *p_out_item = 0; 

	ret = this->user_dragon_explore.get_int_value(RECVBUF_USERID, "wish_id", &out_header.wish_id);
	ret = this->user_ex.get_nick(RECVBUF_USERID, out_header.nick);	
    ret = this->user_wish_wall.get_all(RECVBUF_USERID, &p_out_item, &out_header.count);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 全局表t_day 中拉取若干count值
 */
int Croute_func::sysarg_day_get_value(DEAL_FUN_ARG)
{
    sysarg_day_get_value_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(sysarg_day_get_value_in_item));
    sysarg_day_get_value_in_item * p_in_item=(sysarg_day_get_value_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
    sysarg_day_get_value_out_header  out_header = { 0 };
    sysarg_day_get_value_out_item *p_out_item = 0;
    ret=this->usermap_day.get_value_list_by_some_type(RECVBUF_USERID, p_in->count, p_in_item, &p_out_item, &out_header.count);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 许愿墙，玩家许愿
 */
int Croute_func::user_set_wish(DEAL_FUN_ARG)
{
    user_set_wish_in *p_in=PRI_IN_POS;
    user_set_wish_out out={0};
	uint32_t wish_id = 0;
    ret = this->user_dragon_explore.get_int_value(RECVBUF_USERID, "wish_id", &wish_id);

	if(ret != SUCC){
		ret = this->user_dragon_explore.insert(RECVBUF_USERID, 0, 0);
		ret = this->user_dragon_explore.set_int_value(RECVBUF_USERID, "wish_id", p_in->wish_id);
	}
	else{
		if(wish_id != 0){
			out.state = 2;
		}
	   	else{
			ret = this->user_dragon_explore.set_int_value(RECVBUF_USERID, "wish_id", p_in->wish_id);
		}
	}
	
    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 檢查可否搖獎可否產生
 */
int Croute_func::sysarg_check_prob_lahm(DEAL_FUN_ARG)
{
    sysarg_check_prob_lahm_out out={0};
	//ret = this->sysarg_prob_lahm.check(RECVBUF_USERID, &out);
	
	//判断是否可以产生年超拉
	uint32_t super_uid = 0;
	ret = this->sysarg_prob_lahm.get_one_col("super_uid", &super_uid);
	if(super_uid == 0){
		out.is_able_year = 1;
	}
	else{
		out.is_able_year = 0;
	}

	//判断是否可以产生月超拉
	uint32_t datetime = 0;
	ret = this->sysarg_prob_lahm.get_one_col("datetime", &datetime);
	uint32_t now = time(0);
	if(get_date(datetime) == get_date(now)){
		out.is_able_month = 0;
	}
	else{
		uint32_t cnt = 0; 
		prob_super_lahm_t *p_tmp = 0;
		this->sysarg_prob_month_lahm.get_all(&p_tmp, &cnt);
		if(cnt >= 27){
			out.is_able_month= 0; 
		}
		else{
			uint32_t k = 0;
			for(; k < cnt; ++k){
				if((p_tmp+k)->userid == RECVBUF_USERID){
					break;
				}
			}
			if(k >= cnt){
				out.is_able_month= 1;
			}
			else{
				 out.is_able_month= 0;
			}
		}
	}//else

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 產生隨機超拉
 */
int Croute_func::sysarg_add_prob_lahm(DEAL_FUN_ARG)
{
    sysarg_add_prob_lahm_in *p_in=PRI_IN_POS;
	uint32_t now = time(0);
	if(p_in->flag == 2){//一年超拉
		ret = this->sysarg_prob_lahm.update_all(RECVBUF_USERID, now, p_in->nick);
		if(ret != SUCC){
			ret = this->sysarg_prob_lahm.insert(RECVBUF_USERID, p_in->nick, now, 0);
		}
	}
	else{//一月超拉
		ret = this->sysarg_prob_month_lahm.insert(RECVBUF_USERID, now, p_in->nick);	
		ret = this->sysarg_prob_lahm.update_one_col("datetime", now);
		if(ret != SUCC){
			char nick[NICK_LEN] = { 0 };
			ret = this->sysarg_prob_lahm.insert(0, nick, 0, now);
		}
	}

    STD_RETURN(SUCC);
}
/*
 * 查看随机超拉
 */
int Croute_func::sysarg_get_prob_lahm(DEAL_FUN_ARG)
{

	char buf[PROTO_MAX_LEN] = { 0 };
    sysarg_get_prob_lahm_out_header  *out_header = (sysarg_get_prob_lahm_out_header*)buf;
    sysarg_get_prob_lahm_out_item *p_out_item = (sysarg_get_prob_lahm_out_item*)(buf+sizeof(sysarg_get_prob_lahm_out_header));

    ret = this->sysarg_prob_lahm.get_all(&out_header->super_lahm, &out_header->datetime, out_header->nick);
	prob_super_lahm_t *p_tmp = 0;
	ret = this->sysarg_prob_month_lahm.get_all(&p_tmp, &out_header->count);

	DEBUG_LOG("size: %lu", (char*)p_out_item - buf);
	memcpy((char*)p_out_item, (char*)p_tmp, sizeof(prob_super_lahm_t)*out_header->count);
	char* p_offset = (char*)p_out_item + sizeof(prob_super_lahm_t)*out_header->count;
	if(p_tmp != 0){
		free(p_tmp);
	}
	DEBUG_LOG("size: %lu", p_offset - buf);

	STD_RETURN_WITH_BUF(SUCC, buf, p_offset - buf);
}

/*
 * 设置两队能量值
 */
int Croute_func::sysarg_set_two_team_energy(DEAL_FUN_ARG)
{
    sysarg_set_two_team_energy_in *p_in=PRI_IN_POS;
	int32_t first_energy = 0;
	int32_t second_energy = 0;
    ret = this->sys_arg.get_value(1106, &first_energy);
    ret = this->sys_arg.get_value(1107, &second_energy);
	first_energy = first_energy + p_in->first_team;	
	second_energy = second_energy +  p_in->second_team;

    ret = this->sys_arg.set_value(1106, first_energy);
	ret = this->sys_arg.set_value(1107, second_energy);

	//uint32_t buf_barr[4]={ RECVBUF_USERID, 1};
	//if(p_in->first_team != 0){
		//msglog(this->msglog_file, 0x0409C304, time(NULL), buf_barr, 8);
	//}
	//else{
		//msglog(this->msglog_file, 0x0409C303, time(NULL), buf_barr, 8);
	//}

    STD_RETURN(ret);
}

/*
 *查看两队能量值 
 */
int Croute_func::sysarg_get_two_team_energy(DEAL_FUN_ARG)
{
    sysarg_get_two_team_energy_out out={0};
    ret = this->sys_arg.get_value(1106, &out.first_team);
    ret = this->sys_arg.get_value(1107, &out.second_team);
	if(ret != SUCC){
		ret = this->sys_arg.set_value(1106, 0);
		ret = this->sys_arg.set_value(1107, 0);
		out.first_team = 0;
		out.second_team = 0;
	}

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 *记录猜对玩家 
 */
int Croute_func::sysarg_add_guess_price(DEAL_FUN_ARG)
{
    sysarg_add_guess_price_in *p_in=PRI_IN_POS;
    ret = this->sysarg_guess_price.insert(RECVBUF_USERID, p_in->nick, p_in->itemid, p_in->price);

    STD_RETURN(ret);
}
/*
 * 拉取记录
 */
int Croute_func::sysarg_get_guess_price(DEAL_FUN_ARG)
{
    sysarg_get_guess_price_in *p_in=PRI_IN_POS;
    sysarg_get_guess_price_out_header  out_header = { 0 };
    sysarg_get_guess_price_out_item *p_out_item = 0;
    ret = this->sysarg_guess_price.get_records_by_date(RECVBUF_USERID, p_in->date, &p_out_item, &out_header.count);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 置春节登陆次数
 */
int Croute_func::user_spring_festival_login(DEAL_FUN_ARG)
{
	uint32_t count = 0, date = 0;
    ret = this->user_continue_login.select(RECVBUF_USERID, 3, &count, &date);
	if(ret != SUCC){
		ret = this->user_continue_login.insert(RECVBUF_USERID, 3, 1);
	}
	else{
		uint32_t today =get_date(time(0));
		if(today != date){
			ret = this->user_continue_login.update_all(RECVBUF_USERID, 3, count+1, today);
		}
	}

    STD_RETURN(ret);
}

/*
 *春节登陆领取奖励 
 */
int Croute_func::user_spring_festival_recive_award(DEAL_FUN_ARG)
{
	char buf[PROTO_MAX_LEN] = { 0 };
    user_spring_festival_recive_award_in *p_in=PRI_IN_POS;
	DEBUG_LOG("days: %u",  p_in->days);
	uint32_t up_limit_days = 0;
#ifndef TW_VER
	up_limit_days = 13;
#else
	up_limit_days = 10;
#endif
	if(p_in->days > up_limit_days){
        return NOT_CORRECT_DAYS_ERR;
    }
    if(p_in->days > (up_limit_days-3) && p_in->days <= up_limit_days){
        p_in->days = up_limit_days - 3;
    }	

	
    user_spring_festival_recive_award_out_header  *out_header = (user_spring_festival_recive_award_out_header*)buf;
    user_spring_festival_recive_award_out_item *p_out_item = (user_spring_festival_recive_award_out_item*)
		(buf+sizeof(user_spring_festival_recive_award_out_header));
	char* p_offset = (char*)p_out_item;
	uint32_t count = 0, flags = 0;
    ret = this->user_continue_login.get_two_cols(RECVBUF_USERID, 3, "count", "flags", &count, &flags); 
	DEBUG_LOG("days: %u, count: %u, flags: %u",  p_in->days, count, flags);

	if( p_in->days <= count){
		if((flags & (1 <<(p_in->days - 1))) != 0){
			return SPRING_LOGIN_AWARD_ALREADY_RECEIVE_ERR;
		}		
		//给礼物
		{
			 user_add_attire_in  add_item[][3] = {
				 //一级礼包
				 { {1, 160176, 1, 99 }, { 0,1230058,2, 99999999}, {0, 16012, 5, 99999999} },

				 //二级礼包
				 { {1, 160181, 1, 1}, { 1,160182,1, 1}, {0, 16012, 10, 99999999} },

				 //三级礼包
				 { {2,1220254 , 1, 1 }, { 0,1230089,2, 99999999}, {0, 16012, 15, 99999999} },

				 //四级礼包
				 { {1, 160175, 1, 99}, { 1,160185,1, 1}, {0, 16012, 20, 99999999} },

				 //五级礼包
				 { {1, 160183, 1, 1}, { 1,160687,1, 99}, {0, 16012, 25, 99999999} },

				 //六级礼包
				 { {1, 160690, 1, 99 }, { 1,160686,1, 99}, {0, 16012, 30, 99999999} },

				 //七级礼包
				 { {0, 14109, 1, 1 }, { 36,1593057,1, 99999999}, {0, 16012, 35, 99999999} },

				 //八级礼包
				 { {1, 160188, 1, 99 }, { 1,160885,1, 99}, {0, 16012, 40, 99999999} },

				 //九级礼包
				 { {1, 160189, 1, 99}, { 0,1353305,1, 99999999}, {0, 16012, 45, 99999999} },

				 //十级礼包
				 { {36, 1593055, 1, 99999999 }, { 1,160177,1, 99}, {0, 16012, 50, 99999999} },
			 };
			 out_header->count  = 3; 
			 for(uint32_t k = 0; k < 3; ++k){
				ret = this->user_add_attire(RECVBUF_USERID, &add_item[p_in->days-1][k]);
				(p_out_item+k)->itemid = add_item[p_in->days-1][k].attireid;
				(p_out_item+k)->count = add_item[p_in->days-1][k].count;
				 p_offset = p_offset + sizeof(user_spring_festival_recive_award_out_item);
			 }
			 if(p_in->days - 1 == 9){
				user_add_attire_in tmp = { 0 };	
				tmp.attireid = 1353312; 
				tmp.attiretype = 0;
				tmp.count = 1;
				tmp.maxcount = 99999999;
				ret = this->user_add_attire(RECVBUF_USERID, &tmp);
				(p_out_item+3)->itemid = 1353312;
				(p_out_item+3)->count = 1;
				 p_offset = p_offset + sizeof(user_spring_festival_recive_award_out_item);
				out_header->count = out_header->count+1;
			 }
#ifdef TW_VER
		 if(p_in->days - 1 == 6){
				user_add_attire_in tmp = { 0 };
                tmp.attireid = 1353312;
                tmp.attiretype = 0;
                tmp.count = 1;
                tmp.maxcount = 99999999;
                ret = this->user_add_attire(RECVBUF_USERID, &tmp);
                (p_out_item+3)->itemid = 1353312;
                (p_out_item+3)->count = 1;
                 p_offset = p_offset + sizeof(user_spring_festival_recive_award_out_item);
                out_header->count = out_header->count+1;
		 }
#endif
		}
		ret = this->user_continue_login.update_flags(RECVBUF_USERID, 3, flags | (1 << (p_in->days-1)));
	}

	STD_RETURN_WITH_BUF(SUCC, buf, p_offset - buf);
}

/*
 * 查看登陆天数和领取情况
 */
int Croute_func::user_get_spring_festival_login_info(DEAL_FUN_ARG)
{
    user_get_spring_festival_login_info_out out={0};
    ret = this->user_continue_login.get_two_cols(RECVBUF_USERID, 3, "count", "flags", &out.count, &out.flags);

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 饕餮晚宴
 */
int Croute_func::user_set_spring_feast(DEAL_FUN_ARG)
{
    user_set_spring_feast_in *p_in=PRI_IN_POS;
    user_set_spring_feast_out out={0};//0不成功， 1成功
	uint32_t value = 0;
    ret = this->user_dragon_explore.get_int_value(RECVBUF_USERID, "contribute", &value);
	if(ret != SUCC){
		 ret = this->user_dragon_explore.insert(RECVBUF_USERID, p_in->start_time, 0);
		 out.state = 1;
	}
	else{
		if(value != p_in->start_time){
			ret = this->user_dragon_explore.set_int_value(RECVBUF_USERID, "contribute", p_in->start_time);
			out.state = 1;
		}
	}
    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 领取许愿物品
 */
int Croute_func::user_get_wish_award(DEAL_FUN_ARG)
{
	user_get_wish_award_out out = { 0 };
    ret = this->user_dragon_explore.get_int_value(RECVBUF_USERID, "wish_id", &out.wish_id);
	if(out.wish_id != 0 && out.wish_id != 1){
		ret = this->user_dragon_explore.set_int_value(RECVBUF_USERID, "wish_id", 1);
	}
    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 *置vip周连续登陆 
 */
int Croute_func::user_vip_continue_week_login(DEAL_FUN_ARG)
{
	bool is_vip = false;
    ret = this->user_ex.get_vip(RECVBUF_USERID, &is_vip);
	if(is_vip){
		ret = this->user_continue_login.update_info(RECVBUF_USERID, 6);
		if(ret != SUCC){
			uint32_t now = time(0);
			ret = this->user_continue_login.insert(RECVBUF_USERID, 6, 1, now, 1);

		}
	}

    STD_RETURN(SUCC);
}
/*
 * 查看连续登陆信息
 */
int Croute_func::user_vip_get_continue_week(DEAL_FUN_ARG)
{
	user_vip_get_continue_week_in *p_in = PRI_IN_POS;
    user_vip_get_continue_week_out out={0};
    ret = this->user_continue_login.get_two_cols(RECVBUF_USERID, p_in->type, "count", "flags", &out.count, &out.flags);
	if(out.count >= 1){
		if(out.count > 3){
			out.count = 3;
		}
		uint32_t tmp_flags = out.flags;
		out.flags = (out.flags >> ((out.count - 1)*2)) & 3;
		if(out.count == 3){
			if(((tmp_flags >> 2) & 0x03) == 1 && ((tmp_flags >> 4) & 0x03) != 0){
				 out.flags= (tmp_flags>> 2) & 3;
			}
		}
	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * vip连续登陆领取奖品
 */
int Croute_func::user_vip_get_week_ward(DEAL_FUN_ARG)
{
	char buf[PROTO_MAX_LEN] = { 0 };
    user_vip_get_week_ward_out_header *out_header=(user_vip_get_week_ward_out_header*)buf;
	user_vip_get_week_ward_out_item *p_out_item = (user_vip_get_week_ward_out_item*)(buf+sizeof(user_vip_get_week_ward_out_header));
	uint32_t itemids[] = { 1613918, 1613924, 1613926};
	uint32_t flags = 0;
	int ret = this->user_continue_login.get_flags(RECVBUF_USERID, 6, &flags);

	user_add_attire_in tmp = { 0 };
	tmp.attiretype = 36;
	tmp.count = 1;
	tmp.maxcount = 0xFFFFFFFF;

	for(int32_t index = 2; index >= 0; --index){
		if(((flags >> (index *2)) & 0x03) == 1){
			flags = flags & (~(3 << index*2));
			flags = flags|(2<<(index*2));
			for(int32_t k = 0; k < index+1; ++k){
				(p_out_item + out_header->count)->itemid = itemids[k];
				(p_out_item + out_header->count)->count = 1;
				++out_header->count;
				tmp.attireid = itemids[k];
				ret = this->user_add_attire(RECVBUF_USERID, &tmp);
			}
			out_header->state = 1;
			break;
		}
	}
	ret = this->user_continue_login.update_flags(RECVBUF_USERID, 6, flags);
		
	STD_RETURN_WITH_BUF(SUCC, buf, sizeof(*out_header)+out_header->count*sizeof(user_vip_get_week_ward_out_item));
}
/*
 * 置周末连续登陆
 */
int Croute_func::user_set_weekend_login(DEAL_FUN_ARG)
{
    ret = this->user_continue_login.set_continue_login_weekend(RECVBUF_USERID, 5);

    STD_RETURN(SUCC);
}
/*
 * 获取周末连续登陆礼包
 */
int Croute_func::user_get_weekend_login_award(DEAL_FUN_ARG)
{
	user_get_weekend_login_award_in* p_in = PRI_IN_POS;
    ret = this->user_continue_login.update_flags(RECVBUF_USERID, 5, p_in->cnt);

    STD_RETURN(SUCC);
}
/*
 * 周末登陆
 */
int Croute_func::user_get_login_weekend(DEAL_FUN_ARG)
{
	user_get_login_weekend_out out={ 0 };
    ret = this->user_continue_login.get_two_cols(RECVBUF_USERID, 5, "count", "flags" ,
		   	&out.count, &out.flags);

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 *经典服装回顾，给服装评分, 全局表 
 */
int Croute_func::sysarg_add_mark_attire(DEAL_FUN_ARG)
{
    sysarg_add_mark_attire_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(sysarg_add_mark_attire_in_item));
	sysarg_add_mark_attire_in_item *p_in_item = (sysarg_add_mark_attire_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
	for(uint32_t k = 0; k < p_in->count; ++k){
		ret = this->sysarg_mark_attire.add((p_in_item+k)->attireid, (p_in_item+k)->score, 1);
	}

    STD_RETURN(SUCC);
}

/*
 *经典服装回顾，查看评分,全局表
 */
int Croute_func::sysarg_get_mark_attire(DEAL_FUN_ARG)
{
	sysarg_get_mark_attire_out_header  out_header = { 0 };
	sysarg_get_mark_attire_out_item *p_out_item = 0;
	ret = this->sysarg_mark_attire.select_all(&out_header.count, &p_out_item);

	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);

}
/*
 * 经典服装回顾展，玩家评分，或修改分数
 */
int Croute_func::user_set_mark_attire(DEAL_FUN_ARG)
{
    user_set_mark_attire_in_header *p_in=PRI_IN_POS;
	CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_set_mark_attire_in_item));
    user_set_mark_attire_in_item *p_in_item = (user_set_mark_attire_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;;
	
	for(uint32_t k = 0; k < p_in->count; ++k){
		ret = this->user_mark_attire.insert(RECVBUF_USERID, (p_in_item+k)->attireid, (p_in_item+k)->score);
		if(ret != SUCC){
			ret = this->user_mark_attire.update(RECVBUF_USERID, (p_in_item+k)->attireid, (p_in_item+k)->score);
		}
	}
    STD_RETURN(SUCC);

}
/*
 * 经典服装回顾展，查看玩家评分
 */
int Croute_func::user_get_mark_attire(DEAL_FUN_ARG)
{
    user_get_mark_attire_out_header  out_header = {0};
    user_get_mark_attire_out_item *p_out_item = 0;
    ret = this->user_mark_attire.get_all(RECVBUF_USERID, &out_header.count, &p_out_item);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 强化冰雪精灵龙
 */
int Croute_func::user_strength_ice_dragon(DEAL_FUN_ARG)
{
	const uint32_t itemid = 1351304;

	const uint32_t new_dragonid = 1350045;//雪麒麟座骑
	const uint32_t fairy_dragonid = 1350044;//冰雪精灵座骑 

	const uint32_t fairy_angel = 1354224;//冰雪精灵天使
	const uint32_t dragon_angel= 1354228;//雪麒麟天使
	uint32_t item_count = 0;
	ret = this->user_temp_item.get_count(RECVBUF_USERID, itemid, item_count);
	uint32_t flag = 0;
	if(item_count > 0){
		uint32_t fairy_count = 0;//冰雪精灵天使个数
		this->user_paradise_contract.get_another_count(RECVBUF_USERID, fairy_angel, fairy_count);

		uint32_t dr_angel_count = 0;//雪麒麟天使个数	
		this->user_paradise_contract.get_another_count(RECVBUF_USERID, dragon_angel, dr_angel_count);
		
			
		DEBUG_LOG("dr_angel_count: %u, fairy_count: %u", dr_angel_count, fairy_count);
		if(dr_angel_count == 0){
			if(fairy_count == 1){
				ret = this->user_dragon.del(RECVBUF_USERID, fairy_dragonid);
				//开启事务
				STD_CLOSE_AUTOCOMMIT(ret);
				if(ret != SUCC)  {
					return ret;
				}
				ret = this->user_dragon.add(RECVBUF_USERID, new_dragonid);
				if(ret == SUCC){
					ret = this->user_paradise_contract.set_angelid(RECVBUF_USERID, fairy_angel, dragon_angel);
				}
				if(ret==SUCC){
					//提交
					flag = 1;
					STD_COMMIT(ret);
				}else{
					//回滚
					STD_ROLLBACK();
				}
				//关闭事务
				STD_OPEN_AUTOCOMMIT() ;	
				
			}
			else if( fairy_count > 1){
				ret = this->user_paradise_contract.update_count_by_angelid_another(RECVBUF_USERID, fairy_angel, -1);
				//开启事务
				STD_CLOSE_AUTOCOMMIT(ret);
				if(ret != SUCC)  {
					return ret;
				}
				ret = this->user_paradise_contract.insert(RECVBUF_USERID, dragon_angel, 1, 3); 
				if(ret == SUCC){
					ret = this->user_dragon.add(RECVBUF_USERID, new_dragonid);
				}
				if(ret==SUCC){
                    //提交
                    flag = 1;
                    STD_COMMIT(ret);
                }else{
                    //回滚
                    STD_ROLLBACK();
                }
                //关闭事务
                STD_OPEN_AUTOCOMMIT() ;
			}		
		}
		else{
			if(fairy_count > 0){
				ret = this->user_paradise_contract.del_contract_angel_another(RECVBUF_USERID, fairy_angel, fairy_count-1);
				if(ret == SUCC){
					if(fairy_count == 1){
						ret = this->user_dragon.del(RECVBUF_USERID, fairy_dragonid);
					}
					if(ret == SUCC){
						ret = this->user_paradise_contract.update_count_by_angelid(RECVBUF_USERID, dragon_angel, 1);
						flag = 1;
					}
				}
				
			}
		}
		if(flag == 1){
			user_del_attire_in del_item = { 0 };
			del_item.attireid = itemid;
			del_item.attiretype = 99;
			del_item.count = 1;
			del_item.maxcount=99999;
			ret=this->user_del_attire(RECVBUF_USERID ,&del_item);
		}
	}

    STD_RETURN(ret);
}
/*
 * 玩家获取金钥匙
 */
int Croute_func::user_get_golden_key(DEAL_FUN_ARG)
{
	user_get_golden_key_in *p_in=PRI_IN_POS;
	user_get_golden_key_out out = { 0 };	

	user_del_attire_in del_item = { 0 };
	del_item.attireid = p_in->itemid;
	del_item.attiretype = 0;
	del_item.count = 1;
	del_item.maxcount=99999;
	ret=this->user_del_attire(RECVBUF_USERID ,&del_item);
	if(ret == SUCC){
		uint32_t range = 0;
		if(p_in->itemid == 190912){
			range = 5;	
		}
		else if(p_in->itemid == 190913){
			range = 2;	
		}
		uint32_t numerator = 0;
		ret = this->user_temp_active.get_one(RECVBUF_USERID, 0, "value_1", &numerator);
		if(ret != SUCC){
			numerator = range;
		}
		else{
			numerator += range;
			if(numerator > 100){
				numerator = 100;
			}
		}
		ret = this->user_temp_active.add(RECVBUF_USERID, 0, numerator, 0);
		
		uint32_t golden_key_cnt = 0;	
		ret = this->user_attire.get_count(RECVBUF_USERID, 190915, golden_key_cnt);	
		user_add_attire_in tmp = { 0 };
		uint32_t random = rand()%100;
		if(golden_key_cnt != 0){
			random = numerator + 1;
		}

		if(random < numerator){
			out.itemid = 190915;	
			out.count = 1;
			tmp.attiretype = 0;
			tmp.maxcount = 1;
		}
		else{
			uint32_t rand2 = rand()%100;
			if(rand2 < 50){
				out.itemid = 0;
				out.count = 10;
			}
			else if( rand2 < 80){
				out.itemid = 0;
				out.count  = 100;
			}
			else if(rand2 < 90){
				out.itemid = 0;
				out.count = 1000;
			}
			else if(rand2 < 96){
				out.itemid = 16012;
				out.count = 1;
			}
			else if(rand2 < 99){
				out.itemid = 16012;
				out.count = 2;
			}
			else{
				out.itemid = 16012;
				out.count = 10;
			}
			tmp.attiretype = 0;
			tmp.maxcount = 99999999;
		}
		if(out.itemid != 0){
			tmp.attireid = out.itemid;
			tmp.count = out.count;
			ret = this->user_add_attire(RECVBUF_USERID, &tmp);
		}
		else{
			int money = 0;
			ret = this->user.change_xiaomee(RECVBUF_USERID, out.count, XIAOMEE_USE_GOLDEN_KEY, 0, &money);
		}
	}

    STD_RETURN_WITH_STRUCT(ret,out);
}


/*
 * 肥肥馆机械工坊,肥肥管系统第三期,2012年2月20日
 */

/*
 * 进入机械工厂
 */
int Croute_func::user_get_piglet_machine_work(DEAL_FUN_ARG)
{

	user_get_piglet_machine_work_in *p_in=PRI_IN_POS;

	char buf[PROTO_MAX_LEN]={ 0 };
	user_get_piglet_machine_work_out_header  *out_header = (user_get_piglet_machine_work_out_header*)buf;
	ret = this->user_piglet_house.get_levels(RECVBUF_USERID, &out_header->current_exp,
			&out_header->current_level,&out_header->machine_level, &out_header->warhouse_level);
	ret = this->user_piglet.get_special_piglets(RECVBUF_USERID, 2, &out_header->work_piglets_cnt);
	DEBUG_LOG("current_exp: %u, current_level: %u, machine_level: %u, warehouse_level: %u", out_header->current_exp,
			out_header->current_level, out_header->machine_level, out_header->warhouse_level);
	char *p_offset = buf+sizeof(user_get_piglet_machine_work_out_header);
	user_get_piglet_machine_work_out_item_1 *p_out_item_1 = 0;
	ret = this->user_piglet.get_machine_piglets(RECVBUF_USERID, &out_header->count_1, &p_out_item_1);

	memcpy(p_offset, (char*)p_out_item_1, sizeof(user_get_piglet_machine_work_out_item_1)*out_header->count_1);
	p_offset += sizeof(user_get_piglet_machine_work_out_item_1)*out_header->count_1;
	if(p_out_item_1 != 0){
		free(p_out_item_1);
	}

	user_get_piglet_machine_work_out_item_2 *p_out_item_2 = 0;
	ret = this->user_piglet_work.get_work_info(RECVBUF_USERID, &out_header->count_2, &p_out_item_2);
	if( out_header->count_2 == 0){
		if(RECVBUF_USERID == p_in->uid){
			out_header->first_flag = 1;
			const uint32_t stove_id = 1;
			const uint32_t m_tool_id = 1;
			work_piglets_t work_piglets;
			memset(&work_piglets, 0, sizeof(work_piglets_t));
			this->user_piglet_work.add(RECVBUF_USERID, 1, 1, stove_id, 0, &work_piglets, 0, 0);
			this->user_piglet_work.add(RECVBUF_USERID, 2, 1, m_tool_id, 0, &work_piglets, 0, 0);
			ret = this->user_piglet_work.get_work_info(RECVBUF_USERID, &out_header->count_2, &p_out_item_2);

		}
		else{
			 out_header->first_flag = 2;
		}
	}
	memcpy(p_offset, (char*)p_out_item_2, sizeof(user_get_piglet_machine_work_out_item_2)*out_header->count_2);
	p_offset += sizeof(user_get_piglet_machine_work_out_item_2)*out_header->count_2;
	if(p_out_item_2 != 0){
		free(p_out_item_2);
	}	
	
	STD_RETURN_WITH_BUF(ret, buf, p_offset- buf);
}

/*
 * 派遣猪仔去探矿
 */
int Croute_func::user_send_piglet_mining(DEAL_FUN_ARG)
{
    user_send_piglet_mining_in *p_in=PRI_IN_POS;
	user_send_piglet_mining_out out = {  0 };
	uint32_t count = 0;
	ret = this->user_piglet_mining.get_map_exist(RECVBUF_USERID, p_in->mapid, &count);
	if(count == 0){
		uint32_t now = time(0);
		ret = this->user_piglet.send_to_mining(RECVBUF_USERID, p_in->piglet_id, p_in->need_energy, &out.state);
		if(out.state == 1){
			ret = this->user_piglet_mining.add(RECVBUF_USERID, p_in->mapid, p_in->piglet_id, now + p_in->need_time);
		}
	}
	else{
		out.state = 0;
	}
	

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 *熔炉熔炼
 */
int Croute_func::user_piglet_melt_ore(DEAL_FUN_ARG)
{
	enum{
		RET_SUCC           = 0,//成功
		ORE_NOT_ENOUGH     = 1,//矿石不够
		STOVE_NOT_EXIST    = 2,//熔炉不存在
		PIGLET_NOT_SATISFY = 3,//猪仔不满足条件
		STOVE_NOT_FIT_ORE  = 4,//熔炉与矿石不匹配
	};
    user_piglet_melt_ore_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->piglet_count)*sizeof(user_piglet_melt_ore_in_item));
    user_piglet_melt_ore_in_item * p_in_item=(user_piglet_melt_ore_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
	
	DEBUG_LOG("[stove_index: %u  ore_id: %u  piglet_count: %u]", p_in->stove_index, p_in->ore_id, p_in->piglet_count);
    user_piglet_melt_ore_out out = { 0 };
	//校验猪是否满足	
	uint32_t temp_state = 0;
	ret = this->user_piglet.check_piglets_whether_work(RECVBUF_USERID, p_in->piglet_count, p_in_item, &temp_state,
			1, p_in->ore_count);
	if(temp_state == 0){
		out.state = PIGLET_NOT_SATISFY;	
		STD_RETURN_WITH_STRUCT(SUCC,out);
	}
	
	//校验熔炉是否存在	
	const uint32_t type = 1;
	uint32_t stove_cnt = 0;
	ret = this->user_piglet_work.get_machine(RECVBUF_USERID, type, &stove_cnt);
	if(stove_cnt < p_in->stove_index){
		out.state = STOVE_NOT_EXIST;
		STD_RETURN_WITH_STRUCT(SUCC,out);
	}
	//检验熔炉是否正在工作
	uint32_t work_temp_time = 0;
	ret = this->user_piglet_work.get_one_col(RECVBUF_USERID, 1, p_in->stove_index, "work_time", &work_temp_time);
	if(work_temp_time != 0){
		out.state = STOVE_NOT_EXIST;
		STD_RETURN_WITH_STRUCT(SUCC,out);
	}

	//检验熔炉是否可以熔炼指定矿石
	uint32_t stove = 0;
	ret = this->user_piglet_work.get_one_col(RECVBUF_USERID, 1, p_in->stove_index, "tool_itemid", &stove);
	uint32_t flag = 0;
	this->user_piglet_work.check_tool_satisfy_material(1, stove, p_in->ore_id, &flag);
	if(flag == 0){
		out.state = STOVE_NOT_FIT_ORE; 
		STD_RETURN_WITH_STRUCT(SUCC,out);
	}

	//校验矿石是否足够
	uint32_t ore_count = 0, need_count = 0;	
	ret = this->user_piglet_attire.get_count(RECVBUF_USERID, p_in->ore_id, ore_count);
	ret = this->user_piglet_work.get_need_count(RECVBUF_USERID, p_in->stove_index, p_in->ore_count, &need_count);
	if(ore_count < need_count){
		out.state = ORE_NOT_ENOUGH;
		STD_RETURN_WITH_STRUCT(SUCC,out);

	}
	work_piglets_t work_piglets;
	memset(&work_piglets, 0, sizeof(work_piglets_t));
	for(uint32_t k = 0; k < p_in->piglet_count; ++k){
		//ret = this->user_piglet.update(RECVBUF_USERID, (p_in_item+k)->piglet_index, "work", 1);
		work_piglets.piglets[work_piglets.count] =(p_in_item+k)->piglet_index;
		++work_piglets.count;
	}
	uint32_t ore_time = this->user_piglet_work.get_ore_time(p_in->ore_id, p_in->ore_count);
	uint32_t now = time(0);

	uint32_t consume_energy = 10;
	uint32_t ret_prod_cnt = 0;
	DEBUG_LOG("p_in->ore_count: %u", p_in->ore_count);
	if(p_in->ore_count > 0){
		uint32_t prod_cnt = 0, prod_id = 0;
		this->user_piglet_work.get_stove_product(p_in->ore_id, &prod_id, &prod_cnt);
		ret_prod_cnt = prod_cnt * 10;
		if(p_in->stove_index == 2){
			ret_prod_cnt = 2* ret_prod_cnt;
		}
		else if(p_in->stove_index == 3){
			ret_prod_cnt = 3* ret_prod_cnt;
		}
		//p_in->ore_id = (ret_prod_cnt << 16)| p_in->ore_id; 
		consume_energy = 50;
		DEBUG_LOG("prod_id: %u, prod_cnt: %u", prod_id, prod_cnt);
	}
	DEBUG_LOG("p_in->ore_count: %u, ret_prod_cnt: %u", p_in->ore_count, ret_prod_cnt);
	this->user_piglet_work.start_working(RECVBUF_USERID, type, p_in->stove_index, now+ore_time,
			   	ore_time, &work_piglets, p_in->ore_id, ret_prod_cnt);
	this->user_piglet.start_working(RECVBUF_USERID, p_in_item, p_in->piglet_count, consume_energy);	

	user_del_attire_in del_item = { 0 };
	del_item.attiretype = 36;
	del_item.maxcount=99999;
	del_item.attireid = p_in->ore_id;
	del_item.count = need_count;
	ret=this->user_del_attire(RECVBUF_USERID ,&del_item);

	if(out.state == RET_SUCC){
		out.tool_type = 1;	
		out.tool_index =  p_in->stove_index;
		this->user_piglet_work.get_one_col(RECVBUF_USERID, 1, p_in->stove_index, "need_time", &out.total_time);
		this->user_piglet_work.get_one_another_info(RECVBUF_USERID, 1, p_in->stove_index,
				                &out.tool_level, &out.work_state, &out.left_time);	
	}


    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 查询探矿信息
 */
int Croute_func::user_get_piglet_mining_info(DEAL_FUN_ARG)
{
    user_get_piglet_mining_info_out_header  out_header = { 0 };
    user_get_piglet_mining_info_out_item *p_out_item = 0;
	ret = this->user_piglet_mining.get_all(RECVBUF_USERID, &out_header.count, &p_out_item);
	if(out_header.count != 0){
		piglet_item_t *p_list = 0;
		uint32_t cnt = 0;
		ret = this->user_piglet.get_some_piglet_itemid(RECVBUF_USERID, out_header.count, p_out_item, 
					&p_list, &cnt);
		for(uint32_t k = 0; k < out_header.count; ++k){
			piglet_item_t *iter = std::find(p_list, p_list+cnt, (p_out_item+k)->piglet_id);
			if(iter != p_list + cnt){
				(p_out_item+k)->piglet_itemid = iter->piglet_itemid;
			}
		}
		if( p_list != 0){
			free(p_list);
		}
	}
	
    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 地图探矿完成
 */
int Croute_func::user_finish_some_map_mining(DEAL_FUN_ARG)
{
    user_finish_some_map_mining_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_finish_some_map_mining_in_item));
    user_finish_some_map_mining_in_item * p_in_item=(user_finish_some_map_mining_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
    ret = this->user_piglet.finish_mining(RECVBUF_USERID, p_in->count, p_in_item);
	ret = this->user_piglet_mining.drop(RECVBUF_USERID, p_in->count, p_in_item);

    STD_RETURN(SUCC);
}
/*
 * 机床生产
 */
int Croute_func::user_produce_machine_part(DEAL_FUN_ARG)
{

	enum{
		RET_SUCC           		= 0,//成功
		MATERAIL_NOT_ENOUGH     = 1,//原材料不够
		M_TOOL_NOT_EXIST    	= 2,//机床不存在
		PIGLET_NOT_SATISFY 		= 3,//猪仔不满足条件
		M_TOOL_NOT_FIT_MAT  	= 4,//机床与原材料不匹配
		OBJ_PART_NOT_EXIST  	= 5,//目标零件非法
	};
    user_produce_machine_part_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->piglet_count)*sizeof(user_produce_machine_part_in_item));
    user_produce_machine_part_in_item * p_in_item=(user_produce_machine_part_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
    user_produce_machine_part_out out = { 0 };
	DEBUG_LOG("obj_part: %u, obj_count: %u", p_in->obj_part, p_in->obj_count);
	part_material_t head;
	memset(&head, 0, sizeof(part_material_t));
	ret = this->user_piglet_work.find(p_in->obj_part, p_in->obj_count, &head);
	//校验猪是否满足	
	uint32_t temp_state = 0;
	ret = this->user_piglet.check_piglets_whether_work(RECVBUF_USERID, p_in->piglet_count, p_in_item, &temp_state,
			2, head.need_energy);
	if(temp_state == 0){
		out.state = PIGLET_NOT_SATISFY;	
		STD_RETURN_WITH_STRUCT(SUCC,out);
	}
	//校验机床是否存在	
	const uint32_t type = 2;
	uint32_t m_tool_cnt = 0;
	ret = this->user_piglet_work.get_machine(RECVBUF_USERID, type, &m_tool_cnt);
	if(m_tool_cnt < p_in->m_tool_index){
		out.state = M_TOOL_NOT_EXIST;
		STD_RETURN_WITH_STRUCT(SUCC,out);
	}

	//检验机床是否在生产中
	uint32_t work_temp_time = 0;
	ret = this->user_piglet_work.get_one_col(RECVBUF_USERID, 2, p_in->m_tool_index, "work_time", &work_temp_time);
	if(work_temp_time != 0){
		out.state = M_TOOL_NOT_EXIST;
		STD_RETURN_WITH_STRUCT(SUCC,out);
	}

	//检验机床生产目标零件
	uint32_t need_time = 0;
	if(ret == 0){
		uint32_t m_tool = 0;
		ret = this->user_piglet_work.get_two_col(RECVBUF_USERID, 2, p_in->m_tool_index, "tool_itemid",
			   "need_time",	&m_tool, &need_time);
		for(uint32_t k = 0; k < 3; ++k){
			if(head.materials[k].material_id != 0){
				uint32_t flag = 0;		
				user_piglet_work.check_tool_satisfy_material(2, m_tool, head.materials[k].material_id, &flag);
				//检查原材料类型是否合适
				if(flag == 0){
					out.state = M_TOOL_NOT_FIT_MAT;
					STD_RETURN_WITH_STRUCT(SUCC,out);
				}
				//检查原料数量是否足够
				uint32_t m_count = 0;
				ret = this->user_piglet_attire.get_count(RECVBUF_USERID, head.materials[k].material_id, m_count);
				if(m_count < head.materials[k].count){
					out.state = MATERAIL_NOT_ENOUGH; 
					STD_RETURN_WITH_STRUCT(SUCC,out);
				}

			}
		}//for		
	}
	else{//检查目标零件非法
		out.state = OBJ_PART_NOT_EXIST;
		STD_RETURN_WITH_STRUCT(SUCC,out);
	}
	
	uint32_t now = time(0);
	work_piglets_t w_piglets;
	memset(&w_piglets, 0, sizeof(work_piglets_t));
	for(uint32_t j = 0; j < p_in->piglet_count; ++j){
		//ret = this->user_piglet.update(RECVBUF_USERID, (p_in_item+j)->piglet_index, "work", 1); 
        w_piglets.piglets[w_piglets.count] =(p_in_item+j)->piglet_index;
        ++w_piglets.count;	
	}
	this->user_piglet_work.start_working(RECVBUF_USERID, 2, p_in->m_tool_index, now+head.need_time,
			head.need_time, &w_piglets, head.part_id, head.type);
	this->user_piglet.start_working(RECVBUF_USERID, p_in_item, p_in->piglet_count, head.need_energy);	

	DEBUG_LOG("obj_part: %u, obj_count: %u, need_time: %u, head.part_id: %u, head.type: %u", p_in->obj_part, p_in->obj_count, head.need_time,  head.part_id, head.type);
	user_del_attire_in del_item = { 0 };
	del_item.attiretype = 36;
	del_item.maxcount=99999;
	for(uint32_t i = 0; i < 3; ++i){
		if(head.materials[i].material_id != 0){
			del_item.attireid = head.materials[i].material_id;
			del_item.count = head.materials[i].count;
			ret=this->user_del_attire(RECVBUF_USERID ,&del_item);
		}
	}

	if(out.state == RET_SUCC){
		out.tool_type = 2;	
		out.tool_index =  p_in->m_tool_index;
		this->user_piglet_work.get_one_col(RECVBUF_USERID, 1, p_in->m_tool_index, "need_time", &out.total_time);
		this->user_piglet_work.get_one_another_info(RECVBUF_USERID, 2, p_in->m_tool_index,
				                &out.tool_level, &out.work_state, &out.left_time);	
	}
	
    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 熔炉熔炼完成，或机床加工完成
 */
int Croute_func::user_piglet_finish_work(DEAL_FUN_ARG)
{
	enum{
		MACHINE_NOT_EXIST     = 0,//熔炉或机床不存在
		NOT_ENOUGH_TIME_FINIH = 1,//完成时间没到
		RET_SUCC              = 2,//成功
	};
    user_piglet_finish_work_in *p_in=PRI_IN_POS;
    user_piglet_finish_work_out out={0};
	uint32_t end_time = 0, obj_part = 0;
	work_piglets_t work_piglets;
	memset(&work_piglets, 0, sizeof(work_piglets_t));
    ret = this->user_piglet_work.get_piglets_datetime(RECVBUF_USERID, p_in->tool_type, p_in->tool_index,
			   	&work_piglets, &end_time, &obj_part);
	uint32_t obj_count = 0;	
	ret = this->user_piglet_work.get_one_col(RECVBUF_USERID, p_in->tool_type, p_in->tool_index, "obj_count", &obj_count);
	if(ret == SUCC){
		uint32_t now = time(0);
		if(end_time <= now){
			//for(uint32_t k = 0; k < work_piglets.count; ++k){
				//this->user_piglet.update(RECVBUF_USERID, work_piglets.piglets[k], "work", 0);
			//}
			this->user_piglet.finish_working(RECVBUF_USERID, work_piglets.count, work_piglets.piglets);
			memset(&work_piglets, 0, sizeof(work_piglets_t));
			this->user_piglet_work.finish_working(RECVBUF_USERID, p_in->tool_type, p_in->tool_index, &work_piglets);

			if(p_in->tool_type == 1){

				uint32_t prod_cnt = obj_count;
				uint32_t prod_id = obj_part;
				DEBUG_LOG("prod_id: %u, prod_cnt: %u", prod_id, prod_cnt);
				ret = user_piglet_work.get_stove_product(prod_id, &out.itemid, &out.count);
				if(prod_cnt == 0){
					if(p_in->tool_index == 2){
						out.count *= 2;
					}
					else if(p_in->tool_index == 3){
						out.count *= 3;
					}
				}
				else{
					out.count = prod_cnt;
				}
				DEBUG_LOG("prod_id: %u, prod_cnt: %u, out.count: %u", prod_id, prod_cnt, out.count);
				
			}
			else{
				uint32_t prod_cnt = obj_count;
				uint32_t prod_id = obj_part;
				DEBUG_LOG("prod_id: %u, prod_cnt: %u", prod_id, prod_cnt);
				if(prod_cnt > 0){
					out.itemid = prod_id;
					out.count = prod_cnt;
				}
				else{
					out.itemid = prod_id;
					out.count = 1;
				}
			}
			user_add_attire_in tmp = { 0 };
			tmp.attireid = out.itemid;
			tmp.attiretype = 36;
			tmp.count = out.count;
			tmp.maxcount = 99999999;
			ret = this->user_add_attire(RECVBUF_USERID, &tmp);
			out.state = RET_SUCC;
		}
		else{
			out.state = NOT_ENOUGH_TIME_FINIH;
		}
	}	
	else{
		out.state = MACHINE_NOT_EXIST;
	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 拉取熔炉或机床
 */
int Croute_func::user_get_piglet_work_machine(DEAL_FUN_ARG)
{
	char buf[PROTO_MAX_LEN]={ 0 };
    user_get_piglet_work_machine_in *p_in=PRI_IN_POS;
    user_get_piglet_work_machine_out_header  *out_header = (user_get_piglet_work_machine_out_header*)buf;
    user_get_piglet_work_machine_out_item *p_out_item = (user_get_piglet_work_machine_out_item*)(buf+sizeof( *out_header));
	work_piglets_t work_piglets;
	memset(&work_piglets, 0, sizeof(work_piglets_t));
    ret = this->user_piglet_work.get_one_tool_info(RECVBUF_USERID, p_in->tool_type, p_in->tool_index,
		   	&out_header->tool_level, &out_header->end_time, &work_piglets);
	out_header->tool_index = p_in->tool_index;
	out_header->tool_type = p_in->tool_type;
	out_header->count = work_piglets.count;

	for(uint32_t k = 0; k < out_header->count; ++k){
		(p_out_item+k)->piglet_index = work_piglets.piglets[k];
	}

	STD_RETURN_WITH_BUF(ret, buf, sizeof(*out_header)+ sizeof(*p_out_item)*out_header->count);
}

/*
 * 使用机械工厂道具
 */
int Croute_func::user_use_machine_tools(DEAL_FUN_ARG)
{
    user_use_machine_tools_in *p_in=PRI_IN_POS;
    user_use_machine_tools_out out = { 0 };

	uint32_t state = 0;	
	switch(p_in->tool_id){
		case 1614000://能量块
		case 1614001://超级能量块
			{
				uint32_t dose = 0;
				if(p_in->tool_id == 1614000){
					dose = 10;
				}
				else{
					dose = 1000;
				}
				ret = this->user_piglet.inject_energy(RECVBUF_USERID, p_in->index, &state, dose);
			
				break;
			}
		case 1614002://催化剂
		case 1614003://超级催化剂
			{
				uint32_t time = 0;
				if(p_in->tool_id == 1614002){
					time = 5*60;
				}
				else{
					time = 10*60;
				}
				ret = this->user_piglet_work.accelerate_machine(RECVBUF_USERID, 1, p_in->index, time, &state);
				break;
			}
		case 1614004://白色变速齿轮
		case 1614005://绿色变速齿轮
		case 1614006://蓝色变速齿轮
		case 1614007://紫色变速齿轮
		case 1614008://红色变速齿轮
			{
				uint32_t time = 0;
				if(p_in->tool_id == 1614004){
					time = 5*60;
				}
				else if(p_in->tool_id == 1614005){
					time = 10*60;
				}
				else if(p_in->tool_id == 1614006){
					time = 30*60;
				}
				else if(p_in->tool_id == 1614007){
					time = 60*60;
				}
				else{
					time = 3*60*60; 
				}
				ret = this->user_piglet_work.accelerate_machine(RECVBUF_USERID, 2, p_in->index, time, &state);
				break;
			}
		case 1614009://简易胶水
		case 1614010://专业胶水
		case 1614011://万能胶水
			{
				ret = this->user_piglet_work.slow_down(RECVBUF_USERID, p_in->type, p_in->index, p_in->tool_id, &state);
				break;
			}
		case 1614012://简易溶化剂
		case 1614013://专业溶化剂
		case 1614014://万能溶化剂
			{
				ret = this->user_piglet_work.recover(RECVBUF_USERID, p_in->type, p_in->index, p_in->tool_id, &state);
				break;
			}
		case 1614017://活力饮料
			{

				ret = this->user_piglet.update(RECVBUF_USERID, p_in->index, "pour_times", 0);
				state = 1;
				break;
			}
		
	}//switch
	out.state = state;
	DEBUG_LOG("state: %u", out.state);
    STD_RETURN_WITH_STRUCT(SUCC,out);
}
int Croute_func::user_get_process(DEAL_FUN_ARG)
{
    user_get_process_out out={0};
	//通过userid和type=1获取机械工坊处理到第几步并传出记录
    ret=this->user_temp_active.get_one(RECVBUF_USERID,1,"value_1",&out.value_1);

    STD_RETURN_WITH_STRUCT(SUCC,out);
}

int Croute_func::user_set_process(DEAL_FUN_ARG)
{
    user_set_process_in *p_in=PRI_IN_POS; 
	uint32_t old_process = 0;                          //记录上一次的处理情况
	ret=this->user_temp_active.get_one(RECVBUF_USERID,1,"value_1",&old_process);
	if(p_in->process_number == 0 || p_in->process_number> 7){
		STD_RETURN(SUCC);
	}
	if(((old_process+1)%7)==(p_in->process_number%7))
	{
	    //通过userid和type设置机械工坊处理到第几步，如果之前有记录，则更新该记录，假如没有则增加一条记录
        ret=this->user_temp_active.add(RECVBUF_USERID,1,p_in->process_number,0);
	}
    STD_RETURN(SUCC);
}

int Croute_func::user_get_menue(DEAL_FUN_ARG)
{
	//2, 3, 6, 7, 12, 13, 14,15, 32, 33
	user_get_menue_in *p_in=PRI_IN_POS; 
	user_get_menue_out out={0};
    uint32_t tempdata=0;
	uint32_t value_1 = 0, now = time(0);

	uint32_t old_week_id = 0;
	ret=this->user_temp_active.get_one(RECVBUF_USERID,2,"value_1",&old_week_id);

	uint32_t week_id = get_week_id(now);
	if(week_id != old_week_id){
		this->user_temp_active.add(RECVBUF_USERID, 2, week_id, 0);
		this->user_temp_active.drop_record(RECVBUF_USERID, 32);
		this->user_temp_active.drop_record(RECVBUF_USERID, 33);
	}

	//this->user_temp_active.update(RECVBUF_USERID, 14, 0, 0);
	//this->user_temp_active.update(RECVBUF_USERID, 15, 0, 0);
    switch(p_in->type)
	{
         case 1://皇家订单
             ret=this->user_temp_active.get_one(RECVBUF_USERID,32,"value_1",&value_1);
			 if(ret!=SUCC)
			 {
                 out.exist=0;
			 }
			 else
				 out.exist=1;
			 out.order_id = value_1>>16;
			 out.week_id = value_1 & 0xFFFF;
             ret=this->user_temp_active.get_one(RECVBUF_USERID,32,"value_2",&tempdata);
			 //对获取的字段value_2的高低位进行处理
             out.finish_flag = tempdata>>16;
			 out.week_cnt=tempdata-(out.finish_flag<<16);
			 DEBUG_LOG("finish_flag: %u, week_cnt: %u", out.finish_flag, out.week_cnt);
			 break;
		 case 2://加急订单
             ret=this->user_temp_active.get_one(RECVBUF_USERID,33,"value_1",&out.order_id);
			 if(ret!=SUCC)
			 {
                 out.exist=0; 
			 }
			 else
				 out.exist=1;
			 ret=this->user_temp_active.get_one(RECVBUF_USERID,33,"value_2",&out.finish_flag);
			 out.week_cnt=0;
			 break;
		 default:
			 ret=FAIL;
			 break;
	}
    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 完成订单
 */
int Croute_func::user_finish_menue(DEAL_FUN_ARG)
{
    user_finish_menue_in *p_in=PRI_IN_POS; 
	uint32_t tempdata = 0;
	uint32_t temp = 0;
	uint32_t value_1 = 0;
	uint32_t value_2 = 0;
	uint32_t now = time(0);
	uint32_t week_seq = get_week_id(now);

    switch(p_in->type)
	{
		case 1://皇家订单	    
            ret=this->user_temp_active.get_one(RECVBUF_USERID,32,"value_1",&tempdata);
			temp=tempdata>>16;//获取高十六位
			tempdata=tempdata-(temp<<16);//获取低十六位
			//判断现在是不是同一星期
			//uint32_t week_day = get_week_day(time(0));
			if(!(tempdata == week_seq || tempdata+1 == week_seq))
			{
                 //修改完成周次，合并订单ID以及周次
                 value_1=(temp<<16)+week_seq;
				 //修改订单完成状态以及一周完成订单数，并合并高低位
                 value_2=(2<<16)+1;  
			}
			else
			{
				 //修改完成周次，合并订单ID以及周次 
				 value_1= (temp<<16)+week_seq;
		      	 //高十六位存放订单完成状态 第十六位表示一周完成的订单个数
			     ret=this->user_temp_active.get_one(RECVBUF_USERID,32,"value_2",&tempdata);  
                 temp=tempdata>>16;
				 tempdata=tempdata-(temp<<16); 
				 value_2=tempdata+(2<<16)+1;
			}
            ret=this->user_temp_active.add(RECVBUF_USERID,32,value_1,value_2);
			break;
		case 2://加急订单 修改订单状态
			ret=this->user_temp_active.add(RECVBUF_USERID,33,p_in->order_id,2);
			break;
		default:
			ret=FAIL;
			break;

	}
    STD_RETURN(SUCC);
}
/*
 * 接收订单
 */
int Croute_func::user_submit_menue(DEAL_FUN_ARG)
{
    user_submit_menue_in *p_in=PRI_IN_POS; 
	uint32_t tempdata=0;
	uint32_t temp = 0;
	uint32_t now = time(0);
	uint32_t week_seq = get_week_id(now);

    switch(p_in->type)
	{
        case 1://皇家订单 修改订单的状态
		   	//高十六位存放订单完成状态，第十六位表示一周完成的订单个数
			ret = this->user_temp_active.get_one(RECVBUF_USERID, 32, "value_2", &tempdata);

			temp=tempdata>>16;//获得高十六位
			tempdata=tempdata-(temp<<16);//获得低十六位
		    tempdata=(1<<16)+tempdata;//重新整理字段

			//高十六位存放订单id，低十六位表示当前的周次
            p_in->order_id = (p_in->order_id<<16)+week_seq;
			ret=this->user_temp_active.add(RECVBUF_USERID,32,p_in->order_id,tempdata);
			break;
		case 2://加急订单 修改订单状态   
			ret=this->user_temp_active.add(RECVBUF_USERID,33,p_in->order_id,1);
			break;
		default:
			ret=FAIL;
			break;
	}
    STD_RETURN(SUCC);

}

/*
 * 生产机械工厂中的加工道具
 */
int Croute_func::user_produce_special_machine(DEAL_FUN_ARG)
{

    user_produce_special_machine_in *p_in=PRI_IN_POS;
	uint32_t level = 0;
    ret = this->user_piglet_house.get_int_value(RECVBUF_USERID, "machine_level", &level);
	if(p_in->type == 1 || p_in->type == 2){
		DEBUG_LOG("type: %u, tool_id: %u", p_in->type, p_in->tool_id);
		if(level < 2 && (p_in->tool_id == 1613140 || p_in->tool_id == 1613141)){
			return NOT_FIT_MACHINE_LEVEL_TO_PRODUCE_ERR;
		}
		if(level < 3 && (p_in->tool_id == 1613144 || p_in->tool_id == 1613145)){
			 return NOT_FIT_MACHINE_LEVEL_TO_PRODUCE_ERR;
		}
		
		user_del_attire_in del_item = { 0 };
		del_item.attiretype = 36;
		del_item.maxcount=99999;
		uint32_t flag = 0;
		switch(p_in->tool_id)
		{
			case 1613140:
				{
					uint32_t material_items[] = { 1613604, 1613600, 1613601, 1613907};
					uint32_t material_count[] = { 1, 50, 50, 1};
					ret = this->user_piglet_attire.check_items_enough(RECVBUF_USERID, material_items, 
							sizeof(material_items)/sizeof(uint32_t), material_count);
					if(ret != SUCC){
						return ATTIRE_COUNT_NO_ENOUGH_ERR;
					}
					for(uint32_t k = 0; k < 4; ++k){
						del_item.attireid = material_items[k];
						del_item.count = material_count[k];
						ret=this->user_del_attire(RECVBUF_USERID ,&del_item);
						if(ret != SUCC){
							flag = 1;
							break;
						}
					}
					break;
				}
			case 1613141:
				{
					uint32_t material_items[] = { 1613604, 1613600, 1613601, 1613908};
					uint32_t material_count[] = { 1, 50, 50, 1};
					ret = this->user_piglet_attire.check_items_enough(RECVBUF_USERID, material_items, 
							sizeof(material_items)/sizeof(uint32_t), material_count);
					if(ret != SUCC){
						return ATTIRE_COUNT_NO_ENOUGH_ERR;
					}
					for(uint32_t k = 0; k < 4; ++k){
						del_item.attireid = material_items[k];
						del_item.count = material_count[k];
						ret=this->user_del_attire(RECVBUF_USERID ,&del_item);
						if(ret != SUCC){
							flag = 1;
							break;
						}
					}

					break;
				}
			case 1613144:
				{
					uint32_t material_items[] = { 1613604, 1613600, 1613601, 1613917};
					uint32_t material_count[] = { 5, 200, 200, 1};
					ret = this->user_piglet_attire.check_items_enough(RECVBUF_USERID, material_items, 
							sizeof(material_items)/sizeof(uint32_t), material_count);
					if(ret != SUCC){
						return ATTIRE_COUNT_NO_ENOUGH_ERR;
					}
					for(uint32_t k = 0; k < 4; ++k){
						del_item.attireid = material_items[k];
						del_item.count = material_count[k];
						ret=this->user_del_attire(RECVBUF_USERID ,&del_item);
						if(ret != SUCC){
							flag = 1;
							break;
						}
					}

					break;
				}
			case 1613145:
				{
					uint32_t material_items[] = { 1613604, 1613600, 1613601, 1613918};
					uint32_t material_count[] = { 5, 200, 200, 1};
					ret = this->user_piglet_attire.check_items_enough(RECVBUF_USERID, material_items, 
							sizeof(material_items)/sizeof(uint32_t), material_count);
					if(ret != SUCC){
						return ATTIRE_COUNT_NO_ENOUGH_ERR;
					}
					for(uint32_t k = 0; k < 4; ++k){
						del_item.attireid = material_items[k];
						del_item.count = material_count[k];
						ret=this->user_del_attire(RECVBUF_USERID ,&del_item);
						if(ret != SUCC){
							flag = 1;
							break;
						}
					}
					break;
				}
		}
		if(flag == 0){
			uint32_t index = 0;	
			this->user_piglet_work.get_tool_level(p_in->type, p_in->tool_id, &index);
			//if(level == 2){
				//index = 2;
			//}
			//else if(level == 3){
				//index = 3;
			//}
			work_piglets_t piglets;
			memset(&piglets, 0, sizeof(work_piglets_t));
			ret = this->user_piglet_work.add(RECVBUF_USERID, p_in->type, index, p_in->tool_id, 0, &piglets, 0, 0);
		}
	}
	else if(p_in->type == 3){
		uint32_t old_level = level;
		if(level >= 3){
			 return NOT_FIT_MACHINE_LEVEL_TO_PRODUCE_ERR;
		}	
		if(!(level == 1 && p_in->tool_id == 1613138) && !(level == 2 && p_in->tool_id == 1613142)){
			return NOT_FIT_MACHINE_LEVEL_TO_PRODUCE_ERR;
		}

		user_del_attire_in del_item = { 0 };
		del_item.attiretype = 36;
		del_item.maxcount=99999;
		if(level == 1 && p_in->tool_id == 1613138){
			uint32_t material_items[] = { 1613604, 1613600, 1613601, 1613905};
			uint32_t material_count[] = { 1, 50, 50, 1};
			ret = this->user_piglet_attire.check_items_enough(RECVBUF_USERID, material_items, 
					sizeof(material_items)/sizeof(uint32_t), material_count);
			if(ret != SUCC){
				return ATTIRE_COUNT_NO_ENOUGH_ERR;
			}
			uint32_t k = 0;
			for(; k < 4; ++k){
				del_item.attireid = material_items[k];
				del_item.count = material_count[k];
				ret=this->user_del_attire(RECVBUF_USERID ,&del_item);
				if(ret != SUCC){
					break;
				}
			}
			if(k >= 4){
				level = 2;
			}
		}
		else if(level == 2 && p_in->tool_id == 1613142){
			uint32_t material_items[] = { 1613604, 1613600, 1613601, 1613915};
			uint32_t material_count[] = { 5, 200, 200, 1};
			ret = this->user_piglet_attire.check_items_enough(RECVBUF_USERID, material_items, 
					sizeof(material_items)/sizeof(uint32_t), material_count);
			if(ret != SUCC){
				return ATTIRE_COUNT_NO_ENOUGH_ERR;
			}
			uint32_t k = 0;
			for(; k < 4; ++k){
				del_item.attireid = material_items[k];
				del_item.count = material_count[k];
				ret=this->user_del_attire(RECVBUF_USERID ,&del_item);
				if(ret != SUCC){
					break;
				}
			}
			if(k >= 4){
				level = 3;
			}
		}
		if(level != old_level){
			ret = this->user_piglet_house.set_int_value(RECVBUF_USERID, "machine_level", level);
		}
		
	}
	
    STD_RETURN(ret);
}
/*
 * 摩尔大生产
 */
int Croute_func::sysarg_set_greate_produce(DEAL_FUN_ARG)
{
	 int32_t value = 0;
	 ret = this->sys_arg.get_value(1108, &value);
	 ret = this->sys_arg.set_value(1108, value+1);

    STD_RETURN(ret);
}
/*
 * 摩尔大生产
 */
int Croute_func::sysarg_get_greate_produce(DEAL_FUN_ARG)
{
    sysarg_get_greate_produce_out out={0};
    ret = this->sys_arg.get_value(1108, &out.count);

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/* 
 *机械工坊用道具加工时产生的奖励 
 */
int Croute_func::user_produce_product(DEAL_FUN_ARG)
{
    user_produce_product_out_header  out_header = { 0 };
	user_produce_product_out_item *p_out_item = 0;
    uint32_t count1=0,count2=0;//count1记录每30s产生奖励的次数，count2记录每3min产生奖励的次数
    uint32_t index_1, index_2;//标识加工工具类型和索引
	uint32_t stove;//原生产产物
	float random = 0.0f;//随即概率
	static uint32_t now=0;
	uint32_t gettime;
	uint32_t  endtime;
	out_header.count=0;//初始化获得的奖励数目
    p_out_item=(user_produce_product_out_item*)malloc(sizeof(user_produce_product_out_item)*6*2);
 
	uint32_t old_time_1 = 0, old_time_2 = 0;
	ret=this->user_temp_active.get_one(RECVBUF_USERID, 4, "value_1", &old_time_1);
	ret=this->user_temp_active.get_one(RECVBUF_USERID, 5, "value_1",  &old_time_2);
    int32_t today = get_date(time(0));	
	uint32_t n_time = time(0);
	if(get_date(old_time_1) != today){
		this->user_temp_active.update(RECVBUF_USERID, 4, n_time, 0);
	}
	if(get_date(old_time_2) != today){
		this->user_temp_active.update(RECVBUF_USERID, 5, n_time, 0);
	}

	for(index_1=1;index_1<3;index_1++)//从熔炉，机床遍历
	{
		for(index_2=1;index_2<4;index_2++)//从加工工具的索引依次遍历
		{
		//获取当前机器的生产状态
		 ret=this->user_piglet_work.get_piglets_worktime(RECVBUF_USERID, index_1, index_2, &endtime);
		 if(endtime != 0)//说明当前机器是在正常工作状态,可以生产零件或者奖品
         {
             if(now==0)//第一次调用就会生产奖品或者零件
			 {
				 now = time(0);
				 ret=this->user_temp_active.add(RECVBUF_USERID,4,now,0);//记录30s内产生奖励次数
				 ret=this->user_temp_active.add(RECVBUF_USERID,5,now-30,0);//记录2min内产生奖励次数
                 random = (float)(rand()%100);
				 random /= 100;
				 if(random <= 0.3 && index_2==1)//掉铁粉
				 {
					 (p_out_item+out_header.count)->matchine_type = index_1;
					 (p_out_item+out_header.count)->matchine_index = index_2;
					 (p_out_item+out_header.count)->product_id = 1613403;
					 (p_out_item+out_header.count)->product_count = 1;
                     count1++;    
				     ret=this->user_temp_active.add(RECVBUF_USERID,4,now,1);//记录30s内产生奖励次数
				     out_header.count++; 
				 }
				 else if(random <= 0.4 && index_2==2)//掉铜粉
				 {
                    //
					 (p_out_item+out_header.count)->matchine_type = index_1;
					 (p_out_item+out_header.count)->matchine_index = index_2;
					 (p_out_item+out_header.count)->product_id = 1613407;
					 (p_out_item+out_header.count)->product_count = 1;
                     count1++;    
				     ret=this->user_temp_active.add(RECVBUF_USERID,4,now,1);//记录30s内产生奖励次数
				     out_header.count++; 
				 }
				 else if(random <= 0.5 && index_2==3)//掉金粉
				 {
                     //
					 (p_out_item+out_header.count)->matchine_type = index_1;
					 (p_out_item+out_header.count)->matchine_index = index_2;
					 (p_out_item+out_header.count)->product_id = 3;
					 (p_out_item+out_header.count)->product_count = 1613411;
                     count1++;    
				     ret=this->user_temp_active.add(RECVBUF_USERID,4,now,1);//记录30s内产生奖励次数
				     out_header.count++; 
				 }
			 }
			 else
			 {
                 now = time(0); 
                 random = (float)(rand()%100);
				 random /= 100;
				 ret=this->user_temp_active.get_one(RECVBUF_USERID,4,"value_1",&gettime);
                 if(now-gettime>=30)//30s内可以随机产生东西
				 {
					 ret=this->user_temp_active.get_one(RECVBUF_USERID,4,"value_2",&count1);
					 
					 if( count1<=200)//能再产生
					 {
                         if(random<=0.3 && index_2==1)
						 {
                             count1++;
                             if(index_1==1)//熔炉,产生铁矿
							 {
								 //
					            (p_out_item+out_header.count)->matchine_type = index_1;
					 			(p_out_item+out_header.count)->matchine_index = index_2;
								(p_out_item+out_header.count)->product_id = 1613403;
					 			(p_out_item+out_header.count)->product_count = 1;
							 }
							 else//产生螺母
							 {
								(p_out_item+out_header.count)->matchine_type = index_1;
					 			(p_out_item+out_header.count)->matchine_index = index_2;
					 			(p_out_item+out_header.count)->product_id = 1613600;
					 			(p_out_item+out_header.count)->product_count = 1;
                                 // 
							 }
							 ret=this->user_temp_active.add(RECVBUF_USERID,4,now,count1);
							 out_header.count++;  
						 }
						 else if(random<=0.4 && index_2==2)
						 {
                             count1++;
							 if(index_1==1)//熔炉,产生铜矿
							 {
								//
								(p_out_item+out_header.count)->matchine_type = index_1;
					 			(p_out_item+out_header.count)->matchine_index = index_2;
					 			(p_out_item+out_header.count)->product_id = 1613407;
					 			(p_out_item+out_header.count)->product_count = 1;
							 }
							 else//产生螺栓
							 {
                                 //
								(p_out_item+out_header.count)->matchine_type = index_1;
					 			(p_out_item+out_header.count)->matchine_index = index_2;
					 			(p_out_item+out_header.count)->product_id = 1613601;
					 			(p_out_item+out_header.count)->product_count = 1;
							 }
							 ret=this->user_temp_active.add(RECVBUF_USERID,4,now,count1); 
                             out_header.count++;  
						 }
						 else if(random<=0.5 && index_2==3)
						 {
							 count1++;
                             if(index_1==1)//熔炉，产生金矿
							 {
                                  //
								(p_out_item+out_header.count)->matchine_type = index_1;
					 			(p_out_item+out_header.count)->matchine_index = index_2;
					 			(p_out_item+out_header.count)->product_id = 1613411;
					 			(p_out_item+out_header.count)->product_count = 1;
							 }
							 else //产生垫圈
							 {
								 //
								(p_out_item+out_header.count)->matchine_type = index_1;
					 			(p_out_item+out_header.count)->matchine_index = index_2;
					 			(p_out_item+out_header.count)->product_id = 1613602;
					 			(p_out_item+out_header.count)->product_count = 1;
							 }
							 ret=this->user_temp_active.add(RECVBUF_USERID,4,now,count1); 
						     out_header.count++;  
						 }
					 }
				 }
				 else  //3min内可以随机产生东西
                 {
				     ret=this->user_temp_active.get_one(RECVBUF_USERID,5,"value_1",&gettime);
					 if((now-gettime)== 3*60)
					 {
					     ret=this->user_temp_active.get_one(RECVBUF_USERID,5,"value_2",&count2);
					     if(count2<=20)//能再产生
                        {
                             if((random<=0.2 && index_1==1)||(random<=0.05 && index_2==2))
						     {
                                 count2++;
							     ret=this->user_temp_active.add(RECVBUF_USERID,5,now,count2); 
							     ret = this->user_piglet_work.get_one_col(RECVBUF_USERID, index_1, index_2, "tool_itemid", &stove); 
                                 //掉当前生产物
								(p_out_item+out_header.count)->matchine_type = index_1;
					 			(p_out_item+out_header.count)->matchine_index = index_2;
					 			(p_out_item+out_header.count)->product_id = stove;
					 			(p_out_item+out_header.count)->product_count = 1;

							     out_header.count++;  
						     }
				         }	
				      }
			       }
		  	   }
		    }
		}
	}//
	
	user_add_attire_in tmp = { 0 };
	tmp.attiretype = 36;
	tmp.maxcount = 99999999;
	for(uint32_t k = 0; k < out_header.count; ++k){
		tmp.attireid = (p_out_item+k)->product_id;
		tmp.count = (p_out_item+k)->product_count;
		ret = this->user_add_attire(RECVBUF_USERID, &tmp);
	}
    STD_RETURN_WITH_STRUCT_LIST(SUCC,out_header,p_out_item,out_header.count);
}
/* 
 *设置生日派对画板的内容
 */
int Croute_func::set_partymenue_setting(DEAL_FUN_ARG)
{
     set_partymenue_setting_in *p_in=PRI_IN_POS; 
     ret=this->user_temp_decorate.add(RECVBUF_USERID,p_in->value);

     STD_RETURN(SUCC);
}
/* 
 *获取生日派对画板的内容   
 */
int Croute_func::get_partymenue_setting(DEAL_FUN_ARG)
{
     get_partymenue_setting_out out;
	 memset(out.value, 0, sizeof(out));
     ret=this->user_temp_decorate.get_one(RECVBUF_USERID,out.value);
     STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 查看新友谊宝盒物品
 */
int Croute_func::get_new_friendship_box_items(DEAL_FUN_ARG)
{
	get_new_friendship_box_items_out out={};

	ret=this->user_new_friendship_box.get_item_list(RECVBUF_USERID,&out);
	if(ret != SUCC) {
		ret = SUCC;
	//	memset(&out,0,sizeof(out));
	//	this->user_friend_box.init_record(RECVBUF_USERID);
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 查看新友谊宝盒历史记录
 */
int Croute_func::get_new_friendship_box_history(DEAL_FUN_ARG)
{
	get_new_friendship_box_history_out out={};

	ret=this->user_new_friendship_box.get_history_list(RECVBUF_USERID,&out);
	if(ret != SUCC) {
		ret = SUCC;
	//	memset(&out,0,sizeof(out));
	//	this->user_friend_box.init_record(RECVBUF_USERID);
	}
	STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 放物品到新的友谊宝盒
 */
int Croute_func::put_item_to_new_friendship_box(DEAL_FUN_ARG)
{
	int flag = 0;
	put_item_to_new_friendship_box_in *p_in=PRI_IN_POS; 
	put_item_to_new_friendship_box_out out={};

	ret=this->user_new_friendship_box.get_item_list(RECVBUF_USERID,&out);
	if(ret != SUCC) {
		flag = 1;
		ret = SUCC;
	//	memset(&out,0,sizeof(out));
		this->user_new_friendship_box.init_record(RECVBUF_USERID);
	} 

	if(flag == 0) {
		uint32_t  i = 0;
		for(i = 0; i < out.count;i++) {
			if(out.items[i].attireid == p_in->attireid) {
				out.items[i].count += p_in->count;
				break;
			}
		}
		if(i == out.count) flag = 1;
	}

	if(flag == 1) {
		if(out.count == 6) return CAN_NOT_PUT_IN_BOX_ERR;
		out.items[out.count].attireid=p_in->attireid;
		out.items[out.count].count = p_in->count;
		out.count++;
	}

	user_del_attire_in del_item;
	del_item.attireid=p_in->attireid;
	del_item.attiretype=p_in->attiretype;
	del_item.count=p_in->count;
	del_item.maxcount=99999;
	ret=this->user_del_attire(RECVBUF_USERID ,&del_item);
	if(ret == SUCC) {
		this->user_new_friendship_box.set_item_list(RECVBUF_USERID,&out);
	}

	STD_RETURN(ret);
}
/*
 * 从新友谊宝盒中拿取物品
 */
int Croute_func::get_item_from_new_friendship_box(DEAL_FUN_ARG)
{
	get_item_from_new_friendship_box_in *p_in=PRI_IN_POS; 
	get_item_from_new_friendship_box_out out={};


	ret=this->user_new_friendship_box.get_item_list(RECVBUF_USERID,&out);
	if(ret != SUCC) {
	//	memset(&out,0,sizeof(out));
	//	this->user_friend_box.init_record(RECVBUF_USERID);
		return NO_ITEM_TO_SHARE_ERR;
	}

	uint32_t i = 0;
	for(i=0; i < out.count;i++) {
		if(out.items[i].attireid == p_in->info.attireid) break;
	}
	if(i == out.count)
		return NO_ITEM_TO_SHARE_ERR;
    if(out.items[i].count < p_in->count)
		return NOT_ENOUGH_ITEM_TO_SHARE_ERR;
	
	if(out.items[i].count > p_in->count) {
		out.items[i].count -= p_in->count;
	} else {
		out.count--;
		if(out.count > i)
			memmove((out.items + i), out.items + i + 1,sizeof(out.items[0]) * (out.count - i));
		memset(out.items + out.count,0,sizeof(out.items[0]));
	}
	
	if(p_in->info.userid != RECVBUF_USERID) {
		get_friend_box_history_out history={};
		this->user_new_friendship_box.get_history_list(RECVBUF_USERID,&history);
		if(history.count == 20) {
			memmove(history.infos,history.infos + 1,sizeof(history.infos[0]) * 19);	
			history.count = 19;
		}
		history.infos[history.count] = p_in->info;
		history.infos[history.count].stamp=time(NULL);
		history.count++;
		this->user_new_friendship_box.set_history_list(RECVBUF_USERID,&history);

		change_log_item c_item;
		c_item.userid=RECVBUF_USERID;
		c_item.change_type=10006;
		c_item.logtime=time(NULL);
		c_item.change_value=p_in->count;
		c_item.change_v1=p_in->info.attireid;
		c_item.change_v2=0;
		this->send_log.send(&c_item );	
	}

	ret=this->user_new_friendship_box.set_item_list(RECVBUF_USERID,&out);
	STD_RETURN(ret);
}
/*
 * 检查是否可以从新友谊宝盒中拿取物品
 */
int Croute_func::check_item_from_new_friendship_box(DEAL_FUN_ARG)
{
	uint32_t date;
	share_src_t out={};
	check_item_from_new_friendship_box_in *p_in=PRI_IN_POS;
	uint32_t exsit = 0;
	
	//检查是否有友谊宝盒
	uint32_t count = 0;

	if(RECVBUF_USERID != p_in->userid) {
		ret=this->user_ex.check_friend(RECVBUF_USERID,p_in->userid,&exsit);
		if(ret != SUCC || exsit == 0) {
			return NOT_FRIEND_ERR;
		}
	} 
	ret=this->user_new_friendship_box.get_share_src_list(RECVBUF_USERID,date,&out);
	if(ret != SUCC){
		this->user_new_friendship_box.init_record(RECVBUF_USERID);
	} else {
//检查今天是否拿过
		if(date != (uint32_t)get_date(time(NULL))) {
			date = get_date(time(NULL));
			memset(&out,0,sizeof(out));
			this->user_new_friendship_box.set_share_src_list(RECVBUF_USERID,date,&out);
		} else if(out.count == 5){
			return SHARE_LIMIT_TODAY_ERR;
		} else {
			uint32_t i;
			for(i = 0; i < out.count; i++) {
				if(out.userid[i] == p_in->userid)
					return SHARED_TODAY_ERR;
			}
		}
	}

//检查武品上限
	count = 0;
	ret = this->user_attire.get_count(RECVBUF_USERID,p_in->attireid,count);
	if(ret == SUCC) {
		if(count + p_in->count > p_in->maxcount)
			return TOO_MANY_ITEM_ERR;
	} else {
		ret = SUCC;
	}

	STD_RETURN(ret);
}
/*
 * 设置已从别人新友谊宝盒取得物品
 */
int Croute_func::set_tag_item_from_new_friendship_box(DEAL_FUN_ARG)
{
	uint32_t date;
	share_src_t out={};
	set_tag_item_from_new_friendship_box_in *p_in=PRI_IN_POS;

	if(p_in->userid == RECVBUF_USERID) return SUCC;

	ret=this->user_new_friendship_box.get_share_src_list(RECVBUF_USERID,date,&out);
	if(ret != SUCC) return ret;

	if(date != (uint32_t)get_date(time(NULL))) {
		date = get_date(time(NULL));
	//	memset(&out,0,sizeof(out));
	}

	if(out.count < 5) {
		out.userid[out.count++] = p_in->userid;
	} else {
		out.userid[0] = p_in->userid;
	}

	this->user_new_friendship_box.set_share_src_list(RECVBUF_USERID,date,&out);
	STD_RETURN(ret);
}
/*
 *生日投票 
 */
int Croute_func::sysarg_vote_birthday_decorate(DEAL_FUN_ARG)
{
	sysarg_vote_birthday_decorate_in *p_in = PRI_IN_POS;
    ret = this->sysarg_vote_decorate.add(RECVBUF_USERID, p_in->nick, 1);

    STD_RETURN(ret);
}
/*
 * 今日寿星面板
 */
int Croute_func::sysarg_get_birthday_decorate(DEAL_FUN_ARG)
{
	
    sysarg_get_birthday_decorate_in *p_in=PRI_IN_POS;
    sysarg_get_birthday_decorate_out_header  out_header = { 0 };
    sysarg_get_birthday_decorate_out_item *p_out_item = 0;
    ret = this->sysarg_vote_decorate.get(RECVBUF_USERID, p_in->index, &p_out_item, &out_header.count);
	out_header.cur_page = p_in->index;
	uint32_t cnt = 0;

	this->sysarg_vote_decorate.get_count(&cnt);
	out_header.total_page = cnt / 6;
	if(cnt % 6 != 0){
		out_header.total_page += 1;
	}
	DEBUG_LOG("total_page: %u", out_header.total_page);

    STD_RETURN_WITH_STRUCT_LIST(SUCC,out_header,p_out_item,out_header.count);
}
/* 
 *在灵萌巨树上捕捉蝴蝶，随机的获取捕获结果
 */
int Croute_func::user_get_butterfly(DEAL_FUN_ARG)
{
    user_get_butterfly_out out={0};
    uint32_t type = 0;
	uint32_t count = 0;
	time_t timer;
	struct tm* t_tm; 
	time(&timer); 
	t_tm = localtime(&timer); 


	uint32_t count_1 = 0, count_2 = 0, count_3 = 0, count_4 = 0;
	uint32_t day_1 = 0, day_2 = 0, day_3 = 0, day_4 = 0;
	
	ret = this->user_temp_active.get_one(RECVBUF_USERID,28,"value_1",&count_1);
	ret = this->user_temp_active.get_one(RECVBUF_USERID,28,"value_2",&day_1);

	ret = this->user_temp_active.get_one(RECVBUF_USERID,29,"value_1",&count_2);
	ret = this->user_temp_active.get_one(RECVBUF_USERID,29,"value_2",&day_2);

	ret = this->user_temp_active.get_one(RECVBUF_USERID,30,"value_1",&count_3);
	ret = this->user_temp_active.get_one(RECVBUF_USERID,30,"value_2",&day_3);
	
	ret = this->user_temp_active.get_one(RECVBUF_USERID,31,"value_1",&count_4);
	ret = this->user_temp_active.get_one(RECVBUF_USERID,31,"value_2",&day_4);
	uint32_t today = (uint32_t)t_tm->tm_mday;
	DEBUG_LOG("count_3: %u, day_3: %u, count_4: %u, day_4: %u, count_1: %u, day_1: %u, count_2: %u, day_2: %u, today: %u",
			count_3, day_3, count_4, day_4, count_1, day_1, count_2, day_2, today);
	if(((count_3 >= 10 && day_3 == today) && (count_4 >= 10 && day_4 == today) && (count_1>=5 && day_1 == today)
			   	&& (count_2 >= 5 &&  day_2 == today)))
	{
		out.butterfly_count=-1;
		STD_RETURN_WITH_STRUCT(SUCC,out);
	}

    uint32_t random = (rand()%100);
	if(random < 10)//蝴蝶天使
	{
		type = 28;
		if(count_1 >= 5 &&  (day_1==today)){
            out.butterfly_count = 0;
            STD_RETURN_WITH_STRUCT(SUCC,out);
        }
	}
	else if( random < 25){
		type = 29;	

		if(count_2 >= 5 && (day_2==today)){
            out.butterfly_count = 0;
            STD_RETURN_WITH_STRUCT(SUCC,out);
        }
	}
	else if( random < 60){
		out.butterfly_count = 0;
		STD_RETURN_WITH_STRUCT(SUCC,out);
	}
	else
	{
        type = (random)%2 + 30;//9 黄凤蝶，10 蓝凤蝶
		if(count_3 >= 10 && type == 30 && (day_3==today)){
			out.butterfly_count = 0;
			STD_RETURN_WITH_STRUCT(SUCC,out);
		}
		if(count_4 >= 10 && type == 31 &&(day_4==today)){
			out.butterfly_count = 0;
			STD_RETURN_WITH_STRUCT(SUCC,out);
		}
	}

	uint32_t day = 0;
	if(type == 28){
		day = day_1; 
		count = count_1;
	}
	else if(type == 29){
		day = day_2;
		count = count_2;
	}
	else if(type == 30){
		day = day_3;
		count = count_3;
	}
	else if(type == 31){
		day = day_4;
		count = count_4;
	}

	if(day == (uint32_t)t_tm->tm_mday)
	{
		ret = this->user_temp_active.add(RECVBUF_USERID,type,count+1,day);
	}
	else
	{
		ret = this->user_temp_active.add(RECVBUF_USERID,type,1,t_tm->tm_mday);
	}

	switch(type)
	{
		case 29:
			out.butterfly_type = 1220269;
			break;
		case 30:
			out.butterfly_type = 1270026;
			break;
		case 31:
			out.butterfly_type = 1270027;
			break;
		case 28:
			out.butterfly_type = 1353317;//////////a蝴蝶天使ID 
			break;
	}
	out.butterfly_count = 1;

	STD_RETURN_WITH_STRUCT(SUCC,out);
}
/* 
 *机械工坊中，采矿时回收猪猪
 */
int Croute_func::user_reset_pigmap(DEAL_FUN_ARG)
{
	user_reset_pigmap_in *p_in=PRI_IN_POS; 
    uint32_t pigletid;
	ret=this->user_piglet_mining.get_one(RECVBUF_USERID,p_in->mapid,"pigletid",&pigletid);
	ret=this->user_piglet.update(RECVBUF_USERID,pigletid,"work",0);
	ret=this->user_piglet_mining.drop_one(RECVBUF_USERID,p_in->mapid);
	STD_RETURN(ret);
}	
/* 
 * 创建MVP队伍
 */
int Croute_func::user_create_team(DEAL_FUN_ARG)
{

	char buf[PROTO_MAX_LEN]={ 0 };
    user_create_team_in *p_in=PRI_IN_POS; 
	user_create_team_out_header *out_header = (user_create_team_out_header*)buf;
	user_create_team_out_item *p_out_item = (user_create_team_out_item*)(buf+sizeof(*out_header));		
	bool is_vip = false;
	uint32_t isadded = 1;
	ret=this->user.get_int_value(RECVBUF_USERID,"teamid",&isadded);
	if(isadded)
	{
        out_header->flg = -1;//已经创建过队伍，不能再建	
		STD_RETURN_WITH_BUF(SUCC, buf, sizeof(*out_header)+ sizeof(*p_out_item)*out_header->count);
    }
	ret = this->user_ex.get_vip(RECVBUF_USERID, &is_vip);
	if(!is_vip){
	    uint32_t child_count = 0;
	    ret = this->user_connect.get_int_value(RECVBUF_USERID, "childcount", &child_count);
	    if(child_count < 10){
            out_header->flg = 1;//人数不够，不能创建
			STD_RETURN_WITH_BUF(SUCC, buf, sizeof(*out_header)+ sizeof(*p_out_item)*out_header->count);
	    }
		else
        {
	        ret=this->user_temp_team.insert(RECVBUF_USERID,p_in->teamname,p_in->teamid,p_in->logo);
			out_header->flg = 0;//创建队伍成功
			ret = this->user.set_int_value(RECVBUF_USERID, "teamid", RECVBUF_USERID);
			ret = this->user_mvp_team.add(RECVBUF_USERID,RECVBUF_USERID);
		}								     
	}
    else
	{
        ret=this->user_temp_team.insert(RECVBUF_USERID,p_in->teamname,p_in->teamid,p_in->logo);
		out_header->flg = 0;//创建队伍成功
		ret = this->user.set_int_value(RECVBUF_USERID, "teamid", RECVBUF_USERID);
		ret = this->user_mvp_team.add(RECVBUF_USERID,RECVBUF_USERID);
	}

	id_list friendlist;
	ret=this->user_ex.get_idlist(RECVBUF_USERID ,FRIEND_LIST_STR, &friendlist);
	out_header->count = friendlist.count;
	memcpy(p_out_item, friendlist.item, sizeof(uint32_t)*friendlist.count);

	STD_RETURN_WITH_BUF(SUCC, buf, sizeof(*out_header)+ sizeof(*p_out_item)*out_header->count);
}
/*
 *2012摩尔运动会,查询属于的mvp队伍
 */
int Croute_func::user_mvp_get_teamid(DEAL_FUN_ARG)
{
    user_mvp_get_teamid_out out={0};
    ret = this->user.get_int_value(RECVBUF_USERID, "teamid", &out.mvp_team);

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 2012摩尔运动会，设置mvp队伍
 */
int Croute_func::user_mvp_set_teamid(DEAL_FUN_ARG)
{
	user_mvp_set_teamid_in *p_in=PRI_IN_POS;
	DEBUG_LOG("[team_id: %u]", p_in->team_id);
	ret = this->user.set_int_value(RECVBUF_USERID, "teamid", p_in->team_id);

	STD_RETURN(ret);

}
/* 
 * 踢出MVP队伍中的某一用户
 */
int Croute_func::user_mvp_removeone(DEAL_FUN_ARG)
{	
    user_mvp_removeone_in *p_in=PRI_IN_POS; 
    user_mvp_removeone_out out={0};
	uint32_t  count;
    ret = this->user_mvp_team.remove(RECVBUF_USERID,p_in->member_id);
	DEBUG_LOG("ret: %u", ret);
    if(ret!=SUCC)
	{
		out.flg = 0;
        STD_RETURN_WITH_STRUCT(ret,out);
	}
	else
		out.flg = 1;
	ret = this->user_mvp_team.get_count(RECVBUF_USERID, &count);
	//ret = this->user_temp_team.get_one(RECVBUF_USERID,"count",&count);
	ret = this->user_temp_team.set_one(RECVBUF_USERID,"count",count);
	out.count = count;

    STD_RETURN_WITH_STRUCT(ret,out);
}

/* 
 * 增加MVP队伍成员
 */
int Croute_func::user_mvp_addone(DEAL_FUN_ARG)
{
    user_mvp_addone_in *p_in=PRI_IN_POS; 
    user_mvp_addone_out out={0};
	uint32_t count = 0;
	uint32_t teamid = 0;
	//ret = this->user_temp_team.get_one(RECVBUF_USERID,"count",&count);
	ret = this->user_mvp_team.get_count(RECVBUF_USERID, &count);
	if(ret == SUCC){
		if(count >= 99)
		{
			out.flg= 3;//添加失败,人数达到上限 
			STD_RETURN_WITH_STRUCT(SUCC,out);
		}
		ret = this->user_temp_team.get_teamid(RECVBUF_USERID,&teamid);
		if(teamid != p_in->team_id)
		{
			out.flg= 0;//添加失败，没有参加到队伍中
			STD_RETURN_WITH_STRUCT(SUCC,out);
		}
		ret = this->user_temp_team.set_one(RECVBUF_USERID,"count",1+count);
		ret = this->user_mvp_team.add(RECVBUF_USERID,p_in->userid);
		out.flg = 1;
		out.count = count + 1;

	}
	else{
		out.flg = 2;
	}
	STD_RETURN_WITH_STRUCT(SUCC,out);
}
/* 
  查看所在队伍信息
 */
int Croute_func::user_get_teaminfo(DEAL_FUN_ARG)
{ 
    user_get_teaminfo_out_header  out_header;
	memset(&out_header, 0, sizeof(out_header));
	user_get_teaminfo_out_item *p_out_item = 0;
	DEBUG_LOG("userid_teamid: %u", RECVBUF_USERID);	
    ret=this->user_temp_team.get_teaminfo(RECVBUF_USERID, &out_header);
	DEBUG_LOG("count: %u", out_header.count);	
	if( ret == SUCC){
		out_header.userid = RECVBUF_USERID;
	}
	ret = this->user_mvp_team.get_memberlist(RECVBUF_USERID, &p_out_item, &out_header.count);

	STD_RETURN_WITH_STRUCT_LIST(SUCC,out_header,p_out_item,out_header.count);
}
/*
 * 解散MVP队伍
 */
int Croute_func::user_mvp_deleteall(DEAL_FUN_ARG)
{
    user_mvp_deleteall_out_header out_header={0};
	user_mvp_deleteall_out_item*  p_out_item= 0;
    uint32_t isadded;
    ret=this->user.get_int_value(RECVBUF_USERID,"teamid",&isadded);
    if(!isadded)
    {
	    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
    }
	ret = this->user_temp_team.remove(RECVBUF_USERID);//删除队伍
   //设置标志解散其他成员
    ret = this->user_mvp_team.get_memberlist(RECVBUF_USERID,&p_out_item,&out_header.count);
   	ret	= this->user_mvp_team.destory_team(RECVBUF_USERID);//删除组长与成员之间的关系依赖
	ret = this->user.set_int_value(RECVBUF_USERID, "teamid", 0);
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 全局mvp小队排名表, 创建mvp小队
 */
int Croute_func::sysarg_create_mvp_team(DEAL_FUN_ARG)
{
    sysarg_create_mvp_team_in *p_in=PRI_IN_POS;
    ret = this->sysarg_mvp_team.insert(p_in->mvp_team, p_in->teamname, p_in->logo, p_in->teamid);

    STD_RETURN(SUCC);
}
/*
 * 全局mvp排名表， 删掉mvp小队
 */
int Croute_func::sysarg_drop_mvp_team(DEAL_FUN_ARG)
{
    sysarg_drop_mvp_team_in *p_in=PRI_IN_POS;
    ret = this->sysarg_mvp_team.drop(p_in->mvp_team);

    STD_RETURN(SUCC);
}
/*
 * 全局mvp排名表， 拉取mvp小队排名
 */
int Croute_func::sysarg_get_mvp_team(DEAL_FUN_ARG)
{
    sysarg_get_mvp_team_in *p_in=PRI_IN_POS;
    sysarg_get_mvp_team_out_header  out_header = { 0 };
    sysarg_get_mvp_team_out_item *p_out_item = 0;
	uint32_t count = 0;
	ret = this->sysarg_mvp_team.get_count(&count);
	out_header.total_page = count / 8;
	if(count % 8 != 0){
		out_header.total_page = out_header.total_page + 1;
	}
	if(out_header.total_page == 0){
		out_header.total_page = 1;
	}
	DEBUG_LOG("count: %u, totoal_page: %u", count,  out_header.total_page);
	out_header.cur_page = p_in->page;

    ret = this->sysarg_mvp_team.get_page(p_in->page, &p_out_item, &out_header.count);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*                                                      
 * 全局mvp排名表，更新mvp小队的徽章个数
 */                                                     
int Croute_func::sysarg_set_mvp_badge(DEAL_FUN_ARG)     
{                                                       
    sysarg_set_mvp_badge_in *p_in=PRI_IN_POS;           
	struct tm *local;
	time_t t;
	uint32_t oldday;
	uint32_t oldbadge;
    t=time(NULL);
    local=localtime(&t);
    
    if (p_in->badge <= 0)
	{
        STD_RETURN(ret);   
	}
    ret=this->sysarg_mvp_team.update(p_in->mvp_team,p_in->badge);//徽章个数在原有基础上增加
	ret = this->sysarg_mvp_day.get_last_day(&oldday);
	if(oldday == (uint32_t)local->tm_yday)
	{
		 if(p_in->teamid == 1)
		 {
		     ret = this->sysarg_mvp_day.get_one_by_col(oldday,"value_1",&oldbadge);
             ret = this->sysarg_mvp_day.update_oldday(local->tm_yday,"value_1",p_in->badge+oldbadge);
		 }
	     else
		 {
		     ret = this->sysarg_mvp_day.get_one_by_col(oldday,"value_2",&oldbadge);
			 ret = this->sysarg_mvp_day.update_oldday(local->tm_yday,"value_2",p_in->badge+oldbadge);
		 }
	}
	else
	{
        if(p_in->teamid == 1)
             ret = this->sysarg_mvp_day.insert_newday(local->tm_yday,"value_1",p_in->badge);
        else
             ret = this->sysarg_mvp_day.insert_newday(local->tm_yday,"value_2",p_in->badge); 
	}
    STD_RETURN(ret);        
	/* 
    ret=this->sysarg_mvp_team.update(p_in->mvp_team,p_in->badge);//徽章个数在原有基础上增加
	switch(p_in->teamid)
	{
		case 1://
	        ret=this->sysarg_mvp_day.update_one(local->tm_yday,"value_1",p_in->badge);
			break;
		case 2://NONO
   	        ret=this->sysarg_mvp_day.update_one(local->tm_yday,"value_2",p_in->badge);
			break;
		default:
			break;
	}
    STD_RETURN(ret);        
	*/                                     
}
/*
 * t_user_temp_team表，更新mvp小队的徽章个数
 */
int Croute_func::user_set_mvp_badge(DEAL_FUN_ARG)
{
	user_set_mvp_badge_in *p_in=PRI_IN_POS; 
	uint32_t badge = 0;
	ret=this->user_temp_team.get_one(RECVBUF_USERID,"badge",&badge);
	badge += p_in->badge;
	ret=this->user_temp_team.update_badge(RECVBUF_USERID,p_in->teamid,badge);
	STD_RETURN(ret);
}
/*
 * 全局mvp排名表, 更改小队人数
 */
int Croute_func::sysarg_change_mvp_team_member_count(DEAL_FUN_ARG)
{
    sysarg_change_mvp_team_member_count_in *p_in=PRI_IN_POS;
	//ret=this->sysarg_mvp_team.change_member_count(RECVBUF_USERID, p_in->cnt);
	ret = this->sysarg_mvp_team.change_member_counts(RECVBUF_USERID, p_in->cnt);

    STD_RETURN(SUCC);
}
/*
 * 全局mvp排名表，抽取徽章最多，且人数没满的小队
 */
int Croute_func::sysarg_get_random_mvp_team(DEAL_FUN_ARG)
{
	sysarg_get_random_mvp_team_in *p_in = PRI_IN_POS;
    sysarg_get_random_mvp_team_out out={ 0 };
    ret = this->sysarg_mvp_team.get_max_not_full(p_in->team_id, &out.mvp_team);

    STD_RETURN_WITH_STRUCT(ret,out);
}
/*                                                                      
 * 全局mvp排名表，获取mvp小队的徽章数                                   
 */                                                                     
int Croute_func::user_get_mvp_badge(DEAL_FUN_ARG)                       
{                                                                       
    user_get_mvp_badge_out out={0};    
    struct tm *local;
    time_t t;
	uint32_t count = 0;
	struct p_list* list;
    t=time(NULL);
    local=localtime(&t);
    ret = this->sysarg_mvp_day.get_two(local->tm_yday,&list,&count,&out.putao_win,&out.nono_win);
	//for(i=0;i<count;i++)
    //{
		//if(list+i != NULL)
            //free(list+i);
	//}	
	if(list != NULL)
		free(list);
	ret = this->sysarg_mvp_day.get_current(local->tm_yday,&out.badge_putao,&out.badge_nono);	
	if(ret != SUCC)
	{
		out.badge_putao = out.badge_nono = 0;
	}
    STD_RETURN_WITH_STRUCT(SUCC,out);                                    
}              
/* 
 * 获取用户所在小队id
 */

int Croute_func::user_get_teamid(DEAL_FUN_ARG)
{
	user_get_teamid_out out={0};
	ret=this->user.get_teamid(RECVBUF_USERID,&out.team_id);
	STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 查询全局表mvp小队信息
 */
int Croute_func::user_get_sysarg_mvp_teaminfo(DEAL_FUN_ARG)
{
    user_get_sysarg_mvp_teaminfo_out out={0};
	memset(&out, 0 , sizeof(user_get_sysarg_mvp_teaminfo_out));

    ret = this->sysarg_mvp_team.select_mvp_team(RECVBUF_USERID, &out);
    STD_RETURN_WITH_STRUCT(ret,out);
}
/*
 * 设置猪猪向前冲活动当前猜想记录
 */
int Croute_func::user_set_pig_guess(DEAL_FUN_ARG)
{
	user_set_pig_guess_in *p_in=PRI_IN_POS; 
	ret=this->user_temp_active.add(RECVBUF_USERID,p_in->index+15,p_in->index,p_in->pig_id);
	STD_RETURN(ret);
}
/* 
 * 获取当前用户猪猪向前冲所有记录
 */
int Croute_func::user_get_pig_guess(DEAL_FUN_ARG)
{
	user_get_pig_guess_out_header  out_header = {0};
	user_get_pig_guess_out_item *p_out_item = {0};
	ret=this->user_temp_active.get_pig_guess_info(RECVBUF_USERID,&p_out_item,&out_header.count);
	for(uint32_t k = 0; k < out_header.count; ++k){
		DEBUG_LOG("round: %u, pigid: %u", (p_out_item+k)->index, (p_out_item+k)->pig_id);
	}
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 猪猪向前冲领取猪猪奖励
 */
int Croute_func::user_get_pig_prize(DEAL_FUN_ARG)
{
	user_get_pig_prize_in *p_in=PRI_IN_POS; 
	user_get_pig_prize_out out={0};
    user_add_attire_in tmp = { 0 };
    uint32_t value_1 = 0;
	uint32_t value_2 = 0;
    uint32_t isget = 0;
	ret=this->user_temp_active.get_two(RECVBUF_USERID,15+p_in->index,"value_1","value_2",&value_1,&value_2);
	if(ret == SUCC&&(value_2==p_in->pig_id))
	{
        isget = value_1>>16;
		if(isget == 0)//没有领取
        {
			value_1 = (1<<16)+value_1;
			ret = this->user_temp_active.update(RECVBUF_USERID,15+p_in->index,value_1,value_2);//update the status
            tmp.attiretype = 36;
            tmp.maxcount = 99999999;
            tmp.attireid = p_in->pig_id;
            tmp.count = 1;
            ret = this->user_add_attire(RECVBUF_USERID, &tmp);
			out.isget = 1;//原先没领，刚领过
		}
		else
		{
            out.isget = 0;//已经领过了
		}
	}
	else
	{
        out.isget = -1;//没有参加此场比赛猜猜
	}
	out.index = p_in->index;
	out.pig_id= p_in->pig_id;

	STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 客服机械工厂协议
 */
int Croute_func::su_user_get_piglet_machine_info(DEAL_FUN_ARG)
{
    su_user_get_piglet_machine_info_out_header  out_header = { 0 };
    su_user_get_piglet_machine_info_out_item *p_out_item = 0;
	ret = this->user_piglet_house.get_int_value(RECVBUF_USERID, "machine_level", &out_header.machine_level);
    ret = this->user_piglet_work.get_work_info(RECVBUF_USERID, &out_header.count, &p_out_item);
    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 客服查询机械工坊中猪的信息
 */
int Croute_func::su_user_get_work_piglet_info(DEAL_FUN_ARG)
{
    su_user_get_work_piglet_info_out_header  out_header = { 0 };
    su_user_get_work_piglet_info_out_item *p_out_item = 0;
    ret = this->user_piglet.get_machine_piglets(RECVBUF_USERID, &out_header.count, &p_out_item);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 客服查询机械工坊仓库
 */
int Croute_func::su_user_get_piglet_machine_warehouse(DEAL_FUN_ARG)
{
    su_user_get_piglet_machine_warehouse_out_header  out_header = { 0 };
    su_user_get_piglet_machine_warehouse_out_item *p_out_item = 0;
	const uint32_t start = 1613400;
    const uint32_t end = 1613999;
    ret = this->user_piglet_attire.get_items_range(RECVBUF_USERID, start, end, 2, &out_header.count, &p_out_item);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 台灣每日登陸，隨機10名獎勵
 */
int Croute_func::sysarg_tw_day_award_get(DEAL_FUN_ARG)
{
	uint32_t today = get_date(time(0));
    uint32_t count = 0;
    ret = this->sysarg_tw_day_award.get_count(RECVBUF_USERID, count ,today);
	if(count < 10){
         ret = this->sysarg_tw_day_award.insert(RECVBUF_USERID, today);
     }
	STD_RETURN(SUCC);
}
/*
 * 查询合影拍照信息
 */
int Croute_func::user_get_together_photo_info(DEAL_FUN_ARG)
{

	char buf[PROTO_MAX_LEN]={ 0 };

	user_get_together_photo_info_in *p_in=PRI_IN_POS; 
    user_get_together_photo_info_out_header  *out_header = (user_get_together_photo_info_out_header*)buf;
    user_get_together_photo_info_out_item *p_out_item = (user_get_together_photo_info_out_item*)
		(buf+sizeof(user_get_together_photo_info_out_header));
	user_photo_t photos;
	memset(&photos, 0, sizeof(photos));
    ret = this->user_together_photo.get_info(RECVBUF_USERID, p_in->type, &photos);
	out_header->count = photos.count;
	out_header->type = p_in->type;
	memcpy(p_out_item, photos.dress, sizeof(uint32_t)*photos.count);

	STD_RETURN_WITH_BUF(SUCC, buf, sizeof(*out_header)+ sizeof(uint32_t)*out_header->count);
}
/*
 * 合影拍照
 */
int Croute_func::user_set_together_photo(DEAL_FUN_ARG)
{
    user_set_together_photo_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_set_together_photo_in_item));
    user_set_together_photo_in_item * p_in_item=(user_set_together_photo_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
	user_photo_t photos;
	memset(&photos, 0, sizeof(photos));
	photos.count = p_in->count;
	for(uint32_t k = 0; k < p_in->count; ++k){
		photos.dress[k] = (p_in_item + k)->itemid;
	}
    ret = this->user_together_photo.insert(RECVBUF_USERID, p_in->type, &photos);

    STD_RETURN(SUCC);
}
/*
 * 杰克与魔豆策划案,浇水
 */
int Croute_func::sysarg_magic_bean_watering(DEAL_FUN_ARG)
{
    sysarg_magic_bean_watering_out out={0};
    ret = this->sysarg_top_rank.add(3, &out.count);

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 *  杰克与魔豆策划案, 查询树木状态
 */
int Croute_func::sysarg_magic_bean_querying(DEAL_FUN_ARG)
{
    sysarg_magic_bean_querying_out out={0};
	uint32_t datetime = 0;
    ret = this->sysarg_top_rank.select_count_datetime(3, &out.count, &datetime);
	uint32_t now = time(0);
	if(out.count >= 20 && (now - datetime ) >= 30*60){
		out.count = 0;
		ret = this->sysarg_top_rank.update_count_time(3, 0);
	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 思念音符策划案1
 */
int Croute_func::user_miss_note_stone(DEAL_FUN_ARG)
{
    user_miss_note_stone_in *p_in=PRI_IN_POS;
    user_miss_note_stone_out out={ 0 };

	if(p_in->type == 1){
		out.itemid = 0;
		out.state = 1;
	}
	else{
		uint32_t value_1 = 0, value_2 = 0;
		ret = this->user_temp_active.get_two(RECVBUF_USERID, 34, "value_1", "value_2", &value_1, &value_2);

		uint32_t low = value_2 & 0xFFFF;
		uint32_t high = value_2 >> 16;

		if((value_1 & (1 << (p_in->flag - 1))) != 0){
			out.state = 0;
		}
		else{
			value_1 = value_1 | (1 << (p_in->flag - 1));
			DEBUG_LOG("value_1 : %u", value_1);
			uint32_t count = 0;

			for(uint32_t k = 0; k < 5; ++k){
				uint32_t  bit = 1 << k;
				if( (value_1 & bit)  != 0){
				  ++count;	
				}
				else{
					break;
				}
			}
			DEBUG_LOG("count : %u", count);
			if(high == 3){
				out.itemid = 0;
				++low;
			}
			else{
				if(low == 2){
					out.itemid = 1351345;
					DEBUG_LOG("out.itemid : %u", out.itemid);
					++high;
				}
				else if(low + high < 5){
					uint32_t random  = rand()%5;
					if(random < 2){
						out.itemid = 0;
						++low;
					}
					else{
						out.itemid = 1351345;
						DEBUG_LOG("out.itemid : %u 111111", out.itemid);
						++high;
					}
				}
			}//else
			value_2 = (high << 16) | low;
			if(count == 5){
				ret = this->user_temp_active.add(RECVBUF_USERID, 34, 0, 0);
				out.round = 1;
			}
			else{
				ret = this->user_temp_active.add(RECVBUF_USERID, 34, value_1, value_2);
			}
			out.state = 1;
		}

		if(out.itemid != 0){
			user_add_attire_in tmp = { 0 };
			tmp.attiretype = 99;
			tmp.maxcount = 99999999;
			tmp.attireid = out.itemid;
			tmp.count = 1;
			ret = this->user_add_attire(RECVBUF_USERID, &tmp);
		}
		
	
	}
	if(out.state == 1){
		uint32_t total = 0;
		ret = this->user_temp_active.get_one(RECVBUF_USERID, 35, "value_1", &total);
		
		if(p_in->type == 1 || (p_in->type == 2 && out.round == 1)){
			if(total >= 10){
				ret = this->user_temp_active.add(RECVBUF_USERID, 35, 1, 0);
			}
			else{
				ret = this->user_temp_active.add(RECVBUF_USERID, 35, total+1, 0);
			}
			uint32_t msg_buff[2]={ RECVBUF_USERID, 1};
			msglog(this->msglog_file, 0x0409C3AC, time(NULL), msg_buff, 8);
		}

		ret = this->user_temp_active.get_one(RECVBUF_USERID, 35, "value_1", &total);
		if( total != 0 && total%3 == 0){
			out.itemid_3 = 1353220;
			user_add_attire_in tmp = { 0 };
			tmp.attiretype = 0;
			tmp.maxcount = 99999999;
			tmp.attireid = 1353220 ;
			tmp.count = 1;
			ret = this->user_add_attire(RECVBUF_USERID, &tmp);
		}
		if(total == 10){
			out.award = 1353306;
			user_add_attire_in tmp = { 0 };
			tmp.attiretype = 0;
			tmp.maxcount = 99999999;
			tmp.attireid = 1353306 ;
			tmp.count = 1;
			ret = this->user_add_attire(RECVBUF_USERID, &tmp);
		}
	}

	DEBUG_LOG("out.itemid : %u 2222", out.itemid);
    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 思念音符策划案2
 */
int Croute_func::user_get_miss_not_stone(DEAL_FUN_ARG)
{
    user_get_miss_not_stone_out out={ 0 };
    ret = this->user_temp_active.get_one(RECVBUF_USERID, 34, "value_1", &out.state);
    ret = this->user_temp_active.get_one(RECVBUF_USERID, 35, "value_1", &out.times);

	
    STD_RETURN_WITH_STRUCT(SUCC,out);
}

int Croute_func::user_add_attire_new(  userid_t userid, uint32_t attiretype, uint32_t attireid, uint32_t count, 
		uint32_t maxcount, uint32_t is_vip_opt_type)
{
	user_add_attire_in tmp = { 0 };
	tmp.attiretype = attiretype;
	tmp.maxcount = maxcount;
	tmp.attireid = attireid;
	tmp.count = count;
	uint32_t iret = this->user_add_attire(userid, &tmp);
	return iret;
}

int Croute_func::user_del_attire_new(  userid_t userid, uint32_t attiretype, uint32_t attireid, uint32_t count, 
		uint32_t maxcount, uint32_t is_vip_opt_type)
{


	user_del_attire_in del_item = {  0 };
	del_item.attireid = attireid;
	del_item.attiretype = attiretype;
	del_item.count = count;
	del_item.maxcount = maxcount;
	int iret=this->user_del_attire(userid ,&del_item);

	return iret;

}

int Croute_func::user_shake_dice_act(DEAL_FUN_ARG)
{
	user_shake_dice_out out={};
	uint32_t last_time = 0;
	uint32_t six_flag = 0;
	uint32_t last_date = 0;
	ret=this->user_shake_dice.query_time_flag(RECVBUF_USERID, &last_time, &six_flag, &last_date);
	if (ret == USER_ID_NOFIND_ERR)
	{
		out.num = rand()%6 + 1;
		this->user_shake_dice.insert(RECVBUF_USERID, time(0), 1);
		if (out.num == 6){
			ret = this->user_shake_dice.update(RECVBUF_USERID, "six_flag", 10000);
			if (ret == SUCC){
				this->user_add_attire_new(RECVBUF_USERID, 99, 1351346, 1, 99999);
			}
		}
		ret = 0;
	}
	else{	
		uint32_t today = get_date(time(0));
		if (today != last_date){
			this->user_shake_dice.update(RECVBUF_USERID, "last_date", today);
			this->user_shake_dice.update(RECVBUF_USERID, "six_flag", 0);
			six_flag = 0;
		}
		if ((last_time + 5*60) > time(0))
		{
			return USER_SHAKE_DICE_TIME_TOO_SHORT_ERR;
		}
		if (six_flag == 10000){
			out.num = 0;
		}
		else{
			out.num = rand()%6 + 1;
			if (six_flag >= 2){
				out.num = 6;
			}
			if (out.num == 6){
				ret = this->user_shake_dice.update(RECVBUF_USERID, "six_flag", 10000);
				if (ret == SUCC){
					this->user_add_attire_new(RECVBUF_USERID, 99, 1351346, 1, 99999);
				}
			}
			else{
				this->user_shake_dice.update(RECVBUF_USERID, "six_flag", six_flag + 1);
			}
		}
		this->user_shake_dice.update(RECVBUF_USERID, "last_time", time(0));
	}

	STD_RETURN_WITH_STRUCT(ret,out);
}


int Croute_func::user_get_shake_dice_left_time(DEAL_FUN_ARG)
{
	user_get_shake_dice_left_time_out out={};
	uint32_t last_time = 0;
	uint32_t six_flag = 0;
	uint32_t last_date = 0;
	ret=this->user_shake_dice.query_time_flag(RECVBUF_USERID, &last_time, &six_flag, &last_date);	
	if (ret == USER_ID_NOFIND_ERR){
		out.left_time = 0;
		ret = SUCC;
	}
	else
	{
		if (last_time > time(0) - 5*60){
			out.left_time = 5*60 - (time(0) - last_time);
		}
		else{
			out.left_time = 0;
		}
	}
	if (last_date != (uint32_t)get_date(time(0)))
	{
		out.six_flag = 0;
	}
	else
	{ 	if (six_flag != 10000){
			six_flag = 0;
		}
		else{
			six_flag = 1;
		}

		out.six_flag = six_flag;
		
	}


	STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * 摩达尼号探险活动策划案
 */
int Croute_func::user_check_expedition_lock(DEAL_FUN_ARG)
{
	user_check_expedition_lock_in *p_in = PRI_IN_POS; 
    user_check_expedition_lock_out out = { 0 };
	uint32_t need_item[] = { 1, 2, 2, 3, 3, 3, 3, 3};
	uint32_t lock = 0;
    ret = this->user_temp_active.get_one(RECVBUF_USERID, 37, "value_1", &lock);
	out.already_unlock = lock;

	if(p_in->flag == 0 && lock != 255){
		uint32_t del_count = 0;
		uint32_t itemid = 1351355;
		uint32_t count = 0;
		ret = this->user_temp_item.get_count(RECVBUF_USERID, itemid, count);
		for(uint32_t k = 0; k < 8; ++k){
			uint32_t bit = 1 << k;
			if((lock & bit) == 0 && count >= need_item[k]){
				 out.already_unlock =  out.already_unlock | bit;	
				 count = count - need_item[k];
				 del_count = del_count + need_item[k];
			}
		}
		
		if(out.already_unlock != lock){
			user_del_attire_in del_item;
			del_item.attireid = itemid;
			del_item.attiretype = 99;
			del_item.count = del_count;
			del_item.maxcount = 99999;
			ret=this->user_del_attire(RECVBUF_USERID ,&del_item);
			this->user_temp_active.add(RECVBUF_USERID, 37, out.already_unlock, 0);

		}
	}//if
		
    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 美人鱼与王子故事章节1
 */
int Croute_func::user_set_story_chapter_state(DEAL_FUN_ARG)
{
	enum{
		NOT_ITEM_COUNT         =        0, //物品个数不足
		WRONG_DIRECTION        =        1,//方向不正确
		RIGHT_DIRECTION        =        2,//方向正确
		DAY_LIMIT              =        3,//奖励达到上限，不会再送
	};
	//38, 39, 40, 41 已用
    user_set_story_chapter_state_in *p_in=PRI_IN_POS;
	user_set_story_chapter_state_out out = { 0 };	
	uint32_t state = 0;
	ret = this->user_temp_active.get_one(RECVBUF_USERID, p_in->type, "value_1", &state);
	uint32_t new_state = state;
	if(p_in->type == 38){
		uint32_t tmp = 1 << p_in->seq;
		if((state & tmp) == 0){
			new_state = state | tmp;
		}
	}
	else if(p_in->type == 39){
		;
	}
	else if(p_in->type == 40){
		const uint32_t itemid = 1351369;
		uint32_t count = 0;
		ret = this->user_temp_item.get_count(RECVBUF_USERID, itemid, count);		
		if(count < 1){
			out.state = NOT_ITEM_COUNT;
			STD_RETURN_WITH_STRUCT(SUCC,out);
		}
		else{
			user_del_attire_in del_item = { 0 };
			del_item.attireid = itemid;
			del_item.attiretype = 99;
			del_item.count = 1;
			del_item.maxcount = 99999;
			ret=this->user_del_attire(RECVBUF_USERID ,&del_item);

			uint32_t day_count = 0, day_time = 0;
			uint32_t now = time(0);	
			this->user_temp_active.get_two(RECVBUF_USERID, 41, "value_1", "value_2", &day_count, &day_time);
			uint32_t today = get_date(now);
			if(today != (uint32_t)get_date(day_time)){
				day_count = 0;
			}
			if(day_count < 150){
				uint32_t random = rand()%3;
				if(p_in->seq == random){
					out.item_cnt = 10;
					out.state = RIGHT_DIRECTION;
				}
				else{
					out.state = WRONG_DIRECTION;
					out.item_cnt = 5;
				}

				user_add_attire_in tmp = { 0 };
				tmp.attiretype = 99;
				tmp.maxcount = 0xFFFFFFFF;
				tmp.attireid = 1351367;
				tmp.count = out.item_cnt;
				this->user_add_attire(RECVBUF_USERID, &tmp);

				uint32_t msg_buff[2]={ RECVBUF_USERID, 1};
				msglog(this->msglog_file, 0x04040D70, time(NULL), msg_buff, 8);

				day_count = day_count + out.item_cnt;
				this->user_temp_active.add(RECVBUF_USERID, 41, day_count, now);

			}
			else{
				out.state = DAY_LIMIT;
			}
			if(new_state == 4){
				out.itemid = 14258;
			}
			else if(new_state == 9){
				out.itemid = 14259;
			}
			else{
				out.itemid = 0;
			}
			if(out.itemid != 0){
				user_add_attire_in tmp = { 0 };
				tmp.attiretype = 0;
				tmp.maxcount = 1;
				tmp.attireid = out.itemid;
				tmp.count = 1;
				this->user_add_attire(RECVBUF_USERID, &tmp);
			}

			if(new_state < 10){
				++new_state;
			}
			if(state == 10){
				out.cnt = 11;
			}
			else{
				out.cnt = new_state;
			}
			uint32_t msg_buff[2]={ RECVBUF_USERID, 1};
			msglog(this->msglog_file, 0x0409C3ED, time(NULL), msg_buff, 8);
		}
	}
	else if(p_in->type == 42){
		uint32_t low = state & 0xFFFF;
		uint32_t high = state >> 16;
		if(high+low == 5){
			out.itemid = 1623000;
			user_add_attire_in tmp = { 0 };
			tmp.attiretype = 0;
			tmp.maxcount = 999999;
			tmp.attireid = out.itemid;
			tmp.count = 1;
			this->user_add_attire(RECVBUF_USERID, &tmp);

		}
		if(p_in->seq == 1){
			high = high >= 3? high: (high+1);
		}
		else{
			low = low >= 3 ? low: (low+1);
		}
		new_state = (high << 16)|low;
		
	}
	else if(p_in->type == 44){
		DEBUG_LOG("type: %u, seq:%u", p_in->type, p_in->seq);

		uint32_t palpus = 0, datetime_1 = 0, special_fish = 0, datetime_2 = 0;
		this->user_temp_active.get_two(RECVBUF_USERID, 49, "value_1", "value_2", &palpus, &datetime_1);
		this->user_temp_active.get_two(RECVBUF_USERID, 48, "value_1", "value_2", &special_fish, &datetime_2);

		uint32_t now = time(0);
		if(get_date(now) != get_date(datetime_1)){
			this->user_temp_active.add(RECVBUF_USERID, 49, 0, now);
			palpus = 0;
		}
		if(get_date(now) != get_date(datetime_2)){
			this->user_temp_active.add(RECVBUF_USERID, 48, 0, now);
			special_fish = 0;
		}

		if(get_date(now) == get_date(datetime_1)){
			if(palpus >= 150){
				out.state |= 0x01;
			}
		}
		if(get_date(now) == get_date(datetime_2)){
			if(special_fish >= 3){
				out.state |= 0x02;
			}
		}
		if(out.state < 3 && p_in->seq == 0){
			if(state == 9){
				out.itemid = 1623003;
				out.item_cnt = 3;
				this->user_add_attire_new(RECVBUF_USERID, 0, out.itemid, 3, 999999);
			}
			new_state = state >= 10? 10:(state+1);
		}	
	}
	else if(p_in->type == 46){
		uint32_t low = 0, middle = 0, high = 0;
		low = state % 10;
		middle = (state/10)%10;
		high = state / 100;
		
		if((p_in->seq == 2 && low == 0) || (p_in->seq == 3 && (low == 0 || middle == 0))){
			out.state = 0;
		}	
		else{
			if(p_in->seq == 1 && low == 0){
				new_state = new_state + 1;
				out.state = 1;
			}
			if(p_in->seq == 2 && middle == 0){
				new_state = new_state + 10;
				out.state = 1;
			}
			if(p_in->seq == 3 && high == 0){
				new_state = new_state + 100;	
				out.state = 1;
			}
			if(out.state == 1 && new_state == 111){
				out.itemid = 1623005;
				out.item_cnt = 3;
				this->user_add_attire_new(RECVBUF_USERID, 0, out.itemid, 3, 999999);
			}
		}
	}
	else if(p_in->type == 49){
		uint32_t now = time(0);	
		uint32_t datetime = 0, palpus = 0;
		this->user_temp_active.get_two(RECVBUF_USERID, 49, "value_1", "value_2", &palpus, &datetime);
		if(get_date(now) == get_date(datetime) && palpus < 150 ){
			this->user_temp_active.add(RECVBUF_USERID, 49, palpus+p_in->seq, now);
		}
		else if(get_date(now) != get_date(datetime)){
			this->user_temp_active.add(RECVBUF_USERID, 49, p_in->seq, now);
		}
	}
	else if(p_in->type == 48){
		uint32_t now = time(0);	
		uint32_t datetime = 0, special_fish = 0;
		this->user_temp_active.get_two(RECVBUF_USERID, 48, "value_1", "value_2", &special_fish, &datetime);
		if(get_date(now) == get_date(datetime) && special_fish < 3 ){
			this->user_temp_active.add(RECVBUF_USERID, 48, special_fish+p_in->seq, now);
		}
		else if(get_date(now) != get_date(datetime)){
			this->user_temp_active.add(RECVBUF_USERID, 48, p_in->seq, now);
		}

	}
	else if(p_in->type == 251){//type==251打工五次

		uint32_t db_buff[2] = { RECVBUF_USERID, 1};
		msglog(this->msglog_file, 0x0409C44D,time(NULL), db_buff, sizeof(db_buff));
		int m_ret = user_del_attire_new(RECVBUF_USERID, 0, 1351392, 2, 0xFFFFFFF);
		if(m_ret == SUCC){
			if(state == 4){
				out.state = 1633032;
				out.cnt = 1;
				out.itemid = 1623003;
				out.item_cnt = 3;
				this->user_add_attire_new(RECVBUF_USERID, 0, out.itemid, 3, 999999);
				this->user_add_attire_new(RECVBUF_USERID, 0, 1633032, 1, 999999);
				++new_state;
			}
			else if(state < 4){
				ret = this->user.update_xiaomee_inc(RECVBUF_USERID, 200);
				++new_state;
			}
		}
		else{
			out.itemid = 0;
			out.item_cnt = 0;
		}
		uint32_t value_2 = 0;
		ret = this->user_temp_active.get_one(RECVBUF_USERID, 45, "value_2", &value_2);
		if(ret == SUCC){
			if(value_2 < 5){
				ret = this->user_temp_active.update_one(RECVBUF_USERID, 45, "value_2", value_2 + 1);
			}
		}
		
	}

	DEBUG_LOG("state: %u, new_state: %u", state, new_state);
	if(new_state != state){
		this->user_temp_active.add(RECVBUF_USERID, p_in->type, new_state, 0);
	}

	STD_RETURN_WITH_STRUCT(SUCC,out);
}

/*
 * 美人鱼与王子故事章节2
 */
int Croute_func::user_get_story_chapter_state(DEAL_FUN_ARG)
{
    user_get_story_chapter_state_out_header  out_header = { 0 };
    user_get_story_chapter_state_out_item *p_out_item = 0;
    ret = this->user_temp_active.get_chapter_states(RECVBUF_USERID, &p_out_item, &out_header.count);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}


/*
 * 造潜艇活动策划案
 */
int Croute_func::user_get_make_submarine(DEAL_FUN_ARG)
{
	char buf[1024]={ 0 };
    user_get_make_submarine_out_header  *out_header = (user_get_make_submarine_out_header*)buf;
    user_get_make_submarine_out_item *p_out_item = (user_get_make_submarine_out_item*)(buf+sizeof(*out_header));

	uint32_t count = 0;
	ret = this->user_temp_item.get_count(RECVBUF_USERID, 1351364, count);
	if(count >= 1){
		uint32_t make_times = 0;
		ret = this->user_temp_active.get_one(RECVBUF_USERID, 39, "value_1", &make_times);
		if( make_times == 2){
			(p_out_item+out_header->count)->itemid = 14174;
			++out_header->count;
			user_add_attire_in tmp = { 0 };
			tmp.attiretype = 0;
			tmp.maxcount = 1;
			tmp.attireid = 14174;
			tmp.count = 1;
			this->user_add_attire(RECVBUF_USERID, &tmp);
		//	uint32_t msg_buff[2]={ RECVBUF_USERID, 1};
		//	msglog(this->msglog_file, 0x0201087E, time(NULL), msg_buff, 8);
		}

		uint32_t itemids[] = { 1270006, 1270007, 1270015, 1270016, 1270017};
		uint32_t index = rand()%5;
		(p_out_item + out_header->count)->itemid = itemids[index];
		++out_header->count;	
		user_add_attire_in tms = { 0 };
		tms.attiretype = 0;
		tms.maxcount = 999999;
		tms.attireid = itemids[index];
		tms.count = 1;
		this->user_add_attire(RECVBUF_USERID, &tms);

		if(make_times < 3){
			this->user_temp_active.add(RECVBUF_USERID, 39, make_times+1, 0);
		}	
		//扣除零食物品造舰木材	
		user_del_attire_in del_item;
		del_item.attireid = 1351364;
		del_item.attiretype = 99;
		del_item.count = 1;
		del_item.maxcount = 99999;
		ret=this->user_del_attire(RECVBUF_USERID ,&del_item);

		out_header->state = 1;
		uint32_t msg_buff[2]={ RECVBUF_USERID, 1};
		msglog(this->msglog_file, 0x0409C3E6, time(NULL), msg_buff, 8);

	}
	STD_RETURN_WITH_BUF(SUCC, buf, sizeof(*out_header)+ sizeof(user_get_make_submarine_out_item)*out_header->count);
}

/*
 * 库拉的生日，石头剪刀布
 */
int Croute_func::user_stone_scissors_cloth(DEAL_FUN_ARG)
{
    user_stone_scissors_cloth_in *p_in=PRI_IN_POS;
    user_stone_scissors_cloth_out out={0};
	uint32_t rand_type[2] = { 0, 0};
	if(p_in->type == 1){
		rand_type[0] = 2;
		rand_type[1] = 3;
	}
	else if(p_in->type == 2){
		rand_type[0] = 1;
		rand_type[1] = 3;
	}
	else if(p_in->type == 3){
		rand_type[0] = 1;
		rand_type[1] = 2;
	}

	uint32_t random = rand()%2;
	out.self_type = p_in->type;
	out.kula_type = rand_type[random];

	DEBUG_LOG("type: %u, random: %u", p_in->type, rand_type[random]);
	if(p_in->type > rand_type[random] || (p_in->type == 1 && rand_type[random] == 3)){
		if(p_in->type == 3 && rand_type[random] == 1){
			out.state = 0;
		}
		else{
			out.state = 1;

			uint32_t items[] = { 14226, 14227, 14228, 14229, 14273, 14274, 14275};
			id_list array;
			memset(&array, 0, sizeof(id_list));
			array.count = sizeof(items)/sizeof(uint32_t);
			for(uint32_t k = 0; k < array.count; ++k){
				array.item[k] = items[k];
			}
		
			uint32_t count = 0;	
			attire_count* p_item = 0;
			ret = this->user_attire.get_list_by_idlist(RECVBUF_USERID, &array, &count, &p_item); 
			uint32_t k = 0;
			for(; k < array.count; ++k){
				attire_count other = { items[k], 0};
				attire_count* iter = std::find(p_item, p_item+count, other);
				if(iter == p_item+count){
					out.itemid = items[k];
					break;
				}
			}
			if(k >= array.count){
				out.itemid = 17032; 
			}
			if(p_item != 0){
				free(p_item);
			}
			user_add_attire_in tms = { 0 };
			tms.attiretype = 0;
			tms.maxcount = 999999;
			tms.attireid = out.itemid;
			tms.count = 1;
			this->user_add_attire(RECVBUF_USERID, &tms);
		}//else
	}
	
    STD_RETURN_WITH_STRUCT(SUCC,out);
}

/*
 * 库拉生日，检查色子
 */
int Croute_func::user_check_roll_dice(DEAL_FUN_ARG)
{
    user_check_roll_dice_out out={0};
	uint32_t count = 0;
    ret = this->user_temp_item.get_count(RECVBUF_USERID, 1351346, count);
	if(count >= 1){
		out.state = 1;

		user_del_attire_in del_item;
		del_item.attireid = 1351346;
		del_item.attiretype = 99;
		del_item.count = 1;
		del_item.maxcount = 99999;
		ret=this->user_del_attire(RECVBUF_USERID ,&del_item);
	}
    STD_RETURN_WITH_STRUCT(SUCC,out);
}

/*
 * 拉取摇奖vip，循环播放
 */
int Croute_func::sysarg_get_free_vip_player(DEAL_FUN_ARG)
{
    sysarg_get_free_vip_player_out_header  out_header = { 0 };
    sysarg_get_free_vip_player_out_item *p_out_item = 0;
    ret = this->sysarg_guess_price.get_records_by_itemid(&p_out_item, &out_header.count);

    STD_RETURN_WITH_STRUCT_LIST(SUCC,out_header,p_out_item,out_header.count);
}
/*
 * 人鱼王国
 */
int Croute_func::user_get_merman_kingdom(DEAL_FUN_ARG)
{
    user_get_merman_kingdom_out_header  out_header = { 0 };
    user_get_merman_kingdom_out_item *p_out_item = 0;
    ret = this->user_temp_active.get_merman_kingdom(RECVBUF_USERID, &p_out_item, &out_header.count);

    STD_RETURN_WITH_STRUCT_LIST(SUCC,out_header,p_out_item,out_header.count);
}
/*
 * 年中特卖会
 */
int Croute_func::user_middle_year_cheap_seal(DEAL_FUN_ARG)
{
    user_middle_year_cheap_seal_out out={0};
	uint32_t blue_cnt = 0, red_cnt = 0;
    ret=this->user.get_attire_count( HOME_STR, RECVBUF_USERID, 160365, 2, &blue_cnt );
    ret=this->user.get_attire_count( HOME_STR, RECVBUF_USERID, 160364, 2, &red_cnt );
	uint32_t itemid = 0;
	if(blue_cnt == 0 && red_cnt == 0){
		uint32_t items[] = {  160364, 160365};	
		uint32_t index = rand()%2;
		itemid = items[index];
	}
	else if(blue_cnt == 0 && red_cnt > 0){
		itemid = 160365;	
	}
	else if(blue_cnt > 0 && red_cnt == 0){
		itemid = 160364;
	}	
	if(itemid != 0){
		out.itemid = itemid;
		user_add_attire_in tms = { 0 };
		tms.attiretype = 1;
		tms.maxcount = 1;
		tms.attireid = itemid;
		tms.count = 1;
		this->user_add_attire(RECVBUF_USERID, &tms);
	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}

int Croute_func::user_join_cosplay_race(DEAL_FUN_ARG)
{
	user_join_cosplay_race_in *p_in=PRI_IN_POS; 
	user_join_cosplay_race_out out={0};
	uint32_t day_count = 0, day_date = 0;
	uint32_t day_max = 0;
	bool is_vip = 0;
	ret = this->user_ex.get_vip(RECVBUF_USERID, &is_vip );
	if (is_vip){
		day_max = 6;
	}
	else{
		day_max = 3;
	}

	uint32_t today = get_date(time(0));
	ret=this->user_temp_active.get_two(RECVBUF_USERID, 50+p_in->starid, "value_1", "value_2", &day_count, &day_date);
	if (ret == USER_ID_NOFIND_ERR){
		this->user_temp_active.add(RECVBUF_USERID, 50+p_in->starid, 1, today);
	}
	else{
		if(today != day_date){
			this->user_temp_active.update(RECVBUF_USERID, 50+p_in->starid, 1, today);
			day_count = 0;
		}

		if (day_count >= day_max){
			uint32_t num = 0;
	    	ret = this->user_temp_item.get_count(RECVBUF_USERID, 1351388, num);
			if (ret == USER_ID_NOFIND_ERR){
				return USER_JION_COSPLAY_STAR_DAY_MAX_ERR;
			}
			if(num >= 1){
				user_del_attire_in del_item;
				del_item.attireid = 1351388;
				del_item.attiretype = 99;
				del_item.count = 1;
				del_item.maxcount = 99999;
				this->user_del_attire(RECVBUF_USERID ,&del_item);
			}
			else{
				return USER_JION_COSPLAY_STAR_DAY_MAX_ERR;
			}
		}
		this->user_temp_active.update(RECVBUF_USERID, 50+p_in->starid, 1+day_count, today);	
	}
	
	this->user_add_attire_new(RECVBUF_USERID, 0, 190951, p_in->cnt, 99999);
	uint32_t medal_cnt = 0;
	uint32_t medal_date = 0;
	ret=this->user_temp_active.get_two(RECVBUF_USERID, 57, "value_1", "value_2", &medal_cnt, &medal_date);
	if ((ret == USER_ID_NOFIND_ERR) || (medal_date != today)) {
		this->user_temp_active.add(RECVBUF_USERID, 57, p_in->cnt, today);
		medal_cnt = 0;
		ret = SUCC;
	}
	else{
		this->user_temp_active.update(RECVBUF_USERID, 57, p_in->cnt+medal_cnt, today);
	}

	out.all_cnt = medal_cnt + p_in->cnt;
	out.itemid = 190951;
	out.count = p_in->cnt;

	STD_RETURN_WITH_STRUCT(ret,out);
}

int Croute_func::sysarg_set_cos_user_info(DEAL_FUN_ARG)
{
	sysarg_set_cos_user_info_in *p_in=PRI_IN_POS;
	uint32_t today = get_date(time(0));
	ret=this->sysarg_cos_rank.update_count(today, RECVBUF_USERID, p_in->count);
	if (ret == USER_ID_NOFIND_ERR){
		uint32_t count = 0;
		ret=this->sysarg_cos_rank.get_record_count(today, &count);
		if (count < 50){
			this->sysarg_cos_rank.insert(RECVBUF_USERID, p_in->count, p_in->nick);	
		}
		else{
			uint32_t num = 0;
			this->sysarg_cos_rank.get_min_count(today, &num);
			if(p_in->count > num){
				this->sysarg_cos_rank.update_last_record(today, RECVBUF_USERID, p_in->count, p_in->nick);
			}
		}
	}

	STD_RETURN(ret);
}

int Croute_func::sysarg_get_cos_rank(DEAL_FUN_ARG)
{
	sysarg_get_cos_rank_in *p_in=PRI_IN_POS; 
	sysarg_get_cos_rank_out_header  out_header;
	sysarg_get_cos_rank_out_item *p_out_item;
	ret=this->sysarg_cos_rank.get_cos_rank(p_in->datetime, &p_out_item, &(out_header.count));
	ret = SUCC;
	STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}


int Croute_func::sysarg_get_user_rank_flag(DEAL_FUN_ARG)
{
	sysarg_get_user_rank_flag_out out={};
	uint32_t count = 0;
	ret=this->sysarg_cos_rank.get_user_record(RECVBUF_USERID, &count);
	if (count == 0)
	{
		out.flag = 0;
	}
	else {
		uint32_t date_begin = 20120606;
		uint32_t date_end = get_date(time(0));
		uint32_t i = 0; 
		for (i = date_begin; i < date_end; i++)
		{
			uint32_t cnt = 0;
			this->sysarg_cos_rank.get_tenth_count(i, &cnt);			
			uint32_t user_cnt = 0;
			this->sysarg_cos_rank.get_user_date_count(RECVBUF_USERID, i, &user_cnt);
			
			if (user_cnt >= cnt){
				out.flag = 1;
				break;
			}
		}
	}

	STD_RETURN_WITH_STRUCT(ret,out);
}


/*
 * 海底世界
 *
 * 进入海底世界
 */
int Croute_func::user_enter_ocean(DEAL_FUN_ARG)
{
	char buf[PROTO_MAX_LEN]={ 0 };
    user_enter_ocean_in *p_in=PRI_IN_POS;
    user_enter_ocean_out_header  *out_header = (user_enter_ocean_out_header*)buf;
    user_enter_ocean_out_item_1 *p_out_item_1 = (user_enter_ocean_out_item_1 *)(buf+sizeof( *out_header));


	//拉取海底diy
	furnish_diy_t diy;
	memset(&diy, 0, sizeof(furnish_diy_t));
    ret = this->user_ocean.get_all(RECVBUF_USERID, p_in->oceanid, &diy, &out_header->capacity);
	uint32_t exp = 0, datetime = 0;
	ret = this->user_ocean_info.get(RECVBUF_USERID, &exp, &datetime);

	if(ret != SUCC){
		if(p_in->userid == RECVBUF_USERID){
			const uint32_t siren = 0;
			this->user_ocean_info.add(RECVBUF_USERID, exp);
			this->user_ocean.add(RECVBUF_USERID,  siren);
			const uint32_t fishid = 1623000, breed = 1;
			this->user_fish.raise_fish(RECVBUF_USERID, 1, fishid, breed, 0);
			this->user_fish.raise_fish(RECVBUF_USERID, 1, fishid, breed, 41, 0);
			this->user_ocean_info.update_coin(RECVBUF_USERID, 100);
			this->user_add_attire_new(RECVBUF_USERID, 0, 1633000, 100, 99999);

			ret = this->user_ocean.get_all(RECVBUF_USERID, p_in->oceanid, &diy, &out_header->capacity);
		}
	}
	
	uint32_t freshman = 0;
	this->user_temp_active.get_one(RECVBUF_USERID, 301, "value_1", &freshman);
	if(freshman == 0){
		uint32_t db_buff[2] = { RECVBUF_USERID, 1};
		msglog(this->msglog_file, 0x0409C44F,time(NULL), db_buff, sizeof(db_buff));
		this->user_temp_active.add(RECVBUF_USERID, 301, 1, 0);
		this->user_add_attire_new(RECVBUF_USERID, 0, 1623000, 2, 99999);
		this->user_ocean_info.update_coin(RECVBUF_USERID, 100);
		this->user_add_attire_new(RECVBUF_USERID, 0, 1633009, 2, 99999);
	}	
	out_header->freshman = freshman;
	DEBUG_LOG("fresh_man: %u",  out_header->freshman);

	uint32_t golden_shell = 0;
	this->user_attire.get_noused_count(RECVBUF_USERID, 1633004, golden_shell);
	DEBUG_LOG("golden_shell: %u", golden_shell);
	this->user_ocean_info.get_coin(RECVBUF_USERID, &out_header->coin);
	out_header->coin += golden_shell * 3;	
	this->user_ocean_info.set_coin(RECVBUF_USERID, out_header->coin);
	if(golden_shell != 0){
		user_del_attire_new(RECVBUF_USERID, 0, 1633004, golden_shell, 0xFFFFFFF);
	}

	out_header->cur_exp = exp;
	out_header->level = this->user_ocean.get_level(exp);
	out_header->upgrade_need_exp = this->user_ocean.get_upgrade_exp(out_header->level) -  exp; 
		
	out_header->ground = diy.ground;
	out_header->count_1 = diy.count;
	memcpy((char*)p_out_item_1, (char*)diy.furnishes, sizeof(user_enter_ocean_out_item_1)*diy.count);

	uint32_t foodid[3] = { 1633000, 1633001, 1633002};
	for(uint32_t k = 0; k < 3; ++k){
		uint32_t count = 0;
		this->user_attire.get_count(RECVBUF_USERID, foodid[k], count);
		out_header->fish_food[k] = count;
	}

	//拉取鱼群
	user_enter_ocean_out_item_2 *p_out_item_2 = (user_enter_ocean_out_item_2*)((char*)p_out_item_1 + 
			sizeof(user_enter_ocean_out_item_1)*out_header->count_1);
	ret = this->user_fish.get_ocean_fish(RECVBUF_USERID, p_in->oceanid, p_out_item_2, &out_header->count_2,
			&out_header->shells);
	DEBUG_LOG("count_1: %u, count_2: %u", out_header->count_1, out_header->count_2);

	char* p_offset = (char*)p_out_item_2 + sizeof(user_enter_ocean_out_item_2)*out_header->count_2;
	
	for(uint32_t k = 0; k < out_header->count_2; ++k){
		DEBUG_LOG("index: %u, fishid: %u, breed: %u, birthday: %u, growth: %u, state: %u, hungry: %u, lifetime: %u", (p_out_item_2+k)->index, (p_out_item_2+k)->fishid, (p_out_item_2+k)->breed, (p_out_item_2+k)->birthday, (p_out_item_2+k)->growth, (p_out_item_2+k)->state, (p_out_item_2+k)->hungry, (p_out_item_2+k)->lifetime);
	}
	
	uint32_t db_buff[2] = { RECVBUF_USERID, 1};
	msglog(this->msglog_file, 0x0409C42E,time(NULL), db_buff, sizeof(db_buff));

	if(out_header->level != 0){
		uint32_t msg_id = 0;
		if(out_header->level%10 != 0){
			msg_id = out_header->level / 10;
		}
		else{
			msg_id  = (out_header->level / 10) - 1;
		}
		msglog(this->msglog_file, msg_id + 0x0409C424,time(NULL), db_buff, sizeof(db_buff));

	}
	
	STD_RETURN_WITH_BUF(SUCC, buf, p_offset - buf);
}
/*
 *海底世界， 喂食鱼苗
 */
int Croute_func::user_feed_fish(DEAL_FUN_ARG)
{
	enum{
		FISH_NOTHING      =   0, //要喂食的鱼不存在
		FOOD_NO_ENOUGH    =   1,//鱼食不够
		FISH_NO_CONDITION =   2,//鱼和鱼食不匹配
		RET_SUCC          =   3,//成功
	};
    user_feed_fish_in *p_in=PRI_IN_POS;
    user_feed_fish_out out={ 0 };
	
	//查看鱼食数量
	uint32_t count = 0;
	ret = this->user_attire.get_count(RECVBUF_USERID, p_in->foodid, count);
	if(count < 1){
		out.state = FOOD_NO_ENOUGH;
		STD_RETURN_WITH_STRUCT(SUCC,out);
	}

	//检查鱼是否存在
	uint32_t fishid = 0;
    ret=this->user_fish.get_double_col(RECVBUF_USERID, p_in->oceanid, p_in->fishid, "hungry", "fishid", 
			&out.hungry, &fishid);
	if(ret == SUCC){
		uint32_t birthday = 0, lifetime = 0;
		this->user_fish.get_double_col(RECVBUF_USERID, p_in->oceanid, p_in->fishid, "birthday", "lifetime", 
			&birthday, &lifetime);
		uint32_t now = time(0);
		if(now - birthday > lifetime){
			out.state = FISH_NOTHING;
			STD_RETURN_WITH_STRUCT(SUCC,out);
		}
		//检查鱼是否饥饿
		if(out.hungry > 20){
			out.state = FISH_NO_CONDITION;
			STD_RETURN_WITH_STRUCT(SUCC,out);
		}
		//检查鱼的种类与鱼食是否匹配
		ret = user_fish.check_match_food(fishid, p_in->foodid);
		if(ret == -1){
			out.state = FISH_NO_CONDITION;
			STD_RETURN_WITH_STRUCT(SUCC,out);

		}

		out.hungry = out.hungry + p_in->add_value;
		if(out.hungry > 50){
			out.hungry = 50;
		}

		ret = this->user_fish.update_double_col(RECVBUF_USERID, p_in->oceanid, p_in->fishid, "hungry",
			   "feed_time", out.hungry, now);

		uint32_t exp = 0;
		this->user_ocean_info.get_exp(RECVBUF_USERID, &exp);
		uint32_t old_level = this->user_ocean.get_level(exp);
		this->user_ocean_info.set_exp(RECVBUF_USERID, exp+2);

		uint32_t new_exp = 0;
		this->user_ocean_info.get_exp(RECVBUF_USERID, &new_exp);
		uint32_t new_level = this->user_ocean.get_level(new_exp);

		if(new_level != old_level){
			out.is_upgrade = 1;
		}
		out.cur_exp = new_exp;
		out.upgrade_need_exp = this->user_ocean.get_upgrade_exp(new_level) -  out.cur_exp;

		user_del_attire_new(RECVBUF_USERID, 0, p_in->foodid, 1, 0xFFFFFFF);
		out.state = RET_SUCC;

		uint32_t db_buff[2] = { RECVBUF_USERID, 1};
		msglog(this->msglog_file, 0x0409C42F,time(NULL), db_buff, sizeof(db_buff));

	}//if

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 *鱼放入海底世界 
 */
int Croute_func::user_put_in_ocean(DEAL_FUN_ARG)
{
	enum{
		NOT_CORRECT_FISH        =   0,//不正确的鱼
		OCEAN_CONGEST           =   1,//海底太拥挤
		RET_SUCC                =   2,//成功

	};
    user_put_in_ocean_in *p_in=PRI_IN_POS;
    user_put_in_ocean_out out={0};


	uint32_t item_cnt = 0;
	ret = this->user_attire.get_count(RECVBUF_USERID, p_in->fishid, item_cnt);
	if(item_cnt < 1){

		STD_RETURN_WITH_STRUCT(SUCC,out);
	}

	uint32_t count = 0, capacity = 0;
	ret = this->user_fish.get_count(RECVBUF_USERID, p_in->oceanid, &count);
	ret = this->user_ocean.get_one_col(RECVBUF_USERID, p_in->oceanid, "capacity", &capacity);
	if(count < capacity){
		ret = this->user_fish.raise_fish(RECVBUF_USERID, p_in->oceanid, p_in->fishid, p_in->breed);
		if(ret == -1){
			out.state = NOT_CORRECT_FISH;
		}
		else{
			out.state  = RET_SUCC;
			user_del_attire_new(RECVBUF_USERID, 0, p_in->fishid, 1, 0xFFFFFFF);
			ret = this->user_fish.get_one_fish(RECVBUF_USERID, p_in->oceanid, &out);

			uint32_t db_buff[2] = { RECVBUF_USERID, 1};
			msglog(this->msglog_file, 0x0409C432,time(NULL), db_buff, sizeof(db_buff));
			this->user_ocean_handbook.insert(RECVBUF_USERID, p_in->fishid);
		}
		
	}
	else{
		out.state = OCEAN_CONGEST;
	}
    STD_RETURN_WITH_STRUCT(SUCC,out);

}

/*
 *diy海底世界 
 */
int Croute_func::user_diy_ocean(DEAL_FUN_ARG)
{
	enum{
		NOT_ITEM            =        0,//物品不存在
		DIY_LIMIT           =        1,//diy上限
		OCEAN_NOT_EXIST     =        2,//海底世界不存在
		RET_SUCC            =        3,//成功
	};

	user_diy_ocean_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_diy_ocean_in_item));
    user_diy_ocean_in_item * p_in_item=(user_diy_ocean_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
	for(uint32_t k = 0; k < p_in->count; ++k){
		DEBUG_LOG("(p_in_item+k)->diys.itemid: %u", (p_in_item+k)->diys.itemid);
	}
	
    user_diy_ocean_out out={0};

	struct put_take_t{
		uint32_t itemid;
		uint32_t count;
		int32_t state;
	};	
	put_take_t tmp[FURNISH_CNT*2];
	uint32_t tmp_cnt = 0;

	furnish_diy_t box;
    memset(&box, sizeof(furnish_diy_t), 0);
    int ret = this->user_ocean.get_diy(RECVBUF_USERID, p_in->oceanid, &box);
	DEBUG_LOG("count: %u", box.count);
	if(ret != SUCC){
		out.state = OCEAN_NOT_EXIST; 
		STD_RETURN_WITH_STRUCT(SUCC,out);
	}
	if(p_in->count > FURNISH_CNT){
		out.state = DIY_LIMIT; 
		STD_RETURN_WITH_STRUCT(SUCC,out);
	}
	if(p_in->background != 0){
		uint32_t back_cnt = 0;
		ret = this->user_attire.get_noused_count(RECVBUF_USERID, p_in->background, back_cnt);
		if(back_cnt < 1){
			out.state = NOT_ITEM; 
			STD_RETURN_WITH_STRUCT(SUCC,out);
		}
	}

	std::map<uint32_t, uint32_t> box_map;
	for(uint32_t i = 0; i < box.count; ++i){
		++box_map[box.furnishes[i].itemid];	
	}
	std::map<uint32_t, uint32_t> in_map;
	for(uint32_t i = 0; i < p_in->count;++i){
		++in_map[(p_in_item+i)->diys.itemid];
	}
	std::map<uint32_t, uint32_t>::iterator  is1 = box_map.begin();
	for(;is1 != box_map.end(); ++is1){
		std::map<uint32_t, uint32_t>::iterator is2 = in_map.begin();
		for(; is2 != in_map.end(); ++is2){
			if(is1->first == is2->first){
				break;
			}
		}
		if(is2 == in_map.end()){
			tmp[tmp_cnt].itemid = is1->first;	
			tmp[tmp_cnt].state = 1;
			tmp[tmp_cnt].count = is1->second;;
			++tmp_cnt;
		}
	}
	
	std::map<uint32_t, uint32_t>::iterator it1 = in_map.begin();
	for(;it1 != in_map.end(); ++it1){
		std::map<uint32_t, uint32_t>::iterator it2= box_map.begin();
		for(;it2 != box_map.end(); ++it2){
			if(it1->first == it2->first){
				break;
			}
		}
		if(it2 == box_map.end()){
			tmp[tmp_cnt].itemid = it1->first;	
			tmp[tmp_cnt].state = -1;
			tmp[tmp_cnt].count = it1->second;;
			++tmp_cnt;
		}
	}


	std::map<uint32_t,uint32_t>::iterator iq1 = in_map.begin();
	for(; iq1 != in_map.end(); ++iq1){
		std::map<uint32_t,uint32_t>::iterator it2 = box_map.begin();
		for(; it2 != box_map.end(); ++it2){
			if(iq1->first == it2->first && iq1->second != it2->second){
				tmp[tmp_cnt].itemid = iq1->first;	
				if(iq1->second > it2->second){
					tmp[tmp_cnt].state = -1;
					tmp[tmp_cnt].count = iq1->second - it2->second;
					
				}
				else{
					tmp[tmp_cnt].state = 1;
					tmp[tmp_cnt].count = it2->second - iq1->second;
				}//else
				++tmp_cnt;
			}//if
		}//for
		
	}

			

	DEBUG_LOG("tmp_cnt: %u", tmp_cnt);
	for(uint32_t k = 0; k < tmp_cnt; ++k){
		uint32_t count = 0;		
		ret = this->user_attire.get_noused_count(RECVBUF_USERID, tmp[k].itemid, count);
		DEBUG_LOG("count: %u, tmp[k].count: %u, itemid: %u", count, tmp[k].count, tmp[k].itemid);
		if(tmp[k].state == -1 && count < tmp[k].count){
			out.state = NOT_ITEM;
			STD_RETURN_WITH_STRUCT(SUCC,out);
		}
	}
	for(uint32_t k = 0; k < tmp_cnt; ++k){
		if(tmp[k].state == -1){
			this->user_attire.put_on(RECVBUF_USERID, tmp[k].itemid, tmp[k].count);
		}
		else{
			this->user_attire.take_off(RECVBUF_USERID, tmp[k].itemid, tmp[k].count);
		}
	}

	if(p_in->background != 0){
		this->user_attire.put_on(RECVBUF_USERID, p_in->background, 1);
		this->user_attire.take_off(RECVBUF_USERID, box.ground, 1);
	}
	uint32_t old_ground = box.ground;
    memset(&box, sizeof(furnish_diy_t), 0);
	if(p_in->background != 0){
		box.ground = p_in->background;
	}
	else{
		box.ground = old_ground;

	}
	box.count = p_in->count;
	memcpy(box.furnishes, (char*)p_in_item, sizeof(user_diy_ocean_in_item)*p_in->count);
	
	ret = this->user_ocean.update(RECVBUF_USERID, p_in->oceanid, &box);
	out.state = RET_SUCC;
	
    STD_RETURN_WITH_STRUCT(SUCC,out);
}

/*
 * 使用道具
 */
int Croute_func::user_apply_fish_tool(DEAL_FUN_ARG)
{
    user_apply_fish_tool_in *p_in=PRI_IN_POS;
    user_apply_fish_tool_out out={0};

	switch(p_in->toolid){
		case 0:
			{
				break;
			}
		case 1:
			{
				break;
			}
	}
    STD_RETURN_WITH_STRUCT(ret,out);
}

/*
 * 海底世界扩容
 */
int Croute_func::user_expand_ocean_capacity(DEAL_FUN_ARG)
{
    user_expand_ocean_capacity_in *p_in=PRI_IN_POS;
    ret = this->user_ocean.update_one_col(RECVBUF_USERID, p_in->oceanid, "capacity", 20);

    STD_RETURN(ret);
}

/*
 * 拉取海底世界物品
 */
int Croute_func::user_get_ocean_items(DEAL_FUN_ARG)
{
    user_get_ocean_items_out_header  out_header = {  0 };
    user_get_ocean_items_out_item *p_out_item = 0;

	const uint32_t start = 1623000;
	const uint32_t end = 1642999;
    ret = this->user_attire.get_all_list_by_attireid_interval(RECVBUF_USERID, start, end, 0, 
		   	&out_header.count, &p_out_item);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}

/*
 * 海底世界宝箱，拉取积攒贝壳币
 */
int Croute_func::user_get_ocean_offline_shells(DEAL_FUN_ARG)
{
    user_get_ocean_offline_shells_in *p_in=PRI_IN_POS;
    user_get_ocean_offline_shells_out out={ 0 };
	
	uint32_t exp =0, datetime = 0;	
	ret = this->user_ocean_info.get(RECVBUF_USERID, &exp, &datetime);
	uint32_t old_level = this->user_ocean.get_level(exp);

	out.oceanid = p_in->oceanid;
    ret = this->user_fish.cal_output_shells(RECVBUF_USERID, p_in->oceanid, &out.shells);
	if(out.shells > 100*old_level){
		out.shells = 100*old_level;
	}

	if(out.shells != 0){
		this->user_ocean_info.update_coin(RECVBUF_USERID, out.shells);
	}

	uint32_t now = time(0);
	uint32_t today = get_date(now);
	if(today != (uint32_t)get_date(datetime)){
		exp += 2*old_level;
		this->user_ocean_info.set(RECVBUF_USERID, exp, now);

		uint32_t new_exp = 0;
		this->user_ocean_info.get_exp(RECVBUF_USERID, &new_exp);

		uint32_t new_level = this->user_ocean.get_level(new_exp); 
		if(new_level > old_level){
			out.is_upgrade = 1;
		}
		//this->user_ocean_info.set(RECVBUF_USERID, exp, now);
	}
	uint32_t table_exp = 0;
	this->user_ocean_info.get_exp(RECVBUF_USERID, &table_exp);
	uint32_t up_level = this->user_ocean.get_level(table_exp); 
	out.upgrade_need_exp = this->user_ocean.get_upgrade_exp(up_level) -  table_exp;
	out.cur_exp = table_exp;
	DEBUG_LOG("out.cur_exp: %u, need_exp: %u, shells: %u", out.cur_exp, out.upgrade_need_exp, out.shells);

	uint32_t db_buff[2] = { RECVBUF_USERID, 1};
	msglog(this->msglog_file, 0x0409C430,time(NULL), db_buff, sizeof(db_buff));

    STD_RETURN_WITH_STRUCT(SUCC,out);
}

/*
 * 海底世界，玩家在线掉贝壳
 */
int Croute_func::user_get_ocean_online_shells(DEAL_FUN_ARG)
{
	char buf[PROTO_MAX_LEN]={ 0 };
    user_get_ocean_online_shells_in *p_in=PRI_IN_POS;
    user_get_ocean_online_shells_out_header* out_header = (user_get_ocean_online_shells_out_header*)buf;
	user_get_ocean_online_shells_out_item *p_out_item = (user_get_ocean_online_shells_out_item*)(buf+sizeof(*out_header));

	ret = this->user_fish.get_online_fish_output(RECVBUF_USERID, p_in->oceanid, &out_header->count, p_out_item);
	char* p_offset = buf + sizeof(*out_header) + sizeof(user_get_ocean_online_shells_out_item)*out_header->count;

	uint32_t db_buff[2] = { RECVBUF_USERID, 1};
	msglog(this->msglog_file, 0x0409C431,time(NULL), db_buff, sizeof(db_buff));

	STD_RETURN_WITH_BUF(SUCC, buf, p_offset - buf);
}

/*
 * 玩家上线后，清空上次在线掉贝壳时间
 */
int Croute_func::user_clear_online_ocean_drop(DEAL_FUN_ARG)
{
    ret = this->user_fish.clear_last_drop_shell_time(RECVBUF_USERID);

    STD_RETURN(SUCC);
}
/*
 * 人鱼国度探险，祈祷活动,设置
 */
int Croute_func::user_set_expedition_pray(DEAL_FUN_ARG)
{
	user_set_expedition_pray_in *p_in=PRI_IN_POS;
    user_set_expedition_pray_out out={ 0 };
	uint32_t data = 0, old = 0;;
	ret = this->user_temp_active.get_one(RECVBUF_USERID, 43, "value_1", &data);
	old = data;
	
	if(p_in->step == 1){
		if(data % 10 < 3){

			uint32_t db_buff[2] = { RECVBUF_USERID, 1};
			msglog(this->msglog_file, 0x0409C415,time(NULL), db_buff, sizeof(db_buff));
			data = data + 1;
			if(data % 10 == 3){
				out.itemid = 1633006;;
				this->user_add_attire_new(RECVBUF_USERID, 0, out.itemid, 1, 99999);
				msglog(this->msglog_file, 0x040A0D06,time(NULL), db_buff, sizeof(db_buff));
			}
		}	
	}	
	else if(p_in->step == 2){
		if((data /10)%10 < 3){

			uint32_t db_buff[2] = { RECVBUF_USERID, 1};
			msglog(this->msglog_file, 0x0409C416,time(NULL), db_buff, sizeof(db_buff));
			data = data + 10;
			if((data/10)%10 == 3){
				out.itemid = 1633008;;
				this->user_add_attire_new(RECVBUF_USERID, 0, out.itemid, 1, 99999);
				msglog(this->msglog_file, 0x040A0D08,time(NULL), db_buff, sizeof(db_buff));
			}
		}
	}
	else if(p_in->step == 3){
		if(data / 100 < 3){
			uint32_t db_buff[2] = { RECVBUF_USERID, 1};
			msglog(this->msglog_file, 0x0409C417,time(NULL), db_buff, sizeof(db_buff));
			data = data + 100;
			if(data / 100 == 3){
				out.itemid = 1623001;
				this->user_add_attire_new(RECVBUF_USERID, 0, out.itemid, 3, 99999);
				msglog(this->msglog_file, 0x0409E5F1,time(NULL), db_buff, sizeof(db_buff));
			}
		}
	}
	if(data != old){
		ret = this->user_temp_active.add(RECVBUF_USERID, 43, data, 0);
	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 人鱼过探险，起到活动， 查询
 */
int Croute_func::user_get_expedition_pray(DEAL_FUN_ARG)
{
    user_get_expedition_pray_out out={0};
    ret = this->user_temp_active.get_one(RECVBUF_USERID, 43, "value_1", &out.step_pray);

    STD_RETURN_WITH_STRUCT(SUCC,out);
}

/*
 * 海底世界，卖出鱼
 */
int Croute_func::user_sale_ocean_fish(DEAL_FUN_ARG)
{
    user_sale_ocean_fish_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(user_sale_ocean_fish_in_item));
    user_sale_ocean_fish_in_item * p_in_item=(user_sale_ocean_fish_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;

    user_sale_ocean_fish_out out={0};
    ret = this->user_fish.cal_price_result(RECVBUF_USERID, p_in_item, p_in->count, &out.shells);
	if(out.shells != 0){
		this->user_ocean_info.update_coin(RECVBUF_USERID, out.shells);
		uint32_t db_buff[2] = { RECVBUF_USERID, 1};
		msglog(this->msglog_file, 0x0409C433,time(NULL), db_buff, sizeof(db_buff));
	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 增加贝壳币
 */
int Croute_func::user_set_ocean_shell(DEAL_FUN_ARG)
{
    user_set_ocean_shell_in *p_in=PRI_IN_POS;
    ret = this->user_ocean_info.update_coin(RECVBUF_USERID, p_in->coin);

    STD_RETURN(ret);
}

/*
 * 购买海底生物
 */
int Croute_func::user_buy_ocean_things(DEAL_FUN_ARG)
{
    user_buy_ocean_things_in *p_in=PRI_IN_POS;
    user_buy_ocean_things_out out={0};


	uint32_t coin = 0;
	ret=this->user_ocean_info.get_coin(RECVBUF_USERID, &coin);
	if(coin < p_in->useshells){
		//return SHELL_COIN_NOT_ENOUGH_ERR;
	}
	/*	
	uint32_t itemid[]= {
		1633000, 1623000, 1623001, 1633009, 1633010, 1633027, 1633028, 1633029, 1633030, 1633031, 1633032	
	};
	uint32_t price[] = {
		20, 30, 30, 200, 200, 500, 500, 800, 800, 1000, 1000
	};
	uint32_t k = 0;
	for(; k <sizeof(itemid)/sizeof(uint32_t); ++k ){
		if(itemid[k] == p_in->attire_item.attireid){
			break;
		}
	}
	if(k >= sizeof(itemid)/sizeof(uint32_t)){
		return SHELL_COIN_NOT_ENOUGH_ERR;
	}
	uint32_t shells = p_in->attire_item.count * price[k];
	if(coin < shells){
		return SHELL_COIN_NOT_ENOUGH_ERR;
	}
	*/
	uint32_t new_coin = coin - p_in->useshells;
	//uint32_t new_coin = coin - shells;
	DEBUG_LOG("coin: %u, useshells: %u", coin, p_in->useshells);
	ret=this->user_ocean_info.set_coin(RECVBUF_USERID, new_coin);
	if(ret != SUCC){
		return ret;
	}
	ret=this->user_add_attire(RECVBUF_USERID,&(p_in->attire_item ) );
	if (ret!=SUCC){ //没有增加成功 ,设置xiaomee为原值 
		int tmp_ret=this->user_ocean_info.set_coin(RECVBUF_USERID, coin);
		if (tmp_ret!=SUCC){
			//回滚出现严重 ,需要手工处理
			ERROR_LOG("ERROR:xiaomee route back error ret[%d],userid[%u],shells[%d]",
				 tmp_ret ,RECVBUF_USERID,p_in->useshells);
		}
	}


	out.leave_shells = new_coin;
	out.buy_attireid=p_in->attire_item.attireid;
	out.buy_count=p_in->attire_item.count;

    STD_RETURN_WITH_STRUCT(SUCC,out);
}

/*
 * 海底世界，冒险模式，过关
 */
int Croute_func::user_add_mole_adventure_pass(DEAL_FUN_ARG)
{
	enum{
		PRE_GATE_NOT_PASS       =   0,
		GATE_DAY_LIMIT          =   1,
		NOT_RIGHT_GATE          =   2,
		RET_SUCC                =   3,
	};

	//temp_active, 从100开始
    user_add_mole_adventure_pass_in *p_in=PRI_IN_POS;
    user_add_mole_adventure_pass_out out = { 0 };
	
	uint32_t gate_way[] = { 2, 3};	
	uint32_t gate_award[] = { 1623000, 1623002};	
	DEBUG_LOG("secondary: %u, prime: %u", p_in->secondary, p_in->prime);
	//关卡不正确
	if(p_in->prime < 1 || p_in->prime > 2 || p_in->secondary < 1 || p_in->secondary > gate_way[p_in->prime-1]){
		out.state = NOT_RIGHT_GATE;
		STD_RETURN_WITH_STRUCT(SUCC,out);
	}
	//上一大关卡没有过
	uint32_t light = 0;	
	ret = this->user_temp_active.get_one(RECVBUF_USERID, 100, "value_1", &light);
	if(p_in->prime > 1){
		uint32_t pre_gate = p_in->prime - 1;
		if((light&(1<<(pre_gate-1))) == 0){
			out.state = PRE_GATE_NOT_PASS; 
			STD_RETURN_WITH_STRUCT(SUCC,out);
		}
	}
	//每一关卡大于，每日十次限制	
	uint32_t day_count = 0, datetime = 0;	
	ret=this->user_temp_active.get_two(RECVBUF_USERID, (p_in->prime+100), "value_1", "value_2", &day_count, &datetime);
	uint32_t now = time(0);
	if(get_date(now) == get_date(datetime)){
		if(day_count >= 10){
			out.state = GATE_DAY_LIMIT; 
			STD_RETURN_WITH_STRUCT(SUCC,out);
		}
	}
	//通过一大关送奖励
	uint32_t tmp_cnt = 0, flag = 0;
	uint32_t* p_tmp = 0;
	ret = this->user_ocean_adventure.get_secondary(RECVBUF_USERID, p_in->prime, &p_tmp, &tmp_cnt);
	for(uint32_t k = 0; k < tmp_cnt; ++k){
		if(*(p_tmp+k) == (p_in->secondary-1)){
			flag = 1;
			break;
		}
	}
	DEBUG_LOG("ret:%u  value: %u, secondary: %u,  flag: %u", ret, USER_ID_NOFIND_ERR, p_in->secondary, flag);
	if((tmp_cnt == 0 && p_in->secondary == 1) || flag == 1){
		if(gate_way[p_in->prime-1] == p_in->secondary){
			ret = this->user_temp_active.add(RECVBUF_USERID, 100, light|(1<<(p_in->prime - 1)), 0);
			ret = this->user_temp_active.add(RECVBUF_USERID, 100+p_in->prime, day_count+1, now);
			out.itemid = gate_award[p_in->prime - 1];
			this->user_add_attire_new(RECVBUF_USERID, 0, out.itemid, 1, 999999);
			out.count = 1;
			this->user_ocean_adventure.clear(RECVBUF_USERID, p_in->prime);
		}
		else if( p_in->secondary < gate_way[p_in->prime-1]){
			ret = this->user_ocean_adventure.add(RECVBUF_USERID, p_in->prime, p_in->secondary);
		}
		if(p_in->prime == 1){
			uint32_t db_buff[2] = { RECVBUF_USERID, 1};
			msglog(this->msglog_file, 0x0409C435 + 2*(p_in->secondary - 1),time(NULL), db_buff, sizeof(db_buff));
		}
		else if(p_in->prime == 2){
			uint32_t db_buff[2] = { RECVBUF_USERID, 1};
			msglog(this->msglog_file, 0x0409C439 + 2*(p_in->secondary - 1),time(NULL), db_buff, sizeof(db_buff));
		}
		
		// add acitivity
		{
			uint32_t th_cnt = 0, low = 0, high = 0;
			ret = this->user_temp_active.get_one(RECVBUF_USERID, 45, "value_1", &th_cnt);
			low = th_cnt & 0xFFFF;
			high = th_cnt >> 16;
			DEBUG_LOG("---th_cnt: %u, low: %u, high: %u---", th_cnt, low, high);
			uint32_t new_low = low;	
			if(low < 5){
				this->user_add_attire_new(RECVBUF_USERID, 0, 1351392, 2, 999999);
				out.crystal_cnt = 1;
				++new_low;
			}
			if(new_low != low){
				this->user_temp_active.add(RECVBUF_USERID, 45, (high << 16)|new_low, 0);
			}
			this->user_add_attire_new(RECVBUF_USERID, 0, out.itemid, 1, 999999);
		}

		out.state = RET_SUCC;
	}
	else{
		out.state = NOT_RIGHT_GATE;
	}
	if(p_tmp != 0){
		free(p_tmp);
	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 海底世界，冒险模式，查看已过关卡
 */
int Croute_func::user_get_mole_adventure_pass(DEAL_FUN_ARG)
{
	char buf[PROTO_MAX_LEN]={ 0 };
    user_get_mole_adventure_pass_out_header *out_header = (user_get_mole_adventure_pass_out_header*)buf;
    user_get_mole_adventure_pass_out_item_1 *p_out_item_1 = (user_get_mole_adventure_pass_out_item_1*)(buf+sizeof(*out_header));

	ret = this->user_temp_active.get_one(RECVBUF_USERID, 100, "value_1", &out_header->already_pass);
	user_get_mole_adventure_pass_out_item_1* p_tmp = 0;
    ret = this->user_ocean_adventure.get(RECVBUF_USERID, &out_header->count_1, &p_tmp);
	memcpy((char*)p_out_item_1, (char*)p_tmp, sizeof(user_get_mole_adventure_pass_out_item_1)*out_header->count_1);
	char* p_offset = (char*)p_out_item_1 +sizeof(user_get_mole_adventure_pass_out_item_1)*out_header->count_1;
	if(p_tmp != 0){
		free(p_tmp);
	}
	user_get_mole_adventure_pass_out_item_2 *p_list = 0;
	ret = this->user_temp_active.get_day_ocean_list(RECVBUF_USERID, &out_header->count_2, &p_list);

	user_get_mole_adventure_pass_out_item_2* p_out_item_2 = (user_get_mole_adventure_pass_out_item_2*)p_offset;
	memcpy((char*)p_out_item_2, (char*)p_list, sizeof(user_get_mole_adventure_pass_out_item_2)*out_header->count_2);
	p_offset += sizeof(user_get_mole_adventure_pass_out_item_2)*out_header->count_2;
	if(p_list != 0){
		free(p_list);
	}
	
	STD_RETURN_WITH_BUF(SUCC, buf, p_offset - buf);
	//STD_RETURN_WITH_STRUCT_LIST(SUCC,out_header,p_out_item,out_header.count);
}

/*
 * 查看个人小游戏信息
 */
int Croute_func::user_get_games_info(DEAL_FUN_ARG)
{
    user_get_games_info_out_header  out_header = { 0 };
    user_get_games_info_out_item *p_out_item = 0;

    ret = this->user_self_games.get_all(RECVBUF_USERID, &p_out_item, &out_header.count);
	ret = this->user.get_one_col(RECVBUF_USERID, "game_exp", &out_header.game_exp);

    STD_RETURN_WITH_STRUCT_LIST(SUCC,out_header,p_out_item,out_header.count);

}
/*
 * 查看海底世界图鉴
 */
int Croute_func::user_get_ocean_handbook(DEAL_FUN_ARG)
{
    user_get_ocean_handbook_out_header  out_header = { 0 };
    user_get_ocean_handbook_out_item *p_out_item = 0;
    ret = this->user_ocean_handbook.get_all(RECVBUF_USERID, &p_out_item, &out_header.count);
    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 查看海底世界好友等级
 */
int Croute_func::sysarg_get_ocean_friend(DEAL_FUN_ARG)
{
    sysarg_get_ocean_friend_in_header *p_in=PRI_IN_POS;
    CHECK_PRI_IN_LEN_WITHOUT_HEADER((p_in->count)*sizeof(sysarg_get_ocean_friend_in_item));
    sysarg_get_ocean_friend_in_item * p_in_item=(sysarg_get_ocean_friend_in_item*)(RCVBUF_PRIVATE_POS+sizeof(*p_in)) ;
	DEBUG_LOG("===p_count: %u", p_in->count);
    sysarg_get_ocean_friend_out_header  out_header = { 0 }; 
	sysarg_get_ocean_friend_out_item *p_out_item = 0;
    ret = this->sysarg_ocean_info.select_ocean_friend(RECVBUF_USERID, p_in->count, p_in_item, &out_header.count,
        &p_out_item);

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 进入游戏大厅
 */
int Croute_func::sysarg_get_game_top_ten(DEAL_FUN_ARG)
{
    sysarg_get_game_top_ten_out_header  out_header = { 0 };
    sysarg_get_game_top_ten_out_item *p_out_item = 0;

    ret = this->sysarg_game_hall.get_recent_ten(&p_out_item, &out_header.count);

	uint32_t db_buff[2] = { RECVBUF_USERID, 1};
	msglog(this->msglog_file, 0x0409C45A,time(NULL), db_buff, sizeof(db_buff));

    STD_RETURN_WITH_STRUCT_LIST(ret,out_header,p_out_item,out_header.count);
}
/*
 * 玩家小游戏加分数
 */
int Croute_func::user_add_game_socre(DEAL_FUN_ARG)
{
    user_add_game_socre_in *p_in=PRI_IN_POS;
	uint32_t game_exp = 0;
	ret = this->user_self_games.cal_exp(RECVBUF_USERID, p_in->gameid, p_in->score, &game_exp);
	DEBUG_LOG("gameid: %u, score: %u, game_exp: %u", p_in->gameid, p_in->score, game_exp);

	if(game_exp != 0){
		uint32_t old_exp = 0;
		this->user.get_one_col(RECVBUF_USERID, "game_exp", &old_exp);	
		uint32_t old_level = 0;
		old_level = old_exp / 1000;

		this->user.update_one_col(RECVBUF_USERID, "game_exp", old_exp + game_exp);
		uint32_t new_exp = 0;
		this->user.get_one_col(RECVBUF_USERID, "game_exp", &new_exp);	
		uint32_t new_level = new_exp / 1000;
		if(old_level != new_level){
			uint32_t msgid = 0;
			if(new_level >= 1 && new_level <= 10){
				msgid = 0x0409C45B;
			}
			else if(new_level >10 && new_level <= 20){
				msgid = 0x0409C45C;

			}
			else if(new_level > 20 && new_level <= 30){
				msgid = 0x0409C45D;

			}
			else if(new_level > 30 && new_level <= 40){
				msgid = 0x0409C45E;

			}
			else if(new_level > 40 && new_level <= 50){
				msgid = 0x0409C45F;

			}
			if(msgid != 0){
				uint32_t db_buff[2] = { RECVBUF_USERID, 1};
				msglog(this->msglog_file, msgid,time(NULL), db_buff, sizeof(db_buff));
			}
		}
	}

    STD_RETURN(SUCC);
}
/*
 *查看某一小游戏分数 
 */
int Croute_func::user_get_socre_by_gameid(DEAL_FUN_ARG)
{
	user_get_socre_by_gameid_in *p_in = PRI_IN_POS;
    user_get_socre_by_gameid_out out={0};
    ret = this->user_self_games.get_score_by_gameid(RECVBUF_USERID, p_in->gameid, &out.score);
	out.gameid = p_in->gameid;

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 *全局表，更新玩家游戏大厅数据
 */
int Croute_func::sysarg_game_hall_change(DEAL_FUN_ARG)
{
    sysarg_game_hall_change_in *p_in=PRI_IN_POS;
    ret = this->sysarg_game_hall.change_hall_data(RECVBUF_USERID, p_in);

    STD_RETURN(ret);
}
/*
 * 查看已经领取地图状态
 */
int Croute_func::user_get_scroll_map_state(DEAL_FUN_ARG)
{
    user_get_scroll_map_state_out out={ 0 };
	uint32_t value = 0;
	ret = this->user_temp_active.get_one(RECVBUF_USERID, 45, "value_1", &value);
	uint32_t high = value >> 16;
	if(high >= 4){
		out.flag = 2;
	}
	else{
		out.flag = 1;
	}
	ret = this->user_temp_active.get_one(RECVBUF_USERID, 200, "value_1", &out.state);

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 地图找卷轴碎片
 */
int Croute_func::user_get_scroll_dragment(DEAL_FUN_ARG)
{
	//type = 200 表示找卷轴碎片地图状态 
    user_get_scroll_dragment_in *p_in=PRI_IN_POS;
    user_get_scroll_dragment_out out={ 0 };

	uint32_t value = 0;
	ret = this->user_temp_active.get_one(RECVBUF_USERID, 45, "value_1", &value);
	uint32_t high = value >> 16;
	if(high >= 4){
		out.state = 2;
	}
	else{
		
		uint32_t db_buff[2] = { RECVBUF_USERID, 1};
		msglog(this->msglog_file, 0x0409C44C,time(NULL), db_buff, sizeof(db_buff));
		uint32_t map_flag = 0, right_map = 0;
		ret = this->user_temp_active.get_two(RECVBUF_USERID, 200, "value_1", "value_2", &map_flag, &right_map);

		if(map_flag == 0 && right_map == 0){
			right_map = rand()%4 + 1;
		}
		uint32_t flag = 0;
		DEBUG_LOG("---------map_flag: %u, mapid: %u ------------", map_flag, p_in->mapid);
		if((map_flag & (1 << (p_in->mapid-1))) == 0){
			if(right_map == p_in->mapid){
				out.itemid = 1351393;
				this->user_add_attire_new(RECVBUF_USERID, 99, out.itemid, 1, 999999);
				flag = 1;
			}
		}
		map_flag = map_flag | (1 << (p_in->mapid - 1));
		
		if(flag  == 1){
			high++;	
			if(high == 4){
				out.state = 2;
			}
			uint32_t low = value & 0xFFFF;
			this->user_temp_active.add(RECVBUF_USERID, 45, (high << 16)|low , 0);
			map_flag = 0;
			right_map = 0;
		}
		ret = this->user_temp_active.add(RECVBUF_USERID, 200, map_flag, right_map);

	}
	
    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 海底世界经验同步到全局表
 */
int Croute_func::sysarg_ocean_synchro_exp(DEAL_FUN_ARG)
{
    sysarg_ocean_synchro_exp_in *p_in=PRI_IN_POS;
    ret = this->sysarg_ocean_info.add(RECVBUF_USERID, p_in->exp);

    STD_RETURN(ret);
}

/*
 *玩家游戏排名 
 */
int Croute_func::sysarg_self_game_rank(DEAL_FUN_ARG)
{
    sysarg_self_game_rank_out out={ 0 };
    ret = this->sysarg_game_hall.get_self_rank(RECVBUF_USERID, &out.rank);
	DEBUG_LOG("rank: %u", out.rank);

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
/*
 * 人鱼国探险系列活动结束
 */
int Croute_func::user_finish_merman_kindom(DEAL_FUN_ARG)
{
    user_finish_merman_kindom_out out={ 0 };
	uint32_t count = 0;
    user_get_merman_kingdom_out_item *p_item = 0;
    ret = this->user_temp_active.get_merman_kingdom(RECVBUF_USERID, &p_item, &count);
	if(count == 5){
		uint32_t k = 0;
		for(; k < count; ++k){
			if((p_item+k)->state != 2){
				break;
			}
		}
		if(k >= count){
			uint32_t flag = 0;
			ret = this->user_temp_active.get_one(RECVBUF_USERID, 47, "value_1", &flag);
			if(flag == 0){
				out.state = 1;
				this->user_add_attire_new(RECVBUF_USERID, 1, 161091, 1, 999999);
				this->user_temp_active.add(RECVBUF_USERID, 47, 1, 0);
			}
			else{
				out.state = 2;// 已经领取过了
			}
		}
	}
	if(p_item != 0){
		free(p_item);
	}

    STD_RETURN_WITH_STRUCT(SUCC,out);
}
