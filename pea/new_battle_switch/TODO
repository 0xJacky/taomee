#
TMP-OK 1. object_pool.hpp: char m_errstr[MAX_ERROR_BUFFER_LEN];
	其中: MAX_ERROR_BUFFER_LEN 定义为4K, 太大, 仅为了保存一下错误码对应的描述, 10w 个obj 就消耗400M内存, 这些内存恐怕连10%都用不到
	不过这是 对象池的数量, 应该不会很多, 4K也不为过

OK(问题转化成大区内不允许同一uid重复登陆) 2. 由于有跨服对战, battle_switch 必须按照 uid + role_tm 来管理 player, 因为同一个 uid 可以同时在多个 区(服)上进入大厅, 并创建房间, 所以必须用 role_tm 区分
	(当然, 也可能存在外挂在同一时刻到所有区(服)为同一个uid注册角色, 这样还需要加上server_id作为区分因素之一);

3. 当 battle_switch 重启后, 对战结束后返回房间的客户端已经无法找到房间,
	此时需要 online 对此作出相应的举动: 根据 battle_switch 的返回 清除房间信息并通知客户端房间解散, 要求客户端重新建立房间;

1. alloc 只负责申请内存和初始化本身数据, 而对 alloc 出来的对象的进一步加入各种管理结构(eg: online_map_t), 则由上层根据 alloc 的返回酌情做出;
	类似的, dealloc 也是只做做最基本的释放内存的操作, 而在此之前, 必须先把对象脱离各种管理结构;

	各层 API:
	alloc / dealloc : 负责 申请(+初始化) / 释放 自身数据;
	reg / unreg: 负责维护直接关系链, reg 把对象加入它所在的列表, unreg 把对象从它所在的列表中脱离;
	add / del: 利用上面的2组底层 api 把 资源分配 和 关系链维护工作包装起来, 特别的 del 接口中还会调用对象的下级关系链的 del 函数, 以此保证不会产生'孤儿room/team/seat' ('孤儿'会造成内存泄露);

说明:
直接关系链的建立过程:
	(1) 先在 add/alloc 中建立 '对象 --> 宿主' 的关系;
	(2) 再在 reg 中建立 '宿主 --> 对象' 的关系;

直接关系链的解除过程:
	(1) 在 del/unreg 中解除 '宿主 --> 对象' 的关系;
	(2) 再在 del/dealloc 中解除 '对象 --> 宿主' 的关系;

这样的模式能够支持具有层次的对象群:
	高层对象建立时, 还没有直接下层对象, 因此初始化维护直接下层对象的管理器即可;
		(eg: online_t 中的 room_map)
	下层对象建立时, 上层以及更高层的对象都已经建立, 此时一定能够建立 '对象 --> 宿主' 的关系;
		(eg: room_t 中的 online)
	高层对象被销毁时, 此时 或许有/也或许没有 下层对象/更下层对象, 不过这没关系, 高层对象只需要调用它的直接下层对象的销毁函数接口接口;
		(eg: 销毁online对象时, 遍历 online->room_map, 对每一个 room 调用 del_room(room) 把online下的房间都销毁掉, 至于del_room具体怎么做, 怎么把 room 的下层甚至更下层的对象销毁, 在online这一层就不用管了)
	下层对象销毁时, 需要按顺序做4件事 (注意: 按顺序做, 否则会导致下层对象找不到上层对象的问题):
		(1) 先把自己从 '宿主 --> 对象' 的关系中解除;
		(2) 把自己从 '间接关系链' 中解除; (eg: 把 player 对象从 seat 上解除)
		(3) 然后把自己当做最高层的对象, 调用本层的销毁函数把自己及其下层的对象都销毁;
		(3) 销毁自身数据;

需要注意的是:
	每层对象向上的指针可以指向上层或更上层的对象,
		理由是: 下层对象存在时, 上层对象一定存在;
	但对下除非有特别用意(eg: room_t 中的 owner), 否则只能管理直接下层的对象, 不要跨层,
		理由是: 上层对象的下层对象可能也可能不存在, 如果跨层引用, 在遍历时代码需要的判断很复杂, 很容易引起bug;
		至于 room->owner 可以跨层引用, 是因为业务上要求一个房间必须有个房主, 因此要求 room->owner 一定是有效的, 所以可以用足够细心的 helper_function 来维护;

销毁策略:
	销毁 room 时, 不会同时销毁 player, 仅仅是把所有座位上的人解除跟seat的直接关联(使player回到大厅), 并把 player 的状态改成 idle (离开对战, 如果有的话)
	而销毁 player 时, 会看看这个 player 是否是该房间的最后一个人, 如果不是, 就简单让 player 解除跟 seat 的直接关联即可, 否则, 可以同时对 player 所在的 room 做 del_room(room) 的动作, 由于上一句的策略, 此时不会引发递归销毁 (即不会出现: del_room->del_player->del_room->...);

================================================================================
OK 1. send_to_player 接口设计;
OK 6. notify 接口的打包函数;
2. room <--> player 辅助关联建立;
3. del_player 还不完善, 如: 与对战信息的关联;
4. 对战对象的加入;

5. 与策划确定:
	(1) 大厅是否看见其它人 (会有这个功能: 用于加好友, 邀请对战等);
	(2) 拉取房间列表策略 (同服, 按ID从小到大, 仅pvp-玩家自己配对房间, 未对战房间, 数量: 8~32 ???);
	(3) 需要对战对象, 对战完成后, 玩家各自回到各自的房间;
	??(4) 创建房间是个非常重的操作, 必须有一定的频率限制;

6. 把 room->team->seat 看做一整套设施, 要创建都创建, 要销毁都销毁, 因为大多数操作都是房间级别的, 但访问的数据可能就要到 team或seat, 这样就不太方便, 因此, 把这几个作为一个整体对待, 可以简化逻辑;

9. 如果 battle_switch 检测到 online 已经crash或断开连接, 则可以考虑在 send_to_player 接口中加上对 online 的这种状态的判断, 如果发现对 online 发消息已经没有不可达或没有意义, 则不发; (注意: 这一逻辑如果实现得不好, 可能造成该发的协议没有发, 从而导致online或客户端阻塞)
